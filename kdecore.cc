# 1 "../kdecore/libkdecore_la_all_cpp.cpp"
# 1 "<built-in>"



# 1 "<command line>"
# 1 "../kdecore/libkdecore_la_all_cpp.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 3 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/libintl.cpp" 1
# 50 "/coolo/prod/kdelibs/kdecore/libintl.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 51 "/coolo/prod/kdelibs/kdecore/libintl.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 39 "/coolo/prod/qt-copy/include/qglobal.h"




# 116 "/coolo/prod/qt-copy/include/qglobal.h"
# 171 "/coolo/prod/qt-copy/include/qglobal.h"
# 275 "/coolo/prod/qt-copy/include/qglobal.h"
# 292 "/coolo/prod/qt-copy/include/qglobal.h"
# 512 "/coolo/prod/qt-copy/include/qglobal.h"
# 550 "/coolo/prod/qt-copy/include/qglobal.h"
# 573 "/coolo/prod/qt-copy/include/qglobal.h"
# 591 "/coolo/prod/qt-copy/include/qglobal.h"
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned uint;
typedef unsigned long ulong;
typedef char *pchar;
typedef uchar *puchar;
typedef const char *pcchar;







const bool FALSE = 0;
const bool TRUE = !0;
# 628 "/coolo/prod/qt-copy/include/qglobal.h"
# 642 "/coolo/prod/qt-copy/include/qglobal.h"








inline int qRound( double d )
{
    return d >= 0.0 ? int(d + 0.5) : int( d - ((int)d-1) + 0.5 ) + ((int)d-1);
}
# 675 "/coolo/prod/qt-copy/include/qglobal.h"
typedef signed char Q_INT8;
typedef unsigned char Q_UINT8;
typedef short Q_INT16;
typedef unsigned short Q_UINT16;
typedef int Q_INT32;
typedef unsigned int Q_UINT32;




typedef long Q_LONG;
typedef unsigned long Q_ULONG;







typedef long long Q_INT64;
typedef unsigned long long Q_UINT64;

typedef Q_INT64 Q_LLONG;
typedef Q_UINT64 Q_ULLONG;







    typedef Q_ULONG QtOffset;







class QDataStream;
# 740 "/coolo/prod/qt-copy/include/qglobal.h"
# 1 "/coolo/prod/qt-copy/include/qconfig.h" 1







# 741 "/coolo/prod/qt-copy/include/qglobal.h" 2
# 750 "/coolo/prod/qt-copy/include/qglobal.h"
# 1 "/coolo/prod/qt-copy/include/qmodules.h" 1

# 751 "/coolo/prod/qt-copy/include/qglobal.h" 2
# 802 "/coolo/prod/qt-copy/include/qglobal.h"



# 1 "/coolo/prod/qt-copy/include/qfeatures.h" 1
# 432 "/coolo/prod/qt-copy/include/qfeatures.h"
# 807 "/coolo/prod/qt-copy/include/qglobal.h" 2
# 856 "/coolo/prod/qt-copy/include/qglobal.h"
# 873 "/coolo/prod/qt-copy/include/qglobal.h"
 const char *qVersion();
 bool qSysInfo( int *wordSize, bool *bigEndian );
 bool qSharedBuild();
# 899 "/coolo/prod/qt-copy/include/qglobal.h"


















# 935 "/coolo/prod/qt-copy/include/qglobal.h"
 void qDebug( const char *, ... )

    __attribute__ ((format (printf, 1, 2)))

;

 void qWarning( const char *, ... )

    __attribute__ ((format (printf, 1, 2)))

;

 void qFatal( const char *, ... )

    __attribute__ ((format (printf, 1, 2)))

;

 void qSystemWarning( const char *, int code = -1 );
# 983 "/coolo/prod/qt-copy/include/qglobal.h"
# 999 "/coolo/prod/qt-copy/include/qglobal.h"
 bool qt_check_pointer( bool c, const char *, int );


# 1013 "/coolo/prod/qt-copy/include/qglobal.h"
enum QtMsgType { QtDebugMsg, QtWarningMsg, QtFatalMsg };

typedef void (*QtMsgHandler)(QtMsgType, const char *);
 QtMsgHandler qInstallMsgHandler( QtMsgHandler );





 void qSuppressObsoleteWarnings( bool = TRUE );

 void qObsolete( const char *obj, const char *oldfunc,
                   const char *newfunc );
 void qObsolete( const char *obj, const char *oldfunc );
 void qObsolete( const char *message );






 const char *qInstallPath();
 const char *qInstallPathDocs();
 const char *qInstallPathHeaders();
 const char *qInstallPathLibs();
 const char *qInstallPathBins();
 const char *qInstallPathPlugins();
 const char *qInstallPathData();
 const char *qInstallPathTranslations();
 const char *qInstallPathSysconf();
# 1059 "/coolo/prod/qt-copy/include/qglobal.h"
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 53 "/coolo/prod/kdelibs/kdecore/libintl.cpp" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 20 "/usr/include/features.h" 3 4
# 109 "/usr/include/features.h" 3 4



# 127 "/usr/include/features.h" 3 4


#undef _XOPEN_SOURCE


#undef _BSD_SOURCE

# 160 "/usr/include/features.h" 3 4
# 176 "/usr/include/features.h" 3 4















#undef __USE_ISOC99
# 211 "/usr/include/features.h" 3 4



























# 256 "/usr/include/features.h" 3 4



# 271 "/usr/include/features.h" 3 4

















# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 20 "/usr/include/sys/cdefs.h" 3 4
# 44 "/usr/include/sys/cdefs.h" 3 4





# 70 "/usr/include/sys/cdefs.h" 3 4






# 104 "/usr/include/sys/cdefs.h" 3 4











# 151 "/usr/include/sys/cdefs.h" 3 4
# 174 "/usr/include/sys/cdefs.h" 3 4
# 183 "/usr/include/sys/cdefs.h" 3 4
# 192 "/usr/include/sys/cdefs.h" 3 4







# 213 "/usr/include/sys/cdefs.h" 3 4
# 223 "/usr/include/sys/cdefs.h" 3 4
# 249 "/usr/include/sys/cdefs.h" 3 4
# 292 "/usr/include/features.h" 2 3 4
# 314 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 315 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/stdlib.h" 2 3 4




# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 188 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4








typedef __SIZE_TYPE__ size_t;
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 264 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
# 291 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef _BSD_WCHAR_T_
# 344 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_wchar_t
# 399 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
# 408 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_NULL
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 26 "/usr/include/bits/waitflags.h" 3 4

# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 29 "/usr/include/bits/waitstatus.h" 3 4
























# 1 "/usr/include/endian.h" 1 3 4
# 20 "/usr/include/endian.h" 3 4
# 32 "/usr/include/endian.h" 3 4


# 1 "/usr/include/bits/endian.h" 1 3 4






# 38 "/usr/include/endian.h" 2 3 4










# 64 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

        unsigned int __w_termsig:7;
        unsigned int __w_coredump:1;
        unsigned int __w_retcode:8;
        unsigned int:16;







      } __wait_terminated;
    struct
      {

        unsigned int __w_stopval:8;
        unsigned int __w_stopsig:8;
        unsigned int:16;






      } __wait_stopped;
  };

# 44 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 64 "/usr/include/stdlib.h" 3 4
# 85 "/usr/include/stdlib.h" 3 4




typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;






__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;












extern size_t __ctype_get_mb_cur_max (void) throw ();




extern double atof (__const char *__nptr) throw () __attribute__ ((__pure__));

extern int atoi (__const char *__nptr) throw () __attribute__ ((__pure__));

extern long int atol (__const char *__nptr) throw () __attribute__ ((__pure__));





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__));





extern double strtod (__const char *__restrict __nptr,
                      char **__restrict __endptr) throw ();





extern float strtof (__const char *__restrict __nptr,
                     char **__restrict __endptr) throw ();

extern long double strtold (__const char *__restrict __nptr,
                            char **__restrict __endptr) throw ();





extern long int strtol (__const char *__restrict __nptr,
                        char **__restrict __endptr, int __base) throw ();

extern unsigned long int strtoul (__const char *__restrict __nptr,
                                  char **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
                             char **__restrict __endptr, int __base) throw ();

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
                                       char **__restrict __endptr, int __base)
     throw ();





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
                              char **__restrict __endptr, int __base) throw ();

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
                                        char **__restrict __endptr, int __base)
     throw ();

# 225 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 22 "/usr/include/xlocale.h" 3 4





typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;
# 226 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (__const char *__restrict __nptr,
                          char **__restrict __endptr, int __base,
                          __locale_t __loc) throw ();

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
                                    char **__restrict __endptr,
                                    int __base, __locale_t __loc) throw ();

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
                                char **__restrict __endptr, int __base,
                                __locale_t __loc) throw ();

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
                                          char **__restrict __endptr,
                                          int __base, __locale_t __loc)
     throw ();

extern double strtod_l (__const char *__restrict __nptr,
                        char **__restrict __endptr, __locale_t __loc)
     throw ();

extern float strtof_l (__const char *__restrict __nptr,
                       char **__restrict __endptr, __locale_t __loc) throw ();

extern long double strtold_l (__const char *__restrict __nptr,
                              char **__restrict __endptr,
                              __locale_t __loc) throw ();






extern double __strtod_internal (__const char *__restrict __nptr,
                                 char **__restrict __endptr, int __group)
     throw ();
extern float __strtof_internal (__const char *__restrict __nptr,
                                char **__restrict __endptr, int __group)
     throw ();
extern long double __strtold_internal (__const char *__restrict __nptr,
                                       char **__restrict __endptr,
                                       int __group) throw ();

extern long int __strtol_internal (__const char *__restrict __nptr,
                                   char **__restrict __endptr,
                                   int __base, int __group) throw ();


extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
                                             char **__restrict __endptr,
                                             int __base, int __group) throw ();



__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
                                         char **__restrict __endptr,
                                         int __base, int __group) throw ();


__extension__
extern unsigned long long int __strtoull_internal (__const char *
                                                   __restrict __nptr,
                                                   char **__restrict __endptr,
                                                   int __base, int __group)
     throw ();
# 408 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw ();


extern long int a64l (__const char *__s) throw () __attribute__ ((__pure__));


# 1 "/usr/include/sys/types.h" 1 3 4
# 25 "/usr/include/sys/types.h" 3 4



extern "C" {

# 1 "/usr/include/bits/types.h" 1 3 4
# 25 "/usr/include/bits/types.h" 3 4


# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 19 "/usr/include/bits/wordsize.h" 3 4
# 29 "/usr/include/bits/types.h" 2 3 4

# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;





__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 103 "/usr/include/bits/types.h" 3 4

# 128 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 25 "/usr/include/bits/typesizes.h" 3 4






# 129 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long int __off_t;
typedef long long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef int __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long long int __fsfilcnt64_t;




typedef int __ssize_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef int __intptr_t;


typedef unsigned int __socklen_t;
# 32 "/usr/include/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;



typedef __loff_t loff_t;



typedef __ino_t ino_t;





typedef __ino64_t ino64_t;



typedef __dev_t dev_t;



typedef __gid_t gid_t;



typedef __mode_t mode_t;



typedef __nlink_t nlink_t;



typedef __uid_t uid_t;




typedef __off_t off_t;





typedef __off64_t off64_t;



typedef __pid_t pid_t;



typedef __id_t id_t;



typedef __ssize_t ssize_t;




typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;




typedef __key_t key_t;




# 1 "/usr/include/time.h" 1 3 4
# 54 "/usr/include/time.h" 3 4





typedef __clock_t clock_t;






#undef __need_clock_t







typedef __time_t time_t;






#undef __need_time_t







typedef __clockid_t clockid_t;










typedef __timer_t timer_t;


#undef __need_timer_t
# 134 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;


typedef __suseconds_t suseconds_t;



# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 184 "/usr/include/sys/types.h" 3 4




typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));












# 1 "/usr/include/sys/select.h" 1 3 4
# 23 "/usr/include/sys/select.h" 3 4







# 1 "/usr/include/bits/select.h" 1 3 4
# 26 "/usr/include/bits/select.h" 3 4
# 37 "/usr/include/bits/select.h" 3 4








# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 21 "/usr/include/bits/sigset.h" 3 4

typedef int __sig_atomic_t;



typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4


typedef __sigset_t sigset_t;



# 1 "/usr/include/time.h" 1 3 4
# 83 "/usr/include/time.h" 3 4
#undef __need_time_t
# 114 "/usr/include/time.h" 3 4



struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };


#undef __need_timespec
# 45 "/usr/include/sys/select.h" 2 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 60 "/usr/include/bits/time.h" 3 4
#undef __need_timeval





struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;








typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];




  } fd_set;

#define FD_SET(fd,fds) \
    (fds)->fds_bits[(fd) / (8 * sizeof(__fd_mask))] |= ((__fd_mask)1) << ((fd) % (8*sizeof(__fd_mask)))
#define FD_ISSET(fd,fds) \
    (((fds)->fds_bits[(fd) / (8 * sizeof(__fd_mask))] & (((__fd_mask)1) << ((fd) % (8*sizeof(__fd_mask))))) != 0)



typedef __fd_mask fd_mask;








extern "C" {






extern int select (int __nfds, fd_set *__restrict __readfds,
                   fd_set *__restrict __writefds,
                   fd_set *__restrict __exceptfds,
                   struct timeval *__restrict __timeout) throw ();





extern int pselect (int __nfds, fd_set *__restrict __readfds,
                    fd_set *__restrict __writefds,
                    fd_set *__restrict __exceptfds,
                    const struct timespec *__restrict __timeout,
                    const __sigset_t *__restrict __sigmask) throw ();


}
# 217 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 21 "/usr/include/sys/sysmacros.h" 3 4






# 220 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;





typedef __blkcnt_t blkcnt_t;


typedef __fsblkcnt_t fsblkcnt_t;


typedef __fsfilcnt_t fsfilcnt_t;
# 258 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 20 "/usr/include/bits/pthreadtypes.h" 3 4

# 1 "/usr/include/bits/sched.h" 1 3 4
# 81 "/usr/include/bits/sched.h" 3 4

struct __sched_param
  {
    int __sched_priority;
  };
#undef __need_schedparam
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4


struct _pthread_fastlock
{
  long int __status;
  int __spinlock;

};



typedef struct _pthread_descr_struct *_pthread_descr;




typedef struct __pthread_attr_s
{
  int __detachstate;
  int __schedpolicy;
  struct __sched_param __schedparam;
  int __inheritsched;
  int __scope;
  size_t __guardsize;
  int __stackaddr_set;
  void *__stackaddr;
  size_t __stacksize;
} pthread_attr_t;





__extension__ typedef long long __pthread_cond_align_t;




typedef struct
{
  struct _pthread_fastlock __c_lock;
  _pthread_descr __c_waiting;
  char __padding[48 - sizeof (struct _pthread_fastlock)
                 - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
  __pthread_cond_align_t __align;
} pthread_cond_t;



typedef struct
{
  int __dummy;
} pthread_condattr_t;


typedef unsigned int pthread_key_t;





typedef struct
{
  int __m_reserved;
  int __m_count;
  _pthread_descr __m_owner;
  int __m_kind;
  struct _pthread_fastlock __m_lock;
} pthread_mutex_t;



typedef struct
{
  int __mutexkind;
} pthread_mutexattr_t;



typedef int pthread_once_t;




typedef struct _pthread_rwlock_t
{
  struct _pthread_fastlock __rw_lock;
  int __rw_readers;
  _pthread_descr __rw_writer;
  _pthread_descr __rw_read_waiting;
  _pthread_descr __rw_write_waiting;
  int __rw_kind;
  int __rw_pshared;
} pthread_rwlock_t;



typedef struct
{
  int __lockkind;
  int __pshared;
} pthread_rwlockattr_t;




typedef volatile int pthread_spinlock_t;


typedef struct {
  struct _pthread_fastlock __ba_lock;
  int __ba_required;
  int __ba_present;
  _pthread_descr __ba_waiting;
} pthread_barrier_t;


typedef struct {
  int __pshared;
} pthread_barrierattr_t;





typedef unsigned long int pthread_t;
# 267 "/usr/include/sys/types.h" 2 3 4


}
# 415 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
                        size_t __statelen) throw ();



extern char *setstate (char *__statebuf) throw ();







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
                     int32_t *__restrict __result) throw ();

extern int srandom_r (unsigned int __seed, struct random_data *__buf) throw ();

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
                        size_t __statelen,
                        struct random_data *__restrict __buf) throw ();

extern int setstate_r (char *__restrict __statebuf,
                       struct random_data *__restrict __buf) throw ();






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw ();


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3]) throw ();


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3]) throw ();


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3]) throw ();
extern void lcong48 (unsigned short int __param[7]) throw ();





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
                      double *__restrict __result) throw ();
extern int erand48_r (unsigned short int __xsubi[3],
                      struct drand48_data *__restrict __buffer,
                      double *__restrict __result) throw ();


extern int lrand48_r (struct drand48_data *__restrict __buffer,
                      long int *__restrict __result) throw ();
extern int nrand48_r (unsigned short int __xsubi[3],
                      struct drand48_data *__restrict __buffer,
                      long int *__restrict __result) throw ();


extern int mrand48_r (struct drand48_data *__restrict __buffer,
                      long int *__restrict __result) throw ();
extern int jrand48_r (unsigned short int __xsubi[3],
                      struct drand48_data *__restrict __buffer,
                      long int *__restrict __result) throw ();


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw ();

extern int seed48_r (unsigned short int __seed16v[3],
                     struct drand48_data *__buffer) throw ();

extern int lcong48_r (unsigned short int __param[7],
                      struct drand48_data *__buffer) throw ();








extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__));

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__));







extern void *realloc (void *__ptr, size_t __size) throw () __attribute__ ((__malloc__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 20 "/usr/include/alloca.h" 3 4



# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();




}
# 577 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__));




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw ();





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw ();






extern void exit (int __status) throw () __attribute__ ((__noreturn__));






extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw ();




extern char *__secure_getenv (__const char *__name) throw ();





extern int putenv (char *__string) throw ();





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw ();


extern int unsetenv (__const char *__name) throw ();






extern int clearenv (void) throw ();
# 661 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw ();







extern int mkstemp (char *__template) throw ();
# 678 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) throw ();
# 688 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw ();





extern int system (__const char *__command) throw ();







extern char *canonicalize_file_name (__const char *__name) throw ();
# 712 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
                       char *__restrict __resolved) throw ();





typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;






extern void *bsearch (__const void *__key, __const void *__base,
                      size_t __nmemb, size_t __size, __compar_fn_t __compar);



extern void qsort (void *__base, size_t __nmemb, size_t __size,
                   __compar_fn_t __compar);



extern int abs (int __x) throw () __attribute__ ((__const__));
extern long int labs (long int __x) throw () __attribute__ ((__const__));



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__));







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__));




__extension__ extern lldiv_t lldiv (long long int __numer,
                                    long long int __denom)
     throw () __attribute__ ((__const__));

# 776 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign) throw ();




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign) throw ();




extern char *gcvt (double __value, int __ndigit, char *__buf) throw ();




extern char *qecvt (long double __value, int __ndigit,
                    int *__restrict __decpt, int *__restrict __sign) throw ();
extern char *qfcvt (long double __value, int __ndigit,
                    int *__restrict __decpt, int *__restrict __sign) throw ();
extern char *qgcvt (long double __value, int __ndigit, char *__buf) throw ();




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign, char *__restrict __buf,
                   size_t __len) throw ();
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign, char *__restrict __buf,
                   size_t __len) throw ();

extern int qecvt_r (long double __value, int __ndigit,
                    int *__restrict __decpt, int *__restrict __sign,
                    char *__restrict __buf, size_t __len) throw ();
extern int qfcvt_r (long double __value, int __ndigit,
                    int *__restrict __decpt, int *__restrict __sign,
                    char *__restrict __buf, size_t __len) throw ();







extern int mblen (__const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
                   __const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
                        __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
                        __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw ();
# 858 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
                      char *__const *__restrict __tokens,
                      char **__restrict __valuep) throw ();





extern void setkey (__const char *__key) throw ();







extern int posix_openpt (int __oflag) throw ();







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw ();






extern int ptsname_r (int __fd, char *__buf, size_t __buflen) throw ();


extern int getpt (void) throw ();






extern int getloadavg (double __loadavg[], int __nelem) throw ();





}
# 55 "/coolo/prod/kdelibs/kdecore/libintl.cpp" 2


# 1 "/usr/include/string.h" 1 3 4
# 24 "/usr/include/string.h" 3 4



extern "C" {


# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 408 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_NULL
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
                     __const void *__restrict __src, size_t __n) throw ();


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw ();






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
                      int __c, size_t __n)
     throw ();





extern void *memset (void *__s, int __c, size_t __n) throw ();


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern void *memchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__));





extern void *rawmemchr (__const void *__s, int __c) throw () __attribute__ ((__pure__));


extern void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__));





extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw ();

extern char *strncpy (char *__restrict __dest,
                      __const char *__restrict __src, size_t __n) throw ();


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw ();

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
                      size_t __n) throw ();


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__));

extern size_t strxfrm (char *__restrict __dest,
                       __const char *__restrict __src, size_t __n) throw ();

# 117 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
                         __locale_t __l) throw ();




extern char *strdup (__const char *__s) throw () __attribute__ ((__malloc__));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__));




# 149 "/usr/include/string.h" 3 4
# 160 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c) throw () __attribute__ ((__pure__));

extern char *strrchr (__const char *__s, int __c) throw () __attribute__ ((__pure__));





extern char *strchrnul (__const char *__s, int __c) throw () __attribute__ ((__pure__));





extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__));

extern char *strpbrk (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__));

extern char *strstr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw ();




extern char *__strtok_r (char *__restrict __s,
                         __const char *__restrict __delim,
                         char **__restrict __save_ptr) throw ();

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
                       char **__restrict __save_ptr) throw ();




extern char *strcasestr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__));






extern void *memmem (__const void *__haystack, size_t __haystacklen,
                     __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__));



extern void *__mempcpy (void *__restrict __dest,
                        __const void *__restrict __src, size_t __n) throw ();
extern void *mempcpy (void *__restrict __dest,
                      __const void *__restrict __src, size_t __n) throw ();





extern size_t strlen (__const char *__s) throw () __attribute__ ((__pure__));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern char *strerror (int __errnum) throw ();




extern char *strerror_r (int __errnum, char *__buf, size_t __buflen) throw ();




extern void __bzero (void *__s, size_t __n) throw ();



extern void bcopy (__const void *__src, void *__dest, size_t __n) throw ();


extern void bzero (void *__s, size_t __n) throw ();


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern char *index (__const char *__s, int __c) throw () __attribute__ ((__pure__));


extern char *rindex (__const char *__s, int __c) throw () __attribute__ ((__pure__));



extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
                         __locale_t __loc) throw () __attribute__ ((__pure__));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
                          size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__));





extern char *strsep (char **__restrict __stringp,
                     __const char *__restrict __delim) throw ();




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__));


extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw ();
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw ();



extern char *__stpncpy (char *__restrict __dest,
                        __const char *__restrict __src, size_t __n) throw ();
extern char *stpncpy (char *__restrict __dest,
                      __const char *__restrict __src, size_t __n) throw ();


extern char *strfry (char *__string) throw ();


extern void *memfrob (void *__s, size_t __n) throw ();






extern char *basename (__const char *__filename) throw ();
# 379 "/usr/include/string.h" 3 4
}
# 58 "/coolo/prod/kdelibs/kdecore/libintl.cpp" 2





# 1 "/usr/include/fcntl.h" 1 3 4
# 24 "/usr/include/fcntl.h" 3 4




extern "C" {



# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 29 "/usr/include/bits/fcntl.h" 3 4
















































struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };









# 34 "/usr/include/fcntl.h" 2 3 4



# 1 "/usr/include/sys/stat.h" 1 3 4
# 24 "/usr/include/sys/stat.h" 3 4










# 1 "/usr/include/time.h" 1 3 4
# 83 "/usr/include/time.h" 3 4
#undef __need_time_t
# 125 "/usr/include/time.h" 3 4
#undef __need_timespec
# 38 "/usr/include/sys/stat.h" 2 3 4
# 103 "/usr/include/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/bits/stat.h" 1 3 4
# 24 "/usr/include/bits/stat.h" 3 4




struct stat
  {
    __dev_t st_dev;
    unsigned short int __pad1;

    __ino_t st_ino;



    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned short int __pad2;

    __off_t st_size;



    __blksize_t st_blksize;


    __blkcnt_t st_blocks;
# 70 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 85 "/usr/include/bits/stat.h" 3 4
    unsigned long int __unused4;
    unsigned long int __unused5;



  };


struct stat64
  {
    __dev_t st_dev;
    unsigned int __pad1;

    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned int __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;

    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 127 "/usr/include/bits/stat.h" 3 4
    __ino64_t st_ino;
  };














# 106 "/usr/include/sys/stat.h" 2 3 4
























# 154 "/usr/include/sys/stat.h" 3 4




























extern int stat (__const char *__restrict __file,
                 struct stat *__restrict __buf) throw ();



extern int fstat (int __fd, struct stat *__buf) throw ();
# 226 "/usr/include/sys/stat.h" 3 4
extern int stat64 (__const char *__restrict __file,
                   struct stat64 *__restrict __buf) throw ();
extern int fstat64 (int __fd, struct stat64 *__buf) throw ();






extern int lstat (__const char *__restrict __file,
                  struct stat *__restrict __buf) throw ();
# 248 "/usr/include/sys/stat.h" 3 4
extern int lstat64 (__const char *__restrict __file,
                    struct stat64 *__restrict __buf) throw ();





extern int chmod (__const char *__file, __mode_t __mode) throw ();





extern int lchmod (__const char *__file, __mode_t __mode) throw ();




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (__const char *__path, __mode_t __mode) throw ();





extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     throw ();




extern int mkfifo (__const char *__path, __mode_t __mode) throw ();
# 319 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) throw ();
extern int __xstat (int __ver, __const char *__filename,
                    struct stat *__stat_buf) throw ();
extern int __lxstat (int __ver, __const char *__filename,
                     struct stat *__stat_buf) throw ();
# 343 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw ();
extern int __xstat64 (int __ver, __const char *__filename,
                      struct stat64 *__stat_buf) throw ();
extern int __lxstat64 (int __ver, __const char *__filename,
                       struct stat64 *__stat_buf) throw ();

extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
                     __dev_t *__dev) throw ();




extern __inline__ int stat (__const char *__path,
                            struct stat *__statbuf) throw ()
{
  return __xstat (3, __path, __statbuf);
}


extern __inline__ int lstat (__const char *__path,
                             struct stat *__statbuf) throw ()
{
  return __lxstat (3, __path, __statbuf);
}


extern __inline__ int fstat (int __fd, struct stat *__statbuf) throw ()
{
  return __fxstat (3, __fd, __statbuf);
}


extern __inline__ int mknod (__const char *__path, __mode_t __mode,
                             __dev_t __dev) throw ()
{
  return __xmknod (1, __path, __mode, &__dev);
}





extern __inline__ int stat64 (__const char *__path,
                              struct stat64 *__statbuf) throw ()
{
  return __xstat64 (3, __path, __statbuf);
}


extern __inline__ int lstat64 (__const char *__path,
                               struct stat64 *__statbuf) throw ()
{
  return __lxstat64 (3, __path, __statbuf);
}


extern __inline__ int fstat64 (int __fd, struct stat64 *__statbuf) throw ()
{
  return __fxstat64 (3, __fd, __statbuf);
}




}
# 38 "/usr/include/fcntl.h" 2 3 4















extern int fcntl (int __fd, int __cmd, ...) throw ();





extern int open (__const char *__file, int __oflag, ...) throw ();
# 76 "/usr/include/fcntl.h" 3 4
extern int open64 (__const char *__file, int __oflag, ...) throw ();






extern int creat (__const char *__file, __mode_t __mode) throw ();
# 93 "/usr/include/fcntl.h" 3 4
extern int creat64 (__const char *__file, __mode_t __mode) throw ();
# 106 "/usr/include/fcntl.h" 3 4


extern int lockf (int __fd, int __cmd, __off_t __len) throw ();
# 122 "/usr/include/fcntl.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) throw ();







extern int posix_fadvise (int __fd, __off_t __offset, size_t __len,
                          int __advise) throw ();
# 142 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, __off64_t __offset, size_t __len,
                            int __advise) throw ();





extern int posix_fallocate (int __fd, __off_t __offset, size_t __len) throw ();
# 160 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, __off64_t __offset, size_t __len)
     throw ();



}
# 64 "/coolo/prod/kdelibs/kdecore/libintl.cpp" 2



# 1 "/usr/include/unistd.h" 1 3 4
# 24 "/usr/include/unistd.h" 3 4



extern "C" {












































# 175 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 21 "/usr/include/bits/posix_opt.h" 3 4










































































# 176 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 19 "/usr/include/bits/wordsize.h" 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 61 "/usr/include/bits/environments.h" 3 4





# 180 "/usr/include/unistd.h" 2 3 4



# 197 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 408 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_NULL
# 200 "/usr/include/unistd.h" 2 3 4
# 240 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;





typedef __socklen_t socklen_t;







extern int access (__const char *__name, int __type) throw ();




extern int euidaccess (__const char *__name, int __type) throw ();









# 290 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 302 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence) throw ();



extern int close (int __fd) throw ();



extern ssize_t read (int __fd, void *__buf, size_t __nbytes) throw ();


extern ssize_t write (int __fd, __const void *__buf, size_t __n) throw ();



extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset)
     throw ();
extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
                       __off_t __offset) throw ();
# 340 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
                        __off64_t __offset) throw ();


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
                         __off64_t __offset) throw ();







extern int pipe (int __pipedes[2]) throw ();
# 362 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 371 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds) throw ();






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();



extern int usleep (__useconds_t __useconds) throw ();





extern int pause (void) throw ();



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw ();



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw ();




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw ();




extern int chdir (__const char *__path) throw ();



extern int fchdir (int __fd) throw ();
# 423 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw ();





extern char *get_current_dir_name (void) throw ();






extern char *getwd (char *__buf) throw ();




extern int dup (int __fd) throw ();


extern int dup2 (int __fd, int __fd2) throw ();


extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
                   char *__const __envp[]) throw ();




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw ();




extern int execv (__const char *__path, char *__const __argv[]) throw ();



extern int execle (__const char *__path, __const char *__arg, ...) throw ();



extern int execl (__const char *__path, __const char *__arg, ...) throw ();



extern int execvp (__const char *__file, char *__const __argv[]) throw ();




extern int execlp (__const char *__file, __const char *__arg, ...) throw ();




extern int nice (int __inc) throw ();




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 25 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,
    _PC_MAX_CANON,
    _PC_MAX_INPUT,
    _PC_NAME_MAX,
    _PC_PATH_MAX,
    _PC_PIPE_BUF,
    _PC_CHOWN_RESTRICTED,
    _PC_NO_TRUNC,
    _PC_VDISABLE,
    _PC_SYNC_IO,
    _PC_ASYNC_IO,
    _PC_PRIO_IO,
    _PC_SOCK_MAXBUF,
    _PC_FILESIZEBITS,
    _PC_REC_INCR_XFER_SIZE,
    _PC_REC_MAX_XFER_SIZE,
    _PC_REC_MIN_XFER_SIZE,
    _PC_REC_XFER_ALIGN,
    _PC_ALLOC_SIZE_MIN,
    _PC_SYMLINK_MAX
  };


enum
  {
    _SC_ARG_MAX,
    _SC_CHILD_MAX,
    _SC_CLK_TCK,
    _SC_NGROUPS_MAX,
    _SC_OPEN_MAX,
    _SC_STREAM_MAX,
    _SC_TZNAME_MAX,
    _SC_JOB_CONTROL,
    _SC_SAVED_IDS,
    _SC_REALTIME_SIGNALS,
    _SC_PRIORITY_SCHEDULING,
    _SC_TIMERS,
    _SC_ASYNCHRONOUS_IO,
    _SC_PRIORITIZED_IO,
    _SC_SYNCHRONIZED_IO,
    _SC_FSYNC,
    _SC_MAPPED_FILES,
    _SC_MEMLOCK,
    _SC_MEMLOCK_RANGE,
    _SC_MEMORY_PROTECTION,
    _SC_MESSAGE_PASSING,
    _SC_SEMAPHORES,
    _SC_SHARED_MEMORY_OBJECTS,
    _SC_AIO_LISTIO_MAX,
    _SC_AIO_MAX,
    _SC_AIO_PRIO_DELTA_MAX,
    _SC_DELAYTIMER_MAX,
    _SC_MQ_OPEN_MAX,
    _SC_MQ_PRIO_MAX,
    _SC_VERSION,
    _SC_PAGESIZE,
    _SC_RTSIG_MAX,
    _SC_SEM_NSEMS_MAX,
    _SC_SEM_VALUE_MAX,
    _SC_SIGQUEUE_MAX,
    _SC_TIMER_MAX,



    _SC_BC_BASE_MAX,
    _SC_BC_DIM_MAX,
    _SC_BC_SCALE_MAX,
    _SC_BC_STRING_MAX,
    _SC_COLL_WEIGHTS_MAX,
    _SC_EQUIV_CLASS_MAX,
    _SC_EXPR_NEST_MAX,
    _SC_LINE_MAX,
    _SC_RE_DUP_MAX,
    _SC_CHARCLASS_NAME_MAX,

    _SC_2_VERSION,
    _SC_2_C_BIND,
    _SC_2_C_DEV,
    _SC_2_FORT_DEV,
    _SC_2_FORT_RUN,
    _SC_2_SW_DEV,
    _SC_2_LOCALEDEF,

    _SC_PII,
    _SC_PII_XTI,
    _SC_PII_SOCKET,
    _SC_PII_INTERNET,
    _SC_PII_OSI,
    _SC_POLL,
    _SC_SELECT,
    _SC_UIO_MAXIOV,
    _SC_IOV_MAX = _SC_UIO_MAXIOV,
    _SC_PII_INTERNET_STREAM,
    _SC_PII_INTERNET_DGRAM,
    _SC_PII_OSI_COTS,
    _SC_PII_OSI_CLTS,
    _SC_PII_OSI_M,
    _SC_T_IOV_MAX,


    _SC_THREADS,
    _SC_THREAD_SAFE_FUNCTIONS,
    _SC_GETGR_R_SIZE_MAX,
    _SC_GETPW_R_SIZE_MAX,
    _SC_LOGIN_NAME_MAX,
    _SC_TTY_NAME_MAX,
    _SC_THREAD_DESTRUCTOR_ITERATIONS,
    _SC_THREAD_KEYS_MAX,
    _SC_THREAD_STACK_MIN,
    _SC_THREAD_THREADS_MAX,
    _SC_THREAD_ATTR_STACKADDR,
    _SC_THREAD_ATTR_STACKSIZE,
    _SC_THREAD_PRIORITY_SCHEDULING,
    _SC_THREAD_PRIO_INHERIT,
    _SC_THREAD_PRIO_PROTECT,
    _SC_THREAD_PROCESS_SHARED,

    _SC_NPROCESSORS_CONF,
    _SC_NPROCESSORS_ONLN,
    _SC_PHYS_PAGES,
    _SC_AVPHYS_PAGES,
    _SC_ATEXIT_MAX,
    _SC_PASS_MAX,

    _SC_XOPEN_VERSION,
    _SC_XOPEN_XCU_VERSION,
    _SC_XOPEN_UNIX,
    _SC_XOPEN_CRYPT,
    _SC_XOPEN_ENH_I18N,
    _SC_XOPEN_SHM,

    _SC_2_CHAR_TERM,
    _SC_2_C_VERSION,
    _SC_2_UPE,

    _SC_XOPEN_XPG2,
    _SC_XOPEN_XPG3,
    _SC_XOPEN_XPG4,

    _SC_CHAR_BIT,
    _SC_CHAR_MAX,
    _SC_CHAR_MIN,
    _SC_INT_MAX,
    _SC_INT_MIN,
    _SC_LONG_BIT,
    _SC_WORD_BIT,
    _SC_MB_LEN_MAX,
    _SC_NZERO,
    _SC_SSIZE_MAX,
    _SC_SCHAR_MAX,
    _SC_SCHAR_MIN,
    _SC_SHRT_MAX,
    _SC_SHRT_MIN,
    _SC_UCHAR_MAX,
    _SC_UINT_MAX,
    _SC_ULONG_MAX,
    _SC_USHRT_MAX,

    _SC_NL_ARGMAX,
    _SC_NL_LANGMAX,
    _SC_NL_MSGMAX,
    _SC_NL_NMAX,
    _SC_NL_SETMAX,
    _SC_NL_TEXTMAX,

    _SC_XBS5_ILP32_OFF32,
    _SC_XBS5_ILP32_OFFBIG,
    _SC_XBS5_LP64_OFF64,
    _SC_XBS5_LPBIG_OFFBIG,

    _SC_XOPEN_LEGACY,
    _SC_XOPEN_REALTIME,
    _SC_XOPEN_REALTIME_THREADS,

    _SC_ADVISORY_INFO,
    _SC_BARRIERS,
    _SC_BASE,
    _SC_C_LANG_SUPPORT,
    _SC_C_LANG_SUPPORT_R,
    _SC_CLOCK_SELECTION,
    _SC_CPUTIME,
    _SC_THREAD_CPUTIME,
    _SC_DEVICE_IO,
    _SC_DEVICE_SPECIFIC,
    _SC_DEVICE_SPECIFIC_R,
    _SC_FD_MGMT,
    _SC_FIFO,
    _SC_PIPE,
    _SC_FILE_ATTRIBUTES,
    _SC_FILE_LOCKING,
    _SC_FILE_SYSTEM,
    _SC_MONOTONIC_CLOCK,
    _SC_MULTI_PROCESS,
    _SC_SINGLE_PROCESS,
    _SC_NETWORKING,
    _SC_READER_WRITER_LOCKS,
    _SC_SPIN_LOCKS,
    _SC_REGEXP,
    _SC_REGEX_VERSION,
    _SC_SHELL,
    _SC_SIGNALS,
    _SC_SPAWN,
    _SC_SPORADIC_SERVER,
    _SC_THREAD_SPORADIC_SERVER,
    _SC_SYSTEM_DATABASE,
    _SC_SYSTEM_DATABASE_R,
    _SC_TIMEOUTS,
    _SC_TYPED_MEMORY_OBJECTS,
    _SC_USER_GROUPS,
    _SC_USER_GROUPS_R,
    _SC_2_PBS,
    _SC_2_PBS_ACCOUNTING,
    _SC_2_PBS_LOCATE,
    _SC_2_PBS_MESSAGE,
    _SC_2_PBS_TRACK,
    _SC_SYMLOOP_MAX,
    _SC_STREAMS,
    _SC_2_PBS_CHECKPOINT,

    _SC_V6_ILP32_OFF32,
    _SC_V6_ILP32_OFFBIG,
    _SC_V6_LP64_OFF64,
    _SC_V6_LPBIG_OFFBIG,

    _SC_HOST_NAME_MAX,
    _SC_TRACE,
    _SC_TRACE_EVENT_FILTER,
    _SC_TRACE_INHERIT,
    _SC_TRACE_LOG
  };


enum
  {
    _CS_PATH,

    _CS_V6_WIDTH_RESTRICTED_ENVS,

    _CS_GNU_LIBC_VERSION,
    _CS_GNU_LIBPTHREAD_VERSION,

    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS,
    _CS_LFS_LIBS,
    _CS_LFS_LINTFLAGS,
    _CS_LFS64_CFLAGS,
    _CS_LFS64_LDFLAGS,
    _CS_LFS64_LIBS,
    _CS_LFS64_LINTFLAGS,

    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS,
    _CS_XBS5_ILP32_OFF32_LIBS,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
    _CS_XBS5_ILP32_OFFBIG_LIBS,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
    _CS_XBS5_LP64_OFF64_CFLAGS,
    _CS_XBS5_LP64_OFF64_LDFLAGS,
    _CS_XBS5_LP64_OFF64_LIBS,
    _CS_XBS5_LP64_OFF64_LINTFLAGS,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
    _CS_XBS5_LPBIG_OFFBIG_LIBS,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
    _CS_POSIX_V6_ILP32_OFF32_LIBS,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
    _CS_POSIX_V6_LP64_OFF64_LIBS,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
  };
# 501 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name) throw ();


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw () __attribute__ ((__const__));



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 536 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 562 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 580 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw ();



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__euid, __uid_t *__ruid, __uid_t *__suid);



extern int getresgid (__gid_t *__egid, __gid_t *__rgid, __gid_t *__sgid);



extern int setresuid (__uid_t __euid, __uid_t __ruid, __uid_t __suid);



extern int setresgid (__gid_t __egid, __gid_t __rgid, __gid_t __sgid);






extern __pid_t fork (void) throw ();






extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen) throw ();



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to) throw ();



extern int symlink (__const char *__from, __const char *__to) throw ();




extern int readlink (__const char *__restrict __path, char *__restrict __buf,
                     size_t __len) throw ();



extern int unlink (__const char *__name) throw ();


extern int rmdir (__const char *__path) throw ();



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();



extern char *getlogin (void) throw ();




extern int getlogin_r (char *__name, size_t __name_len) throw ();




extern int setlogin (__const char *__name) throw ();







# 1 "/usr/include/getopt.h" 1 3 4
# 38 "/usr/include/getopt.h" 3 4
extern "C" {
# 47 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 61 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 145 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts);
# 175 "/usr/include/getopt.h" 3 4
}



#undef __need_getopt
# 745 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw ();






extern int sethostname (__const char *__name, size_t __len) throw ();



extern int sethostid (long int __id) throw ();





extern int getdomainname (char *__name, size_t __len) throw ();
extern int setdomainname (__const char *__name, size_t __len) throw ();





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw ();







extern int profil (unsigned short int *__sample_buffer, size_t __size,
                   size_t __offset, unsigned int __scale) throw ();





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw ();






extern int chroot (__const char *__path) throw ();



extern char *getpass (__const char *__prompt) throw ();





extern int fsync (int __fd) throw ();






extern long int gethostid (void) throw ();


extern void sync (void) throw ();




extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int truncate (__const char *__file, __off_t __length) throw ();
# 854 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length) throw ();




extern int ftruncate (int __fd, __off_t __length) throw ();
# 869 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw ();





extern int getdtablesize (void) throw ();
# 884 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw ();





extern void *sbrk (intptr_t __delta) throw ();
# 905 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 945 "/usr/include/unistd.h" 3 4
# 956 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes) throw ();







extern char *crypt (__const char *__key, __const char *__salt) throw ();



extern void encrypt (char *__block, int __edflag) throw ();






extern void swab (__const void *__restrict __from, void *__restrict __to,
                  ssize_t __n) throw ();







extern char *ctermid (char *__s) throw ();
# 1001 "/usr/include/unistd.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
                           void (*__parent) (void),
                           void (*__child) (void)) throw ();


}
# 68 "/coolo/prod/kdelibs/kdecore/libintl.cpp" 2



# 1 "/usr/include/sys/mman.h" 1 3 4
# 21 "/usr/include/sys/mman.h" 3 4



# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 27 "/usr/include/sys/mman.h" 2 3 4
# 42 "/usr/include/sys/mman.h" 3 4
# 1 "/usr/include/bits/mman.h" 1 3 4
# 33 "/usr/include/bits/mman.h" 3 4




























# 43 "/usr/include/sys/mman.h" 2 3 4



extern "C" {
# 58 "/usr/include/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
                   int __flags, int __fd, __off_t __offset) throw ();
# 71 "/usr/include/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
                     int __flags, int __fd, __off64_t __offset) throw ();




extern int munmap (void *__addr, size_t __len) throw ();




extern int mprotect (void *__addr, size_t __len, int __prot) throw ();




extern int msync (void *__addr, size_t __len, int __flags) throw ();




extern int madvise (void *__addr, size_t __len, int __advice) throw ();



extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();




extern int mlock (__const void *__addr, size_t __len) throw ();


extern int munlock (__const void *__addr, size_t __len) throw ();




extern int mlockall (int __flags) throw ();



extern int munlockall (void) throw ();





extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
                     int __may_move) throw ();






extern int mincore (void *__start, size_t __len, unsigned char *__vec);




extern int shm_open (__const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (__const char *__name);

}
# 72 "/coolo/prod/kdelibs/kdecore/libintl.cpp" 2





typedef Q_UINT32 nls_uint32;

struct loaded_domain
{
  const char *data;

  int use_mmap;
  size_t mmap_size;

  int must_swap;
  nls_uint32 nstrings;
  struct string_desc *orig_tab;
  struct string_desc *trans_tab;
  nls_uint32 hash_size;
  nls_uint32 *hash_tab;
};

struct kde_loaded_l10nfile
{
  const char *filename;
  int decided;

  const void *data;

  kde_loaded_l10nfile() : filename(0), decided(0), data(0) {}
};

void k_nl_load_domain(struct kde_loaded_l10nfile *__domain);

static inline nls_uint32
SWAP (nls_uint32 i)
{
  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
}











static inline unsigned long hash_string (const char *__str_param);




struct mo_file_header
{

  nls_uint32 magic;

  nls_uint32 revision;

  nls_uint32 nstrings;

  nls_uint32 orig_tab_offset;

  nls_uint32 trans_tab_offset;

  nls_uint32 hash_tab_size;

  nls_uint32 hash_tab_offset;
};

struct string_desc
{

  nls_uint32 length;

  nls_uint32 offset;
};


char *k_nl_find_msg (struct kde_loaded_l10nfile *domain_file,
                        const char *msgid);

char *
k_nl_find_msg (struct kde_loaded_l10nfile *domain_file, const char *msgid)
{
  size_t top, act, bottom;
  struct loaded_domain *domain;

  if (domain_file->decided == 0)
    k_nl_load_domain (domain_file);

  if (domain_file->data == __null)
    return __null;

  domain = (struct loaded_domain *) domain_file->data;


  if (domain->hash_size > 2 && domain->hash_tab != __null)
    {

      nls_uint32 len = strlen (msgid);
      nls_uint32 hash_val = hash_string (msgid);
      nls_uint32 idx = hash_val % domain->hash_size;
      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));
      nls_uint32 nstr = ((domain->must_swap) ? SWAP (domain->hash_tab[idx]) : (domain->hash_tab[idx]));

      if (nstr == 0)

        return __null;

      if (((domain->must_swap) ? SWAP (domain->orig_tab[nstr - 1].length) : (domain->orig_tab[nstr - 1].length)) == len
          && strcmp (msgid,
                     domain->data + ((domain->must_swap) ? SWAP (domain->orig_tab[nstr - 1].offset) : (domain->orig_tab[nstr - 1].offset))) == 0)

        return (char *) domain->data + ((domain->must_swap) ? SWAP (domain->trans_tab[nstr - 1].offset) : (domain->trans_tab[nstr - 1].offset));


      while (1)
        {
          if (idx >= domain->hash_size - incr)
            idx -= domain->hash_size - incr;
          else
            idx += incr;

          nstr = ((domain->must_swap) ? SWAP (domain->hash_tab[idx]) : (domain->hash_tab[idx]));
          if (nstr == 0)

            return __null;

          if (((domain->must_swap) ? SWAP (domain->orig_tab[nstr - 1].length) : (domain->orig_tab[nstr - 1].length)) == len
              && strcmp (msgid,
                         domain->data + ((domain->must_swap) ? SWAP (domain->orig_tab[nstr - 1].offset) : (domain->orig_tab[nstr - 1].offset)))

                 == 0)
            return (char *) domain->data
              + ((domain->must_swap) ? SWAP (domain->trans_tab[nstr - 1].offset) : (domain->trans_tab[nstr - 1].offset));
        }

    }



  bottom = 0;
  top = domain->nstrings;
  act = top;
  while (bottom < top)
    {
      int cmp_val;

      act = (bottom + top) / 2;
      cmp_val = strcmp (msgid, domain->data
                               + ((domain->must_swap) ? SWAP (domain->orig_tab[act].offset) : (domain->orig_tab[act].offset)));

      if (cmp_val < 0)
        top = act;
      else if (cmp_val > 0)
        bottom = act + 1;
      else
        break;
    }


  return bottom >= top ? __null : (char *) domain->data
                                + ((domain->must_swap) ? SWAP (domain->trans_tab[act].offset) : (domain->trans_tab[act].offset));

}




static inline unsigned long
hash_string (const char *str_param)
{
  unsigned long int hval, g;
  const char *str = str_param;


  hval = 0;
  while (*str != '\0')
    {
      hval <<= 4;
      hval += (unsigned long) *str++;
      g = hval & ((unsigned long) 0xf << (32 - 4));
      if (g != 0)
        {
          hval ^= g >> (32 - 8);
          hval ^= g;
        }
    }
  return hval;
}



void
k_nl_load_domain (struct kde_loaded_l10nfile *domain_file)
{
  int fd;
  struct stat st;
  struct mo_file_header *data = (struct mo_file_header *) -1;

  int use_mmap = 0;

  struct loaded_domain *domain;

  domain_file->decided = 1;
  domain_file->data = __null;





  if (domain_file->filename == __null)
    return;


  fd = open (domain_file->filename, 00);
  if (fd == -1)
    return;


  if (fstat (fd, &st) != 0
      || st.st_size < (off_t) sizeof (struct mo_file_header))
    {

      close (fd);
      return;
    }




  data = (struct mo_file_header *) mmap (__null, st.st_size, 0x1,
                                         0x02, fd, 0);

  if (data != (struct mo_file_header *) -1)
    {

      close (fd);
      use_mmap = 1;
    }




  if (data == (struct mo_file_header *) -1)
    {
      off_t to_read;
      char *read_ptr;

      data = (struct mo_file_header *) malloc (st.st_size);
      if (data == __null)
        return;

      to_read = st.st_size;
      read_ptr = (char *) data;
      do
        {
          long int nb = (long int) read (fd, read_ptr, to_read);
          if (nb == -1)
            {
              close (fd);
              return;
            }

          read_ptr += nb;
          to_read -= nb;
        }
      while (to_read > 0);

      close (fd);
    }



  if (data->magic != 0x950412de && data->magic != 0xde120495)
    {


      if (use_mmap)
        munmap ((char *) data, st.st_size);
      else

        free (data);
      return;
    }

  domain_file->data
    = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
  if (domain_file->data == __null)
    return;

  domain = (struct loaded_domain *) domain_file->data;
  domain->data = (char *) data;

  domain->use_mmap = use_mmap;
  domain->mmap_size = st.st_size;

  domain->must_swap = data->magic != 0x950412de;


  switch (((domain->must_swap) ? SWAP (data->revision) : (data->revision)))
    {
    case 0:
      domain->nstrings = ((domain->must_swap) ? SWAP (data->nstrings) : (data->nstrings));
      domain->orig_tab = (struct string_desc *)
        ((char *) data + ((domain->must_swap) ? SWAP (data->orig_tab_offset) : (data->orig_tab_offset)));
      domain->trans_tab = (struct string_desc *)
        ((char *) data + ((domain->must_swap) ? SWAP (data->trans_tab_offset) : (data->trans_tab_offset)));
      domain->hash_size = ((domain->must_swap) ? SWAP (data->hash_tab_size) : (data->hash_tab_size));
      domain->hash_tab = (nls_uint32 *)
        ((char *) data + ((domain->must_swap) ? SWAP (data->hash_tab_offset) : (data->hash_tab_offset)));
      break;
    default:


      if (use_mmap)
        munmap ((char *) data, st.st_size);
      else

        free (data);
      free (domain);
      domain_file->data = __null;
      return;
    }
}

void
k_nl_unload_domain (struct loaded_domain *domain)
{

  if (domain->use_mmap)
    munmap ((caddr_t) domain->data, domain->mmap_size);
  else

    free ((void *) domain->data);

  free (domain);
}
# 4 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kapplication.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

#undef QT_NO_TRANSLATION
# 1 "/coolo/prod/qt-copy/include/qtranslator.h" 1
# 40 "/coolo/prod/qt-copy/include/qtranslator.h"


# 1 "/coolo/prod/qt-copy/include/qobject.h" 1
# 39 "/coolo/prod/qt-copy/include/qobject.h"


# 1 "/coolo/prod/qt-copy/include/qobjectdefs.h" 1
# 39 "/coolo/prod/qt-copy/include/qobjectdefs.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qobjectdefs.h" 2






# 63 "/coolo/prod/qt-copy/include/qobjectdefs.h"
# 72 "/coolo/prod/qt-copy/include/qobjectdefs.h"
struct QUObject;
# 88 "/coolo/prod/qt-copy/include/qobjectdefs.h"




# 117 "/coolo/prod/qt-copy/include/qobjectdefs.h"
# 137 "/coolo/prod/qt-copy/include/qobjectdefs.h"
# 148 "/coolo/prod/qt-copy/include/qobjectdefs.h"

class QObject;
class QMetaObject;
class QSignal;
class QConnection;
class QEvent;
struct QMetaData;
class QConnectionList;
class QConnectionListIt;
class QSignalVec;
class QObjectList;
class QObjectListIt;
class QMemberDict;

 void *qt_find_obj_child( QObject *, const char *, const char * );


 void *qt_inheritedBy( QMetaObject *super, const QObject *cls );
# 182 "/coolo/prod/qt-copy/include/qobjectdefs.h"
template <typename T>
 T qt_cast(const QObject *object)
{ return (T)qt_inheritedBy( ((T)0)->staticMetaObject(), object ); }
# 43 "/coolo/prod/qt-copy/include/qobject.h" 2
# 1 "/coolo/prod/qt-copy/include/qwindowdefs.h" 1
# 40 "/coolo/prod/qt-copy/include/qwindowdefs.h"



# 1 "/coolo/prod/qt-copy/include/qstring.h" 1
# 39 "/coolo/prod/qt-copy/include/qstring.h"


# 1 "/coolo/prod/qt-copy/include/qcstring.h" 1
# 40 "/coolo/prod/qt-copy/include/qcstring.h"


# 1 "/coolo/prod/qt-copy/include/qmemarray.h" 1
# 39 "/coolo/prod/qt-copy/include/qmemarray.h"


# 1 "/coolo/prod/qt-copy/include/qgarray.h" 1
# 39 "/coolo/prod/qt-copy/include/qgarray.h"


# 1 "/coolo/prod/qt-copy/include/qshared.h" 1
# 39 "/coolo/prod/qt-copy/include/qshared.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qshared.h" 2



struct QShared
{
    QShared() : count( 1 ) { }
    void ref() { count++; }
    bool deref() { return !--count; }
    uint count;
};
# 43 "/coolo/prod/qt-copy/include/qgarray.h" 2



class QGArray
{
friend class QBuffer;
public:


    struct array_data : public QShared {
        array_data():data(0),len(0)



            {}
        char *data;
        uint len;



    };
    QGArray();
    enum Optimization { MemOptim, SpeedOptim };
protected:
    QGArray( int, int );
    QGArray( int size );
    QGArray( const QGArray &a );
    virtual ~QGArray();

    QGArray &operator=( const QGArray &a ) { return assign( a ); }

    virtual void detach() { duplicate(*this); }


    char *data() const { return shd->data; }
    uint nrefs() const { return shd->count; }
    uint size() const { return shd->len; }
    bool isEqual( const QGArray &a ) const;

    bool resize( uint newsize, Optimization optim );
    bool resize( uint newsize );

    bool fill( const char *d, int len, uint sz );

    QGArray &assign( const QGArray &a );
    QGArray &assign( const char *d, uint len );
    QGArray &duplicate( const QGArray &a );
    QGArray &duplicate( const char *d, uint len );
    void store( const char *d, uint len );

    array_data *sharedBlock() const { return shd; }
    void setSharedBlock( array_data *p ) { shd=(array_data*)p; }

    QGArray &setRawData( const char *d, uint len );
    void resetRawData( const char *d, uint len );

    int find( const char *d, uint index, uint sz ) const;
    int contains( const char *d, uint sz ) const;

    void sort( uint sz );
    int bsearch( const char *d, uint sz ) const;

    char *at( uint index ) const;

    bool setExpand( uint index, const char *d, uint sz );

protected:
    virtual array_data *newData();
    virtual void deleteData( array_data *p );

private:
    static void msg_index( uint );
    array_data *shd;
};


inline char *QGArray::at( uint index ) const
{

    if ( index >= size() ) {
        msg_index( index );
        index = 0;
    }

    return &shd->data[index];
}
# 43 "/coolo/prod/qt-copy/include/qmemarray.h" 2



template<class type>
class QMemArray : public QGArray
{
public:
    typedef type* Iterator;
    typedef const type* ConstIterator;
    typedef type ValueType;

protected:
    QMemArray( int, int ) : QGArray( 0, 0 ) {}

public:
    QMemArray() {}
    QMemArray( int size ) : QGArray(size*sizeof(type)) {}
    QMemArray( const QMemArray<type> &a ) : QGArray(a) {}
   ~QMemArray() {}
    QMemArray<type> &operator=(const QMemArray<type> &a)
                                { return (QMemArray<type>&)QGArray::assign(a); }
    type *data() const { return (type *)QGArray::data(); }
    uint nrefs() const { return QGArray::nrefs(); }
    uint size() const { return QGArray::size()/sizeof(type); }
    uint count() const { return size(); }
    bool isEmpty() const { return QGArray::size() == 0; }
    bool isNull() const { return QGArray::data() == 0; }
    bool resize( uint size ) { return QGArray::resize(size*sizeof(type)); }
    bool resize( uint size, Optimization optim ) { return QGArray::resize(size*sizeof(type), optim); }
    bool truncate( uint pos ) { return QGArray::resize(pos*sizeof(type)); }
    bool fill( const type &d, int size = -1 )
        { return QGArray::fill((char*)&d,size,sizeof(type) ); }
    void detach() { QGArray::detach(); }
    QMemArray<type> copy() const
        { QMemArray<type> tmp; return tmp.duplicate(*this); }
    QMemArray<type>& assign( const QMemArray<type>& a )
        { return (QMemArray<type>&)QGArray::assign(a); }
    QMemArray<type>& assign( const type *a, uint n )
        { return (QMemArray<type>&)QGArray::assign((char*)a,n*sizeof(type)); }
    QMemArray<type>& duplicate( const QMemArray<type>& a )
        { return (QMemArray<type>&)QGArray::duplicate(a); }
    QMemArray<type>& duplicate( const type *a, uint n )
        { return (QMemArray<type>&)QGArray::duplicate((char*)a,n*sizeof(type)); }
    QMemArray<type>& setRawData( const type *a, uint n )
        { return (QMemArray<type>&)QGArray::setRawData((char*)a,
                                                     n*sizeof(type)); }
    void resetRawData( const type *a, uint n )
        { QGArray::resetRawData((char*)a,n*sizeof(type)); }
    int find( const type &d, uint i=0 ) const
        { return QGArray::find((char*)&d,i,sizeof(type)); }
    int contains( const type &d ) const
        { return QGArray::contains((char*)&d,sizeof(type)); }
    void sort() { QGArray::sort(sizeof(type)); }
    int bsearch( const type &d ) const
        { return QGArray::bsearch((const char*)&d,sizeof(type)); }

    type& operator[]( int i ) const
        { return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
    type& at( uint i ) const
        { return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
         operator const type*() const { return (const type *)QGArray::data(); }
    bool operator==( const QMemArray<type> &a ) const { return isEqual(a); }
    bool operator!=( const QMemArray<type> &a ) const { return !isEqual(a); }
    Iterator begin() { return data(); }
    Iterator end() { return data() + size(); }
    ConstIterator begin() const { return data(); }
    ConstIterator end() const { return data() + size(); }
};





# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 118 "/coolo/prod/qt-copy/include/qmemarray.h" 2
# 44 "/coolo/prod/qt-copy/include/qcstring.h" 2
# 53 "/coolo/prod/qt-copy/include/qcstring.h"
 void *qmemmove( void *dst, const void *src, uint len );

 char *qstrdup( const char * );

 inline uint qstrlen( const char *str )
{ return str ? (uint)strlen(str) : 0u; }

 inline char *qstrcpy( char *dst, const char *src )
{ return src ? strcpy(dst, src) : 0; }

 char *qstrncpy( char *dst, const char *src, uint len );

 inline int qstrcmp( const char *str1, const char *str2 )
{
    return ( str1 && str2 ) ? strcmp( str1, str2 )
                            : ( str1 ? 1 : ( str2 ? -1 : 0 ) );
}

 inline int qstrncmp( const char *str1, const char *str2, uint len )
{
    return ( str1 && str2 ) ? strncmp( str1, str2, len )
                            : ( str1 ? 1 : ( str2 ? -1 : 0 ) );
}

 int qstricmp( const char *, const char * );

 int qstrnicmp( const char *, const char *, uint len );
# 98 "/coolo/prod/qt-copy/include/qcstring.h"
 Q_UINT16 qChecksum( const char *s, uint len );
# 116 "/coolo/prod/qt-copy/include/qcstring.h"
typedef QMemArray<char> QByteArray;



 QByteArray qCompress( const uchar* data, int nbytes );
 QByteArray qUncompress( const uchar* data, int nbytes );
 inline QByteArray qCompress( const QByteArray& data)
{ return qCompress( (const uchar*)data.data(), data.size() ); }
 inline QByteArray qUncompress( const QByteArray& data )
{ return qUncompress( (const uchar*)data.data(), data.size() ); }






 QDataStream &operator<<( QDataStream &, const QByteArray & );
 QDataStream &operator>>( QDataStream &, QByteArray & );






class QRegExp;

class QCString : public QByteArray
{
public:
    QCString() {}
    QCString( int size );
    QCString( const QCString &s ) : QByteArray( s ) {}
    QCString( const char *str );
    QCString( const char *str, uint maxlen );
    ~QCString();

    QCString &operator=( const QCString &s );
    QCString &operator=( const char *str );

    bool isNull() const;
    bool isEmpty() const;
    uint length() const;
    bool resize( uint newlen );
    bool truncate( uint pos );
    bool fill( char c, int len = -1 );

    QCString copy() const;

    QCString &sprintf( const char *format, ... );

    int find( char c, int index=0, bool cs=TRUE ) const;
    int find( const char *str, int index=0, bool cs=TRUE ) const;

    int find( const QRegExp &, int index=0 ) const;

    int findRev( char c, int index=-1, bool cs=TRUE) const;
    int findRev( const char *str, int index=-1, bool cs=TRUE) const;

    int findRev( const QRegExp &, int index=-1 ) const;

    int contains( char c, bool cs=TRUE ) const;
    int contains( const char *str, bool cs=TRUE ) const;

    int contains( const QRegExp & ) const;

    QCString left( uint len ) const;
    QCString right( uint len ) const;
    QCString mid( uint index, uint len=0xffffffff) const;

    QCString leftJustify( uint width, char fill=' ', bool trunc=FALSE)const;
    QCString rightJustify( uint width, char fill=' ',bool trunc=FALSE)const;

    QCString lower() const;
    QCString upper() const;

    QCString stripWhiteSpace() const;
    QCString simplifyWhiteSpace() const;

    QCString &insert( uint index, const char * );
    QCString &insert( uint index, char );
    QCString &append( const char * );
    QCString &prepend( const char * );
    QCString &remove( uint index, uint len );
    QCString &replace( uint index, uint len, const char * );

    QCString &replace( const QRegExp &, const char * );

    QCString &replace( char c, const char *after );
    QCString &replace( const char *, const char * );
    QCString &replace( char, char );

    short toShort( bool *ok=0 ) const;
    ushort toUShort( bool *ok=0 ) const;
    int toInt( bool *ok=0 ) const;
    uint toUInt( bool *ok=0 ) const;
    long toLong( bool *ok=0 ) const;
    ulong toULong( bool *ok=0 ) const;
    float toFloat( bool *ok=0 ) const;
    double toDouble( bool *ok=0 ) const;

    QCString &setStr( const char *s );
    QCString &setNum( short );
    QCString &setNum( ushort );
    QCString &setNum( int );
    QCString &setNum( uint );
    QCString &setNum( long );
    QCString &setNum( ulong );
    QCString &setNum( float, char f='g', int prec=6 );
    QCString &setNum( double, char f='g', int prec=6 );

    bool setExpand( uint index, char c );

                operator const char *() const;
    QCString &operator+=( const char *str );
    QCString &operator+=( char c );
private:
    int find( const char *str, int index, bool cs, uint l ) const;
};






 QDataStream &operator<<( QDataStream &, const QCString & );
 QDataStream &operator>>( QDataStream &, QCString & );






inline QCString &QCString::operator=( const QCString &s )
{ return (QCString&)assign( s ); }

inline QCString &QCString::operator=( const char *str )
{ return (QCString&)duplicate( str, qstrlen(str)+1 ); }

inline bool QCString::isNull() const
{ return data() == 0; }

inline bool QCString::isEmpty() const
{ return data() == 0 || *data() == '\0'; }

inline uint QCString::length() const
{ return qstrlen( data() ); }

inline bool QCString::truncate( uint pos )
{ return resize(pos+1); }

inline QCString QCString::copy() const
{ return QCString( data() ); }

inline QCString &QCString::prepend( const char *s )
{ return insert(0,s); }

inline QCString &QCString::append( const char *s )
{ return operator+=(s); }

inline QCString &QCString::setNum( short n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( ushort n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( int n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( uint n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QCString::operator const char *() const
{ return (const char *)data(); }






 inline bool operator==( const QCString &s1, const QCString &s2 )
{ return qstrcmp( s1.data(), s2.data() ) == 0; }

 inline bool operator==( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) == 0; }

 inline bool operator==( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) == 0; }

 inline bool operator!=( const QCString &s1, const QCString &s2 )
{ return qstrcmp( s1.data(), s2.data() ) != 0; }

 inline bool operator!=( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) != 0; }

 inline bool operator!=( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) != 0; }

 inline bool operator<( const QCString &s1, const QCString& s2 )
{ return qstrcmp( s1.data(), s2.data() ) < 0; }

 inline bool operator<( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) < 0; }

 inline bool operator<( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) < 0; }

 inline bool operator<=( const QCString &s1, const QCString &s2 )
{ return qstrcmp( s1.data(), s2.data() ) <= 0; }

 inline bool operator<=( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) <= 0; }

 inline bool operator<=( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) <= 0; }

 inline bool operator>( const QCString &s1, const QCString &s2 )
{ return qstrcmp( s1.data(), s2.data() ) > 0; }

 inline bool operator>( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) > 0; }

 inline bool operator>( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) > 0; }

 inline bool operator>=( const QCString &s1, const QCString& s2 )
{ return qstrcmp( s1.data(), s2.data() ) >= 0; }

 inline bool operator>=( const QCString &s1, const char *s2 )
{ return qstrcmp( s1.data(), s2 ) >= 0; }

 inline bool operator>=( const char *s1, const QCString &s2 )
{ return qstrcmp( s1, s2.data() ) >= 0; }

 inline const QCString operator+( const QCString &s1,
                                          const QCString &s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

 inline const QCString operator+( const QCString &s1, const char *s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

 inline const QCString operator+( const char *s1, const QCString &s2 )
{
    QCString tmp( s1 );
    tmp += s2;
    return tmp;
}

 inline const QCString operator+( const QCString &s1, char c2 )
{
    QCString tmp( s1.data() );
    tmp += c2;
    return tmp;
}

 inline const QCString operator+( char c1, const QCString &s2 )
{
    QCString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}
# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 389 "/coolo/prod/qt-copy/include/qcstring.h" 2
# 43 "/coolo/prod/qt-copy/include/qstring.h" 2



# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 1 3 4









# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/syslimits.h" 1 3 4





# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 1 3 4
# 122 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 24 "/usr/include/limits.h" 3 4







# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 26 "/usr/include/bits/posix1_lim.h" 3 4





































































# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 26 "/usr/include/bits/local_lim.h" 3 4







# 1 "/usr/include/linux/limits.h" 1 3 4




# 37 "/usr/include/bits/local_lim.h" 2 3 4



#undef NR_OPEN
#undef __undef_NR_OPEN



#undef LINK_MAX
#undef __undef_LINK_MAX



#undef OPEN_MAX
#undef __undef_OPEN_MAX























# 127 "/usr/include/bits/posix1_lim.h" 2 3 4



# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 24 "/usr/include/bits/posix2_lim.h" 3 4















































# 149 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 31 "/usr/include/bits/xopen_lim.h" 3 4

# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 40 "/usr/include/bits/stdio_lim.h" 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 66 "/usr/include/bits/xopen_lim.h" 3 4

















# 110 "/usr/include/bits/xopen_lim.h" 3 4
# 130 "/usr/include/bits/xopen_lim.h" 3 4
# 153 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/syslimits.h" 2 3 4
#undef _GCC_NEXT_LIMITS_H
# 12 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 2 3 4





# 27 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 3 4







# 51 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 3 4




























# 106 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 3 4




# 47 "/coolo/prod/qt-copy/include/qstring.h" 2
# 68 "/coolo/prod/qt-copy/include/qstring.h"
class QRegExp;
class QString;
class QCharRef;
template <class T> class QDeepCopy;

class QChar {
public:
    QChar();
    QChar( char c );
    QChar( uchar c );
    QChar( uchar c, uchar r );
    QChar( const QChar& c );
    QChar( ushort rc );
    QChar( short rc );
    QChar( uint rc );
    QChar( int rc );

    static const QChar null;
    static const QChar replacement;
    static const QChar byteOrderMark;
    static const QChar byteOrderSwapped;
    static const QChar nbsp;



    enum Category
    {
        NoCategory,

        Mark_NonSpacing,
        Mark_SpacingCombining,
        Mark_Enclosing,

        Number_DecimalDigit,
        Number_Letter,
        Number_Other,

        Separator_Space,
        Separator_Line,
        Separator_Paragraph,

        Other_Control,
        Other_Format,
        Other_Surrogate,
        Other_PrivateUse,
        Other_NotAssigned,

        Letter_Uppercase,
        Letter_Lowercase,
        Letter_Titlecase,
        Letter_Modifier,
        Letter_Other,

        Punctuation_Connector,
        Punctuation_Dash,
        Punctuation_Dask = Punctuation_Dash,
        Punctuation_Open,
        Punctuation_Close,
        Punctuation_InitialQuote,
        Punctuation_FinalQuote,
        Punctuation_Other,

        Symbol_Math,
        Symbol_Currency,
        Symbol_Modifier,
        Symbol_Other
    };

    enum Direction
    {
        DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
        DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN
    };

    enum Decomposition
    {
        Single, Canonical, Font, NoBreak, Initial, Medial,
        Final, Isolated, Circle, Super, Sub, Vertical,
        Wide, Narrow, Small, Square, Compat, Fraction
    };

    enum Joining
    {
        OtherJoining, Dual, Right, Center
    };

    enum CombiningClass
    {
        Combining_BelowLeftAttached = 200,
        Combining_BelowAttached = 202,
        Combining_BelowRightAttached = 204,
        Combining_LeftAttached = 208,
        Combining_RightAttached = 210,
        Combining_AboveLeftAttached = 212,
        Combining_AboveAttached = 214,
        Combining_AboveRightAttached = 216,

        Combining_BelowLeft = 218,
        Combining_Below = 220,
        Combining_BelowRight = 222,
        Combining_Left = 224,
        Combining_Right = 226,
        Combining_AboveLeft = 228,
        Combining_Above = 230,
        Combining_AboveRight = 232,

        Combining_DoubleBelow = 233,
        Combining_DoubleAbove = 234,
        Combining_IotaSubscript = 240
    };



    int digitValue() const;
    QChar lower() const;
    QChar upper() const;

    Category category() const;
    Direction direction() const;
    Joining joining() const;
    bool mirrored() const;
    QChar mirroredChar() const;
    const QString &decomposition() const;
    Decomposition decompositionTag() const;
    unsigned char combiningClass() const;

    char latin1() const { return ucs > 0xff ? 0 : (char) ucs; }
    ushort unicode() const { return ucs; }
    ushort &unicode() { return ucs; }


    operator char() const { return latin1(); }


    bool isNull() const { return unicode()==0; }
    bool isPrint() const;
    bool isPunct() const;
    bool isSpace() const;
    bool isMark() const;
    bool isLetter() const;
    bool isNumber() const;
    bool isLetterOrNumber() const;
    bool isDigit() const;
    bool isSymbol() const;

    uchar cell() const { return ((uchar) ucs & 0xff); }
    uchar row() const { return ((uchar) (ucs>>8)&0xff); }
    void setCell( uchar cell ) { ucs = (ucs & 0xff00) + cell; }
    void setRow( uchar row ) { ucs = (((ushort) row)<<8) + (ucs&0xff); }

    static bool networkOrdered() {
        int wordSize;
        bool bigEndian = FALSE;
        qSysInfo( &wordSize, &bigEndian );
        return bigEndian;
    }

    friend inline bool operator==( char ch, QChar c );
    friend inline bool operator==( QChar c, char ch );
    friend inline bool operator==( QChar c1, QChar c2 );
    friend inline bool operator!=( QChar c1, QChar c2 );
    friend inline bool operator!=( char ch, QChar c );
    friend inline bool operator!=( QChar c, char ch );
    friend inline bool operator<=( QChar c, char ch );
    friend inline bool operator<=( char ch, QChar c );
    friend inline bool operator<=( QChar c1, QChar c2 );

private:
    ushort ucs;



} ;

inline QChar::QChar() : ucs( 0 )



{
}
inline QChar::QChar( char c ) : ucs( (uchar)c )



{
}
inline QChar::QChar( uchar c ) : ucs( c )



{
}
inline QChar::QChar( uchar c, uchar r ) : ucs( (r << 8) | c )



{
}
inline QChar::QChar( const QChar& c ) : ucs( c.ucs )



{
}

inline QChar::QChar( ushort rc ) : ucs( rc )



{
}
inline QChar::QChar( short rc ) : ucs( (ushort) rc )



{
}
inline QChar::QChar( uint rc ) : ucs( (ushort ) (rc & 0xffff) )



{
}
inline QChar::QChar( int rc ) : ucs( (ushort) (rc & 0xffff) )



{
}

inline bool operator==( char ch, QChar c )
{
    return ((uchar) ch) == c.ucs;
}

inline bool operator==( QChar c, char ch )
{
    return ((uchar) ch) == c.ucs;
}

inline bool operator==( QChar c1, QChar c2 )
{
    return c1.ucs == c2.ucs;
}

inline bool operator!=( QChar c1, QChar c2 )
{
    return c1.ucs != c2.ucs;
}

inline bool operator!=( char ch, QChar c )
{
    return ((uchar)ch) != c.ucs;
}

inline bool operator!=( QChar c, char ch )
{
    return ((uchar) ch) != c.ucs;
}

inline bool operator<=( QChar c, char ch )
{
    return c.ucs <= ((uchar) ch);
}

inline bool operator<=( char ch, QChar c )
{
    return ((uchar) ch) <= c.ucs;
}

inline bool operator<=( QChar c1, QChar c2 )
{
    return c1.ucs <= c2.ucs;
}

inline bool operator>=( QChar c, char ch ) { return ch <= c; }
inline bool operator>=( char ch, QChar c ) { return c <= ch; }
inline bool operator>=( QChar c1, QChar c2 ) { return c2 <= c1; }
inline bool operator<( QChar c, char ch ) { return !(ch<=c); }
inline bool operator<( char ch, QChar c ) { return !(c<=ch); }
inline bool operator<( QChar c1, QChar c2 ) { return !(c2<=c1); }
inline bool operator>( QChar c, char ch ) { return !(ch>=c); }
inline bool operator>( char ch, QChar c ) { return !(c>=ch); }
inline bool operator>( QChar c1, QChar c2 ) { return !(c2>=c1); }


struct QStringData : public QShared {
    QStringData() :
        QShared(), unicode(0), ascii(0), len(0), issimpletext(TRUE), maxl(0), islatin1(FALSE) { ref(); }
    QStringData(QChar *u, uint l, uint m) :
        QShared(), unicode(u), ascii(0), len(l), issimpletext(FALSE), maxl(m), islatin1(FALSE) { }
    ~QStringData() { if ( unicode ) delete[] ((char*)unicode);
                     if ( ascii ) delete[] ascii; }

    void deleteSelf();
    QChar *unicode;
    char *ascii;
    void setDirty() {
        if ( ascii ) {
            delete [] ascii;
            ascii = 0;
        }
        issimpletext = FALSE;
    }



    uint len : 30;

    uint issimpletext : 1;



    uint maxl : 30;

    uint islatin1 : 1;

private:

    QStringData( const QStringData& );
    QStringData& operator=( const QStringData& );

};


class QString
{
public:
    QString();
    QString( QChar );
    QString( const QString & );
    QString( const QByteArray& );
    QString( const QChar* unicode, uint length );

    QString( const char *str );




    ~QString();

    QString &operator=( const QString & );
    QString &operator=( const char * );



    QString &operator=( const QCString& );
    QString &operator=( QChar c );
    QString &operator=( char c );

    static const QString null;

    bool isNull() const;
    bool isEmpty() const;
    uint length() const;
    void truncate( uint pos );

    QString & fill( QChar c, int len = -1 );

    QString copy() const;

    QString arg( long a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( ulong a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( Q_LLONG a, int fieldwidth=0, int base=10 ) const;
    QString arg( Q_ULLONG a, int fieldwidth=0, int base=10 ) const;
    QString arg( int a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( uint a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( short a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( ushort a, int fieldWidth = 0, int base = 10 ) const;
    QString arg( double a, int fieldWidth = 0, char fmt = 'g',
                 int prec = -1 ) const;
    QString arg( char a, int fieldWidth = 0 ) const;
    QString arg( QChar a, int fieldWidth = 0 ) const;
    QString arg( const QString& a, int fieldWidth = 0 ) const;
    QString arg( const QString& a1, const QString& a2 ) const;
    QString arg( const QString& a1, const QString& a2,
                 const QString& a3 ) const;
    QString arg( const QString& a1, const QString& a2, const QString& a3,
                 const QString& a4 ) const;


    QString &sprintf( const char* format, ... )

        __attribute__ ((format (printf, 2, 3)))

        ;


    int find( QChar c, int index=0, bool cs=TRUE ) const;
    int find( char c, int index=0, bool cs=TRUE ) const;
    int find( const QString &str, int index=0, bool cs=TRUE ) const;

    int find( const QRegExp &, int index=0 ) const;


    int find( const char* str, int index=0 ) const;

    int findRev( QChar c, int index=-1, bool cs=TRUE) const;
    int findRev( char c, int index=-1, bool cs=TRUE) const;
    int findRev( const QString &str, int index=-1, bool cs=TRUE) const;

    int findRev( const QRegExp &, int index=-1 ) const;


    int findRev( const char* str, int index=-1 ) const;

    int contains( QChar c, bool cs=TRUE ) const;
    int contains( char c, bool cs=TRUE ) const
                    { return contains(QChar(c), cs); }

    int contains( const char* str, bool cs=TRUE ) const;

    int contains( const QString &str, bool cs=TRUE ) const;

    int contains( const QRegExp & ) const;


    enum SectionFlags {
        SectionDefault = 0x00,
        SectionSkipEmpty = 0x01,
        SectionIncludeLeadingSep = 0x02,
        SectionIncludeTrailingSep = 0x04,
        SectionCaseInsensitiveSeps = 0x08
    };
    QString section( QChar sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const;
    QString section( char sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const;

    QString section( const char *in_sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const;

    QString section( const QString &in_sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const;

    QString section( const QRegExp &reg, int start, int end = 0xffffffff, int flags = SectionDefault ) const;


    QString left( uint len ) const;
    QString right( uint len ) const;
    QString mid( uint index, uint len=0xffffffff) const;

    QString leftJustify( uint width, QChar fill=' ', bool trunc=FALSE)const;
    QString rightJustify( uint width, QChar fill=' ',bool trunc=FALSE)const;

    QString lower() const;
    QString upper() const;

    QString stripWhiteSpace() const;
    QString simplifyWhiteSpace() const;

    QString &insert( uint index, const QString & );

    QString &insert( uint index, const QByteArray & );
    QString &insert( uint index, const char * );

    QString &insert( uint index, const QChar*, uint len );
    QString &insert( uint index, QChar );
    QString &insert( uint index, char c ) { return insert(index,QChar(c)); }
    QString &append( char );
    QString &append( QChar );
    QString &append( const QString & );

    QString &append( const QByteArray & );
    QString &append( const char * );




    QString &prepend( char );
    QString &prepend( QChar );
    QString &prepend( const QString & );

    QString &prepend( const QByteArray & );
    QString &prepend( const char * );




    QString &remove( uint index, uint len );




    QString &remove( const QString & );
    QString &remove( const QString &, bool cs );

    QString &remove( QChar c );
    QString &remove( char c )
    { return remove( QChar(c) ); }

    QString &remove( const char * );


    QString &remove( const QRegExp & );

    QString &replace( uint index, uint len, const QString & );
    QString &replace( uint index, uint len, const QChar*, uint clen );
    QString &replace( uint index, uint len, QChar );
    QString &replace( uint index, uint len, char c )
    { return replace( index, len, QChar(c) ); }







    QString &replace( QChar c, const QString & );
    QString &replace( QChar c, const QString &, bool );


    QString &replace( char c, const QString & after )
    { return replace( QChar(c), after, TRUE ); }
    QString &replace( char c, const QString & after, bool cs )
    { return replace( QChar(c), after, cs ); }


    QString &replace( const QString &, const QString & );
    QString &replace( const QString &, const QString &, bool );


    QString &replace( const QRegExp &, const QString & );

    QString &replace( QChar, QChar );

    short toShort( bool *ok=0, int base=10 ) const;
    ushort toUShort( bool *ok=0, int base=10 ) const;
    int toInt( bool *ok=0, int base=10 ) const;
    uint toUInt( bool *ok=0, int base=10 ) const;
    long toLong( bool *ok=0, int base=10 ) const;
    ulong toULong( bool *ok=0, int base=10 ) const;
    Q_LLONG toLongLong( bool *ok=0, int base=10 ) const;
    Q_ULLONG toULongLong( bool *ok=0, int base=10 ) const;
    float toFloat( bool *ok=0 ) const;
    double toDouble( bool *ok=0 ) const;

    QString &setNum( short, int base=10 );
    QString &setNum( ushort, int base=10 );
    QString &setNum( int, int base=10 );
    QString &setNum( uint, int base=10 );
    QString &setNum( long, int base=10 );
    QString &setNum( ulong, int base=10 );
    QString &setNum( Q_LLONG, int base=10 );
    QString &setNum( Q_ULLONG, int base=10 );
    QString &setNum( float, char f='g', int prec=6 );
    QString &setNum( double, char f='g', int prec=6 );

    static QString number( long, int base=10 );
    static QString number( ulong, int base=10);
    static QString number( Q_LLONG, int base=10 );
    static QString number( Q_ULLONG, int base=10);
    static QString number( int, int base=10 );
    static QString number( uint, int base=10);
    static QString number( double, char f='g', int prec=6 );

    void setExpand( uint index, QChar c );

    QString &operator+=( const QString &str );




    QString &operator+=( const QByteArray &str );

    QString &operator+=( const char *str );




    QString &operator+=( QChar c );
    QString &operator+=( char c );

    QChar at( uint i ) const
        { return i < d->len ? d->unicode[i] : QChar::null; }
    QChar operator[]( int i ) const { return at((uint)i); }
    QCharRef at( uint i );
    QCharRef operator[]( int i );

    QChar constref(uint i) const
        { return at(i); }
    QChar& ref(uint i)
        {
            if ( d->count != 1 || i >= d->len )
                subat( i );
            d->setDirty();
            return d->unicode[i];
        }

    const QChar* unicode() const { return d->unicode; }
    const char* ascii() const;
    static QString fromAscii(const char*, int len=-1);
    const char* latin1() const;
    static QString fromLatin1(const char*, int len=-1);
    QCString utf8() const;
    static QString fromUtf8(const char*, int len=-1);
    QCString local8Bit() const;
    static QString fromLocal8Bit(const char*, int len=-1);
    bool operator!() const;







    static QString fromUcs2( const unsigned short *ucs2 );
    const unsigned short *ucs2() const;

    QString &setUnicode( const QChar* unicode, uint len );
    QString &setUnicodeCodes( const ushort* unicode_as_ushorts, uint len );
    QString &setAscii( const char*, int len=-1 );
    QString &setLatin1( const char*, int len=-1 );

    int compare( const QString& s ) const;
    static int compare( const QString& s1, const QString& s2 )
    { return s1.compare( s2 ); }

    int localeAwareCompare( const QString& s ) const;
    static int localeAwareCompare( const QString& s1, const QString& s2 )
    { return s1.localeAwareCompare( s2 ); }


    friend QDataStream &operator>>( QDataStream &, QString & );


    void compose();
# 701 "/coolo/prod/qt-copy/include/qstring.h"
    bool startsWith( const QString& str ) const;
    bool startsWith( const QString& str, bool cs ) const;


    bool endsWith( const QString& str ) const;
    bool endsWith( const QString& str, bool cs ) const;


    void setLength( uint newLength );

    uint capacity() const;
    void reserve( uint minCapacity );
    void squeeze();

    bool simpleText() const { if ( !d->issimpletext ) checkSimpleText(); return (bool)d->issimpletext; }
    bool isRightToLeft() const;


private:
    QString( int size, bool );

    void deref();
    void real_detach();
    void subat( uint );
    QString multiArg( int numArgs, const QString& a1, const QString& a2,
                      const QString& a3 = QString::null,
                      const QString& a4 = QString::null ) const;

    void checkSimpleText() const;
    void grow( uint newLength );

    QString &insertHelper( uint index, const char *s, uint len=(2147483647 * 2U + 1U) );
    QString &operatorPlusEqHelper( const char *s, uint len2=(2147483647 * 2U + 1U) );


    static QChar* latin1ToUnicode( const char*, uint * len, uint maxlen=(uint)-1 );
    static QChar* latin1ToUnicode( const QByteArray&, uint * len );
    static char* unicodeToLatin1( const QChar*, uint len );

    QStringData *d;
    static QStringData* shared_null;
    static QStringData* makeSharedNull();

    friend class QConstString;
    friend class QTextStream;
    QString( QStringData* dd, bool ) : d(dd) { }


    void detach();
    friend class QDeepCopy<QString>;
};

class QCharRef {
    friend class QString;
    QString& s;
    uint p;
    QCharRef(QString* str, uint pos) : s(*str), p(pos) { }

public:




    ushort unicode() const { return s.constref(p).unicode(); }
    char latin1() const { return s.constref(p).latin1(); }


    QCharRef operator=(char c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(uchar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(QChar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(const QCharRef& c ) { s.ref(p)=c.unicode(); return *this; }
    QCharRef operator=(ushort rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(short rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(uint rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(int rc ) { s.ref(p)=rc; return *this; }

    operator QChar () const { return s.constref(p); }


    bool isNull() const { return unicode()==0; }
    bool isPrint() const { return s.constref(p).isPrint(); }
    bool isPunct() const { return s.constref(p).isPunct(); }
    bool isSpace() const { return s.constref(p).isSpace(); }
    bool isMark() const { return s.constref(p).isMark(); }
    bool isLetter() const { return s.constref(p).isLetter(); }
    bool isNumber() const { return s.constref(p).isNumber(); }
    bool isLetterOrNumber() { return s.constref(p).isLetterOrNumber(); }
    bool isDigit() const { return s.constref(p).isDigit(); }

    int digitValue() const { return s.constref(p).digitValue(); }
    QChar lower() const { return s.constref(p).lower(); }
    QChar upper() const { return s.constref(p).upper(); }

    QChar::Category category() const { return s.constref(p).category(); }
    QChar::Direction direction() const { return s.constref(p).direction(); }
    QChar::Joining joining() const { return s.constref(p).joining(); }
    bool mirrored() const { return s.constref(p).mirrored(); }
    QChar mirroredChar() const { return s.constref(p).mirroredChar(); }
    const QString &decomposition() const { return s.constref(p).decomposition(); }
    QChar::Decomposition decompositionTag() const { return s.constref(p).decompositionTag(); }
    unsigned char combiningClass() const { return s.constref(p).combiningClass(); }


    uchar cell() const { return s.constref(p).cell(); }
    uchar row() const { return s.constref(p).row(); }

};

inline QCharRef QString::at( uint i ) { return QCharRef(this,i); }
inline QCharRef QString::operator[]( int i ) { return at((uint)i); }


class QConstString : private QString {
public:
    QConstString( const QChar* unicode, uint length );
    ~QConstString();
    const QString& string() const { return *this; }
};






 QDataStream &operator<<( QDataStream &, const QString & );
 QDataStream &operator>>( QDataStream &, QString & );
# 838 "/coolo/prod/qt-copy/include/qstring.h"
inline QString::QString() :
    d(shared_null ? shared_null : makeSharedNull())
{
    d->ref();
}

inline QString::~QString()
{
    if ( d->deref() ) {
        if ( d != shared_null )
            d->deleteSelf();
    }
}


inline void QString::detach()
{ real_detach(); }

inline QString QString::section( QChar sep, int start, int end, int flags ) const
{ return section(QString(sep), start, end, flags); }

inline QString QString::section( char sep, int start, int end, int flags ) const
{ return section(QChar(sep), start, end, flags); }


inline QString QString::section( const char *in_sep, int start, int end, int flags ) const
{ return section(QString(in_sep), start, end, flags); }


inline QString &QString::operator=( QChar c )
{ *this = QString(c); return *this; }

inline QString &QString::operator=( char c )
{ *this = QString(QChar(c)); return *this; }

inline bool QString::isNull() const
{ return unicode() == 0; }

inline bool QString::operator!() const
{ return isNull(); }

inline uint QString::length() const
{ return d->len; }

inline uint QString::capacity() const
{ return d->maxl; }

inline bool QString::isEmpty() const
{ return length() == 0; }

inline QString QString::copy() const
{ return QString( *this ); }


inline QString &QString::insert( uint index, const char *s )
{ return insertHelper( index, s ); }

inline QString &QString::insert( uint index, const QByteArray &s )
{
    int pos = s.find( 0 );
    return insertHelper( index, s, pos==-1 ? s.size() : pos );
}


inline QString &QString::prepend( const QString & s )
{ return insert(0,s); }

inline QString &QString::prepend( QChar c )
{ return insert(0,c); }

inline QString &QString::prepend( char c )
{ return insert(0,c); }


inline QString &QString::prepend( const QByteArray & s )
{ return insert(0,s); }


inline QString &QString::append( const QString & s )
{ return operator+=(s); }


inline QString &QString::append( const QByteArray &s )
{ return operator+=(s); }

inline QString &QString::append( const char * s )
{ return operator+=(s); }


inline QString &QString::append( QChar c )
{ return operator+=(c); }

inline QString &QString::append( char c )
{ return operator+=(c); }


inline QString &QString::operator+=( const QByteArray &s )
{
    int pos = s.find( 0 );
    return operatorPlusEqHelper( s, pos==-1 ? s.size() : pos );
}
# 952 "/coolo/prod/qt-copy/include/qstring.h"
inline QString &QString::setNum( short n, int base )
{ return setNum((Q_LLONG)n, base); }

inline QString &QString::setNum( ushort n, int base )
{ return setNum((Q_ULLONG)n, base); }

inline QString &QString::setNum( int n, int base )
{ return setNum((Q_LLONG)n, base); }

inline QString &QString::setNum( uint n, int base )
{ return setNum((Q_ULLONG)n, base); }

inline QString &QString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QString QString::arg( int a, int fieldWidth, int base ) const
{ return arg( (Q_LLONG)a, fieldWidth, base ); }

inline QString QString::arg( uint a, int fieldWidth, int base ) const
{ return arg( (Q_ULLONG)a, fieldWidth, base ); }

inline QString QString::arg( short a, int fieldWidth, int base ) const
{ return arg( (Q_LLONG)a, fieldWidth, base ); }

inline QString QString::arg( ushort a, int fieldWidth, int base ) const
{ return arg( (Q_ULLONG)a, fieldWidth, base ); }

inline QString QString::arg( const QString& a1, const QString& a2 ) const {
    return multiArg( 2, a1, a2 );
}

inline QString QString::arg( const QString& a1, const QString& a2,
                             const QString& a3 ) const {
    return multiArg( 3, a1, a2, a3 );
}

inline QString QString::arg( const QString& a1, const QString& a2,
                             const QString& a3, const QString& a4 ) const {
    return multiArg( 4, a1, a2, a3, a4 );
}

inline int QString::find( char c, int index, bool cs ) const
{ return find(QChar(c), index, cs); }

inline int QString::findRev( char c, int index, bool cs ) const
{ return findRev( QChar(c), index, cs ); }


inline int QString::find( const char* str, int index ) const
{ return find(QString::fromAscii(str), index); }

inline int QString::findRev( const char* str, int index ) const
{ return findRev(QString::fromAscii(str), index); }







 bool operator!=( const QString &s1, const QString &s2 );
 bool operator<( const QString &s1, const QString &s2 );
 bool operator<=( const QString &s1, const QString &s2 );
 bool operator==( const QString &s1, const QString &s2 );
 bool operator>( const QString &s1, const QString &s2 );
 bool operator>=( const QString &s1, const QString &s2 );

 bool operator!=( const QString &s1, const char *s2 );
 bool operator<( const QString &s1, const char *s2 );
 bool operator<=( const QString &s1, const char *s2 );
 bool operator==( const QString &s1, const char *s2 );
 bool operator>( const QString &s1, const char *s2 );
 bool operator>=( const QString &s1, const char *s2 );
 bool operator!=( const char *s1, const QString &s2 );
 bool operator<( const char *s1, const QString &s2 );
 bool operator<=( const char *s1, const QString &s2 );
 bool operator==( const char *s1, const QString &s2 );

 bool operator>=( const char *s1, const QString &s2 );


 inline const QString operator+( const QString &s1, const QString &s2 )
{
    QString tmp( s1 );
    tmp += s2;
    return tmp;
}


 inline const QString operator+( const QString &s1, const char *s2 )
{
    QString tmp( s1 );
    tmp += QString::fromAscii(s2);
    return tmp;
}

 inline const QString operator+( const char *s1, const QString &s2 )
{
    QString tmp = QString::fromAscii( s1 );
    tmp += s2;
    return tmp;
}


 inline const QString operator+( const QString &s1, QChar c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

 inline const QString operator+( const QString &s1, char c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

 inline const QString operator+( QChar c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}

 inline const QString operator+( char c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}
# 1094 "/coolo/prod/qt-copy/include/qstring.h"
# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 1096 "/coolo/prod/qt-copy/include/qstring.h" 2
# 45 "/coolo/prod/qt-copy/include/qwindowdefs.h" 2
# 1 "/coolo/prod/qt-copy/include/qnamespace.h" 1
# 39 "/coolo/prod/qt-copy/include/qnamespace.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qnamespace.h" 2



class QColor;
class QCursor;


class Qt {
public:
    static const QColor & color0;
    static const QColor & color1;
    static const QColor & black;
    static const QColor & white;
    static const QColor & darkGray;
    static const QColor & gray;
    static const QColor & lightGray;
    static const QColor & red;
    static const QColor & green;
    static const QColor & blue;
    static const QColor & cyan;
    static const QColor & magenta;
    static const QColor & yellow;
    static const QColor & darkRed;
    static const QColor & darkGreen;
    static const QColor & darkBlue;
    static const QColor & darkCyan;
    static const QColor & darkMagenta;
    static const QColor & darkYellow;


    enum ButtonState {
        NoButton = 0x0000,
        LeftButton = 0x0001,
        RightButton = 0x0002,
        MidButton = 0x0004,
        MouseButtonMask = 0x0007,
        ShiftButton = 0x0100,
        ControlButton = 0x0200,
        AltButton = 0x0400,
        MetaButton = 0x0800,
        KeyButtonMask = 0x0f00,
        Keypad = 0x4000
    };



    enum Orientation {
        Horizontal = 0,
        Vertical
    };


    enum SortOrder {
        Ascending,
        Descending
    };






    enum AlignmentFlags {
        AlignAuto = 0x0000,
        AlignLeft = 0x0001,
        AlignRight = 0x0002,
        AlignHCenter = 0x0004,
        AlignJustify = 0x0008,
        AlignHorizontal_Mask = AlignLeft | AlignRight | AlignHCenter | AlignJustify,
        AlignTop = 0x0010,
        AlignBottom = 0x0020,
        AlignVCenter = 0x0040,
        AlignVertical_Mask = AlignTop | AlignBottom | AlignVCenter,
        AlignCenter = AlignVCenter | AlignHCenter
    };


    enum TextFlags {
        SingleLine = 0x0080,
        DontClip = 0x0100,
        ExpandTabs = 0x0200,
        ShowPrefix = 0x0400,
        WordBreak = 0x0800,
        BreakAnywhere = 0x1000,

        DontPrint = 0x2000,
        Underline = 0x01000000,
        Overline = 0x02000000,
        StrikeOut = 0x04000000,
        IncludeTrailingSpaces = 0x08000000,

        NoAccel = 0x4000
    };


    typedef uint WState;


    enum WidgetState {
        WState_Created = 0x00000001,
        WState_Disabled = 0x00000002,
        WState_Visible = 0x00000004,
        WState_ForceHide = 0x00000008,
        WState_OwnCursor = 0x00000010,
        WState_MouseTracking = 0x00000020,
        WState_CompressKeys = 0x00000040,
        WState_BlockUpdates = 0x00000080,
        WState_InPaintEvent = 0x00000100,
        WState_Reparented = 0x00000200,
        WState_ConfigPending = 0x00000400,
        WState_Resized = 0x00000800,
        WState_AutoMask = 0x00001000,
        WState_Polished = 0x00002000,
        WState_DND = 0x00004000,
        WState_Reserved0 = 0x00008000,
        WState_Reserved1 = 0x00010000,
        WState_OwnSizePolicy = 0x00020000,
        WState_CreatedHidden = 0x00040000,
        WState_Maximized = 0x00080000,
        WState_Minimized = 0x00100000,
        WState_ForceDisabled = 0x00200000,
        WState_Exposed = 0x00400000,
        WState_HasMouse = 0x00800000
    };


    typedef uint WFlags;


    enum WidgetFlags {
        WType_TopLevel = 0x00000001,
        WType_Dialog = 0x00000002,
        WType_Popup = 0x00000004,
        WType_Desktop = 0x00000008,
        WType_Mask = 0x0000000f,

        WStyle_Customize = 0x00000010,
        WStyle_NormalBorder = 0x00000020,
        WStyle_DialogBorder = 0x00000040,
        WStyle_NoBorder = 0x00002000,
        WStyle_Title = 0x00000080,
        WStyle_SysMenu = 0x00000100,
        WStyle_Minimize = 0x00000200,
        WStyle_Maximize = 0x00000400,
        WStyle_MinMax = WStyle_Minimize | WStyle_Maximize,
        WStyle_Tool = 0x00000800,
        WStyle_StaysOnTop = 0x00001000,
        WStyle_ContextHelp = 0x00004000,
        WStyle_Reserved = 0x00008000,
        WStyle_Mask = 0x0000fff0,

        WDestructiveClose = 0x00010000,
        WPaintDesktop = 0x00020000,
        WPaintUnclipped = 0x00040000,
        WPaintClever = 0x00080000,
        WResizeNoErase = 0x00100000,
        WMouseNoMask = 0x00200000,
        WStaticContents = 0x00400000,
        WRepaintNoErase = 0x00800000,

        WX11BypassWM = 0x01000000,
        WWinOwnDC = 0x00000000,
        WMacNoSheet = 0x00000000,
        WMacDrawer = 0x00000000,
# 218 "/coolo/prod/qt-copy/include/qnamespace.h"
        WGroupLeader = 0x02000000,
        WShowModal = 0x04000000,
        WNoMousePropagation = 0x08000000,
        WSubWindow = 0x10000000,

        WStyle_Splash = 0x20000000,




        WNoAutoErase = WRepaintNoErase | WResizeNoErase







    };





    enum ImageConversionFlags {
        ColorMode_Mask = 0x00000003,
        AutoColor = 0x00000000,
        ColorOnly = 0x00000003,
        MonoOnly = 0x00000002,


        AlphaDither_Mask = 0x0000000c,
        ThresholdAlphaDither = 0x00000000,
        OrderedAlphaDither = 0x00000004,
        DiffuseAlphaDither = 0x00000008,
        NoAlpha = 0x0000000c,

        Dither_Mask = 0x00000030,
        DiffuseDither = 0x00000000,
        OrderedDither = 0x00000010,
        ThresholdDither = 0x00000020,


        DitherMode_Mask = 0x000000c0,
        AutoDither = 0x00000000,
        PreferDither = 0x00000040,
        AvoidDither = 0x00000080
    };


    enum BGMode {
        TransparentMode,
        OpaqueMode
    };
# 287 "/coolo/prod/qt-copy/include/qnamespace.h"
    enum GUIStyle {
        WindowsStyle = 1,
        MotifStyle = 4
    };
# 302 "/coolo/prod/qt-copy/include/qnamespace.h"
    enum SequenceMatch {
        NoMatch,
        PartialMatch,
        Identical
    };


    enum Modifier {
        META = 0x00100000,
        SHIFT = 0x00200000,
        CTRL = 0x00400000,
        ALT = 0x00800000,
        MODIFIER_MASK = 0x00f00000,
        UNICODE_ACCEL = 0x10000000,

        ASCII_ACCEL = UNICODE_ACCEL
    };


    enum Key {
        Key_Escape = 0x1000,
        Key_Tab = 0x1001,
        Key_Backtab = 0x1002, Key_BackTab = Key_Backtab,
        Key_Backspace = 0x1003, Key_BackSpace = Key_Backspace,
        Key_Return = 0x1004,
        Key_Enter = 0x1005,
        Key_Insert = 0x1006,
        Key_Delete = 0x1007,
        Key_Pause = 0x1008,
        Key_Print = 0x1009,
        Key_SysReq = 0x100a,
        Key_Clear = 0x100b,
        Key_Home = 0x1010,
        Key_End = 0x1011,
        Key_Left = 0x1012,
        Key_Up = 0x1013,
        Key_Right = 0x1014,
        Key_Down = 0x1015,
        Key_Prior = 0x1016, Key_PageUp = Key_Prior,
        Key_Next = 0x1017, Key_PageDown = Key_Next,
        Key_Shift = 0x1020,
        Key_Control = 0x1021,
        Key_Meta = 0x1022,
        Key_Alt = 0x1023,
        Key_CapsLock = 0x1024,
        Key_NumLock = 0x1025,
        Key_ScrollLock = 0x1026,
        Key_F1 = 0x1030,
        Key_F2 = 0x1031,
        Key_F3 = 0x1032,
        Key_F4 = 0x1033,
        Key_F5 = 0x1034,
        Key_F6 = 0x1035,
        Key_F7 = 0x1036,
        Key_F8 = 0x1037,
        Key_F9 = 0x1038,
        Key_F10 = 0x1039,
        Key_F11 = 0x103a,
        Key_F12 = 0x103b,
        Key_F13 = 0x103c,
        Key_F14 = 0x103d,
        Key_F15 = 0x103e,
        Key_F16 = 0x103f,
        Key_F17 = 0x1040,
        Key_F18 = 0x1041,
        Key_F19 = 0x1042,
        Key_F20 = 0x1043,
        Key_F21 = 0x1044,
        Key_F22 = 0x1045,
        Key_F23 = 0x1046,
        Key_F24 = 0x1047,
        Key_F25 = 0x1048,
        Key_F26 = 0x1049,
        Key_F27 = 0x104a,
        Key_F28 = 0x104b,
        Key_F29 = 0x104c,
        Key_F30 = 0x104d,
        Key_F31 = 0x104e,
        Key_F32 = 0x104f,
        Key_F33 = 0x1050,
        Key_F34 = 0x1051,
        Key_F35 = 0x1052,
        Key_Super_L = 0x1053,
        Key_Super_R = 0x1054,
        Key_Menu = 0x1055,
        Key_Hyper_L = 0x1056,
        Key_Hyper_R = 0x1057,
        Key_Help = 0x1058,
        Key_Direction_L = 0x1059,
        Key_Direction_R = 0x1060,
        Key_Space = 0x20,
        Key_Any = Key_Space,
        Key_Exclam = 0x21,
        Key_QuoteDbl = 0x22,
        Key_NumberSign = 0x23,
        Key_Dollar = 0x24,
        Key_Percent = 0x25,
        Key_Ampersand = 0x26,
        Key_Apostrophe = 0x27,
        Key_ParenLeft = 0x28,
        Key_ParenRight = 0x29,
        Key_Asterisk = 0x2a,
        Key_Plus = 0x2b,
        Key_Comma = 0x2c,
        Key_Minus = 0x2d,
        Key_Period = 0x2e,
        Key_Slash = 0x2f,
        Key_0 = 0x30,
        Key_1 = 0x31,
        Key_2 = 0x32,
        Key_3 = 0x33,
        Key_4 = 0x34,
        Key_5 = 0x35,
        Key_6 = 0x36,
        Key_7 = 0x37,
        Key_8 = 0x38,
        Key_9 = 0x39,
        Key_Colon = 0x3a,
        Key_Semicolon = 0x3b,
        Key_Less = 0x3c,
        Key_Equal = 0x3d,
        Key_Greater = 0x3e,
        Key_Question = 0x3f,
        Key_At = 0x40,
        Key_A = 0x41,
        Key_B = 0x42,
        Key_C = 0x43,
        Key_D = 0x44,
        Key_E = 0x45,
        Key_F = 0x46,
        Key_G = 0x47,
        Key_H = 0x48,
        Key_I = 0x49,
        Key_J = 0x4a,
        Key_K = 0x4b,
        Key_L = 0x4c,
        Key_M = 0x4d,
        Key_N = 0x4e,
        Key_O = 0x4f,
        Key_P = 0x50,
        Key_Q = 0x51,
        Key_R = 0x52,
        Key_S = 0x53,
        Key_T = 0x54,
        Key_U = 0x55,
        Key_V = 0x56,
        Key_W = 0x57,
        Key_X = 0x58,
        Key_Y = 0x59,
        Key_Z = 0x5a,
        Key_BracketLeft = 0x5b,
        Key_Backslash = 0x5c,
        Key_BracketRight = 0x5d,
        Key_AsciiCircum = 0x5e,
        Key_Underscore = 0x5f,
        Key_QuoteLeft = 0x60,
        Key_BraceLeft = 0x7b,
        Key_Bar = 0x7c,
        Key_BraceRight = 0x7d,
        Key_AsciiTilde = 0x7e,



        Key_nobreakspace = 0x0a0,
        Key_exclamdown = 0x0a1,
        Key_cent = 0x0a2,
        Key_sterling = 0x0a3,
        Key_currency = 0x0a4,
        Key_yen = 0x0a5,
        Key_brokenbar = 0x0a6,
        Key_section = 0x0a7,
        Key_diaeresis = 0x0a8,
        Key_copyright = 0x0a9,
        Key_ordfeminine = 0x0aa,
        Key_guillemotleft = 0x0ab,
        Key_notsign = 0x0ac,
        Key_hyphen = 0x0ad,
        Key_registered = 0x0ae,
        Key_macron = 0x0af,
        Key_degree = 0x0b0,
        Key_plusminus = 0x0b1,
        Key_twosuperior = 0x0b2,
        Key_threesuperior = 0x0b3,
        Key_acute = 0x0b4,
        Key_mu = 0x0b5,
        Key_paragraph = 0x0b6,
        Key_periodcentered = 0x0b7,
        Key_cedilla = 0x0b8,
        Key_onesuperior = 0x0b9,
        Key_masculine = 0x0ba,
        Key_guillemotright = 0x0bb,
        Key_onequarter = 0x0bc,
        Key_onehalf = 0x0bd,
        Key_threequarters = 0x0be,
        Key_questiondown = 0x0bf,
        Key_Agrave = 0x0c0,
        Key_Aacute = 0x0c1,
        Key_Acircumflex = 0x0c2,
        Key_Atilde = 0x0c3,
        Key_Adiaeresis = 0x0c4,
        Key_Aring = 0x0c5,
        Key_AE = 0x0c6,
        Key_Ccedilla = 0x0c7,
        Key_Egrave = 0x0c8,
        Key_Eacute = 0x0c9,
        Key_Ecircumflex = 0x0ca,
        Key_Ediaeresis = 0x0cb,
        Key_Igrave = 0x0cc,
        Key_Iacute = 0x0cd,
        Key_Icircumflex = 0x0ce,
        Key_Idiaeresis = 0x0cf,
        Key_ETH = 0x0d0,
        Key_Ntilde = 0x0d1,
        Key_Ograve = 0x0d2,
        Key_Oacute = 0x0d3,
        Key_Ocircumflex = 0x0d4,
        Key_Otilde = 0x0d5,
        Key_Odiaeresis = 0x0d6,
        Key_multiply = 0x0d7,
        Key_Ooblique = 0x0d8,
        Key_Ugrave = 0x0d9,
        Key_Uacute = 0x0da,
        Key_Ucircumflex = 0x0db,
        Key_Udiaeresis = 0x0dc,
        Key_Yacute = 0x0dd,
        Key_THORN = 0x0de,
        Key_ssharp = 0x0df,
        Key_agrave = 0x0e0,
        Key_aacute = 0x0e1,
        Key_acircumflex = 0x0e2,
        Key_atilde = 0x0e3,
        Key_adiaeresis = 0x0e4,
        Key_aring = 0x0e5,
        Key_ae = 0x0e6,
        Key_ccedilla = 0x0e7,
        Key_egrave = 0x0e8,
        Key_eacute = 0x0e9,
        Key_ecircumflex = 0x0ea,
        Key_ediaeresis = 0x0eb,
        Key_igrave = 0x0ec,
        Key_iacute = 0x0ed,
        Key_icircumflex = 0x0ee,
        Key_idiaeresis = 0x0ef,
        Key_eth = 0x0f0,
        Key_ntilde = 0x0f1,
        Key_ograve = 0x0f2,
        Key_oacute = 0x0f3,
        Key_ocircumflex = 0x0f4,
        Key_otilde = 0x0f5,
        Key_odiaeresis = 0x0f6,
        Key_division = 0x0f7,
        Key_oslash = 0x0f8,
        Key_ugrave = 0x0f9,
        Key_uacute = 0x0fa,
        Key_ucircumflex = 0x0fb,
        Key_udiaeresis = 0x0fc,
        Key_yacute = 0x0fd,
        Key_thorn = 0x0fe,
        Key_ydiaeresis = 0x0ff,



        Key_Back = 0x1061,
        Key_Forward = 0x1062,
        Key_Stop = 0x1063,
        Key_Refresh = 0x1064,

        Key_VolumeDown = 0x1070,
        Key_VolumeMute = 0x1071,
        Key_VolumeUp = 0x1072,
        Key_BassBoost = 0x1073,
        Key_BassUp = 0x1074,
        Key_BassDown = 0x1075,
        Key_TrebleUp = 0x1076,
        Key_TrebleDown = 0x1077,

        Key_MediaPlay = 0x1080,
        Key_MediaStop = 0x1081,
        Key_MediaPrev = 0x1082,
        Key_MediaNext = 0x1083,
        Key_MediaRecord = 0x1084,

        Key_HomePage = 0x1090,
        Key_Favorites = 0x1091,
        Key_Search = 0x1092,
        Key_Standby = 0x1093,
        Key_OpenUrl = 0x1094,

        Key_LaunchMail = 0x10a0,
        Key_LaunchMedia = 0x10a1,
        Key_Launch0 = 0x10a2,
        Key_Launch1 = 0x10a3,
        Key_Launch2 = 0x10a4,
        Key_Launch3 = 0x10a5,
        Key_Launch4 = 0x10a6,
        Key_Launch5 = 0x10a7,
        Key_Launch6 = 0x10a8,
        Key_Launch7 = 0x10a9,
        Key_Launch8 = 0x10aa,
        Key_Launch9 = 0x10ab,
        Key_LaunchA = 0x10ac,
        Key_LaunchB = 0x10ad,
        Key_LaunchC = 0x10ae,
        Key_LaunchD = 0x10af,
        Key_LaunchE = 0x10b0,
        Key_LaunchF = 0x10b1,

        Key_MediaLast = 0x1fff,

        Key_unknown = 0xffff
    };


    enum ArrowType {
        UpArrow,
        DownArrow,
        LeftArrow,
        RightArrow
    };


    enum RasterOp {
        CopyROP,
        OrROP,
        XorROP,
        NotAndROP, EraseROP=NotAndROP,
        NotCopyROP,
        NotOrROP,
        NotXorROP,
        AndROP, NotEraseROP=AndROP,
        NotROP,
        ClearROP,
        SetROP,
        NopROP,
        AndNotROP,
        OrNotROP,
        NandROP,
        NorROP, LastROP=NorROP
    };


    enum PenStyle {
        NoPen,
        SolidLine,
        DashLine,
        DotLine,
        DashDotLine,
        DashDotDotLine,
        MPenStyle = 0x0f
    };


    enum PenCapStyle {
        FlatCap = 0x00,
        SquareCap = 0x10,
        RoundCap = 0x20,
        MPenCapStyle = 0x30
    };


    enum PenJoinStyle {
        MiterJoin = 0x00,
        BevelJoin = 0x40,
        RoundJoin = 0x80,
        MPenJoinStyle = 0xc0
    };


    enum BrushStyle {
        NoBrush,
        SolidPattern,
        Dense1Pattern,
        Dense2Pattern,
        Dense3Pattern,
        Dense4Pattern,
        Dense5Pattern,
        Dense6Pattern,
        Dense7Pattern,
        HorPattern,
        VerPattern,
        CrossPattern,
        BDiagPattern,
        FDiagPattern,
        DiagCrossPattern,
        CustomPattern=24
    };


    enum MacintoshVersion {

        MV_Unknown = 0x0000,


        MV_9 = 0x0001,
        MV_10_DOT_0 = 0x0002,
        MV_10_DOT_1 = 0x0003,
        MV_10_DOT_2 = 0x0004,
        MV_10_DOT_3 = 0x0005,


        MV_CHEETAH = MV_10_DOT_0,
        MV_PUMA = MV_10_DOT_1,
        MV_JAGUAR = MV_10_DOT_2,
        MV_PANTHER = MV_10_DOT_3
    };


    enum WindowsVersion {
        WV_32s = 0x0001,
        WV_95 = 0x0002,
        WV_98 = 0x0003,
        WV_Me = 0x0004,
        WV_DOS_based = 0x000f,

        WV_NT = 0x0010,
        WV_2000 = 0x0020,
        WV_XP = 0x0030,
        WV_NT_based = 0x00f0
    };


    enum UIEffect {
        UI_General,
        UI_AnimateMenu,
        UI_FadeMenu,
        UI_AnimateCombo,
        UI_AnimateTooltip,
        UI_FadeTooltip,
        UI_AnimateToolBox
    };


    enum CursorShape {
        ArrowCursor,
        UpArrowCursor,
        CrossCursor,
        WaitCursor,
        IbeamCursor,
        SizeVerCursor,
        SizeHorCursor,
        SizeBDiagCursor,
        SizeFDiagCursor,
        SizeAllCursor,
        BlankCursor,
        SplitVCursor,
        SplitHCursor,
        PointingHandCursor,
        ForbiddenCursor,
        WhatsThisCursor,
        LastCursor = WhatsThisCursor,
        BitmapCursor = 24
    };



    static const QCursor & arrowCursor;
    static const QCursor & upArrowCursor;
    static const QCursor & crossCursor;
    static const QCursor & waitCursor;
    static const QCursor & ibeamCursor;
    static const QCursor & sizeVerCursor;
    static const QCursor & sizeHorCursor;
    static const QCursor & sizeBDiagCursor;
    static const QCursor & sizeFDiagCursor;
    static const QCursor & sizeAllCursor;
    static const QCursor & blankCursor;
    static const QCursor & splitVCursor;

    static const QCursor & splitHCursor;

    static const QCursor & pointingHandCursor;
    static const QCursor & forbiddenCursor;
    static const QCursor & whatsThisCursor;


    enum TextFormat {
        PlainText,
        RichText,
        AutoText,
        LogText
    };


    enum AnchorAttribute {
        AnchorName,
        AnchorHref
    };


    enum Dock {
        DockUnmanaged,
        DockTornOff,
        DockTop,
        DockBottom,
        DockRight,
        DockLeft,
        DockMinimized
# 809 "/coolo/prod/qt-copy/include/qnamespace.h"
    };

    typedef Dock ToolBarDock;


    enum DateFormat {
        TextDate,
        ISODate,
        LocalDate
    };


    enum TimeSpec {
        LocalTime,
        UTC
    };


    enum BackgroundMode {
        FixedColor,
        FixedPixmap,
        NoBackground,
        PaletteForeground,
        PaletteButton,
        PaletteLight,
        PaletteMidlight,
        PaletteDark,
        PaletteMid,
        PaletteText,
        PaletteBrightText,
        PaletteBase,
        PaletteBackground,
        PaletteShadow,
        PaletteHighlight,
        PaletteHighlightedText,
        PaletteButtonText,
        PaletteLink,
        PaletteLinkVisited,
        X11ParentRelative
    };

    typedef uint ComparisonFlags;


    enum StringComparisonMode {
        CaseSensitive = 0x00001,
        BeginsWith = 0x00002,
        EndsWith = 0x00004,
        Contains = 0x00008,
        ExactMatch = 0x00010
    };


    enum Corner {
        TopLeft = 0x00000,
        TopRight = 0x00001,
        BottomLeft = 0x00002,
        BottomRight = 0x00003
    };
# 876 "/coolo/prod/qt-copy/include/qnamespace.h"
    typedef unsigned long HANDLE;



};


class QInternal {
public:
    enum PaintDeviceFlags {
        UndefinedDevice = 0x00,
        Widget = 0x01,
        Pixmap = 0x02,
        Printer = 0x03,
        Picture = 0x04,
        System = 0x05,
        DeviceTypeMask = 0x0f,
        ExternalDevice = 0x10,

        CompatibilityMode = 0x20
    };
};
# 46 "/coolo/prod/qt-copy/include/qwindowdefs.h" 2




class QPaintDevice;
class QPaintDeviceMetrics;
class QWidget;
class QWidgetMapper;
class QDialog;
class QColor;
class QColorGroup;
class QPalette;
class QCursor;
class QPoint;
class QSize;
class QRect;
class QPointArray;
class QPainter;
class QRegion;
class QFont;
class QFontMetrics;
class QFontInfo;
class QPen;
class QBrush;
class QWMatrix;
class QPixmap;
class QBitmap;
class QMovie;
class QImage;
class QImageIO;
class QPicture;
class QPrinter;
class QAccel;
class QTimer;
class QTime;
class QClipboard;




class QWidgetList;
class QWidgetListIt;
# 140 "/coolo/prod/qt-copy/include/qwindowdefs.h"
typedef struct _XDisplay Display;
typedef union _XEvent XEvent;
typedef struct _XGC *GC;
typedef struct _XRegion *Region;
typedef unsigned long WId;

 Display *qt_xdisplay();
 int qt_xscreen();
 WId qt_xrootwin();
 WId qt_xrootwin( int scrn );
 GC qt_xget_readonly_gc( int scrn, bool monochrome );
 GC qt_xget_temp_gc( int scrn, bool monochrome );
# 163 "/coolo/prod/qt-copy/include/qwindowdefs.h"
class QApplication;







typedef Q_INT32 QCOORD;
const QCOORD QCOORD_MAX = 2147483647;
const QCOORD QCOORD_MIN = -QCOORD_MAX - 1;

typedef unsigned int QRgb;

 const char *qAppName();



typedef void (*QtCleanUpFunction)();
 void qAddPostRoutine( QtCleanUpFunction );
 void qRemovePostRoutine( QtCleanUpFunction );
# 44 "/coolo/prod/qt-copy/include/qobject.h" 2

# 1 "/coolo/prod/qt-copy/include/qevent.h" 1
# 39 "/coolo/prod/qt-copy/include/qevent.h"



# 1 "/coolo/prod/qt-copy/include/qregion.h" 1
# 39 "/coolo/prod/qt-copy/include/qregion.h"



# 1 "/coolo/prod/qt-copy/include/qrect.h" 1
# 39 "/coolo/prod/qt-copy/include/qrect.h"


# 1 "/coolo/prod/qt-copy/include/qsize.h" 1
# 39 "/coolo/prod/qt-copy/include/qsize.h"


# 1 "/coolo/prod/qt-copy/include/qpoint.h" 1
# 39 "/coolo/prod/qt-copy/include/qpoint.h"






class QPoint
{
public:
    QPoint();
    QPoint( int xpos, int ypos );

    bool isNull() const;

    int x() const;
    int y() const;
    void setX( int x );
    void setY( int y );

    int manhattanLength() const;

    QCOORD &rx();
    QCOORD &ry();

    QPoint &operator+=( const QPoint &p );
    QPoint &operator-=( const QPoint &p );
    QPoint &operator*=( int c );
    QPoint &operator*=( double c );
    QPoint &operator/=( int c );
    QPoint &operator/=( double c );

    friend inline bool operator==( const QPoint &, const QPoint & );
    friend inline bool operator!=( const QPoint &, const QPoint & );
    friend inline const QPoint operator+( const QPoint &, const QPoint & );
    friend inline const QPoint operator-( const QPoint &, const QPoint & );
    friend inline const QPoint operator*( const QPoint &, int );
    friend inline const QPoint operator*( int, const QPoint & );
    friend inline const QPoint operator*( const QPoint &, double );
    friend inline const QPoint operator*( double, const QPoint & );
    friend inline const QPoint operator-( const QPoint & );
    friend inline const QPoint operator/( const QPoint &, int );
    friend inline const QPoint operator/( const QPoint &, double );

private:
    static void warningDivByZero();





    QCOORD xp;
    QCOORD yp;

};






 QDataStream &operator<<( QDataStream &, const QPoint & );
 QDataStream &operator>>( QDataStream &, QPoint & );






inline QPoint::QPoint()
{ xp=0; yp=0; }

inline QPoint::QPoint( int xpos, int ypos )
{ xp=(QCOORD)xpos; yp=(QCOORD)ypos; }

inline bool QPoint::isNull() const
{ return xp == 0 && yp == 0; }

inline int QPoint::x() const
{ return xp; }

inline int QPoint::y() const
{ return yp; }

inline void QPoint::setX( int x )
{ xp = (QCOORD)x; }

inline void QPoint::setY( int y )
{ yp = (QCOORD)y; }

inline QCOORD &QPoint::rx()
{ return xp; }

inline QCOORD &QPoint::ry()
{ return yp; }

inline QPoint &QPoint::operator+=( const QPoint &p )
{ xp+=p.xp; yp+=p.yp; return *this; }

inline QPoint &QPoint::operator-=( const QPoint &p )
{ xp-=p.xp; yp-=p.yp; return *this; }

inline QPoint &QPoint::operator*=( int c )
{ xp*=(QCOORD)c; yp*=(QCOORD)c; return *this; }

inline QPoint &QPoint::operator*=( double c )
{ xp=(QCOORD)(xp*c); yp=(QCOORD)(yp*c); return *this; }

inline bool operator==( const QPoint &p1, const QPoint &p2 )
{ return p1.xp == p2.xp && p1.yp == p2.yp; }

inline bool operator!=( const QPoint &p1, const QPoint &p2 )
{ return p1.xp != p2.xp || p1.yp != p2.yp; }

inline const QPoint operator+( const QPoint &p1, const QPoint &p2 )
{ return QPoint(p1.xp+p2.xp, p1.yp+p2.yp); }

inline const QPoint operator-( const QPoint &p1, const QPoint &p2 )
{ return QPoint(p1.xp-p2.xp, p1.yp-p2.yp); }

inline const QPoint operator*( const QPoint &p, int c )
{ return QPoint(p.xp*c, p.yp*c); }

inline const QPoint operator*( int c, const QPoint &p )
{ return QPoint(p.xp*c, p.yp*c); }

inline const QPoint operator*( const QPoint &p, double c )
{ return QPoint((QCOORD)(p.xp*c), (QCOORD)(p.yp*c)); }

inline const QPoint operator*( double c, const QPoint &p )
{ return QPoint((QCOORD)(p.xp*c), (QCOORD)(p.yp*c)); }

inline const QPoint operator-( const QPoint &p )
{ return QPoint(-p.xp, -p.yp); }

inline QPoint &QPoint::operator/=( int c )
{

    if ( c == 0 )
        warningDivByZero();

    xp/=(QCOORD)c;
    yp/=(QCOORD)c;
    return *this;
}

inline QPoint &QPoint::operator/=( double c )
{

    if ( c == 0.0 )
        warningDivByZero();

    xp=(QCOORD)(xp/c);
    yp=(QCOORD)(yp/c);
    return *this;
}

inline const QPoint operator/( const QPoint &p, int c )
{

    if ( c == 0 )
        QPoint::warningDivByZero();

    return QPoint(p.xp/c, p.yp/c);
}

inline const QPoint operator/( const QPoint &p, double c )
{

    if ( c == 0.0 )
        QPoint::warningDivByZero();

    return QPoint((QCOORD)(p.xp/c), (QCOORD)(p.yp/c));
}

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 216 "/coolo/prod/qt-copy/include/qpoint.h" 2
# 43 "/coolo/prod/qt-copy/include/qsize.h" 2


class QSize

{
public:

    enum ScaleMode {
        ScaleFree,
        ScaleMin,
        ScaleMax
    };

    QSize();
    QSize( int w, int h );

    bool isNull() const;
    bool isEmpty() const;
    bool isValid() const;

    int width() const;
    int height() const;
    void setWidth( int w );
    void setHeight( int h );
    void transpose();

    void scale( int w, int h, ScaleMode mode );
    void scale( const QSize &s, ScaleMode mode );

    QSize expandedTo( const QSize & ) const;
    QSize boundedTo( const QSize & ) const;

    QCOORD &rwidth();
    QCOORD &rheight();

    QSize &operator+=( const QSize & );
    QSize &operator-=( const QSize & );
    QSize &operator*=( int c );
    QSize &operator*=( double c );
    QSize &operator/=( int c );
    QSize &operator/=( double c );

    friend inline bool operator==( const QSize &, const QSize & );
    friend inline bool operator!=( const QSize &, const QSize & );
    friend inline const QSize operator+( const QSize &, const QSize & );
    friend inline const QSize operator-( const QSize &, const QSize & );
    friend inline const QSize operator*( const QSize &, int );
    friend inline const QSize operator*( int, const QSize & );
    friend inline const QSize operator*( const QSize &, double );
    friend inline const QSize operator*( double, const QSize & );
    friend inline const QSize operator/( const QSize &, int );
    friend inline const QSize operator/( const QSize &, double );

private:
    static void warningDivByZero();

    QCOORD wd;
    QCOORD ht;
};






 QDataStream &operator<<( QDataStream &, const QSize & );
 QDataStream &operator>>( QDataStream &, QSize & );






inline QSize::QSize()
{ wd = ht = -1; }

inline QSize::QSize( int w, int h )
{ wd=(QCOORD)w; ht=(QCOORD)h; }

inline bool QSize::isNull() const
{ return wd==0 && ht==0; }

inline bool QSize::isEmpty() const
{ return wd<1 || ht<1; }

inline bool QSize::isValid() const
{ return wd>=0 && ht>=0; }

inline int QSize::width() const
{ return wd; }

inline int QSize::height() const
{ return ht; }

inline void QSize::setWidth( int w )
{ wd=(QCOORD)w; }

inline void QSize::setHeight( int h )
{ ht=(QCOORD)h; }

inline QCOORD &QSize::rwidth()
{ return wd; }

inline QCOORD &QSize::rheight()
{ return ht; }

inline QSize &QSize::operator+=( const QSize &s )
{ wd+=s.wd; ht+=s.ht; return *this; }

inline QSize &QSize::operator-=( const QSize &s )
{ wd-=s.wd; ht-=s.ht; return *this; }

inline QSize &QSize::operator*=( int c )
{ wd*=(QCOORD)c; ht*=(QCOORD)c; return *this; }

inline QSize &QSize::operator*=( double c )
{ wd=(QCOORD)(wd*c); ht=(QCOORD)(ht*c); return *this; }

inline bool operator==( const QSize &s1, const QSize &s2 )
{ return s1.wd == s2.wd && s1.ht == s2.ht; }

inline bool operator!=( const QSize &s1, const QSize &s2 )
{ return s1.wd != s2.wd || s1.ht != s2.ht; }

inline const QSize operator+( const QSize & s1, const QSize & s2 )
{ return QSize(s1.wd+s2.wd, s1.ht+s2.ht); }

inline const QSize operator-( const QSize &s1, const QSize &s2 )
{ return QSize(s1.wd-s2.wd, s1.ht-s2.ht); }

inline const QSize operator*( const QSize &s, int c )
{ return QSize(s.wd*c, s.ht*c); }

inline const QSize operator*( int c, const QSize &s )
{ return QSize(s.wd*c, s.ht*c); }

inline const QSize operator*( const QSize &s, double c )
{ return QSize((QCOORD)(s.wd*c), (QCOORD)(s.ht*c)); }

inline const QSize operator*( double c, const QSize &s )
{ return QSize((QCOORD)(s.wd*c), (QCOORD)(s.ht*c)); }

inline QSize &QSize::operator/=( int c )
{

    if ( c == 0 )
        warningDivByZero();

    wd/=(QCOORD)c; ht/=(QCOORD)c;
    return *this;
}

inline QSize &QSize::operator/=( double c )
{

    if ( c == 0.0 )
        warningDivByZero();

    wd=(QCOORD)(wd/c); ht=(QCOORD)(ht/c);
    return *this;
}

inline const QSize operator/( const QSize &s, int c )
{

    if ( c == 0 )
        QSize::warningDivByZero();

    return QSize(s.wd/c, s.ht/c);
}

inline const QSize operator/( const QSize &s, double c )
{

    if ( c == 0.0 )
        QSize::warningDivByZero();

    return QSize((QCOORD)(s.wd/c), (QCOORD)(s.ht/c));
}

inline QSize QSize::expandedTo( const QSize & otherSize ) const
{
    return QSize( ((otherSize.wd) < (wd) ? (wd) : (otherSize.wd)), ((otherSize.ht) < (ht) ? (ht) : (otherSize.ht)) );
}

inline QSize QSize::boundedTo( const QSize & otherSize ) const
{
    return QSize( ((wd) < (otherSize.wd) ? (wd) : (otherSize.wd)), ((ht) < (otherSize.ht) ? (ht) : (otherSize.ht)) );
}
# 43 "/coolo/prod/qt-copy/include/qrect.h" 2







class QRect
{
public:
    QRect() { x1 = y1 = 0; x2 = y2 = -1; }
    QRect( const QPoint &topleft, const QPoint &bottomright );
    QRect( const QPoint &topleft, const QSize &size );
    QRect( int left, int top, int width, int height );

    bool isNull() const;
    bool isEmpty() const;
    bool isValid() const;
    QRect normalize() const;

    int left() const;
    int top() const;
    int right() const;
    int bottom() const;

    QCOORD &rLeft();
    QCOORD &rTop();
    QCOORD &rRight();
    QCOORD &rBottom();

    int x() const;
    int y() const;
    void setLeft( int pos );
    void setTop( int pos );
    void setRight( int pos );
    void setBottom( int pos );
    void setX( int x );
    void setY( int y );

    void setTopLeft( const QPoint &p );
    void setBottomRight( const QPoint &p );
    void setTopRight( const QPoint &p );
    void setBottomLeft( const QPoint &p );

    QPoint topLeft() const;
    QPoint bottomRight() const;
    QPoint topRight() const;
    QPoint bottomLeft() const;
    QPoint center() const;

    void rect( int *x, int *y, int *w, int *h ) const;
    void coords( int *x1, int *y1, int *x2, int *y2 ) const;

    void moveLeft( int pos );
    void moveTop( int pos );
    void moveRight( int pos );
    void moveBottom( int pos );
    void moveTopLeft( const QPoint &p );
    void moveBottomRight( const QPoint &p );
    void moveTopRight( const QPoint &p );
    void moveBottomLeft( const QPoint &p );
    void moveCenter( const QPoint &p );
    void moveBy( int dx, int dy );

    void setRect( int x, int y, int w, int h );
    void setCoords( int x1, int y1, int x2, int y2 );
    void addCoords( int x1, int y1, int x2, int y2 );

    QSize size() const;
    int width() const;
    int height() const;
    void setWidth( int w );
    void setHeight( int h );
    void setSize( const QSize &s );

    QRect operator|(const QRect &r) const;
    QRect operator&(const QRect &r) const;
    QRect& operator|=(const QRect &r);
    QRect& operator&=(const QRect &r);

    bool contains( const QPoint &p, bool proper=FALSE ) const;
    bool contains( int x, int y ) const;
    bool contains( int x, int y, bool proper ) const;
    bool contains( const QRect &r, bool proper=FALSE ) const;
    QRect unite( const QRect &r ) const;
    QRect intersect( const QRect &r ) const;
    bool intersects( const QRect &r ) const;

    friend bool operator==( const QRect &, const QRect & );
    friend bool operator!=( const QRect &, const QRect & );

private:

    friend void qt_setCoords( QRect *r, int xp1, int yp1, int xp2, int yp2 );







    QCOORD x1;
    QCOORD y1;
    QCOORD x2;
    QCOORD y2;

};

 bool operator==( const QRect &, const QRect & );
 bool operator!=( const QRect &, const QRect & );






 QDataStream &operator<<( QDataStream &, const QRect & );
 QDataStream &operator>>( QDataStream &, QRect & );






inline QRect::QRect( int left, int top, int width, int height )
{
    x1 = (QCOORD)left;
    y1 = (QCOORD)top;
    x2 = (QCOORD)(left+width-1);
    y2 = (QCOORD)(top+height-1);
}

inline bool QRect::isNull() const
{ return x2 == x1-1 && y2 == y1-1; }

inline bool QRect::isEmpty() const
{ return x1 > x2 || y1 > y2; }

inline bool QRect::isValid() const
{ return x1 <= x2 && y1 <= y2; }

inline int QRect::left() const
{ return x1; }

inline int QRect::top() const
{ return y1; }

inline int QRect::right() const
{ return x2; }

inline int QRect::bottom() const
{ return y2; }

inline QCOORD &QRect::rLeft()
{ return x1; }

inline QCOORD & QRect::rTop()
{ return y1; }

inline QCOORD & QRect::rRight()
{ return x2; }

inline QCOORD & QRect::rBottom()
{ return y2; }

inline int QRect::x() const
{ return x1; }

inline int QRect::y() const
{ return y1; }

inline void QRect::setLeft( int pos )
{ x1 = (QCOORD)pos; }

inline void QRect::setTop( int pos )
{ y1 = (QCOORD)pos; }

inline void QRect::setRight( int pos )
{ x2 = (QCOORD)pos; }

inline void QRect::setBottom( int pos )
{ y2 = (QCOORD)pos; }

inline void QRect::setX( int x )
{ x1 = (QCOORD)x; }

inline void QRect::setY( int y )
{ y1 = (QCOORD)y; }

inline QPoint QRect::topLeft() const
{ return QPoint(x1, y1); }

inline QPoint QRect::bottomRight() const
{ return QPoint(x2, y2); }

inline QPoint QRect::topRight() const
{ return QPoint(x2, y1); }

inline QPoint QRect::bottomLeft() const
{ return QPoint(x1, y2); }

inline QPoint QRect::center() const
{ return QPoint((x1+x2)/2, (y1+y2)/2); }

inline int QRect::width() const
{ return x2 - x1 + 1; }

inline int QRect::height() const
{ return y2 - y1 + 1; }

inline QSize QRect::size() const
{ return QSize(x2-x1+1, y2-y1+1); }

inline bool QRect::contains( int x, int y, bool proper ) const
{
    if ( proper )
        return x > x1 && x < x2 &&
               y > y1 && y < y2;
    else
        return x >= x1 && x <= x2 &&
               y >= y1 && y <= y2;
}

inline bool QRect::contains( int x, int y ) const
{
    return x >= x1 && x <= x2 &&
           y >= y1 && y <= y2;
}
# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 273 "/coolo/prod/qt-copy/include/qrect.h" 2
# 44 "/coolo/prod/qt-copy/include/qregion.h" 2



struct QRegionPrivate;


class QRegion
{
public:
    enum RegionType { Rectangle, Ellipse };

    QRegion();
    QRegion( int x, int y, int w, int h, RegionType = Rectangle );
    QRegion( const QRect &, RegionType = Rectangle );
    QRegion( const QPointArray &, bool winding=FALSE );
    QRegion( const QRegion & );
    QRegion( const QBitmap & );
   ~QRegion();
    QRegion &operator=( const QRegion & );

    bool isNull() const;
    bool isEmpty() const;

    bool contains( const QPoint &p ) const;
    bool contains( const QRect &r ) const;

    void translate( int dx, int dy );

    QRegion unite( const QRegion & ) const;
    QRegion intersect( const QRegion &) const;
    QRegion subtract( const QRegion & ) const;
    QRegion eor( const QRegion & ) const;

    QRect boundingRect() const;
    QMemArray<QRect> rects() const;
    void setRects( const QRect *, int );

    const QRegion operator|( const QRegion & ) const;
    const QRegion operator+( const QRegion & ) const;
    const QRegion operator&( const QRegion & ) const;
    const QRegion operator-( const QRegion & ) const;
    const QRegion operator^( const QRegion & ) const;
    QRegion& operator|=( const QRegion & );
    QRegion& operator+=( const QRegion & );
    QRegion& operator&=( const QRegion & );
    QRegion& operator-=( const QRegion & );
    QRegion& operator^=( const QRegion & );

    bool operator==( const QRegion & ) const;
    bool operator!=( const QRegion &r ) const
                        { return !(operator==(r)); }




    Region handle() const { if(!data->rgn) updateX11Region(); return data->rgn; }
# 108 "/coolo/prod/qt-copy/include/qregion.h"
    friend QDataStream &operator<<( QDataStream &, const QRegion & );
    friend QDataStream &operator>>( QDataStream &, QRegion & );

private:
    QRegion( bool );
    QRegion copy() const;
    void detach();




    void updateX11Region() const;
    void *clipRectangles( int &num ) const;
    friend void *qt_getClipRects( const QRegion &, int & );

    void exec( const QByteArray &, int ver = 0 );
    struct QRegionData : public QShared {



        Region rgn;
        void *xrectangles;
        QRegionPrivate *region;







        bool is_null;
    } *data;







};









 QDataStream &operator<<( QDataStream &, const QRegion & );
 QDataStream &operator>>( QDataStream &, QRegion & );
# 44 "/coolo/prod/qt-copy/include/qevent.h" 2

# 1 "/coolo/prod/qt-copy/include/qmime.h" 1
# 39 "/coolo/prod/qt-copy/include/qmime.h"



# 1 "/coolo/prod/qt-copy/include/qmap.h" 1
# 39 "/coolo/prod/qt-copy/include/qmap.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qmap.h" 2

# 1 "/coolo/prod/qt-copy/include/qdatastream.h" 1
# 39 "/coolo/prod/qt-copy/include/qdatastream.h"


# 1 "/coolo/prod/qt-copy/include/qiodevice.h" 1
# 39 "/coolo/prod/qt-copy/include/qiodevice.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qiodevice.h" 2




















class QIODevice
{
public:



    typedef Q_ULONG Offset;


    QIODevice();
    virtual ~QIODevice();

    int flags() const { return ioMode; }
    int mode() const { return ioMode & 0x00ff; }
    int state() const { return ioMode & 0xf000; }

    bool isDirectAccess() const { return ((ioMode & 0x0100) == 0x0100); }
    bool isSequentialAccess() const { return ((ioMode & 0x0200) == 0x0200); }
    bool isCombinedAccess() const { return ((ioMode & 0x0300) == 0x0300); }
    bool isBuffered() const { return ((ioMode & 0x0040) != 0x0040); }
    bool isRaw() const { return ((ioMode & 0x0040) == 0x0040); }
    bool isSynchronous() const { return ((ioMode & 0x0080) != 0x0080); }
    bool isAsynchronous() const { return ((ioMode & 0x0080) == 0x0080); }
    bool isTranslated() const { return ((ioMode & 0x0010) == 0x0010); }
    bool isReadable() const { return ((ioMode & 0x0001) == 0x0001); }
    bool isWritable() const { return ((ioMode & 0x0002) == 0x0002); }
    bool isReadWrite() const { return ((ioMode & 0x0003) == 0x0003); }
    bool isInactive() const { return state() == 0; }
    bool isOpen() const { return state() == 0x1000; }

    int status() const { return ioSt; }
    void resetStatus() { ioSt = 0; }

    virtual bool open( int mode ) = 0;
    virtual void close() = 0;
    virtual void flush() = 0;

    virtual Offset size() const = 0;
    virtual Offset at() const;
    virtual bool at( Offset );
    virtual bool atEnd() const;
    bool reset() { return at(0); }

    virtual Q_LONG readBlock( char *data, Q_ULONG maxlen ) = 0;
    virtual Q_LONG writeBlock( const char *data, Q_ULONG len ) = 0;
    virtual Q_LONG readLine( char *data, Q_ULONG maxlen );
    Q_LONG writeBlock( const QByteArray& data );
    virtual QByteArray readAll();

    virtual int getch() = 0;
    virtual int putch( int ) = 0;
    virtual int ungetch( int ) = 0;

protected:
    void setFlags( int f ) { ioMode = f; }
    void setType( int );
    void setMode( int );
    void setState( int );
    void setStatus( int );
    Offset ioIndex;

private:
    int ioMode;
    int ioSt;

private:

    QIODevice( const QIODevice & );
    QIODevice &operator=( const QIODevice & );

};
# 43 "/coolo/prod/qt-copy/include/qdatastream.h" 2




class QDataStream
{
public:
    QDataStream();
    QDataStream( QIODevice * );
    QDataStream( QByteArray, int mode );
    virtual ~QDataStream();

    QIODevice *device() const;
    void setDevice( QIODevice * );
    void unsetDevice();

    bool atEnd() const;
    bool eof() const;

    enum ByteOrder { BigEndian, LittleEndian };
    int byteOrder() const;
    void setByteOrder( int );

    bool isPrintableData() const;
    void setPrintableData( bool );

    int version() const;
    void setVersion( int );

    QDataStream &operator>>( Q_INT8 &i );
    QDataStream &operator>>( Q_UINT8 &i );
    QDataStream &operator>>( Q_INT16 &i );
    QDataStream &operator>>( Q_UINT16 &i );
    QDataStream &operator>>( Q_INT32 &i );
    QDataStream &operator>>( Q_UINT32 &i );
    QDataStream &operator>>( Q_INT64 &i );
    QDataStream &operator>>( Q_UINT64 &i );
    QDataStream &operator>>( Q_LONG &i );
    QDataStream &operator>>( Q_ULONG &i );

    QDataStream &operator>>( float &f );
    QDataStream &operator>>( double &f );
    QDataStream &operator>>( char *&str );

    QDataStream &operator<<( Q_INT8 i );
    QDataStream &operator<<( Q_UINT8 i );
    QDataStream &operator<<( Q_INT16 i );
    QDataStream &operator<<( Q_UINT16 i );
    QDataStream &operator<<( Q_INT32 i );
    QDataStream &operator<<( Q_UINT32 i );
    QDataStream &operator<<( Q_INT64 i );
    QDataStream &operator<<( Q_UINT64 i );
    QDataStream &operator<<( Q_LONG i );
    QDataStream &operator<<( Q_ULONG i );
    QDataStream &operator<<( float f );
    QDataStream &operator<<( double f );
    QDataStream &operator<<( const char *str );

    QDataStream &readBytes( char *&, uint &len );
    QDataStream &readRawBytes( char *, uint len );

    QDataStream &writeBytes( const char *, uint len );
    QDataStream &writeRawBytes( const char *, uint len );

private:
    QIODevice *dev;
    bool owndev;
    int byteorder;
    bool printable;
    bool noswap;
    int ver;

private:

    QDataStream( const QDataStream & );
    QDataStream &operator=( const QDataStream & );

};






inline QIODevice *QDataStream::device() const
{ return dev; }

inline bool QDataStream::atEnd() const
{ return dev ? dev->atEnd() : TRUE; }

inline bool QDataStream::eof() const
{ return atEnd(); }

inline int QDataStream::byteOrder() const
{ return byteorder; }

inline bool QDataStream::isPrintableData() const
{ return printable; }

inline void QDataStream::setPrintableData( bool p )
{ printable = p; }

inline int QDataStream::version() const
{ return ver; }

inline void QDataStream::setVersion( int v )
{ ver = v; }

inline QDataStream &QDataStream::operator>>( Q_UINT8 &i )
{ return *this >> (Q_INT8&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT16 &i )
{ return *this >> (Q_INT16&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT32 &i )
{ return *this >> (Q_INT32&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT64 &i )
{ return *this >> (Q_INT64&)i; }

inline QDataStream &QDataStream::operator>>( Q_ULONG &i )
{ return *this >> (Q_LONG&)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT8 i )
{ return *this << (Q_INT8)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT16 i )
{ return *this << (Q_INT16)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT32 i )
{ return *this << (Q_INT32)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT64 i )
{ return *this << (Q_INT64)i; }

inline QDataStream &QDataStream::operator<<( Q_ULONG i )
{ return *this << (Q_LONG)i; }
# 45 "/coolo/prod/qt-copy/include/qmap.h" 2
# 1 "/coolo/prod/qt-copy/include/qpair.h" 1
# 37 "/coolo/prod/qt-copy/include/qpair.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 41 "/coolo/prod/qt-copy/include/qpair.h" 2



template <class T1, class T2>
struct QPair
{
    typedef T1 first_type;
    typedef T2 second_type;

    QPair()
        : first( T1() ), second( T2() )
    {}
    QPair( const T1& t1, const T2& t2 )
        : first( t1 ), second( t2 )
    {}

    T1 first;
    T2 second;
};

template <class T1, class T2>
 bool operator==( const QPair<T1, T2>& x, const QPair<T1, T2>& y )
{
    return x.first == y.first && x.second == y.second;
}

template <class T1, class T2>
 bool operator<( const QPair<T1, T2>& x, const QPair<T1, T2>& y )
{
    return x.first < y.first ||
           ( !( y.first < x.first ) && x.second < y.second );
}

template <class T1, class T2>
 QPair<T1, T2> qMakePair( const T1& x, const T2& y )
{
    return QPair<T1, T2>( x, y );
}


template <class T1, class T2>
inline QDataStream& operator>>( QDataStream& s, QPair<T1, T2>& p )
{
    s >> p.first >> p.second;
    return s;
}

template <class T1, class T2>
inline QDataStream& operator<<( QDataStream& s, const QPair<T1, T2>& p )
{
    s << p.first << p.second;
    return s;
}
# 46 "/coolo/prod/qt-copy/include/qmap.h" 2
# 1 "/coolo/prod/qt-copy/include/qvaluelist.h" 1
# 39 "/coolo/prod/qt-copy/include/qvaluelist.h"


# 1 "/coolo/prod/qt-copy/include/qtl.h" 1
# 39 "/coolo/prod/qt-copy/include/qtl.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qtl.h" 2
# 1 "/coolo/prod/qt-copy/include/qtextstream.h" 1
# 39 "/coolo/prod/qt-copy/include/qtextstream.h"




# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4


extern "C" {

# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 408 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_NULL
# 35 "/usr/include/stdio.h" 2 3 4









typedef struct _IO_FILE FILE;








#undef __need_FILE





typedef struct _IO_FILE __FILE;


#undef __need___FILE




# 1 "/usr/include/libio.h" 1 3 4
# 30 "/usr/include/libio.h" 3 4

# 1 "/usr/include/_G_config.h" 1 3 4








# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 344 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_wchar_t








typedef unsigned int wint_t;

#undef __need_wint_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 408 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_NULL
# 15 "/usr/include/_G_config.h" 2 3 4
# 23 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 47 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 356 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_wint_t
# 49 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 21 "/usr/include/bits/wchar.h" 3 4

# 51 "/usr/include/wchar.h" 2 3 4
# 63 "/usr/include/wchar.h" 3 4







typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;

#undef __need_mbstate_t
# 25 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 1 "/usr/include/gconv.h" 1 3 4
# 24 "/usr/include/gconv.h" 3 4


# 1 "/usr/include/wchar.h" 1 3 4
# 47 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 356 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_wint_t
# 49 "/usr/include/wchar.h" 2 3 4
# 63 "/usr/include/wchar.h" 3 4

# 81 "/usr/include/wchar.h" 3 4
#undef __need_mbstate_t
# 29 "/usr/include/gconv.h" 2 3 4
# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 344 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_wchar_t
# 32 "/usr/include/gconv.h" 2 3 4




enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
                            __const unsigned char **, __const unsigned char *,
                            unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
                                  struct __gconv_step_data *, void *,
                                  __const unsigned char *,
                                  __const unsigned char **,
                                  __const unsigned char *, unsigned char **,
                                  size_t *);


typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
                                          __const unsigned char *,
                                          unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
                                        size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [];
} *__gconv_t;
# 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));















# 33 "/usr/include/libio.h" 2 3 4




# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stdarg.h" 1 3 4
# 37 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stdarg.h" 3 4
#undef __need___va_list




typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4

#undef _IO_va_list
# 76 "/usr/include/libio.h" 3 4












# 105 "/usr/include/libio.h" 3 4












struct _IO_jump_t; struct _IO_FILE;
# 172 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 195 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 263 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;



  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 311 "/usr/include/libio.h" 3 4
  __off64_t _offset;





  void *__pad1;
  void *__pad2;

  int _mode;

  char _unused2[15 * sizeof (int) - 2 * sizeof (void *)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;

# 350 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
                                 size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
                             void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *) throw ();
extern int __uflow (_IO_FILE *) throw ();
extern int __overflow (_IO_FILE *, int) throw ();
extern wint_t __wunderflow (_IO_FILE *) throw ();
extern wint_t __wuflow (_IO_FILE *) throw ();
extern wint_t __woverflow (_IO_FILE *, wint_t) throw ();

















extern int _IO_getc (_IO_FILE *__fp) throw ();
extern int _IO_putc (int __c, _IO_FILE *__fp) throw ();
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp) throw ();




extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 454 "/usr/include/libio.h" 3 4


extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
                        __gnuc_va_list, int *__restrict) throw ();
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
                         __gnuc_va_list) throw ();
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t) throw ();
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t) throw ();

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int) throw ();
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int) throw ();

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 520 "/usr/include/libio.h" 3 4
}
# 73 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;









typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;







# 118 "/usr/include/stdio.h" 3 4




# 138 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 24 "/usr/include/bits/stdio_lim.h" 3 4







# 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;




extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();






extern FILE *tmpfile (void) throw ();
# 171 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) throw ();



extern FILE *tmpfile64 (void) throw ();





extern char *tmpnam_r (char *__s) throw ();
# 193 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__));





extern int fclose (FILE *__stream) throw ();

extern int fflush (FILE *__stream) throw ();




extern int fflush_unlocked (FILE *__stream) throw ();




extern int fcloseall (void) throw ();






extern FILE *fopen (__const char *__restrict __filename,
                    __const char *__restrict __modes) throw ();

extern FILE *freopen (__const char *__restrict __filename,
                      __const char *__restrict __modes,
                      FILE *__restrict __stream) throw ();
# 239 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
                      __const char *__restrict __modes) throw ();
extern FILE *freopen64 (__const char *__restrict __filename,
                        __const char *__restrict __modes,
                        FILE *__restrict __stream) throw ();




extern FILE *fdopen (int __fd, __const char *__modes) throw ();





extern FILE *fopencookie (void *__restrict __magic_cookie,
                          __const char *__restrict __modes,
                          _IO_cookie_io_functions_t __io_funcs) throw ();


extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes) throw ();




extern FILE *open_memstream (char **__restrict __bufloc,
                             size_t *__restrict __sizeloc) throw ();






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
                    int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
                       size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();





extern int fprintf (FILE *__restrict __stream,
                    __const char *__restrict __format, ...) throw ();

extern int printf (__const char *__restrict __format, ...) throw ();

extern int sprintf (char *__restrict __s,
                    __const char *__restrict __format, ...) throw ();


extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
                     __gnuc_va_list __arg) throw ();

extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg)
     throw ();

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
                     __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
                     __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
                      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
                      __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));
extern int __asprintf (char **__restrict __ptr,
                       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int asprintf (char **__restrict __ptr,
                     __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));


extern int vdprintf (int __fd, __const char *__restrict __fmt,
                     __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));





extern int fscanf (FILE *__restrict __stream,
                   __const char *__restrict __format, ...) throw ();

extern int scanf (__const char *__restrict __format, ...) throw ();

extern int sscanf (__const char *__restrict __s,
                   __const char *__restrict __format, ...) throw ();





extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
                    __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));


extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 1, 0)));


extern int vsscanf (__const char *__restrict __s,
                    __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));






extern int fgetc (FILE *__stream) throw ();
extern int getc (FILE *__stream) throw ();


extern int getchar (void) throw ();







extern int getc_unlocked (FILE *__stream) throw ();
extern int getchar_unlocked (void) throw ();




extern int fgetc_unlocked (FILE *__stream) throw ();





extern int fputc (int __c, FILE *__stream) throw ();
extern int putc (int __c, FILE *__stream) throw ();


extern int putchar (int __c) throw ();







extern int fputc_unlocked (int __c, FILE *__stream) throw ();




extern int putc_unlocked (int __c, FILE *__stream) throw ();
extern int putchar_unlocked (int __c) throw ();





extern int getw (FILE *__stream) throw ();


extern int putw (int __w, FILE *__stream) throw ();





extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     throw ();



extern char *gets (char *__s) throw ();




extern char *fgets_unlocked (char *__restrict __s, int __n,
                             FILE *__restrict __stream) throw ();
# 461 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                               size_t *__restrict __n, int __delimiter,
                               FILE *__restrict __stream) throw ();
extern __ssize_t getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) throw ();


extern __ssize_t getline (char **__restrict __lineptr,
                            size_t *__restrict __n,
                            FILE *__restrict __stream) throw ();





extern int fputs (__const char *__restrict __s, FILE *__restrict __stream)
     throw ();


extern int puts (__const char *__s) throw ();



extern int ungetc (int __c, FILE *__stream) throw ();



extern size_t fread (void *__restrict __ptr, size_t __size,
                     size_t __n, FILE *__restrict __stream) throw ();

extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
                      size_t __n, FILE *__restrict __s) throw ();




extern int fputs_unlocked (__const char *__restrict __s,
                           FILE *__restrict __stream) throw ();




extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
                              size_t __n, FILE *__restrict __stream) throw ();
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
                               size_t __n, FILE *__restrict __stream) throw ();





extern int fseek (FILE *__stream, long int __off, int __whence) throw ();

extern long int ftell (FILE *__stream) throw ();

extern void rewind (FILE *__stream) throw ();

# 528 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence) throw ();

extern __off_t ftello (FILE *__stream) throw ();
# 544 "/usr/include/stdio.h" 3 4



extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos)
     throw ();

extern int fsetpos (FILE *__stream, __const fpos_t *__pos) throw ();
# 563 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence) throw ();
extern __off64_t ftello64 (FILE *__stream) throw ();
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos)
     throw ();
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos) throw ();




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw ();

extern int ferror (FILE *__stream) throw ();




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw ();
extern int ferror_unlocked (FILE *__stream) throw ();





extern void perror (__const char *__s) throw ();






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 600 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw ();




extern int fileno_unlocked (FILE *__stream) throw ();






extern FILE *popen (__const char *__command, __const char *__modes) throw ();


extern int pclose (FILE *__stream) throw ();





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s) throw ();




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
                           __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
                            __const char *__restrict __format,
                            __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw ();


extern void funlockfile (FILE *__stream) throw ();
# 677 "/usr/include/stdio.h" 3 4
}
# 45 "/coolo/prod/qt-copy/include/qtextstream.h" 2



class QTextCodec;
class QTextDecoder;

class QTextStreamPrivate;

class QTextStream
{
public:
    enum Encoding { Locale, Latin1, Unicode, UnicodeNetworkOrder,
                    UnicodeReverse, RawUnicode, UnicodeUTF8 };

    void setEncoding( Encoding );

    void setCodec( QTextCodec* );
    QTextCodec *codec();


    QTextStream();
    QTextStream( QIODevice * );
    QTextStream( QString*, int mode );
    QTextStream( QString&, int mode );
    QTextStream( QByteArray, int mode );
    QTextStream( FILE *, int mode );
    virtual ~QTextStream();

    QIODevice *device() const;
    void setDevice( QIODevice * );
    void unsetDevice();

    bool atEnd() const;
    bool eof() const;

    QTextStream &operator>>( QChar & );
    QTextStream &operator>>( char & );
    QTextStream &operator>>( signed short & );
    QTextStream &operator>>( unsigned short & );
    QTextStream &operator>>( signed int & );
    QTextStream &operator>>( unsigned int & );
    QTextStream &operator>>( signed long & );
    QTextStream &operator>>( unsigned long & );
    QTextStream &operator>>( float & );
    QTextStream &operator>>( double & );
    QTextStream &operator>>( char * );
    QTextStream &operator>>( QString & );
    QTextStream &operator>>( QCString & );

    QTextStream &operator<<( QChar );
    QTextStream &operator<<( char );
    QTextStream &operator<<( signed short );
    QTextStream &operator<<( unsigned short );
    QTextStream &operator<<( signed int );
    QTextStream &operator<<( unsigned int );
    QTextStream &operator<<( signed long );
    QTextStream &operator<<( unsigned long );
    QTextStream &operator<<( float );
    QTextStream &operator<<( double );
    QTextStream &operator<<( const char* );
    QTextStream &operator<<( const QString & );
    QTextStream &operator<<( const QCString & );
    QTextStream &operator<<( void * );

    QTextStream &readRawBytes( char *, uint len );
    QTextStream &writeRawBytes( const char* , uint len );

    QString readLine();
    QString read();
    void skipWhiteSpace();

    enum {
        skipws = 0x0001,
        left = 0x0002,
        right = 0x0004,
        internal = 0x0008,
        bin = 0x0010,
        oct = 0x0020,
        dec = 0x0040,
        hex = 0x0080,
        showbase = 0x0100,
        showpoint = 0x0200,
        uppercase = 0x0400,
        showpos = 0x0800,
        scientific= 0x1000,
        fixed = 0x2000
    };

    static const int basefield;
    static const int adjustfield;
    static const int floatfield;

    int flags() const;
    int flags( int f );
    int setf( int bits );
    int setf( int bits, int mask );
    int unsetf( int bits );

    void reset();

    int width() const;
    int width( int );
    int fill() const;
    int fill( int );
    int precision() const;
    int precision( int );

private:
    long input_int();
    void init();
    QTextStream &output_int( int, ulong, bool );
    QIODevice *dev;

    int fflags;
    int fwidth;
    int fillchar;
    int fprec;
    bool doUnicodeHeader;
    bool owndev;
    QTextCodec *mapper;
    QTextStreamPrivate * d;
    QChar unused1;
    bool latin1;
    bool internalOrder;
    bool networkOrder;
    void *unused2;

    QChar eat_ws();
    uint ts_getline( QChar* );
    void ts_ungetc( QChar );
    QChar ts_getc();
    uint ts_getbuf( QChar*, uint );
    void ts_putc(int);
    void ts_putc(QChar);
    bool ts_isspace(QChar);
    bool ts_isdigit(QChar);
    ulong input_bin();
    ulong input_oct();
    ulong input_dec();
    ulong input_hex();
    double input_double();
    QTextStream &writeBlock( const char* p, uint len );
    QTextStream &writeBlock( const QChar* p, uint len );

private:

    QTextStream( const QTextStream & );
    QTextStream &operator=( const QTextStream & );

};

typedef QTextStream QTS;

class QTextIStream : public QTextStream {
public:
    QTextIStream( const QString* s ) :
        QTextStream((QString*)s,0x0001) { }
    QTextIStream( QByteArray ba ) :
        QTextStream(ba,0x0001) { }
    QTextIStream( FILE *f ) :
        QTextStream(f,0x0001) { }

private:

    QTextIStream( const QTextIStream & );
    QTextIStream &operator=( const QTextIStream & );

};

class QTextOStream : public QTextStream {
public:
    QTextOStream( QString* s ) :
        QTextStream(s,0x0002) { }
    QTextOStream( QByteArray ba ) :
        QTextStream(ba,0x0002) { }
    QTextOStream( FILE *f ) :
        QTextStream(f,0x0002) { }

private:

    QTextOStream( const QTextOStream & );
    QTextOStream &operator=( const QTextOStream & );

};





inline QIODevice *QTextStream::device() const
{ return dev; }

inline bool QTextStream::atEnd() const
{ return dev ? dev->atEnd() : FALSE; }

inline bool QTextStream::eof() const
{ return atEnd(); }

inline int QTextStream::flags() const
{ return fflags; }

inline int QTextStream::flags( int f )
{ int oldf = fflags; fflags = f; return oldf; }

inline int QTextStream::setf( int bits )
{ int oldf = fflags; fflags |= bits; return oldf; }

inline int QTextStream::setf( int bits, int mask )
{ int oldf = fflags; fflags = (fflags & ~mask) | (bits & mask); return oldf; }

inline int QTextStream::unsetf( int bits )
{ int oldf = fflags; fflags &= ~bits; return oldf; }

inline int QTextStream::width() const
{ return fwidth; }

inline int QTextStream::width( int w )
{ int oldw = fwidth; fwidth = w; return oldw; }

inline int QTextStream::fill() const
{ return fillchar; }

inline int QTextStream::fill( int f )
{ int oldc = fillchar; fillchar = f; return oldc; }

inline int QTextStream::precision() const
{ return fprec; }

inline int QTextStream::precision( int p )
{ int oldp = fprec; fprec = p; return oldp; }




inline QChar QTextStream::ts_getc()
{ QChar r; return ( ts_getbuf( &r,1 ) == 1 ? r : QChar((ushort)0xffff) ); }





typedef QTextStream & (*QTSFUNC)(QTextStream &);
typedef int (QTextStream::*QTSMFI)(int);

class QTSManip {
public:
    QTSManip( QTSMFI m, int a ) { mf=m; arg=a; }
    void exec( QTextStream &s ) { (s.*mf)(arg); }
private:
    QTSMFI mf;
    int arg;
};

 inline QTextStream &operator>>( QTextStream &s, QTSFUNC f )
{ return (*f)( s ); }

 inline QTextStream &operator<<( QTextStream &s, QTSFUNC f )
{ return (*f)( s ); }

 inline QTextStream &operator<<( QTextStream &s, QTSManip m )
{ m.exec(s); return s; }

 QTextStream &bin( QTextStream &s );
 QTextStream &oct( QTextStream &s );
 QTextStream &dec( QTextStream &s );
 QTextStream &hex( QTextStream &s );
 QTextStream &endl( QTextStream &s );
 QTextStream &flush( QTextStream &s );
 QTextStream &ws( QTextStream &s );
 QTextStream &reset( QTextStream &s );

 inline QTSManip qSetW( int w )
{
    QTSMFI func = &QTextStream::width;
    return QTSManip(func,w);
}

 inline QTSManip qSetFill( int f )
{
    QTSMFI func = &QTextStream::fill;
    return QTSManip(func,f);
}

 inline QTSManip qSetPrecision( int p )
{
    QTSMFI func = &QTextStream::precision;
    return QTSManip(func,p);
}
# 44 "/coolo/prod/qt-copy/include/qtl.h" 2




template <class T>
class QTextOStreamIterator
{
protected:
    QTextOStream& stream;
    QString separator;

public:
    QTextOStreamIterator( QTextOStream& s) : stream( s ) {}
    QTextOStreamIterator( QTextOStream& s, const QString& sep )
        : stream( s ), separator( sep ) {}
    QTextOStreamIterator<T>& operator= ( const T& x ) {
        stream << x;
        if ( !separator.isEmpty() )
            stream << separator;
        return *this;
    }
    QTextOStreamIterator<T>& operator*() { return *this; }
    QTextOStreamIterator<T>& operator++() { return *this; }
    QTextOStreamIterator<T>& operator++(int) { return *this; }
};


template <class InputIterator, class OutputIterator>
inline OutputIterator qCopy( InputIterator _begin, InputIterator _end,
                             OutputIterator _dest )
{
    while( _begin != _end )
        *_dest++ = *_begin++;
    return _dest;
}

template <class BiIterator, class BiOutputIterator>
inline BiOutputIterator qCopyBackward( BiIterator _begin, BiIterator _end,
                                       BiOutputIterator _dest )
{
    while ( _begin != _end )
        *--_dest = *--_end;
    return _dest;
}

template <class InputIterator1, class InputIterator2>
inline bool qEqual( InputIterator1 first1, InputIterator1 last1, InputIterator2 first2 )
{

    for ( ; first1 != last1; ++first1, ++first2 )
        if ( *first1 != *first2 )
            return FALSE;
    return TRUE;
}

template <class ForwardIterator, class T>
inline void qFill( ForwardIterator first, ForwardIterator last, const T& val )
{
    for ( ; first != last; ++first )
        *first = val;
}
# 121 "/coolo/prod/qt-copy/include/qtl.h"
template <class InputIterator, class T>
inline InputIterator qFind( InputIterator first, InputIterator last,
                            const T& val )
{
    while ( first != last && *first != val )
        ++first;
    return first;
}

template <class InputIterator, class T, class Size>
inline void qCount( InputIterator first, InputIterator last, const T& value,
                    Size& n )
{
    for ( ; first != last; ++first )
        if ( *first == value )
            ++n;
}

template <class T>
inline void qSwap( T& _value1, T& _value2 )
{
    T tmp = _value1;
    _value1 = _value2;
    _value2 = tmp;
}


template <class InputIterator>
 void qBubbleSort( InputIterator b, InputIterator e )
{

    InputIterator last = e;
    --last;

    if ( last == b )
        return;


    while( b != last ) {
        bool swapped = FALSE;
        InputIterator swap_pos = b;
        InputIterator x = e;
        InputIterator y = x;
        y--;
        do {
            --x;
            --y;
            if ( *x < *y ) {
                swapped = TRUE;
                qSwap( *x, *y );
                swap_pos = y;
            }
        } while( y != b );
        if ( !swapped )
            return;
        b = swap_pos;
        b++;
    }
}


template <class Container>
inline void qBubbleSort( Container &c )
{
  qBubbleSort( c.begin(), c.end() );
}


template <class Value>
 void qHeapSortPushDown( Value* heap, int first, int last )
{
    int r = first;
    while ( r <= last / 2 ) {
        if ( last == 2 * r ) {

            if ( heap[2 * r] < heap[r] )
                qSwap( heap[r], heap[2 * r] );
            r = last;
        } else {

            if ( heap[2 * r] < heap[r] && !(heap[2 * r + 1] < heap[2 * r]) ) {

                qSwap( heap[r], heap[2 * r] );
                r *= 2;
            } else if ( heap[2 * r + 1] < heap[r]
                        && heap[2 * r + 1] < heap[2 * r] ) {

                qSwap( heap[r], heap[2 * r + 1] );
                r = 2 * r + 1;
            } else {
                r = last;
            }
        }
    }
}


template <class InputIterator, class Value>
 void qHeapSortHelper( InputIterator b, InputIterator e, Value, uint n )
{

    InputIterator insert = b;
    Value* realheap = new Value[n];

    Value* heap = realheap - 1;
    int size = 0;
    for( ; insert != e; ++insert ) {
        heap[++size] = *insert;
        int i = size;
        while( i > 1 && heap[i] < heap[i / 2] ) {
            qSwap( heap[i], heap[i / 2] );
            i /= 2;
        }
    }


    for( uint i = n; i > 0; i-- ) {
        *b++ = heap[1];
        if ( i > 1 ) {
            heap[1] = heap[i];
            qHeapSortPushDown( heap, 1, (int)i - 1 );
        }
    }

    delete[] realheap;
}


template <class InputIterator>
 void qHeapSort( InputIterator b, InputIterator e )
{

    if ( b == e )
        return;


    InputIterator it = b;
    uint n = 0;
    while ( it != e ) {
        ++n;
        ++it;
    }



    qHeapSortHelper( b, e, *b, n );
}


template <class Container>
 void qHeapSort( Container &c )
{
    if ( c.begin() == c.end() )
        return;



    qHeapSortHelper( c.begin(), c.end(), *(c.begin()), (uint)c.count() );
}

template <class Container>
class QBackInsertIterator
{
public:
    explicit QBackInsertIterator( Container &c )
        : container( &c )
    {
    }

    QBackInsertIterator<Container>&
    operator=( const typename Container::value_type &value )
    {
        container->push_back( value );
        return *this;
    }

    QBackInsertIterator<Container>& operator*()
    {
        return *this;
    }

    QBackInsertIterator<Container>& operator++()
    {
        return *this;
    }

    QBackInsertIterator<Container>& operator++(int)
    {
        return *this;
    }

protected:
    Container *container;
};

template <class Container>
inline QBackInsertIterator<Container> qBackInserter( Container &c )
{
    return QBackInsertIterator<Container>( c );
}
# 43 "/coolo/prod/qt-copy/include/qvaluelist.h" 2
# 58 "/coolo/prod/qt-copy/include/qvaluelist.h"
template <class T>
class QValueListNode
{
public:
    QValueListNode( const T& t ) : data( t ) { }
    QValueListNode() { }





    QValueListNode<T>* next;
    QValueListNode<T>* prev;
    T data;
};

template<class T>
class QValueListIterator
{
 public:



    typedef QValueListNode<T>* NodePtr;



    typedef T value_type;
    typedef size_t size_type;



    typedef int difference_type;

    typedef T* pointer;
    typedef T& reference;




    NodePtr node;




    QValueListIterator() : node( 0 ) {}
    QValueListIterator( NodePtr p ) : node( p ) {}
    QValueListIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }
    T& operator*() { return node->data; }



    QValueListIterator<T>& operator++() {
        node = node->next;
        return *this;
    }

    QValueListIterator<T> operator++(int) {
        QValueListIterator<T> tmp = *this;
        node = node->next;
        return tmp;
    }

    QValueListIterator<T>& operator--() {
        node = node->prev;
        return *this;
    }

    QValueListIterator<T> operator--(int) {
        QValueListIterator<T> tmp = *this;
        node = node->prev;
        return tmp;
    }

    QValueListIterator<T>& operator+=( int j ) {
        while ( j-- )
            node = node->next;
        return *this;
    }

    QValueListIterator<T>& operator-=( int j ) {
        while ( j-- )
            node = node->prev;
        return *this;
    }

};

template<class T>
class QValueListConstIterator
{
 public:



    typedef QValueListNode<T>* NodePtr;



    typedef T value_type;
    typedef size_t size_type;



    typedef int difference_type;

    typedef const T* pointer;
    typedef const T& reference;




    NodePtr node;




    QValueListConstIterator() : node( 0 ) {}
    QValueListConstIterator( NodePtr p ) : node( p ) {}
    QValueListConstIterator( const QValueListConstIterator<T>& it ) : node( it.node ) {}
    QValueListConstIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListConstIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListConstIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }



    QValueListConstIterator<T>& operator++() {
        node = node->next;
        return *this;
    }

    QValueListConstIterator<T> operator++(int) {
        QValueListConstIterator<T> tmp = *this;
        node = node->next;
        return tmp;
    }

    QValueListConstIterator<T>& operator--() {
        node = node->prev;
        return *this;
    }

    QValueListConstIterator<T> operator--(int) {
        QValueListConstIterator<T> tmp = *this;
        node = node->prev;
        return tmp;
    }
};

template <class T>
class QValueListPrivate : public QShared
{
public:



    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef QValueListNode<T> Node;
    typedef QValueListNode<T>* NodePtr;
    typedef size_t size_type;




    QValueListPrivate();
    QValueListPrivate( const QValueListPrivate<T>& _p );

    void derefAndDelete()
    {
        if ( deref() )
            delete this;
    }





    ~QValueListPrivate();

    Iterator insert( Iterator it, const T& x );
    Iterator remove( Iterator it );
    NodePtr find( NodePtr start, const T& x ) const;
    int findIndex( NodePtr start, const T& x ) const;
    uint contains( const T& x ) const;
    uint remove( const T& x );
    NodePtr at( size_type i ) const;
    void clear();

    NodePtr node;
    size_type nodes;
};

template <class T>
 QValueListPrivate<T>::QValueListPrivate()
{
    node = new Node; node->next = node->prev = node; nodes = 0;
}

template <class T>
 QValueListPrivate<T>::QValueListPrivate( const QValueListPrivate<T>& _p )
    : QShared()
{
    node = new Node; node->next = node->prev = node; nodes = 0;
    Iterator b( _p.node->next );
    Iterator e( _p.node );
    Iterator i( node );
    while( b != e )
        insert( i, *b++ );
}

template <class T>
 QValueListPrivate<T>::~QValueListPrivate() {
    NodePtr p = node->next;
    while( p != node ) {
        NodePtr x = p->next;
        delete p;
        p = x;
    }
    delete node;
}

template <class T>
 typename QValueListPrivate<T>::Iterator QValueListPrivate<T>::insert( typename QValueListPrivate<T>::Iterator it, const T& x )
{
    NodePtr p = new Node( x );
    p->next = it.node;
    p->prev = it.node->prev;
    it.node->prev->next = p;
    it.node->prev = p;
    nodes++;
    return p;
}

template <class T>
 typename QValueListPrivate<T>::Iterator QValueListPrivate<T>::remove( typename QValueListPrivate<T>::Iterator it )
{
    ((it.node != node) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","it.node != node","/coolo/prod/qt-copy/include/qvaluelist.h",301));
    NodePtr next = it.node->next;
    NodePtr prev = it.node->prev;
    prev->next = next;
    next->prev = prev;
    delete it.node;
    nodes--;
    return Iterator( next );
}

template <class T>
 typename QValueListPrivate<T>::NodePtr QValueListPrivate<T>::find( typename QValueListPrivate<T>::NodePtr start, const T& x ) const
{
    ConstIterator first( start );
    ConstIterator last( node );
    while( first != last) {
        if ( *first == x )
            return first.node;
        ++first;
    }
    return last.node;
}

template <class T>
 int QValueListPrivate<T>::findIndex( typename QValueListPrivate<T>::NodePtr start, const T& x ) const
{
    ConstIterator first( start );
    ConstIterator last( node );
    int pos = 0;
    while( first != last) {
        if ( *first == x )
            return pos;
        ++first;
        ++pos;
    }
    return -1;
}

template <class T>
 uint QValueListPrivate<T>::contains( const T& x ) const
{
    uint result = 0;
    Iterator first = Iterator( node->next );
    Iterator last = Iterator( node );
    while( first != last) {
        if ( *first == x )
            ++result;
        ++first;
    }
    return result;
}

template <class T>
 uint QValueListPrivate<T>::remove( const T& x )
{
    uint result = 0;
    Iterator first = Iterator( node->next );
    Iterator last = Iterator( node );
    while( first != last) {
        if ( *first == x ) {
            first = remove( first );
            ++result;
        } else
            ++first;
    }
    return result;
}

template <class T>
 typename QValueListPrivate<T>::NodePtr QValueListPrivate<T>::at( size_type i ) const
{
    ((i <= nodes) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","i <= nodes","/coolo/prod/qt-copy/include/qvaluelist.h",372));
    NodePtr p = node->next;
    for( size_type x = 0; x < i; ++x )
        p = p->next;
    return p;
}

template <class T>
 void QValueListPrivate<T>::clear()
{
    nodes = 0;
    NodePtr p = node->next;
    while( p != node ) {
        NodePtr next = p->next;
        delete p;
        p = next;
    }
    node->next = node->prev = node;
}












template <class T> class QDeepCopy;

template <class T>
class QValueList
{
public:



    typedef QValueListIterator<T> iterator;
    typedef QValueListConstIterator<T> const_iterator;
    typedef T value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef size_t size_type;



    typedef int difference_type;





    QValueList() { sh = new QValueListPrivate<T>; }
    QValueList( const QValueList<T>& l ) { sh = l.sh; sh->ref(); }







    ~QValueList() { sh->derefAndDelete(); }

    QValueList<T>& operator= ( const QValueList<T>& l )
    {
        l.sh->ref();
        sh->derefAndDelete();
        sh = l.sh;
        return *this;
    }
# 471 "/coolo/prod/qt-copy/include/qvaluelist.h"
    bool operator== ( const QValueList<T>& l ) const;
    bool operator!= ( const QValueList<T>& l ) const { return !( *this == l ); }
    iterator begin() { detach(); return iterator( sh->node->next ); }
    const_iterator begin() const { return const_iterator( sh->node->next ); }
    const_iterator constBegin() const { return const_iterator( sh->node->next ); }
    iterator end() { detach(); return iterator( sh->node ); }
    const_iterator end() const { return const_iterator( sh->node ); }
    const_iterator constEnd() const { return const_iterator( sh->node ); }
    iterator insert( iterator it, const T& x ) { detach(); return sh->insert( it, x ); }
    uint remove( const T& x ) { detach(); return sh->remove( x ); }
    void clear();


    QValueList<T>& operator<< ( const T& x )
    {
        append( x );
        return *this;
    }

    size_type size() const { return sh->nodes; }
    bool empty() const { return sh->nodes == 0; }
    void push_front( const T& x ) { detach(); sh->insert( begin(), x ); }
    void push_back( const T& x ) { detach(); sh->insert( end(), x ); }
    iterator erase( iterator pos ) { detach(); return sh->remove( pos ); }
    iterator erase( iterator first, iterator last );
    reference front() { ; return *begin(); }
    const_reference front() const { ; return *begin(); }
    reference back() { ; return *(--end()); }
    const_reference back() const { ; return *(--end()); }
    void pop_front() { ; erase( begin() ); }
    void pop_back() {
        ;
        iterator tmp = end();
        erase( --tmp );
    }
    void insert( iterator pos, size_type n, const T& x );
# 517 "/coolo/prod/qt-copy/include/qvaluelist.h"
    QValueList<T> operator+ ( const QValueList<T>& l ) const;
    QValueList<T>& operator+= ( const QValueList<T>& l );

    iterator fromLast() { detach(); return iterator( sh->node->prev ); }
    const_iterator fromLast() const { return const_iterator( sh->node->prev ); }

    bool isEmpty() const { return ( sh->nodes == 0 ); }

    iterator append( const T& x ) { detach(); return sh->insert( end(), x ); }
    iterator prepend( const T& x ) { detach(); return sh->insert( begin(), x ); }

    iterator remove( iterator it ) { detach(); return sh->remove( it ); }

    T& first() { ; detach(); return sh->node->next->data; }
    const T& first() const { ; return sh->node->next->data; }
    T& last() { ; detach(); return sh->node->prev->data; }
    const T& last() const { ; return sh->node->prev->data; }

    T& operator[] ( size_type i ) { ; detach(); return sh->at(i)->data; }
    const T& operator[] ( size_type i ) const { ; return sh->at(i)->data; }
    iterator at( size_type i ) { ; detach(); return iterator( sh->at(i) ); }
    const_iterator at( size_type i ) const { ; return const_iterator( sh->at(i) ); }
    iterator find ( const T& x ) { detach(); return iterator( sh->find( sh->node->next, x) ); }
    const_iterator find ( const T& x ) const { return const_iterator( sh->find( sh->node->next, x) ); }
    iterator find ( iterator it, const T& x ) { detach(); return iterator( sh->find( it.node, x ) ); }
    const_iterator find ( const_iterator it, const T& x ) const { return const_iterator( sh->find( it.node, x ) ); }
    int findIndex( const T& x ) const { return sh->findIndex( sh->node->next, x) ; }
    size_type contains( const T& x ) const { return sh->contains( x ); }

    size_type count() const { return sh->nodes; }

    QValueList<T>& operator+= ( const T& x )
    {
        append( x );
        return *this;
    }
    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef T ValueType;

protected:



    void detach() { if ( sh->count > 1 ) detachInternal(); }




    QValueListPrivate<T>* sh;

private:
    void detachInternal();

    friend class QDeepCopy< QValueList<T> >;
};

template <class T>
 bool QValueList<T>::operator== ( const QValueList<T>& l ) const
{
    if ( size() != l.size() )
        return FALSE;
    const_iterator it2 = begin();
    const_iterator it = l.begin();
    for( ; it != l.end(); ++it, ++it2 )
        if ( !( *it == *it2 ) )
            return FALSE;
    return TRUE;
}

template <class T>
 void QValueList<T>::clear()
{
    if ( sh->count == 1 ) sh->clear(); else { sh->deref(); sh = new QValueListPrivate<T>; }
}

template <class T>
 typename QValueList<T>::iterator QValueList<T>::erase( typename QValueList<T>::iterator first, typename QValueList<T>::iterator last )
{
    while ( first != last )
        erase( first++ );
    return last;
}


template <class T>
 void QValueList<T>::insert( typename QValueList<T>::iterator pos, size_type n, const T& x )
{
    for ( ; n > 0; --n )
        insert( pos, x );
}

template <class T>
 QValueList<T> QValueList<T>::operator+ ( const QValueList<T>& l ) const
{
    QValueList<T> l2( *this );
    for( const_iterator it = l.begin(); it != l.end(); ++it )
        l2.append( *it );
    return l2;
}

template <class T>
 QValueList<T>& QValueList<T>::operator+= ( const QValueList<T>& l )
{
    for( const_iterator it = l.begin(); it != l.end(); ++it )
        append( *it );
    return *this;
}

template <class T>
 void QValueList<T>::detachInternal()
{
    sh->deref(); sh = new QValueListPrivate<T>( *sh );
}


template <class T>
 QDataStream& operator>>( QDataStream& s, QValueList<T>& l )
{
    l.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i )
    {
        T t;
        s >> t;
        l.append( t );
        if ( s.atEnd() )
            break;
    }
    return s;
}

template <class T>
 QDataStream& operator<<( QDataStream& s, const QValueList<T>& l )
{
    s << (Q_UINT32)l.size();
    QValueListConstIterator<T> it = l.begin();
    for( ; it != l.end(); ++it )
        s << *it;
    return s;
}


# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 664 "/coolo/prod/qt-copy/include/qvaluelist.h" 2
# 47 "/coolo/prod/qt-copy/include/qmap.h" 2
# 56 "/coolo/prod/qt-copy/include/qmap.h"
struct QMapNodeBase
{
    enum Color { Red, Black };

    QMapNodeBase* left;
    QMapNodeBase* right;
    QMapNodeBase* parent;

    Color color;

    QMapNodeBase* minimum() {
        QMapNodeBase* x = this;
        while ( x->left )
            x = x->left;
        return x;
    }

    QMapNodeBase* maximum() {
        QMapNodeBase* x = this;
        while ( x->right )
            x = x->right;
        return x;
    }
};


template <class K, class T>
struct QMapNode : public QMapNodeBase
{
    QMapNode( const K& _key, const T& _data ) { data = _data; key = _key; }
    QMapNode( const K& _key ) { key = _key; }
    QMapNode( const QMapNode<K,T>& _n ) { key = _n.key; data = _n.data; }
    QMapNode() { }
    T data;
    K key;
};


template<class K, class T>
class QMapIterator
{
 public:



    typedef QMapNode< K, T >* NodePtr;



    typedef T value_type;



    typedef int difference_type;

    typedef T* pointer;
    typedef T& reference;




    QMapNode<K,T>* node;




    QMapIterator() : node( 0 ) {}
    QMapIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapIterator<K,T>& it ) const { return node != it.node; }
    T& operator*() { return node->data; }
    const T& operator*() const { return node->data; }



    const K& key() const { return node->key; }
    T& data() { return node->data; }
    const T& data() const { return node->data; }

private:
    int inc();
    int dec();

public:
    QMapIterator<K,T>& operator++() {
        inc();
        return *this;
    }

    QMapIterator<K,T> operator++(int) {
        QMapIterator<K,T> tmp = *this;
        inc();
        return tmp;
    }

    QMapIterator<K,T>& operator--() {
        dec();
        return *this;
    }

    QMapIterator<K,T> operator--(int) {
        QMapIterator<K,T> tmp = *this;
        dec();
        return tmp;
    }
};

template <class K, class T>
 int QMapIterator<K,T>::inc()
{
    QMapNodeBase* tmp = node;
    if ( tmp->right ) {
        tmp = tmp->right;
        while ( tmp->left )
            tmp = tmp->left;
    } else {
        QMapNodeBase* y = tmp->parent;
        while (tmp == y->right) {
            tmp = y;
            y = y->parent;
        }
        if (tmp->right != y)
            tmp = y;
    }
    node = (NodePtr)tmp;
    return 0;
}

template <class K, class T>
 int QMapIterator<K,T>::dec()
{
    QMapNodeBase* tmp = node;
    if (tmp->color == QMapNodeBase::Red &&
        tmp->parent->parent == tmp ) {
        tmp = tmp->right;
    } else if (tmp->left != 0) {
        QMapNodeBase* y = tmp->left;
        while ( y->right )
            y = y->right;
        tmp = y;
    } else {
        QMapNodeBase* y = tmp->parent;
        while (tmp == y->left) {
            tmp = y;
            y = y->parent;
        }
        tmp = y;
    }
    node = (NodePtr)tmp;
    return 0;
}

template<class K, class T>
class QMapConstIterator
{
 public:



    typedef QMapNode< K, T >* NodePtr;



    typedef T value_type;



    typedef int difference_type;

    typedef const T* pointer;
    typedef const T& reference;





    QMapNode<K,T>* node;




    QMapConstIterator() : node( 0 ) {}
    QMapConstIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapConstIterator( const QMapConstIterator<K,T>& it ) : node( it.node ) {}
    QMapConstIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapConstIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapConstIterator<K,T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }



    const K& key() const { return node->key; }
    const T& data() const { return node->data; }

private:
    int inc();
    int dec();

public:
    QMapConstIterator<K,T>& operator++() {
        inc();
        return *this;
    }

    QMapConstIterator<K,T> operator++(int) {
        QMapConstIterator<K,T> tmp = *this;
        inc();
        return tmp;
    }

    QMapConstIterator<K,T>& operator--() {
        dec();
        return *this;
    }

    QMapConstIterator<K,T> operator--(int) {
        QMapConstIterator<K,T> tmp = *this;
        dec();
        return tmp;
    }
};

template <class K, class T>
 int QMapConstIterator<K,T>::inc()
{
    QMapNodeBase* tmp = node;
    if ( tmp->right ) {
        tmp = tmp->right;
        while ( tmp->left )
            tmp = tmp->left;
    } else {
        QMapNodeBase* y = tmp->parent;
        while (tmp == y->right) {
            tmp = y;
            y = y->parent;
        }
        if (tmp->right != y)
            tmp = y;
    }
    node = (NodePtr)tmp;
    return 0;
}

template <class K, class T>
 int QMapConstIterator<K,T>::dec()
{
    QMapNodeBase* tmp = node;
    if (tmp->color == QMapNodeBase::Red &&
        tmp->parent->parent == tmp ) {
        tmp = tmp->right;
    } else if (tmp->left != 0) {
        QMapNodeBase* y = tmp->left;
        while ( y->right )
            y = y->right;
        tmp = y;
    } else {
        QMapNodeBase* y = tmp->parent;
        while (tmp == y->left) {
            tmp = y;
            y = y->parent;
        }
        tmp = y;
    }
    node = (NodePtr)tmp;
    return 0;
}


class QMapPrivateBase : public QShared
{
public:
    QMapPrivateBase() {
        node_count = 0;
    }
    QMapPrivateBase( const QMapPrivateBase* _map) {
        node_count = _map->node_count;
    }




    void rotateLeft( QMapNodeBase* x, QMapNodeBase*& root);
    void rotateRight( QMapNodeBase* x, QMapNodeBase*& root );
    void rebalance( QMapNodeBase* x, QMapNodeBase*& root );
    QMapNodeBase* removeAndRebalance( QMapNodeBase* z, QMapNodeBase*& root,
                                      QMapNodeBase*& leftmost,
                                      QMapNodeBase*& rightmost );




    int node_count;
};


template <class Key, class T>
class QMapPrivate : public QMapPrivateBase
{
public:



    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef QMapNode< Key, T > Node;
    typedef QMapNode< Key, T >* NodePtr;




    QMapPrivate();
    QMapPrivate( const QMapPrivate< Key, T >* _map );
    ~QMapPrivate() { clear(); delete header; }

    NodePtr copy( NodePtr p );
    void clear();
    void clear( NodePtr p );

    Iterator begin() { return Iterator( (NodePtr)(header->left ) ); }
    Iterator end() { return Iterator( header ); }
    ConstIterator begin() const { return ConstIterator( (NodePtr)(header->left ) ); }
    ConstIterator end() const { return ConstIterator( header ); }

    ConstIterator find(const Key& k) const;

    void remove( Iterator it ) {
        NodePtr del = (NodePtr) removeAndRebalance( it.node, header->parent, header->left, header->right );
        delete del;
        --node_count;
    }
# 414 "/coolo/prod/qt-copy/include/qmap.h"
    Iterator insertSingle( const Key& k );
    Iterator insert( QMapNodeBase* x, QMapNodeBase* y, const Key& k );

protected:



    const Key& key( QMapNodeBase* b ) const { return ((NodePtr)b)->key; }




    NodePtr header;
};


template <class Key, class T>
 QMapPrivate<Key,T>::QMapPrivate() {
    header = new Node;
    header->color = QMapNodeBase::Red;
    header->parent = 0;
    header->left = header->right = header;
}
template <class Key, class T>
 QMapPrivate<Key,T>::QMapPrivate( const QMapPrivate< Key, T >* _map ) : QMapPrivateBase( _map ) {
    header = new Node;
    header->color = QMapNodeBase::Red;
    if ( _map->header->parent == 0 ) {
        header->parent = 0;
        header->left = header->right = header;
    } else {
        header->parent = copy( (NodePtr)(_map->header->parent) );
        header->parent->parent = header;
        header->left = header->parent->minimum();
        header->right = header->parent->maximum();
    }
}

template <class Key, class T>
 typename QMapPrivate<Key,T>::NodePtr QMapPrivate<Key,T>::copy( typename QMapPrivate<Key,T>::NodePtr p )
{
    if ( !p )
        return 0;
    NodePtr n = new Node( *p );
    n->color = p->color;
    if ( p->left ) {
        n->left = copy( (NodePtr)(p->left) );
        n->left->parent = n;
    } else {
        n->left = 0;
    }
    if ( p->right ) {
        n->right = copy( (NodePtr)(p->right) );
        n->right->parent = n;
    } else {
        n->right = 0;
    }
    return n;
}

template <class Key, class T>
 void QMapPrivate<Key,T>::clear()
{
    clear( (NodePtr)(header->parent) );
    header->color = QMapNodeBase::Red;
    header->parent = 0;
    header->left = header->right = header;
    node_count = 0;
}

template <class Key, class T>
 void QMapPrivate<Key,T>::clear( typename QMapPrivate<Key,T>::NodePtr p )
{
    while ( p != 0 ) {
        clear( (NodePtr)p->right );
        NodePtr y = (NodePtr)p->left;
        delete p;
        p = y;
    }
}

template <class Key, class T>
 typename QMapPrivate<Key,T>::ConstIterator QMapPrivate<Key,T>::find(const Key& k) const
{
    QMapNodeBase* y = header;
    QMapNodeBase* x = header->parent;

    while ( x != 0 ) {

        if ( !( key(x) < k ) ) {
            y = x;
            x = x->left;
        } else {
            x = x->right;
        }
    }



    if ( y == header || k < key(y) )
        return ConstIterator( header );
    return ConstIterator( (NodePtr)y );
}

template <class Key, class T>
 typename QMapPrivate<Key,T>::Iterator QMapPrivate<Key,T>::insertSingle( const Key& k )
{

    QMapNodeBase* y = header;
    QMapNodeBase* x = header->parent;
    bool result = TRUE;
    while ( x != 0 ) {
        result = ( k < key(x) );
        y = x;
        x = result ? x->left : x->right;
    }

    Iterator j( (NodePtr)y );
    if ( result ) {

        if ( j == begin() ) {
            return insert(x, y, k );
        } else {

            --j;
        }
    }

    if ( (j.node->key) < k )
        return insert(x, y, k );

    return j;
}


template <class Key, class T>
 typename QMapPrivate<Key,T>::Iterator QMapPrivate<Key,T>::insert( QMapNodeBase* x, QMapNodeBase* y, const Key& k )
{
    NodePtr z = new Node( k );
    if (y == header || x != 0 || k < key(y) ) {
        y->left = z;
        if ( y == header ) {
            header->parent = z;
            header->right = z;
        } else if ( y == header->left )
            header->left = z;
    } else {
        y->right = z;
        if ( y == header->right )
            header->right = z;
    }
    z->parent = y;
    z->left = 0;
    z->right = 0;
    rebalance( z, header->parent );
    ++node_count;
    return Iterator(z);
}













template <class T> class QDeepCopy;

template<class Key, class T>
class QMap
{
public:



    typedef Key key_type;
    typedef T mapped_type;
    typedef QPair<const key_type, mapped_type> value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;



    typedef int difference_type;

    typedef size_t size_type;
    typedef QMapIterator<Key,T> iterator;
    typedef QMapConstIterator<Key,T> const_iterator;
    typedef QPair<iterator,bool> insert_pair;

    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef T ValueType;
    typedef QMapPrivate< Key, T > Priv;




    QMap()
    {
        sh = new QMapPrivate< Key, T >;
    }
    QMap( const QMap<Key,T>& m )
    {
        sh = m.sh; sh->ref();
    }
# 641 "/coolo/prod/qt-copy/include/qmap.h"
    ~QMap()
    {
        if ( sh->deref() )
            delete sh;
    }
    QMap<Key,T>& operator= ( const QMap<Key,T>& m );
# 660 "/coolo/prod/qt-copy/include/qmap.h"
    iterator begin() { detach(); return sh->begin(); }
    iterator end() { detach(); return sh->end(); }
    const_iterator begin() const { return ((const Priv*)sh)->begin(); }
    const_iterator end() const { return ((const Priv*)sh)->end(); }
    const_iterator constBegin() const { return begin(); }
    const_iterator constEnd() const { return end(); }

    iterator replace( const Key& k, const T& v )
    {
        remove( k );
        return insert( k, v );
    }

    size_type size() const
    {
        return sh->node_count;
    }
    bool empty() const
    {
        return sh->node_count == 0;
    }
    QPair<iterator,bool> insert( const value_type& x );

    void erase( iterator it )
    {
        detach();
        sh->remove( it );
    }
    void erase( const key_type& k );
    size_type count( const key_type& k ) const;
    T& operator[] ( const Key& k );
    void clear();

    iterator find ( const Key& k )
    {
        detach();
        return iterator( sh->find( k ).node );
    }
    const_iterator find ( const Key& k ) const { return sh->find( k ); }

    const T& operator[] ( const Key& k ) const
        { ; return sh->find( k ).data(); }
    bool contains ( const Key& k ) const
        { return find( k ) != end(); }


    size_type count() const { return sh->node_count; }

    QValueList<Key> keys() const {
        QValueList<Key> r;
        for (const_iterator i=begin(); i!=end(); ++i)
            r.append(i.key());
        return r;
    }

    QValueList<T> values() const {
        QValueList<T> r;
        for (const_iterator i=begin(); i!=end(); ++i)
            r.append(*i);
        return r;
    }

    bool isEmpty() const { return sh->node_count == 0; }

    iterator insert( const Key& key, const T& value, bool overwrite = TRUE );
    void remove( iterator it ) { detach(); sh->remove( it ); }
    void remove( const Key& k );
# 735 "/coolo/prod/qt-copy/include/qmap.h"
protected:



    void detach() { if ( sh->count > 1 ) detachInternal(); }

    Priv* sh;
private:
    void detachInternal();

    friend class QDeepCopy< QMap<Key,T> >;
};

template<class Key, class T>
 QMap<Key,T>& QMap<Key,T>::operator= ( const QMap<Key,T>& m )
{
    m.sh->ref();
    if ( sh->deref() )
        delete sh;
    sh = m.sh;
    return *this;
}

template<class Key, class T>
 typename QMap<Key,T>::insert_pair QMap<Key,T>::insert( const typename QMap<Key,T>::value_type& x )
{
    detach();
    size_type n = size();
    iterator it = sh->insertSingle( x.first );
    bool inserted = FALSE;
    if ( n < size() ) {
        inserted = TRUE;
        it.data() = x.second;
    }
    return QPair<iterator,bool>( it, inserted );
}

template<class Key, class T>
 void QMap<Key,T>::erase( const Key& k )
{
    detach();
    iterator it( sh->find( k ).node );
    if ( it != end() )
        sh->remove( it );
}

template<class Key, class T>
 typename QMap<Key,T>::size_type QMap<Key,T>::count( const Key& k ) const
{
    const_iterator it( sh->find( k ).node );
    if ( it != end() ) {
        size_type c = 0;
        while ( it != end() ) {
            ++it;
            ++c;
        }
        return c;
    }
    return 0;
}

template<class Key, class T>
 T& QMap<Key,T>::operator[] ( const Key& k )
{
    detach();
    QMapNode<Key,T>* p = sh->find( k ).node;
    if ( p != sh->end().node )
        return p->data;
    return insert( k, T() ).data();
}

template<class Key, class T>
 void QMap<Key,T>::clear()
{
    if ( sh->count == 1 )
        sh->clear();
    else {
        sh->deref();
        sh = new QMapPrivate<Key,T>;
    }
}

template<class Key, class T>
 typename QMap<Key,T>::iterator QMap<Key,T>::insert( const Key& key, const T& value, bool overwrite )
{
    detach();
    size_type n = size();
    iterator it = sh->insertSingle( key );
    if ( overwrite || n < size() )
        it.data() = value;
    return it;
}

template<class Key, class T>
 void QMap<Key,T>::remove( const Key& k )
{
    detach();
    iterator it( sh->find( k ).node );
    if ( it != end() )
        sh->remove( it );
}

template<class Key, class T>
 void QMap<Key,T>::detachInternal()
{
    sh->deref(); sh = new QMapPrivate<Key,T>( sh );
}



template<class Key, class T>
 QDataStream& operator>>( QDataStream& s, QMap<Key,T>& m ) {
    m.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i ) {
        Key k; T t;
        s >> k >> t;
        m.insert( k, t );
        if ( s.atEnd() )
            break;
    }
    return s;
}


template<class Key, class T>
 QDataStream& operator<<( QDataStream& s, const QMap<Key,T>& m ) {
    s << (Q_UINT32)m.size();
    QMapConstIterator<Key,T> it = m.begin();
    for( ; it != m.end(); ++it )
        s << it.key() << it.data();
    return s;
}


# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 873 "/coolo/prod/qt-copy/include/qmap.h" 2
# 44 "/coolo/prod/qt-copy/include/qmime.h" 2




class QImageDrag;
class QTextDrag;

class QMimeSource
{
    friend class QClipboardData;

public:
    QMimeSource();
    virtual ~QMimeSource();
    virtual const char* format( int n = 0 ) const = 0;
    virtual bool provides( const char* ) const;
    virtual QByteArray encodedData( const char* ) const = 0;
    int serialNumber() const;

private:
    int ser_no;
    enum { NoCache, Text, Graphics } cacheType;
    union
    {
        struct
        {
            QString *str;
            QCString *subtype;
        } txt;
        struct
        {
            QImage *img;
            QPixmap *pix;
        } gfx;
    } cache;
    void clearCache();


    friend class QImageDrag;
    friend class QTextDrag;

};

inline int QMimeSource::serialNumber() const
{ return ser_no; }

class QStringList;
class QMimeSourceFactoryData;

class QMimeSourceFactory {
public:
    QMimeSourceFactory();
    virtual ~QMimeSourceFactory();

    static QMimeSourceFactory* defaultFactory();
    static void setDefaultFactory( QMimeSourceFactory* );
    static QMimeSourceFactory* takeDefaultFactory();
    static void addFactory( QMimeSourceFactory *f );
    static void removeFactory( QMimeSourceFactory *f );

    virtual const QMimeSource* data(const QString& abs_name) const;
    virtual QString makeAbsolute(const QString& abs_or_rel_name, const QString& context) const;
    const QMimeSource* data(const QString& abs_or_rel_name, const QString& context) const;

    virtual void setText( const QString& abs_name, const QString& text );
    virtual void setImage( const QString& abs_name, const QImage& im );
    virtual void setPixmap( const QString& abs_name, const QPixmap& pm );
    virtual void setData( const QString& abs_name, QMimeSource* data );
    virtual void setFilePath( const QStringList& );
    virtual QStringList filePath() const;
    void addFilePath( const QString& );
    virtual void setExtensionType( const QString& ext, const char* mimetype );

private:
    QMimeSource *dataInternal(const QString& abs_name, const QMap<QString, QString> &extensions ) const;
    QMimeSourceFactoryData* d;
};
# 46 "/coolo/prod/qt-copy/include/qevent.h" 2



class QEvent: public Qt
{
public:
    enum Type {
# 61 "/coolo/prod/qt-copy/include/qevent.h"
        None = 0,


        Timer = 1,
        MouseButtonPress = 2,
        MouseButtonRelease = 3,
        MouseButtonDblClick = 4,
        MouseMove = 5,
        KeyPress = 6,
        KeyRelease = 7,
        FocusIn = 8,
        FocusOut = 9,
        Enter = 10,
        Leave = 11,
        Paint = 12,
        Move = 13,
        Resize = 14,
        Create = 15,
        Destroy = 16,
        Show = 17,
        Hide = 18,
        Close = 19,
        Quit = 20,
        Reparent = 21,
        ShowMinimized = 22,
        ShowNormal = 23,
        WindowActivate = 24,
        WindowDeactivate = 25,
        ShowToParent = 26,
        HideToParent = 27,
        ShowMaximized = 28,
        ShowFullScreen = 29,
        Accel = 30,
        Wheel = 31,
        AccelAvailable = 32,
        CaptionChange = 33,
        IconChange = 34,
        ParentFontChange = 35,
        ApplicationFontChange = 36,
        ParentPaletteChange = 37,
        ApplicationPaletteChange = 38,
        PaletteChange = 39,
        Clipboard = 40,
        Speech = 42,
        SockAct = 50,
        AccelOverride = 51,
        DeferredDelete = 52,
        DragEnter = 60,
        DragMove = 61,
        DragLeave = 62,
        Drop = 63,
        DragResponse = 64,
        ChildInserted = 70,
        ChildRemoved = 71,
        LayoutHint = 72,
        ShowWindowRequest = 73,
        ActivateControl = 80,
        DeactivateControl = 81,
        ContextMenu = 82,
        IMStart = 83,
        IMCompose = 84,
        IMEnd = 85,
        Accessibility = 86,
        TabletMove = 87,
        LocaleChange = 88,
        LanguageChange = 89,
        LayoutDirectionChange = 90,
        Style = 91,
        TabletPress = 92,
        TabletRelease = 93,
        User = 1000,
        MaxUser = 65535
    };


    QEvent( Type type ) : t(type), posted(FALSE), spont(FALSE) {}
    virtual ~QEvent();
    Type type() const { return t; }
    bool spontaneous() const { return spont; }
protected:
    Type t;
private:
    uint posted : 1;
    uint spont : 1;


    friend class QApplication;
    friend class QAccelManager;
    friend class QBaseApplication;
    friend class QETWidget;
};


class QTimerEvent : public QEvent
{
public:
    QTimerEvent( int timerId )
        : QEvent(Timer), id(timerId) {}
    int timerId() const { return id; }
protected:
    int id;
};


class QMouseEvent : public QEvent
{
public:
    QMouseEvent( Type type, const QPoint &pos, int button, int state );

    QMouseEvent( Type type, const QPoint &pos, const QPoint&globalPos,
                 int button, int state )
        : QEvent(type), p(pos), g(globalPos), b((ushort)button),s((ushort)state),accpt(TRUE) {};

    const QPoint &pos() const { return p; }
    const QPoint &globalPos() const { return g; }
    int x() const { return p.x(); }
    int y() const { return p.y(); }
    int globalX() const { return g.x(); }
    int globalY() const { return g.y(); }
    ButtonState button() const { return (ButtonState) b; }
    ButtonState state() const { return (ButtonState) s; }
    ButtonState stateAfter() const;
    bool isAccepted() const { return accpt; }
    void accept() { accpt = TRUE; }
    void ignore() { accpt = FALSE; }
protected:
    QPoint p;
    QPoint g;
    ushort b;
    ushort s;
    uint accpt:1;
};



class QWheelEvent : public QEvent
{
public:
    QWheelEvent( const QPoint &pos, int delta, int state, Orientation orient = Vertical );
    QWheelEvent( const QPoint &pos, const QPoint& globalPos, int delta, int state, Orientation orient = Vertical )
        : QEvent(Wheel), p(pos), g(globalPos), d(delta), s((ushort)state),
          accpt(TRUE), o(orient) {}
    int delta() const { return d; }
    const QPoint &pos() const { return p; }
    const QPoint &globalPos() const { return g; }
    int x() const { return p.x(); }
    int y() const { return p.y(); }
    int globalX() const { return g.x(); }
    int globalY() const { return g.y(); }
    ButtonState state() const { return ButtonState(s); }
    Orientation orientation() const { return o; }
    bool isAccepted() const { return accpt; }
    void accept() { accpt = TRUE; }
    void ignore() { accpt = FALSE; }
protected:
    QPoint p;
    QPoint g;
    int d;
    ushort s;
    bool accpt;
    Orientation o;
};


class QTabletEvent : public QEvent
{
public:
    enum TabletDevice { NoDevice = -1, Puck, Stylus, Eraser };
    QTabletEvent( Type t, const QPoint &pos, const QPoint &globalPos, int device,
                  int pressure, int xTilt, int yTilt, const QPair<int,int> &uId );
    QTabletEvent( const QPoint &pos, const QPoint &globalPos, int device,
                  int pressure, int xTilt, int yTilt, const QPair<int,int> &uId )
        : QEvent( TabletMove ), mPos( pos ), mGPos( globalPos ), mDev( device ),
          mPress( pressure ), mXT( xTilt ), mYT( yTilt ), mType( uId.first ),
          mPhy( uId.second ), mbAcc(TRUE)
    {}
    int pressure() const { return mPress; }
    int xTilt() const { return mXT; }
    int yTilt() const { return mYT; }
    const QPoint &pos() const { return mPos; }
    const QPoint &globalPos() const { return mGPos; }
    int x() const { return mPos.x(); }
    int y() const { return mPos.y(); }
    int globalX() const { return mGPos.x(); }
    int globalY() const { return mGPos.y(); }
    TabletDevice device() const { return TabletDevice(mDev); }
    int isAccepted() const { return mbAcc; }
    void accept() { mbAcc = TRUE; }
    void ignore() { mbAcc = FALSE; }
    QPair<int,int> uniqueId() { return QPair<int,int>( mType, mPhy); }
protected:
    QPoint mPos;
    QPoint mGPos;
    int mDev,
        mPress,
        mXT,
        mYT,
        mType,
        mPhy;
    bool mbAcc;

};

class QKeyEvent : public QEvent
{
public:
    QKeyEvent( Type type, int key, int ascii, int state,
                const QString& text=QString::null, bool autorep=FALSE, ushort count=1 )
        : QEvent(type), txt(text), k((ushort)key), s((ushort)state),
            a((uchar)ascii), accpt(TRUE), autor(autorep), c(count)
    {
        if ( key >= Key_Back && key <= Key_MediaLast )
            accpt = FALSE;
    }
    int key() const { return k; }
    int ascii() const { return a; }
    ButtonState state() const { return ButtonState(s); }
    ButtonState stateAfter() const;
    bool isAccepted() const { return accpt; }
    QString text() const { return txt; }
    bool isAutoRepeat() const { return autor; }
    int count() const { return int(c); }
    void accept() { accpt = TRUE; }
    void ignore() { accpt = FALSE; }

protected:
    QString txt;
    ushort k, s;
    uchar a;
    uint accpt:1;
    uint autor:1;
    ushort c;
};


class QFocusEvent : public QEvent
{
public:

    QFocusEvent( Type type )
        : QEvent(type) {}

    bool gotFocus() const { return type() == FocusIn; }
    bool lostFocus() const { return type() == FocusOut; }

    enum Reason { Mouse, Tab, Backtab, ActiveWindow, Popup, Shortcut, Other };
    static Reason reason();
    static void setReason( Reason reason );
    static void resetReason();

private:
    static Reason m_reason;
    static Reason prev_reason;
};


class QPaintEvent : public QEvent
{
public:
    QPaintEvent( const QRegion& paintRegion, bool erased = TRUE)
        : QEvent(Paint),
          rec(paintRegion.boundingRect()),
          reg(paintRegion),
          erase(erased){}
    QPaintEvent( const QRect &paintRect, bool erased = TRUE )
        : QEvent(Paint),
          rec(paintRect),
          reg(paintRect),
          erase(erased){}
    const QRect &rect() const { return rec; }
    const QRegion &region() const { return reg; }
    bool erased() const { return erase; }
protected:
    friend class QApplication;
    friend class QBaseApplication;
    QRect rec;
    QRegion reg;
    bool erase;
};


class QMoveEvent : public QEvent
{
public:
    QMoveEvent( const QPoint &pos, const QPoint &oldPos )
        : QEvent(Move), p(pos), oldp(oldPos) {}
    const QPoint &pos() const { return p; }
    const QPoint &oldPos()const { return oldp;}
protected:
    QPoint p, oldp;
    friend class QApplication;
    friend class QBaseApplication;
};


class QResizeEvent : public QEvent
{
public:
    QResizeEvent( const QSize &size, const QSize &oldSize )
        : QEvent(Resize), s(size), olds(oldSize) {}
    const QSize &size() const { return s; }
    const QSize &oldSize()const { return olds;}
protected:
    QSize s, olds;
    friend class QApplication;
    friend class QBaseApplication;
};


class QCloseEvent : public QEvent
{
public:
    QCloseEvent()
        : QEvent(Close), accpt(FALSE) {}
    bool isAccepted() const { return accpt; }
    void accept() { accpt = TRUE; }
    void ignore() { accpt = FALSE; }
protected:
    bool accpt;
};


class QShowEvent : public QEvent
{
public:
    QShowEvent()
        : QEvent(Show) {}
};


class QHideEvent : public QEvent
{
public:
    QHideEvent()
        : QEvent(Hide) {}
};

class QContextMenuEvent : public QEvent
{
public:
    enum Reason { Mouse, Keyboard, Other };
    QContextMenuEvent( Reason reason, const QPoint &pos, const QPoint &globalPos, int state )
        : QEvent( ContextMenu ), p( pos ), gp( globalPos ), accpt( TRUE ), consum( TRUE ),
        reas( reason ), s((ushort)state) {}
    QContextMenuEvent( Reason reason, const QPoint &pos, int state );

    int x() const { return p.x(); }
    int y() const { return p.y(); }
    int globalX() const { return gp.x(); }
    int globalY() const { return gp.y(); }

    const QPoint& pos() const { return p; }
    const QPoint& globalPos() const { return gp; }

    ButtonState state() const { return (ButtonState) s; }
    bool isAccepted() const { return accpt; }
    bool isConsumed() const { return consum; }
    void consume() { accpt = FALSE; consum = TRUE; }
    void accept() { accpt = TRUE; consum = TRUE; }
    void ignore() { accpt = FALSE; consum = FALSE; }

    Reason reason() const { return Reason( reas ); }

protected:
    QPoint p;
    QPoint gp;
    bool accpt;
    bool consum;
    uint reas:8;
    ushort s;
};


class QIMEvent : public QEvent
{
public:
    QIMEvent( Type type, const QString &text, int cursorPosition )
        : QEvent(type), txt(text), cpos(cursorPosition), a(TRUE) {}
    const QString &text() const { return txt; }
    int cursorPos() const { return cpos; }
    bool isAccepted() const { return a; }
    void accept() { a = TRUE; }
    void ignore() { a = FALSE; }
    int selectionLength() const;

private:
    QString txt;
    int cpos;
    bool a;
};

class QIMComposeEvent : public QIMEvent
{
public:
    QIMComposeEvent( Type type, const QString &text, int cursorPosition,
                     int selLength )
        : QIMEvent( type, text, cursorPosition ), selLen( selLength ) { }

private:
    int selLen;

    friend class QIMEvent;
};

inline int QIMEvent::selectionLength() const
{
    if ( type() != IMCompose ) return 0;
    QIMComposeEvent *that = (QIMComposeEvent *) this;
    return that->selLen;
}
# 479 "/coolo/prod/qt-copy/include/qevent.h"
class QDropEvent : public QEvent, public QMimeSource
{
public:
    QDropEvent( const QPoint& pos, Type typ=Drop )
        : QEvent(typ), p(pos),
          act(0), accpt(0), accptact(0), resv(0),
          d(0)
        {}
    const QPoint &pos() const { return p; }
    bool isAccepted() const { return accpt || accptact; }
    void accept(bool y=TRUE) { accpt = y; }
    void ignore() { accpt = FALSE; }

    bool isActionAccepted() const { return accptact; }
    void acceptAction(bool y=TRUE) { accptact = y; }
    enum Action { Copy, Link, Move, Private, UserAction=100 };
    void setAction( Action a ) { act = (uint)a; }
    Action action() const { return Action(act); }

    QWidget* source() const;
    const char* format( int n = 0 ) const;
    QByteArray encodedData( const char* ) const;
    bool provides( const char* ) const;

    QByteArray data(const char* f) const { return encodedData(f); }

    void setPoint( const QPoint& np ) { p = np; }

protected:
    QPoint p;
    uint act:8;
    uint accpt:1;
    uint accptact:1;
    uint resv:5;
    void * d;
};



class QDragMoveEvent : public QDropEvent
{
public:
    QDragMoveEvent( const QPoint& pos, Type typ=DragMove )
        : QDropEvent(pos,typ),
          rect( pos, QSize( 1, 1 ) ) {}
    QRect answerRect() const { return rect; }
    void accept( bool y=TRUE ) { QDropEvent::accept(y); }
    void accept( const QRect & r) { accpt = TRUE; rect = r; }
    void ignore( const QRect & r) { accpt =FALSE; rect = r; }
    void ignore() { QDropEvent::ignore(); }

protected:
    QRect rect;
};


class QDragEnterEvent : public QDragMoveEvent
{
public:
    QDragEnterEvent( const QPoint& pos ) :
        QDragMoveEvent(pos, DragEnter) { }
};



class QDragResponseEvent : public QEvent
{
public:
    QDragResponseEvent( bool accepted )
        : QEvent(DragResponse), a(accepted) {}
    bool dragAccepted() const { return a; }
protected:
    bool a;
};


class QDragLeaveEvent : public QEvent
{
public:
    QDragLeaveEvent()
        : QEvent(DragLeave) {}
};



class QChildEvent : public QEvent
{
public:
    QChildEvent( Type type, QObject *child )
        : QEvent(type), c(child) {}
    QObject *child() const { return c; }
    bool inserted() const { return t == ChildInserted; }
    bool removed() const { return t == ChildRemoved; }
protected:
    QObject *c;
};


class QCustomEvent : public QEvent
{
public:
    QCustomEvent( int type );
    QCustomEvent( Type type, void *data )
        : QEvent(type), d(data) {};
    void *data() const { return d; }
    void setData( void* data ) { d = data; }
private:
    void *d;
};
# 46 "/coolo/prod/qt-copy/include/qobject.h" 2




class QMetaObject;
class QVariant;
class QMetaProperty;
class QPostEventList;
class QSenderObjectList;
class QObjectPrivate;

class QObjectUserData;

struct QUObject;

class QObject: public Qt
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   

public:
    QObject( QObject *parent=0, const char *name=0 );
    virtual ~QObject();
# 79 "/coolo/prod/qt-copy/include/qobject.h"
    virtual bool event( QEvent * );
    virtual bool eventFilter( QObject *, QEvent * );

    bool isA( const char * ) const;
    bool inherits( const char * ) const;

    const char *name() const;
    const char *name( const char * defaultName ) const;

    virtual void setName( const char *name );
    bool isWidgetType() const { return isWidget; }
    bool highPriority() const { return FALSE; }

    bool signalsBlocked() const { return blockSig; }
    void blockSignals( bool b );

    int startTimer( int interval );
    void killTimer( int id );
    void killTimers();

    QObject *child( const char *objName, const char *inheritsClass = 0, bool recursiveSearch = TRUE );
    const QObjectList *children() const { return childObjects; }

    static const QObjectList *objectTrees();

    QObjectList *queryList( const char *inheritsClass = 0,
                                  const char *objName = 0,
                                  bool regexpMatch = TRUE,
                                  bool recursiveSearch = TRUE ) const;

    virtual void insertChild( QObject * );
    virtual void removeChild( QObject * );

    void installEventFilter( const QObject * );
    void removeEventFilter( const QObject * );

    static bool connect( const QObject *sender, const char *signal,
                          const QObject *receiver, const char *member );
    bool connect( const QObject *sender, const char *signal,
                          const char *member ) const;
    static bool disconnect( const QObject *sender, const char *signal,
                             const QObject *receiver, const char *member );
    bool disconnect( const char *signal=0,
                             const QObject *receiver=0, const char *member=0 );
    bool disconnect( const QObject *receiver, const char *member=0 );
    static void connectInternal( const QObject *sender, int signal_index,
                          const QObject *receiver, int membcode, int member_index );
    static bool disconnectInternal( const QObject *sender, int signal_index,
                             const QObject *receiver, int membcode, int member_index );

    void dumpObjectTree();
    void dumpObjectInfo();


    virtual bool setProperty( const char *name, const QVariant& value );
    virtual QVariant property( const char *name ) const;
# 144 "/coolo/prod/qt-copy/include/qobject.h"
    static uint registerUserData();
    void setUserData( uint id, QObjectUserData* data);
    QObjectUserData* userData( uint id ) const;


protected:
    void destroyed();
    void destroyed( QObject* obj );

public:
    QObject *parent() const { return parentObj; }

public :
    void deleteLater();

private :
    void cleanupEventFilter( QObject* );

protected:
    bool activate_filters( QEvent * );
    QConnectionList *receivers( const char* signal ) const;
    QConnectionList *receivers( int signal ) const;
    void activate_signal( int signal );
    void activate_signal( int signal, int );
    void activate_signal( int signal, double );
    void activate_signal( int signal, QString );
    void activate_signal_bool( int signal, bool );
    void activate_signal( QConnectionList *clist, QUObject *o );

    const QObject *sender();

    virtual void timerEvent( QTimerEvent * );
    virtual void childEvent( QChildEvent * );
    virtual void customEvent( QCustomEvent * );

    virtual void connectNotify( const char *signal );
    virtual void disconnectNotify( const char *signal );
    virtual bool checkConnectArgs( const char *signal, const QObject *receiver,
                                   const char *member );
    static QCString normalizeSignalSlot( const char *signalSlot );

private:
    uint isSignal : 1;
    uint isWidget : 1;
    uint pendTimer : 1;
    uint blockSig : 1;
    uint wasDeleted : 1;
    uint isTree : 1;

    const char *objname;
    QObject *parentObj;
    QObjectList *childObjects;
    QSignalVec *connections;
    QSenderObjectList *senderObjects;
    QObjectList *eventFilters;
    QPostEventList *postedEvents;
    QObjectPrivate* d;

    static QMetaObject* staticQtMetaObject();

    friend class QApplication;
    friend class QBaseApplication;
    friend class QWidget;
    friend class QSignal;

private:

    QObject( const QObject & );
    QObject &operator=( const QObject & );

};



class QObjectUserData {
public:
    virtual ~QObjectUserData();
};



inline bool QObject::connect( const QObject *sender, const char *signal,
                              const char *member ) const
{
    return connect( sender, signal, this, member );
}


inline bool QObject::disconnect( const char *signal,
                                 const QObject *receiver, const char *member )
{
    return disconnect( this, signal, receiver, member );
}


inline bool QObject::disconnect( const QObject *receiver, const char *member )
{
    return disconnect( this, 0, receiver, member );
}
# 257 "/coolo/prod/qt-copy/include/qobject.h"
# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 259 "/coolo/prod/qt-copy/include/qobject.h" 2
# 44 "/coolo/prod/qt-copy/include/qtranslator.h" 2





class QTranslatorPrivate;

class QTranslatorMessage
{
public:
    QTranslatorMessage();
    QTranslatorMessage( const char * context,
                        const char * sourceText,
                        const char * comment,
                        const QString& translation = QString::null );
    QTranslatorMessage( QDataStream & );
    QTranslatorMessage( const QTranslatorMessage & m );

    QTranslatorMessage & operator=( const QTranslatorMessage & m );

    uint hash() const { return h; }
    const char *context() const { return cx; }
    const char *sourceText() const { return st; }
    const char *comment() const { return cm; }

    void setTranslation( const QString & translation ) { tn = translation; }
    QString translation() const { return tn; }

    enum Prefix { NoPrefix, Hash, HashContext, HashContextSourceText,
                  HashContextSourceTextComment };
    void write( QDataStream & s, bool strip = FALSE,
                Prefix prefix = HashContextSourceTextComment ) const;
    Prefix commonPrefix( const QTranslatorMessage& ) const;

    bool operator==( const QTranslatorMessage& m ) const;
    bool operator!=( const QTranslatorMessage& m ) const
    { return !operator==( m ); }
    bool operator<( const QTranslatorMessage& m ) const;
    bool operator<=( const QTranslatorMessage& m ) const
    { return !m.operator<( *this ); }
    bool operator>( const QTranslatorMessage& m ) const
    { return m.operator<( *this ); }
    bool operator>=( const QTranslatorMessage& m ) const
    { return !operator<( m ); }

private:
    uint h;
    QCString cx;
    QCString st;
    QCString cm;
    QString tn;

    enum Tag { Tag_End = 1, Tag_SourceText16, Tag_Translation, Tag_Context16,
               Tag_Hash, Tag_SourceText, Tag_Context, Tag_Comment,
               Tag_Obsolete1 };
};


class QTranslator: public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QTranslator( QObject * parent = 0, const char * name = 0 );
    ~QTranslator();






    virtual QTranslatorMessage findMessage( const char *, const char *,
                                            const char * = 0 ) const;

    bool load( const QString & filename,
               const QString & directory = QString::null,
               const QString & search_delimiters = QString::null,
               const QString & suffix = QString::null );
    bool load( const uchar *data, int len ) {
        clear();
        return do_load( data, len );
    }

    void clear();


    enum SaveMode { Everything, Stripped };

    bool save( const QString & filename, SaveMode mode = Everything );

    void insert( const QTranslatorMessage& );
    void insert( const char *context, const char *sourceText, const QString &translation ) {
        insert( QTranslatorMessage(context, sourceText, "", translation) );
    }
    void remove( const QTranslatorMessage& );
    void remove( const char *context, const char *sourceText ) {
        remove( QTranslatorMessage(context, sourceText, "") );
    }
    bool contains( const char *, const char *, const char * comment = 0 ) const;

    void squeeze( SaveMode = Everything );
    void unsqueeze();

    QValueList<QTranslatorMessage> messages() const;


    bool isEmpty() const;

private:

    QTranslator( const QTranslator & );
    QTranslator &operator=( const QTranslator & );


    bool do_load( const uchar *data, int len );

    QTranslatorPrivate * d;
};
# 27 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qdir.h" 1
# 39 "/coolo/prod/qt-copy/include/qdir.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qdir.h" 2
# 1 "/coolo/prod/qt-copy/include/qstrlist.h" 1
# 39 "/coolo/prod/qt-copy/include/qstrlist.h"



# 1 "/coolo/prod/qt-copy/include/qptrlist.h" 1
# 37 "/coolo/prod/qt-copy/include/qptrlist.h"


# 1 "/coolo/prod/qt-copy/include/qglist.h" 1
# 39 "/coolo/prod/qt-copy/include/qglist.h"


# 1 "/coolo/prod/qt-copy/include/qptrcollection.h" 1
# 37 "/coolo/prod/qt-copy/include/qptrcollection.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 41 "/coolo/prod/qt-copy/include/qptrcollection.h" 2



class QGVector;
class QGList;
class QGDict;


class QPtrCollection
{
public:
    bool autoDelete() const { return del_item; }
    void setAutoDelete( bool enable ) { del_item = enable; }

    virtual uint count() const = 0;
    virtual void clear() = 0;

    typedef void *Item;

protected:
    QPtrCollection() { del_item = FALSE; }
    QPtrCollection(const QPtrCollection &) { del_item = FALSE; }
    virtual ~QPtrCollection() {}

    bool del_item;

    virtual Item newItem( Item );
    virtual void deleteItem( Item ) = 0;
};
# 43 "/coolo/prod/qt-copy/include/qglist.h" 2


class QLNode
{
friend class QGList;
friend class QGListIterator;
friend class QGListStdIterator;
public:
    QPtrCollection::Item getData() { return data; }
private:
    QPtrCollection::Item data;
    QLNode *prev;
    QLNode *next;
    QLNode( QPtrCollection::Item d ) { data = d; }
};

class QGListIteratorList;

class QGList : public QPtrCollection
{
friend class QGListIterator;
friend class QGListIteratorList;
friend class QGVector;
public:
    uint count() const;


    QDataStream &read( QDataStream & );
    QDataStream &write( QDataStream & ) const;

protected:
    QGList();
    QGList( const QGList & );
    virtual ~QGList();

    QGList &operator=( const QGList & );
    bool operator==( const QGList& ) const;

    void inSort( QPtrCollection::Item );
    void append( QPtrCollection::Item );
    bool insertAt( uint index, QPtrCollection::Item );
    void relinkNode( QLNode * );
    bool removeNode( QLNode * );
    bool remove( QPtrCollection::Item = 0 );
    bool removeRef( QPtrCollection::Item = 0 );
    bool removeFirst();
    bool removeLast();
    bool removeAt( uint );
    bool replaceAt( uint, QPtrCollection::Item );
    QPtrCollection::Item takeNode( QLNode * );
    QPtrCollection::Item take();
    QPtrCollection::Item takeAt( uint index );
    QPtrCollection::Item takeFirst();
    QPtrCollection::Item takeLast();

    void sort();
    void clear();

    int findRef( QPtrCollection::Item, bool = TRUE );
    int find( QPtrCollection::Item, bool = TRUE );

    uint containsRef( QPtrCollection::Item ) const;
    uint contains( QPtrCollection::Item ) const;

    QPtrCollection::Item at( uint index );
    int at() const;
    QLNode *currentNode() const;

    QPtrCollection::Item get() const;

    QPtrCollection::Item cfirst() const;
    QPtrCollection::Item clast() const;
    QPtrCollection::Item first();
    QPtrCollection::Item last();
    QPtrCollection::Item next();
    QPtrCollection::Item prev();

    void toVector( QGVector * ) const;

    virtual int compareItems( QPtrCollection::Item, QPtrCollection::Item );


    virtual QDataStream &read( QDataStream &, QPtrCollection::Item & );
    virtual QDataStream &write( QDataStream &, QPtrCollection::Item ) const;


    QLNode* begin() const { return firstNode; }
    QLNode* end() const { return 0; }
    QLNode* erase( QLNode* it );

private:
    void prepend( QPtrCollection::Item );

    void heapSortPushDown( QPtrCollection::Item* heap, int first, int last );

    QLNode *firstNode;
    QLNode *lastNode;
    QLNode *curNode;
    int curIndex;
    uint numNodes;
    QGListIteratorList *iterators;

    QLNode *locate( uint );
    QLNode *unlink();
};


inline uint QGList::count() const
{
    return numNodes;
}

inline bool QGList::removeFirst()
{
    first();
    return remove();
}

inline bool QGList::removeLast()
{
    last();
    return remove();
}

inline int QGList::at() const
{
    return curIndex;
}

inline QPtrCollection::Item QGList::at( uint index )
{
    QLNode *n = locate( index );
    return n ? n->data : 0;
}

inline QLNode *QGList::currentNode() const
{
    return curNode;
}

inline QPtrCollection::Item QGList::get() const
{
    return curNode ? curNode->data : 0;
}

inline QPtrCollection::Item QGList::cfirst() const
{
    return firstNode ? firstNode->data : 0;
}

inline QPtrCollection::Item QGList::clast() const
{
    return lastNode ? lastNode->data : 0;
}







 QDataStream &operator>>( QDataStream &, QGList & );
 QDataStream &operator<<( QDataStream &, const QGList & );






class QGListIterator
{
friend class QGList;
friend class QGListIteratorList;
protected:
    QGListIterator( const QGList & );
    QGListIterator( const QGListIterator & );
    QGListIterator &operator=( const QGListIterator & );
   ~QGListIterator();

    bool atFirst() const;
    bool atLast() const;
    QPtrCollection::Item toFirst();
    QPtrCollection::Item toLast();

    QPtrCollection::Item get() const;
    QPtrCollection::Item operator()();
    QPtrCollection::Item operator++();
    QPtrCollection::Item operator+=(uint);
    QPtrCollection::Item operator--();
    QPtrCollection::Item operator-=(uint);

protected:
    QGList *list;

private:
    QLNode *curNode;
};


inline bool QGListIterator::atFirst() const
{
    return curNode == list->firstNode;
}

inline bool QGListIterator::atLast() const
{
    return curNode == list->lastNode;
}

inline QPtrCollection::Item QGListIterator::get() const
{
    return curNode ? curNode->data : 0;
}

class QGListStdIterator
{
public:
    inline QGListStdIterator( QLNode* n ) : node( n ){}
    inline operator QLNode* () { return node; }
protected:
    inline QLNode *next() { return node->next; }
    QLNode *node;
};
# 41 "/coolo/prod/qt-copy/include/qptrlist.h" 2


template<class type>
class QPtrListStdIterator : public QGListStdIterator
{
public:
    inline QPtrListStdIterator( QLNode* n ): QGListStdIterator(n){}
    type *operator*() { return node ? (type *)node->getData() : 0; }
    inline QPtrListStdIterator<type> operator++()
    { return node = next(); return *this; }
    inline QPtrListStdIterator<type> operator++(int)
    { QLNode* n = node; node = next(); return QPtrListStdIterator<type>( n ); }
    inline bool operator==( const QPtrListStdIterator<type>& it ) const { return node == it.node; }
    inline bool operator!=( const QPtrListStdIterator<type>& it ) const { return node != it.node; }
};


template<class type>
class QPtrList



        : public QGList

{
public:

    QPtrList() {}
    QPtrList( const QPtrList<type> &l ) : QGList(l) {}
    ~QPtrList() { clear(); }
    QPtrList<type> &operator=(const QPtrList<type> &l)
                        { return (QPtrList<type>&)QGList::operator=(l); }
    bool operator==( const QPtrList<type> &list ) const
    { return QGList::operator==( list ); }
    bool operator!=( const QPtrList<type> &list ) const
    { return !QGList::operator==( list ); }
    uint count() const { return QGList::count(); }
    bool isEmpty() const { return QGList::count() == 0; }
    bool insert( uint i, const type *d){ return QGList::insertAt(i,(QPtrCollection::Item)d); }
    void inSort( const type *d ) { QGList::inSort((QPtrCollection::Item)d); }
    void prepend( const type *d ) { QGList::insertAt(0,(QPtrCollection::Item)d); }
    void append( const type *d ) { QGList::append((QPtrCollection::Item)d); }
    bool remove( uint i ) { return QGList::removeAt(i); }
    bool remove() { return QGList::remove((QPtrCollection::Item)0); }
    bool remove( const type *d ) { return QGList::remove((QPtrCollection::Item)d); }
    bool removeRef( const type *d ) { return QGList::removeRef((QPtrCollection::Item)d); }
    void removeNode( QLNode *n ) { QGList::removeNode(n); }
    bool removeFirst() { return QGList::removeFirst(); }
    bool removeLast() { return QGList::removeLast(); }
    type *take( uint i ) { return (type *)QGList::takeAt(i); }
    type *take() { return (type *)QGList::take(); }
    type *takeNode( QLNode *n ) { return (type *)QGList::takeNode(n); }
    void clear() { QGList::clear(); }
    void sort() { QGList::sort(); }
    int find( const type *d ) { return QGList::find((QPtrCollection::Item)d); }
    int findNext( const type *d ) { return QGList::find((QPtrCollection::Item)d,FALSE); }
    int findRef( const type *d ) { return QGList::findRef((QPtrCollection::Item)d); }
    int findNextRef( const type *d ){ return QGList::findRef((QPtrCollection::Item)d,FALSE);}
    uint contains( const type *d ) const { return QGList::contains((QPtrCollection::Item)d); }
    uint containsRef( const type *d ) const
                                        { return QGList::containsRef((QPtrCollection::Item)d); }
    bool replace( uint i, const type *d ) { return QGList::replaceAt( i, (QPtrCollection::Item)d ); }
    type *at( uint i ) { return (type *)QGList::at(i); }
    int at() const { return QGList::at(); }
    type *current() const { return (type *)QGList::get(); }
    QLNode *currentNode() const { return QGList::currentNode(); }
    type *getFirst() const { return (type *)QGList::cfirst(); }
    type *getLast() const { return (type *)QGList::clast(); }
    type *first() { return (type *)QGList::first(); }
    type *last() { return (type *)QGList::last(); }
    type *next() { return (type *)QGList::next(); }
    type *prev() { return (type *)QGList::prev(); }
    void toVector( QGVector *vec )const{ QGList::toVector(vec); }



    typedef QPtrListStdIterator<type> Iterator;
    typedef QPtrListStdIterator<type> ConstIterator;
    inline Iterator begin() { return QGList::begin(); }
    inline ConstIterator begin() const { return QGList::begin(); }
    inline ConstIterator constBegin() const { return QGList::begin(); }
    inline Iterator end() { return QGList::end(); }
    inline ConstIterator end() const { return QGList::end(); }
    inline ConstIterator constEnd() const { return QGList::end(); }
    inline Iterator erase( Iterator it ) { return QGList::erase( it ); }

    typedef Iterator iterator;
    typedef ConstIterator const_iterator;
# 138 "/coolo/prod/qt-copy/include/qptrlist.h"
private:
    void deleteItem( Item d );
};


template<> inline void QPtrList<void>::deleteItem( QPtrCollection::Item )
{
}


template<class type> inline void QPtrList<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}

template<class type>
class QPtrListIterator : public QGListIterator
{
public:
    QPtrListIterator(const QPtrList<type> &l) :QGListIterator((QGList &)l) {}
   ~QPtrListIterator() {}
    uint count() const { return list->count(); }
    bool isEmpty() const { return list->count() == 0; }
    bool atFirst() const { return QGListIterator::atFirst(); }
    bool atLast() const { return QGListIterator::atLast(); }
    type *toFirst() { return (type *)QGListIterator::toFirst(); }
    type *toLast() { return (type *)QGListIterator::toLast(); }
    operator type *() const { return (type *)QGListIterator::get(); }
    type *operator*() { return (type *)QGListIterator::get(); }







    type *current() const { return (type *)QGListIterator::get(); }
    type *operator()() { return (type *)QGListIterator::operator()();}
    type *operator++() { return (type *)QGListIterator::operator++(); }
    type *operator+=(uint j) { return (type *)QGListIterator::operator+=(j);}
    type *operator--() { return (type *)QGListIterator::operator--(); }
    type *operator-=(uint j) { return (type *)QGListIterator::operator-=(j);}
    QPtrListIterator<type>& operator=(const QPtrListIterator<type>&it)
                              { QGListIterator::operator=(it); return *this; }
};






# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 191 "/coolo/prod/qt-copy/include/qptrlist.h" 2
# 44 "/coolo/prod/qt-copy/include/qstrlist.h" 2
# 52 "/coolo/prod/qt-copy/include/qstrlist.h"
typedef QPtrListIterator<char> QStrListIterator;


class QStrList : public QPtrList<char>
{
public:
    QStrList( bool deepCopies=TRUE ) { dc = deepCopies; del_item = deepCopies; }
    QStrList( const QStrList & );
    ~QStrList() { clear(); }
    QStrList& operator=( const QStrList & );

private:
    QPtrCollection::Item newItem( QPtrCollection::Item d ) { return dc ? qstrdup( (const char*)d ) : d; }
    void deleteItem( QPtrCollection::Item d ) { if ( del_item ) delete[] (char*)d; }
    int compareItems( QPtrCollection::Item s1, QPtrCollection::Item s2 ) { return qstrcmp((const char*)s1,
                                                         (const char*)s2); }

    QDataStream &read( QDataStream &s, QPtrCollection::Item &d )
                                { s >> (char *&)d; return s; }
    QDataStream &write( QDataStream &s, QPtrCollection::Item d ) const
                                { return s << (const char *)d; }

    bool dc;
};


class QStrIList : public QStrList
{
public:
    QStrIList( bool deepCopies=TRUE ) : QStrList( deepCopies ) {}
    ~QStrIList() { clear(); }
private:
    int compareItems( QPtrCollection::Item s1, QPtrCollection::Item s2 )
                                { return qstricmp((const char*)s1,
                                                    (const char*)s2); }
};


inline QStrList & QStrList::operator=( const QStrList &strList )
{
    clear();
    dc = strList.dc;
    del_item = dc;
    QPtrList<char>::operator=( strList );
    return *this;
}

inline QStrList::QStrList( const QStrList &strList )
    : QPtrList<char>( strList )
{
    dc = FALSE;
    operator=( strList );
}
# 44 "/coolo/prod/qt-copy/include/qdir.h" 2
# 1 "/coolo/prod/qt-copy/include/qfileinfo.h" 1
# 39 "/coolo/prod/qt-copy/include/qfileinfo.h"


# 1 "/coolo/prod/qt-copy/include/qfile.h" 1
# 39 "/coolo/prod/qt-copy/include/qfile.h"







class QDir;
class QFilePrivate;

class QFile : public QIODevice
{
public:
    QFile();
    QFile( const QString &name );
   ~QFile();

    QString name() const;
    void setName( const QString &name );

    typedef QCString (*EncoderFn)( const QString &fileName );
    typedef QString (*DecoderFn)( const QCString &localfileName );
    static QCString encodeName( const QString &fileName );
    static QString decodeName( const QCString &localFileName );
    static void setEncodingFunction( EncoderFn );
    static void setDecodingFunction( DecoderFn );

    bool exists() const;
    static bool exists( const QString &fileName );

    bool remove();
    static bool remove( const QString &fileName );

    bool open( int );
    bool open( int, FILE * );
    bool open( int, int );
    void close();
    void flush();

    Offset size() const;
    Offset at() const;
    bool at( Offset );
    bool atEnd() const;

    Q_LONG readBlock( char *data, Q_ULONG len );
    Q_LONG writeBlock( const char *data, Q_ULONG len );
    Q_LONG writeBlock( const QByteArray& data )
                      { return QIODevice::writeBlock(data); }
    Q_LONG readLine( char *data, Q_ULONG maxlen );
    Q_LONG readLine( QString &, Q_ULONG maxlen );

    int getch();
    int putch( int );
    int ungetch( int );

    int handle() const;

    QString errorString() const;

protected:
    void setErrorString( const QString& );
    QString fn;
    FILE *fh;
    int fd;
    Offset length;
    bool ext_f;
    QFilePrivate *d;

private:
    void init();
    void setErrorStringErrno( int );
    QCString ungetchBuffer;

private:

    QFile( const QFile & );
    QFile &operator=( const QFile & );

};


inline QString QFile::name() const
{ return fn; }

inline QIODevice::Offset QFile::at() const
{ return ioIndex; }
# 43 "/coolo/prod/qt-copy/include/qfileinfo.h" 2
# 1 "/coolo/prod/qt-copy/include/qdatetime.h" 1
# 39 "/coolo/prod/qt-copy/include/qdatetime.h"
# 51 "/coolo/prod/qt-copy/include/qdatetime.h"
class QDate
{
public:
    QDate() { jd = 0; }
    QDate( int y, int m, int d );

    bool isNull() const { return jd == 0; }
    bool isValid() const;

    int year() const;
    int month() const;
    int day() const;
    int dayOfWeek() const;
    int dayOfYear() const;
    int daysInMonth() const;
    int daysInYear() const;
    int weekNumber( int *yearNum = 0 ) const;






    static QString shortMonthName( int month );
    static QString shortDayName( int weekday );
    static QString longMonthName( int month );
    static QString longDayName( int weekday );



    QString toString( Qt::DateFormat f = Qt::TextDate ) const;

    QString toString( const QString& format ) const;

    bool setYMD( int y, int m, int d );

    QDate addDays( int days ) const;
    QDate addMonths( int months ) const;
    QDate addYears( int years ) const;
    int daysTo( const QDate & ) const;

    bool operator==( const QDate &d ) const { return jd == d.jd; }
    bool operator!=( const QDate &d ) const { return jd != d.jd; }
    bool operator<( const QDate &d ) const { return jd < d.jd; }
    bool operator<=( const QDate &d ) const { return jd <= d.jd; }
    bool operator>( const QDate &d ) const { return jd > d.jd; }
    bool operator>=( const QDate &d ) const { return jd >= d.jd; }

    static QDate currentDate();
    static QDate currentDate( Qt::TimeSpec );

    static QDate fromString( const QString& s, Qt::DateFormat f = Qt::TextDate );

    static bool isValid( int y, int m, int d );
    static bool leapYear( int year );

    static uint gregorianToJulian( int y, int m, int d );
    static void julianToGregorian( uint jd, int &y, int &m, int &d );
private:
    uint jd;
    friend class QDateTime;

    friend QDataStream &operator<<( QDataStream &, const QDate & );
    friend QDataStream &operator>>( QDataStream &, QDate & );

};






class QTime
{
public:
    QTime() { ds=0; }
    QTime( int h, int m, int s=0, int ms=0 );

    bool isNull() const { return ds == 0; }
    bool isValid() const;

    int hour() const;
    int minute() const;
    int second() const;
    int msec() const;


    QString toString( Qt::DateFormat f = Qt::TextDate ) const;

    QString toString( const QString& format ) const;

    bool setHMS( int h, int m, int s, int ms=0 );

    QTime addSecs( int secs ) const;
    int secsTo( const QTime & ) const;
    QTime addMSecs( int ms ) const;
    int msecsTo( const QTime & ) const;

    bool operator==( const QTime &d ) const { return ds == d.ds; }
    bool operator!=( const QTime &d ) const { return ds != d.ds; }
    bool operator<( const QTime &d ) const { return ds < d.ds; }
    bool operator<=( const QTime &d ) const { return ds <= d.ds; }
    bool operator>( const QTime &d ) const { return ds > d.ds; }
    bool operator>=( const QTime &d ) const { return ds >= d.ds; }

    static QTime currentTime();
    static QTime currentTime( Qt::TimeSpec );

    static QTime fromString( const QString& s, Qt::DateFormat f = Qt::TextDate );

    static bool isValid( int h, int m, int s, int ms=0 );

    void start();
    int restart();
    int elapsed() const;

private:
    static bool currentTime( QTime * );
    static bool currentTime( QTime *, Qt::TimeSpec );

    uint ds;
    friend class QDateTime;

    friend QDataStream &operator<<( QDataStream &, const QTime & );
    friend QDataStream &operator>>( QDataStream &, QTime & );

};






class QDateTime
{
public:
    QDateTime() {}
    QDateTime( const QDate & );
    QDateTime( const QDate &, const QTime & );

    bool isNull() const { return d.isNull() && t.isNull(); }
    bool isValid() const { return d.isValid() && t.isValid(); }

    QDate date() const { return d; }
    QTime time() const { return t; }
    uint toTime_t() const;
    void setDate( const QDate &date ) { d = date; }
    void setTime( const QTime &time ) { t = time; }
    void setTime_t( uint secsSince1Jan1970UTC );
    void setTime_t( uint secsSince1Jan1970UTC, Qt::TimeSpec );


    QString toString( Qt::DateFormat f = Qt::TextDate ) const;

    QString toString( const QString& format ) const;

    QDateTime addDays( int days ) const;
    QDateTime addMonths( int months ) const;
    QDateTime addYears( int years ) const;
    QDateTime addSecs( int secs ) const;
    int daysTo( const QDateTime & ) const;
    int secsTo( const QDateTime & ) const;

    bool operator==( const QDateTime &dt ) const;
    bool operator!=( const QDateTime &dt ) const;
    bool operator<( const QDateTime &dt ) const;
    bool operator<=( const QDateTime &dt ) const;
    bool operator>( const QDateTime &dt ) const;
    bool operator>=( const QDateTime &dt ) const;

    static QDateTime currentDateTime();
    static QDateTime currentDateTime( Qt::TimeSpec );

    static QDateTime fromString( const QString& s, Qt::DateFormat f = Qt::TextDate );

private:
    QDate d;
    QTime t;

    friend QDataStream &operator<<( QDataStream &, const QDateTime &);
    friend QDataStream &operator>>( QDataStream &, QDateTime & );

};







 QDataStream &operator<<( QDataStream &, const QDate & );
 QDataStream &operator>>( QDataStream &, QDate & );
 QDataStream &operator<<( QDataStream &, const QTime & );
 QDataStream &operator>>( QDataStream &, QTime & );
 QDataStream &operator<<( QDataStream &, const QDateTime & );
 QDataStream &operator>>( QDataStream &, QDateTime & );
# 44 "/coolo/prod/qt-copy/include/qfileinfo.h" 2



class QDir;
struct QFileInfoCache;
template <class T> class QDeepCopy;


class QFileInfo
{
public:
    enum PermissionSpec {
        ReadOwner = 04000, WriteOwner = 02000, ExeOwner = 01000,
        ReadUser = 00400, WriteUser = 00200, ExeUser = 00100,
        ReadGroup = 00040, WriteGroup = 00020, ExeGroup = 00010,
        ReadOther = 00004, WriteOther = 00002, ExeOther = 00001 };

    QFileInfo();
    QFileInfo( const QString &file );
    QFileInfo( const QFile & );

    QFileInfo( const QDir &, const QString &fileName );

    QFileInfo( const QFileInfo & );
   ~QFileInfo();

    QFileInfo &operator=( const QFileInfo & );

    void setFile( const QString &file );
    void setFile( const QFile & );

    void setFile( const QDir &, const QString &fileName );

    bool exists() const;
    void refresh() const;
    bool caching() const;
    void setCaching( bool );

    QString filePath() const;
    QString fileName() const;

    QString absFilePath() const;

    QString baseName( bool complete = FALSE ) const;
    QString extension( bool complete = TRUE ) const;


    QString dirPath( bool absPath = FALSE ) const;


    QDir dir( bool absPath = FALSE ) const;

    bool isReadable() const;
    bool isWritable() const;
    bool isExecutable() const;
    bool isHidden() const;


    bool isRelative() const;
    bool convertToAbs();


    bool isFile() const;
    bool isDir() const;
    bool isSymLink() const;

    QString readLink() const;

    QString owner() const;
    uint ownerId() const;
    QString group() const;
    uint groupId() const;

    bool permission( int permissionSpec ) const;






    uint size() const;


    QDateTime created() const;
    QDateTime lastModified() const;
    QDateTime lastRead() const;

private:
    void doStat() const;
    static void slashify( QString & );
    static void makeAbs( QString & );

    QString fn;
    QFileInfoCache *fic;
    bool cache;

    bool symLink;


    void detach();
    friend class QDeepCopy< QFileInfo >;
};


inline bool QFileInfo::caching() const
{
    return cache;
}
# 45 "/coolo/prod/qt-copy/include/qdir.h" 2




typedef QPtrList<QFileInfo> QFileInfoList;
typedef QPtrListIterator<QFileInfo> QFileInfoListIterator;
class QStringList;
template <class T> class QDeepCopy;


class QDir
{
public:
    enum FilterSpec { Dirs = 0x001,
                      Files = 0x002,
                      Drives = 0x004,
                      NoSymLinks = 0x008,
                      All = 0x007,
                      TypeMask = 0x00F,

                      Readable = 0x010,
                      Writable = 0x020,
                      Executable = 0x040,
                      RWEMask = 0x070,

                      Modified = 0x080,
                      Hidden = 0x100,
                      System = 0x200,
                      AccessMask = 0x3F0,

                      DefaultFilter = -1 };

    enum SortSpec { Name = 0x00,
                      Time = 0x01,
                      Size = 0x02,
                      Unsorted = 0x03,
                      SortByMask = 0x03,

                      DirsFirst = 0x04,
                      Reversed = 0x08,
                      IgnoreCase = 0x10,
                      DefaultSort = -1 };

    QDir();
    QDir( const QString &path, const QString &nameFilter = QString::null,
          int sortSpec = Name | IgnoreCase, int filterSpec = All );
    QDir( const QDir & );

    virtual ~QDir();

    QDir &operator=( const QDir & );
    QDir &operator=( const QString &path );

    virtual void setPath( const QString &path );
    virtual QString path() const;
    virtual QString absPath() const;
    virtual QString canonicalPath() const;

    virtual QString dirName() const;
    virtual QString filePath( const QString &fileName,
                              bool acceptAbsPath = TRUE ) const;
    virtual QString absFilePath( const QString &fileName,
                                 bool acceptAbsPath = TRUE ) const;

    static QString convertSeparators( const QString &pathName );

    virtual bool cd( const QString &dirName, bool acceptAbsPath = TRUE );
    virtual bool cdUp();

    QString nameFilter() const;
    virtual void setNameFilter( const QString &nameFilter );
    FilterSpec filter() const;
    virtual void setFilter( int filterSpec );
    SortSpec sorting() const;
    virtual void setSorting( int sortSpec );

    bool matchAllDirs() const;
    virtual void setMatchAllDirs( bool );

    uint count() const;
    QString operator[]( int ) const;

    virtual QStrList encodedEntryList( int filterSpec = DefaultFilter,
                                       int sortSpec = DefaultSort ) const;
    virtual QStrList encodedEntryList( const QString &nameFilter,
                                       int filterSpec = DefaultFilter,
                                       int sortSpec = DefaultSort ) const;
    virtual QStringList entryList( int filterSpec = DefaultFilter,
                                   int sortSpec = DefaultSort ) const;
    virtual QStringList entryList( const QString &nameFilter,
                                   int filterSpec = DefaultFilter,
                                   int sortSpec = DefaultSort ) const;

    virtual const QFileInfoList *entryInfoList( int filterSpec = DefaultFilter,
                                                int sortSpec = DefaultSort ) const;
    virtual const QFileInfoList *entryInfoList( const QString &nameFilter,
                                                int filterSpec = DefaultFilter,
                                                int sortSpec = DefaultSort ) const;

    static const QFileInfoList *drives();

    virtual bool mkdir( const QString &dirName,
                        bool acceptAbsPath = TRUE ) const;
    virtual bool rmdir( const QString &dirName,
                        bool acceptAbsPath = TRUE ) const;

    virtual bool isReadable() const;
    virtual bool exists() const;
    virtual bool isRoot() const;

    virtual bool isRelative() const;
    virtual void convertToAbs();

    virtual bool operator==( const QDir & ) const;
    virtual bool operator!=( const QDir & ) const;

    virtual bool remove( const QString &fileName,
                         bool acceptAbsPath = TRUE );
    virtual bool rename( const QString &name, const QString &newName,
                         bool acceptAbsPaths = TRUE );
    virtual bool exists( const QString &name,
                         bool acceptAbsPath = TRUE );

    static char separator();

    static bool setCurrent( const QString &path );
    static QDir current();
    static QDir home();
    static QDir root();
    static QString currentDirPath();
    static QString homeDirPath();
    static QString rootDirPath();

    static bool match( const QStringList &filters, const QString &fileName );
    static bool match( const QString &filter, const QString &fileName );
    static QString cleanDirPath( const QString &dirPath );
    static bool isRelativePath( const QString &path );
    void refresh() const;

private:




    void init();
    virtual bool readDirEntries( const QString &nameFilter,
                                 int FilterSpec, int SortSpec );

    static void slashify( QString & );

    QString dPath;
    QStringList *fList;
    QFileInfoList *fiList;
    QString nameFilt;
    FilterSpec filtS;
    SortSpec sortS;
    uint dirty : 1;
    uint allDirs : 1;

    void detach();
    friend class QDeepCopy< QDir >;
};


inline QString QDir::path() const
{
    return dPath;
}

inline QString QDir::nameFilter() const
{
    return nameFilt;
}

inline QDir::FilterSpec QDir::filter() const
{
    return filtS;
}

inline QDir::SortSpec QDir::sorting() const
{
    return sortS;
}

inline bool QDir::matchAllDirs() const
{
    return allDirs;
}

inline bool QDir::operator!=( const QDir &d ) const
{
    return !(*this == d);
}


struct QDirSortItem {
    QString filename_cache;
    QFileInfo* item;
};
# 29 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qwidgetlist.h" 1
# 39 "/coolo/prod/qt-copy/include/qwidgetlist.h"


# 1 "/coolo/prod/qt-copy/include/qwidget.h" 1
# 39 "/coolo/prod/qt-copy/include/qwidget.h"




# 1 "/coolo/prod/qt-copy/include/qpaintdevice.h" 1
# 39 "/coolo/prod/qt-copy/include/qpaintdevice.h"
# 51 "/coolo/prod/qt-copy/include/qpaintdevice.h"
class QIODevice;
class QString;
class QTextItem;



struct QPaintDeviceX11Data;


union QPDevCmdParam {
    int ival;
    int *ivec;
    QString *str;
    const QPoint *point;
    const QRect *rect;
    const QPointArray *ptarr;
    const QPixmap *pixmap;
    const QImage *image;
    const QColor *color;
    const QFont *font;
    const QPen *pen;
    const QBrush *brush;
    const QRegion *rgn;
    const QWMatrix *matrix;
    const QTextItem *textItem;
    QIODevice *device;
};



class QPaintDevice
{
public:
    virtual ~QPaintDevice();

    int devType() const;
    bool isExtDev() const;
    bool paintingActive() const;

    virtual void setResolution( int );
    virtual int resolution() const;






    virtual Qt::HANDLE handle() const;
    virtual Qt::HANDLE x11RenderHandle() const;







    Display *x11Display() const;
    int x11Screen() const;
    int x11Depth() const;
    int x11Cells() const;
    Qt::HANDLE x11Colormap() const;
    bool x11DefaultColormap() const;
    void *x11Visual() const;
    bool x11DefaultVisual() const;

    static Display *x11AppDisplay();
    static int x11AppScreen();

    static int x11AppDpiX();
    static int x11AppDpiY();
    static void x11SetAppDpiX(int);
    static void x11SetAppDpiY(int);
    static int x11AppDepth();
    static int x11AppCells();
    static Qt::HANDLE x11AppRootWindow();
    static Qt::HANDLE x11AppColormap();
    static bool x11AppDefaultColormap();
    static void *x11AppVisual();
    static bool x11AppDefaultVisual();



    static int x11AppDepth( int screen );
    static int x11AppCells( int screen );
    static Qt::HANDLE x11AppRootWindow( int screen );
    static Qt::HANDLE x11AppColormap( int screen );
    static void *x11AppVisual( int screen );
    static bool x11AppDefaultColormap( int screen );
    static bool x11AppDefaultVisual( int screen );
    static int x11AppDpiX( int );
    static int x11AppDpiY( int );
    static void x11SetAppDpiX( int, int );
    static void x11SetAppDpiY( int, int );
# 153 "/coolo/prod/qt-copy/include/qpaintdevice.h"
    enum PDevCmd {
        PdcNOP = 0,
        PdcDrawPoint = 1,
        PdcDrawFirst = PdcDrawPoint,
        PdcMoveTo = 2,
        PdcLineTo = 3,
        PdcDrawLine = 4,
        PdcDrawRect = 5,
        PdcDrawRoundRect = 6,
        PdcDrawEllipse = 7,
        PdcDrawArc = 8,
        PdcDrawPie = 9,
        PdcDrawChord = 10,
        PdcDrawLineSegments = 11,
        PdcDrawPolyline = 12,
        PdcDrawPolygon = 13,
        PdcDrawCubicBezier = 14,
        PdcDrawText = 15,
        PdcDrawTextFormatted = 16,
        PdcDrawPixmap = 17,
        PdcDrawImage = 18,
        PdcDrawText2 = 19,
        PdcDrawText2Formatted = 20,
        PdcDrawTextItem = 21,
        PdcDrawLast = PdcDrawTextItem,



        PdcBegin = 30,
        PdcEnd = 31,
        PdcSave = 32,
        PdcRestore = 33,
        PdcSetdev = 34,
        PdcSetBkColor = 40,
        PdcSetBkMode = 41,
        PdcSetROP = 42,
        PdcSetBrushOrigin = 43,
        PdcSetFont = 45,
        PdcSetPen = 46,
        PdcSetBrush = 47,
        PdcSetTabStops = 48,
        PdcSetTabArray = 49,
        PdcSetUnit = 50,
        PdcSetVXform = 51,
        PdcSetWindow = 52,
        PdcSetViewport = 53,
        PdcSetWXform = 54,
        PdcSetWMatrix = 55,
        PdcSaveWMatrix = 56,
        PdcRestoreWMatrix = 57,
        PdcSetClip = 60,
        PdcSetClipRegion = 61,

        PdcReservedStart = 0,
        PdcReservedStop = 199
    };

protected:
    QPaintDevice( uint devflags );




    Qt::HANDLE hd;
    Qt::HANDLE rendhd;

    void copyX11Data( const QPaintDevice * );
    void cloneX11Data( const QPaintDevice * );
    virtual void setX11Data( const QPaintDeviceX11Data* );
    QPaintDeviceX11Data* getX11Data( bool def=FALSE ) const;
# 232 "/coolo/prod/qt-copy/include/qpaintdevice.h"
    virtual bool cmd( int, QPainter *, QPDevCmdParam * );
    virtual int metric( int ) const;
    virtual int fontMet( QFont *, int, const char * = 0, int = 0 ) const;
    virtual int fontInf( QFont *, int ) const;

    ushort devFlags;
    ushort painters;

    friend class QPainter;
    friend class QPaintDeviceMetrics;







    friend void bitBlt( QPaintDevice *, int, int,
                                 const QPaintDevice *,
                                 int, int, int, int, Qt::RasterOp, bool );


    friend void qt_init_internal( int *, char **, Display *, Qt::HANDLE, Qt::HANDLE );
    friend void qt_cleanup();


private:

    static Display *x_appdisplay;
    static int x_appscreen;

    static int x_appdepth;
    static int x_appcells;
    static Qt::HANDLE x_approotwindow;
    static Qt::HANDLE x_appcolormap;
    static bool x_appdefcolormap;
    static void *x_appvisual;
    static bool x_appdefvisual;


    static int *x_appdepth_arr;
    static int *x_appcells_arr;
    static Qt::HANDLE *x_approotwindow_arr;
    static Qt::HANDLE *x_appcolormap_arr;
    static bool *x_appdefcolormap_arr;
    static void **x_appvisual_arr;
    static bool *x_appdefvisual_arr;

    QPaintDeviceX11Data* x11Data;


private:

    QPaintDevice( const QPaintDevice & );
    QPaintDevice &operator=( const QPaintDevice & );

};



void bitBlt( QPaintDevice *dst, int dx, int dy,
             const QPaintDevice *src, int sx=0, int sy=0, int sw=-1, int sh=-1,
             Qt::RasterOp = Qt::CopyROP, bool ignoreMask=FALSE );


void bitBlt( QPaintDevice *dst, int dx, int dy,
             const QImage *src, int sx=0, int sy=0, int sw=-1, int sh=-1,
             int conversion_flags=0 );




struct QPaintDeviceX11Data : public QShared {
    Display* x_display;
    int x_screen;
    int x_depth;
    int x_cells;
    Qt::HANDLE x_colormap;
    bool x_defcolormap;
    void* x_visual;
    bool x_defvisual;
};







inline int QPaintDevice::devType() const
{ return devFlags & QInternal::DeviceTypeMask; }

inline bool QPaintDevice::isExtDev() const
{ return (devFlags & QInternal::ExternalDevice) != 0; }

inline bool QPaintDevice::paintingActive() const
{ return painters != 0; }


inline Display *QPaintDevice::x11Display() const
{ return x11Data ? x11Data->x_display : x_appdisplay; }

inline int QPaintDevice::x11Screen() const
{ return x11Data ? x11Data->x_screen : x_appscreen; }

inline int QPaintDevice::x11Depth() const
{ return x11Data ? x11Data->x_depth : x_appdepth; }

inline int QPaintDevice::x11Cells() const
{ return x11Data ? x11Data->x_cells : x_appcells; }

inline Qt::HANDLE QPaintDevice::x11Colormap() const
{ return x11Data ? x11Data->x_colormap : x_appcolormap; }

inline bool QPaintDevice::x11DefaultColormap() const
{ return x11Data ? x11Data->x_defcolormap : x_appdefcolormap; }

inline void *QPaintDevice::x11Visual() const
{ return x11Data ? x11Data->x_visual : x_appvisual; }

inline bool QPaintDevice::x11DefaultVisual() const
{ return x11Data ? x11Data->x_defvisual : x_appdefvisual; }

inline Display *QPaintDevice::x11AppDisplay()
{ return x_appdisplay; }

inline int QPaintDevice::x11AppScreen()
{ return x_appscreen; }

inline int QPaintDevice::x11AppDepth( int screen )
{ return x_appdepth_arr[ screen == -1 ? x_appscreen : screen ]; }

inline int QPaintDevice::x11AppCells( int screen )
{ return x_appcells_arr[ screen == -1 ? x_appscreen : screen ]; }

inline Qt::HANDLE QPaintDevice::x11AppRootWindow( int screen )
{ return x_approotwindow_arr[ screen == -1 ? x_appscreen : screen ]; }

inline Qt::HANDLE QPaintDevice::x11AppColormap( int screen )
{ return x_appcolormap_arr[ screen == -1 ? x_appscreen : screen ]; }

inline bool QPaintDevice::x11AppDefaultColormap( int screen )
{ return x_appdefcolormap_arr[ screen == -1 ? x_appscreen : screen ]; }

inline void *QPaintDevice::x11AppVisual( int screen )
{ return x_appvisual_arr[ screen == -1 ? x_appscreen : screen ]; }

inline bool QPaintDevice::x11AppDefaultVisual( int screen )
{ return x_appdefvisual_arr[ screen == -1 ? x_appscreen : screen ]; }

inline int QPaintDevice::x11AppDepth()
{ return x_appdepth; }

inline int QPaintDevice::x11AppCells()
{ return x_appcells; }

inline Qt::HANDLE QPaintDevice::x11AppRootWindow()
{ return x_approotwindow; }

inline Qt::HANDLE QPaintDevice::x11AppColormap()
{ return x_appcolormap; }

inline bool QPaintDevice::x11AppDefaultColormap()
{ return x_appdefcolormap; }

inline void *QPaintDevice::x11AppVisual()
{ return x_appvisual; }

inline bool QPaintDevice::x11AppDefaultVisual()
{ return x_appdefvisual; }





inline void bitBlt( QPaintDevice *dst, const QPoint &dp,
                    const QPaintDevice *src, const QRect &sr =QRect(0,0,-1,-1),
                    Qt::RasterOp rop=Qt::CopyROP, bool ignoreMask=FALSE )
{
    bitBlt( dst, dp.x(), dp.y(), src, sr.x(), sr.y(), sr.width(), sr.height(),
            rop, ignoreMask );
}
# 45 "/coolo/prod/qt-copy/include/qwidget.h" 2
# 1 "/coolo/prod/qt-copy/include/qpalette.h" 1
# 39 "/coolo/prod/qt-copy/include/qpalette.h"



# 1 "/coolo/prod/qt-copy/include/qcolor.h" 1
# 39 "/coolo/prod/qt-copy/include/qcolor.h"



# 1 "/coolo/prod/qt-copy/include/qstringlist.h" 1
# 39 "/coolo/prod/qt-copy/include/qstringlist.h"
# 49 "/coolo/prod/qt-copy/include/qstringlist.h"
class QRegExp;
template <class T> class QDeepCopy;







class QStringList : public QValueList<QString>
{
public:
    QStringList() { }
    QStringList( const QStringList& l ) : QValueList<QString>(l) { }
    QStringList( const QValueList<QString>& l ) : QValueList<QString>(l) { }
    QStringList( const QString& i ) { append(i); }

    QStringList( const char* i ) { append(i); }


    static QStringList fromStrList(const QStrList&);

    void sort();

    static QStringList split( const QString &sep, const QString &str, bool allowEmptyEntries = FALSE );
    static QStringList split( const QChar &sep, const QString &str, bool allowEmptyEntries = FALSE );

    static QStringList split( const QRegExp &sep, const QString &str, bool allowEmptyEntries = FALSE );

    QString join( const QString &sep ) const;

    QStringList grep( const QString &str, bool cs = TRUE ) const;

    QStringList grep( const QRegExp &expr ) const;


    QStringList& gres( const QString &before, const QString &after,
                       bool cs = TRUE );

    QStringList& gres( const QRegExp &expr, const QString &after );


protected:
    void detach() { QValueList<QString>::detach(); }
    friend class QDeepCopy< QStringList >;
};


class QDataStream;
extern QDataStream &operator>>( QDataStream &, QStringList& );
extern QDataStream &operator<<( QDataStream &, const QStringList& );
# 44 "/coolo/prod/qt-copy/include/qcolor.h" 2


const QRgb RGB_MASK = 0x00ffffff;

 inline int qRed( QRgb rgb )
{ return (int)((rgb >> 16) & 0xff); }

 inline int qGreen( QRgb rgb )
{ return (int)((rgb >> 8) & 0xff); }

 inline int qBlue( QRgb rgb )
{ return (int)(rgb & 0xff); }

 inline int qAlpha( QRgb rgb )
{ return (int)((rgb >> 24) & 0xff); }

 inline QRgb qRgb( int r, int g, int b )
{ return (0xff << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

 inline QRgb qRgba( int r, int g, int b, int a )
{ return ((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

 inline int qGray( int r, int g, int b )
{ return (r*11+g*16+b*5)/32; }

 inline int qGray( QRgb rgb )
{ return qGray( qRed(rgb), qGreen(rgb), qBlue(rgb) ); }


class QColor
{
public:
    enum Spec { Rgb, Hsv };

    QColor();
    QColor( int r, int g, int b );
    QColor( int x, int y, int z, Spec );
    QColor( QRgb rgb, uint pixel=0xffffffff);
    QColor( const QString& name );
    QColor( const char *name );
    QColor( const QColor & );
    QColor &operator=( const QColor & );

    bool isValid() const;
    bool isDirty() const;
    QString name() const;
    void setNamedColor( const QString& name );

    QRgb rgb() const;
    void setRgb( int r, int g, int b );
    void setRgb( QRgb rgb );
    void getRgb( int *r, int *g, int *b ) const { rgb( r, g, b ); }
    void rgb( int *r, int *g, int *b ) const;

    int red() const;
    int green() const;
    int blue() const;

    void setHsv( int h, int s, int v );
    void getHsv( int *h, int *s, int *v ) const { hsv( h, s, v ); }
    void hsv( int *h, int *s, int *v ) const;
    void getHsv( int &h, int &s, int &v ) const { hsv( &h, &s, &v ); }

    QColor light( int f = 150 ) const;
    QColor dark( int f = 200 ) const;

    bool operator==( const QColor &c ) const;
    bool operator!=( const QColor &c ) const;

    uint alloc();
    uint pixel() const;



    uint alloc( int screen );
    uint pixel( int screen ) const;


    static int maxColors();
    static int numBitPlanes();

    static int enterAllocContext();
    static void leaveAllocContext();
    static int currentAllocContext();
    static void destroyAllocContext( int );
# 138 "/coolo/prod/qt-copy/include/qcolor.h"
    static void initialize();
    static void cleanup();

    static QStringList colorNames();

    enum { Dirt = 0x44495254, Invalid = 0x49000000 };

private:
    void setSystemNamedColor( const QString& name );
    void setPixel( uint pixel );
    static void initGlobalColors();
    static uint argbToPix32(QRgb);
    static QColor* globalColors();
    static bool color_init;
    static bool globals_init;



    static enum ColorModel { d8, d32 } colormodel;
    union {
        QRgb argb;
        struct D8 {
            QRgb argb;
            uchar pix;
            uchar invalid;
            uchar dirty;
            uchar direct;
        } d8;
        struct D32 {
            QRgb argb;
            uint pix;
            bool invalid() const { return argb == QColor::Invalid && pix == QColor::Dirt; }
            bool probablyDirty() const { return pix == QColor::Dirt; }
        } d32;
    } d;
};


inline QColor::QColor()
{ d.d32.argb = Invalid; d.d32.pix = Dirt; }

inline QColor::QColor( int r, int g, int b )
{ setRgb( r, g, b ); }

inline QRgb QColor::rgb() const
{ return d.argb; }

inline int QColor::red() const
{ return qRed(d.argb); }

inline int QColor::green() const
{ return qGreen(d.argb); }

inline int QColor::blue() const
{ return qBlue(d.argb); }

inline bool QColor::isValid() const
{
    if ( colormodel == d8 )
        return !d.d8.invalid;
    else
        return !d.d32.invalid();
}

inline bool QColor::operator==( const QColor &c ) const
{
    return d.argb == c.d.argb && isValid() == c.isValid();
}

inline bool QColor::operator!=( const QColor &c ) const
{
    return !operator==(c);
}







 QDataStream &operator<<( QDataStream &, const QColor & );
 QDataStream &operator>>( QDataStream &, QColor & );
# 44 "/coolo/prod/qt-copy/include/qpalette.h" 2

# 1 "/coolo/prod/qt-copy/include/qbrush.h" 1
# 39 "/coolo/prod/qt-copy/include/qbrush.h"







class QBrush: public Qt
{
friend class QPainter;
public:
    QBrush();
    QBrush( BrushStyle );
    QBrush( const QColor &, BrushStyle=SolidPattern );
    QBrush( const QColor &, const QPixmap & );
    QBrush( const QBrush & );
   ~QBrush();
    QBrush &operator=( const QBrush & );

    BrushStyle style() const { return data->style; }
    void setStyle( BrushStyle );
    const QColor &color()const { return data->color; }
    void setColor( const QColor & );
    QPixmap *pixmap() const { return data->pixmap; }
    void setPixmap( const QPixmap & );

    bool operator==( const QBrush &p ) const;
    bool operator!=( const QBrush &b ) const
                                        { return !(operator==(b)); }

private:
    QBrush copy() const;
    void detach();
    void init( const QColor &, BrushStyle );
    struct QBrushData : public QShared {
        BrushStyle style;
        QColor color;
        QPixmap *pixmap;
    } *data;
};







 QDataStream &operator<<( QDataStream &, const QBrush & );
 QDataStream &operator>>( QDataStream &, QBrush & );
# 46 "/coolo/prod/qt-copy/include/qpalette.h" 2




class QColorGroupPrivate;

class QColorGroup
{
public:
    QColorGroup();
    QColorGroup( const QColor &foreground, const QColor &button,
                 const QColor &light, const QColor &dark, const QColor &mid,
                 const QColor &text, const QColor &base );
    QColorGroup( const QBrush &foreground, const QBrush &button,
                 const QBrush &light, const QBrush &dark, const QBrush &mid,
                 const QBrush &text, const QBrush &bright_text,
                 const QBrush &base, const QBrush &background);
    QColorGroup( const QColorGroup & );

   ~QColorGroup();

    QColorGroup& operator =(const QColorGroup&);


    enum ColorRole { Foreground, Button, Light, Midlight, Dark, Mid,
                     Text, BrightText, ButtonText, Base, Background, Shadow,
                     Highlight, HighlightedText, Link, LinkVisited,
                     NColorRoles };

    const QColor &color( ColorRole ) const;
    const QBrush &brush( ColorRole ) const;
    void setColor( ColorRole, const QColor & );
    void setBrush( ColorRole, const QBrush & );

    const QColor &foreground() const { return br[Foreground].color(); }
    const QColor &button() const { return br[Button].color(); }
    const QColor &light() const { return br[Light].color(); }
    const QColor &dark() const { return br[Dark].color(); }
    const QColor &mid() const { return br[Mid].color(); }
    const QColor &text() const { return br[Text].color(); }
    const QColor &base() const { return br[Base].color(); }
    const QColor &background() const { return br[Background].color(); }

    const QColor &midlight() const { return br[Midlight].color(); }
    const QColor &brightText() const { return br[BrightText].color(); }
    const QColor &buttonText() const { return br[ButtonText].color(); }
    const QColor &shadow() const { return br[Shadow].color(); }
    const QColor &highlight() const { return br[Highlight].color(); }
    const QColor &highlightedText() const{return br[HighlightedText].color(); }
    const QColor &link() const { return br[Link].color(); }
    const QColor &linkVisited() const { return br[LinkVisited].color(); }

    bool operator==( const QColorGroup &g ) const;
    bool operator!=( const QColorGroup &g ) const
        { return !(operator==(g)); }

private:
    QBrush *br;
    QColorGroupPrivate * d;

    friend class QPalette;
};


class QPalette
{
public:
    QPalette();
    QPalette( const QColor &button );
    QPalette( const QColor &button, const QColor &background );
    QPalette( const QColorGroup &active, const QColorGroup &disabled,
              const QColorGroup &inactive );
    QPalette( const QPalette & );
    ~QPalette();
    QPalette &operator=( const QPalette & );

    enum ColorGroup { Disabled, Active, Inactive, NColorGroups, Normal=Active };

    const QColor &color( ColorGroup, QColorGroup::ColorRole ) const;
    const QBrush &brush( ColorGroup, QColorGroup::ColorRole ) const;
    void setColor( ColorGroup, QColorGroup::ColorRole, const QColor & );
    void setBrush( ColorGroup, QColorGroup::ColorRole, const QBrush & );

    void setColor( QColorGroup::ColorRole, const QColor & );
    void setBrush( QColorGroup::ColorRole, const QBrush & );

    QPalette copy() const;

    const QColorGroup &active() const { return data->active; }
    const QColorGroup &disabled() const { return data->disabled; }
    const QColorGroup &inactive() const { return data->inactive; }




    void setActive( const QColorGroup & );
    void setDisabled( const QColorGroup & );
    void setInactive( const QColorGroup & );




    bool operator==( const QPalette &p ) const;
    bool operator!=( const QPalette &p ) const
              { return !(operator==(p)); }
    bool isCopyOf( const QPalette & );

    int serialNumber() const { return data->ser_no; }


    static QColorGroup::ColorRole foregroundRoleFromMode( Qt::BackgroundMode mode );
    static QColorGroup::ColorRole backgroundRoleFromMode( Qt::BackgroundMode mode);

private:
    void detach();
    const QBrush &directBrush( ColorGroup, QColorGroup::ColorRole ) const;
    void directSetBrush( ColorGroup, QColorGroup::ColorRole, const QBrush& );

    struct QPalData : public QShared {
        QColorGroup disabled;
        QColorGroup active;
        int ser_no;
        QColorGroup inactive;
    } *data;
};







 QDataStream &operator<<( QDataStream &, const QColorGroup & );
 QDataStream &operator>>( QDataStream &, QColorGroup & );

 QDataStream &operator<<( QDataStream &, const QPalette & );
 QDataStream &operator>>( QDataStream &, QPalette & );
# 46 "/coolo/prod/qt-copy/include/qwidget.h" 2
# 1 "/coolo/prod/qt-copy/include/qfont.h" 1
# 39 "/coolo/prod/qt-copy/include/qfont.h"







class QFontPrivate;
class QStringList;
class QTextFormatCollection;

class QFont
{
public:
    enum StyleHint {
        Helvetica, SansSerif = Helvetica,
        Times, Serif = Times,
        Courier, TypeWriter = Courier,
        OldEnglish, Decorative = OldEnglish,
        System,
        AnyStyle
    };

    enum StyleStrategy {
        PreferDefault = 0x0001,
        PreferBitmap = 0x0002,
        PreferDevice = 0x0004,
        PreferOutline = 0x0008,
        ForceOutline = 0x0010,
        PreferMatch = 0x0020,
        PreferQuality = 0x0040,
        PreferAntialias = 0x0080,
        NoAntialias = 0x0100,
        OpenGLCompatible = 0x0200
    };

    enum Weight {
        Light = 25,
        Normal = 50,
        DemiBold = 63,
        Bold = 75,
        Black = 87
    };

    enum Stretch {
        UltraCondensed = 50,
        ExtraCondensed = 62,
        Condensed = 75,
        SemiCondensed = 87,
        Unstretched = 100,
        SemiExpanded = 112,
        Expanded = 125,
        ExtraExpanded = 150,
        UltraExpanded = 200
    };


    QFont();





    QFont( const QString &family, int pointSize = -1, int weight = -1,
           bool italic = FALSE );


    QFont( const QFont & );

    ~QFont();

    QString family() const;
    void setFamily( const QString &);

    int pointSize() const;
    float pointSizeFloat() const;
    void setPointSize( int );
    void setPointSizeFloat( float );

    int pixelSize() const;
    void setPixelSize( int );
    void setPixelSizeFloat( float );

    int weight() const;
    void setWeight( int );

    bool bold() const;
    void setBold( bool );

    bool italic() const;
    void setItalic( bool );

    bool underline() const;
    void setUnderline( bool );

    bool overline() const;
    void setOverline( bool );

    bool strikeOut() const;
    void setStrikeOut( bool );

    bool fixedPitch() const;
    void setFixedPitch( bool );

    StyleHint styleHint() const;
    StyleStrategy styleStrategy() const;
    void setStyleHint( StyleHint, StyleStrategy = PreferDefault );
    void setStyleStrategy( StyleStrategy s );

    int stretch() const;
    void setStretch( int );


    bool rawMode() const;
    void setRawMode( bool );


    bool exactMatch() const;

    QFont &operator=( const QFont & );
    bool operator==( const QFont & ) const;
    bool operator!=( const QFont & ) const;
    bool isCopyOf( const QFont & ) const;





    Qt::HANDLE handle() const;




    void setRawName( const QString & );
    QString rawName() const;

    QString key() const;

    QString toString() const;
    bool fromString(const QString &);


    static QString substitute(const QString &);
    static QStringList substitutes(const QString &);
    static QStringList substitutions();
    static void insertSubstitution(const QString&, const QString &);
    static void insertSubstitutions(const QString&, const QStringList &);
    static void removeSubstitution(const QString &);

    static void initialize();
    static void cleanup();

    static void cacheStatistics();
# 203 "/coolo/prod/qt-copy/include/qfont.h"
    enum Script {

        Latin,
        Greek,
        Cyrillic,
        Armenian,
        Georgian,
        Runic,
        Ogham,
        SpacingModifiers,
        CombiningMarks,


        Hebrew,
        Arabic,
        Syriac,
        Thaana,


        Devanagari,
        Bengali,
        Gurmukhi,
        Gujarati,
        Oriya,
        Tamil,
        Telugu,
        Kannada,
        Malayalam,
        Sinhala,
        Thai,
        Lao,
        Tibetan,
        Myanmar,
        Khmer,


        Han,
        Hiragana,
        Katakana,
        Hangul,
        Bopomofo,
        Yi,


        Ethiopic,
        Cherokee,
        CanadianAboriginal,
        Mongolian,


        CurrencySymbols,
        LetterlikeSymbols,
        NumberForms,
        MathematicalOperators,
        TechnicalSymbols,
        GeometricSymbols,
        MiscellaneousSymbols,
        EnclosedAndSquare,
        Braille,

        Unicode,


        Tagalog,
        Hanunoo,
        Buhid,
        Tagbanwa,

        KatakanaHalfWidth,


        NScripts,
        UnknownScript = NScripts,

        NoScript,





        Han_Japanese,
        Han_SimplifiedChinese,
        Han_TraditionalChinese,
        Han_Korean,

        LastPrivateScript

    };

    QString defaultFamily() const;
    QString lastResortFamily() const;
    QString lastResortFont() const;
# 303 "/coolo/prod/qt-copy/include/qfont.h"
    QFont resolve( const QFont & ) const;

protected:

    bool dirty() const;
    int deciPointSize() const;

private:
    QFont( QFontPrivate *, QPaintDevice *pd );

    void detach();




    void x11SetScreen( int screen = -1 );
    int x11Screen() const;


    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QPainter;
    friend class QPSPrinterFont;
    friend class QApplication;
    friend class QWidget;
    friend class QTextFormatCollection;
    friend class QTextLayout;
    friend class QTextItem;


    friend QDataStream &operator<<( QDataStream &, const QFont & );
    friend QDataStream &operator>>( QDataStream &, QFont & );


    QFontPrivate *d;
};


inline bool QFont::bold() const
{ return weight() > Normal; }


inline void QFont::setBold( bool enable )
{ setWeight( enable ? Bold : Normal ); }
# 356 "/coolo/prod/qt-copy/include/qfont.h"
 QDataStream &operator<<( QDataStream &, const QFont & );
 QDataStream &operator>>( QDataStream &, QFont & );
# 47 "/coolo/prod/qt-copy/include/qwidget.h" 2
# 1 "/coolo/prod/qt-copy/include/qfontmetrics.h" 1
# 39 "/coolo/prod/qt-copy/include/qfontmetrics.h"
# 50 "/coolo/prod/qt-copy/include/qfontmetrics.h"
class QTextCodec;
class QTextParag;

class QFontMetrics
{
public:
    QFontMetrics( const QFont & );
    QFontMetrics( const QFont &, QFont::Script );
    QFontMetrics( const QFontMetrics & );
    ~QFontMetrics();

    QFontMetrics &operator=( const QFontMetrics & );

    int ascent() const;
    int descent() const;
    int height() const;
    int leading() const;
    int lineSpacing() const;
    int minLeftBearing() const;
    int minRightBearing() const;
    int maxWidth() const;

    bool inFont(QChar) const;

    int leftBearing(QChar) const;
    int rightBearing(QChar) const;
    int width( const QString &, int len = -1 ) const;

    int width( QChar ) const;




    int charWidth( const QString &str, int pos ) const;
    QRect boundingRect( const QString &, int len = -1 ) const;
    QRect boundingRect( QChar ) const;
    QRect boundingRect( int x, int y, int w, int h, int flags,
                              const QString& str, int len=-1, int tabstops=0,
                              int *tabarray=0, QTextParag **intern=0 ) const;
    QSize size( int flags,
                      const QString& str, int len=-1, int tabstops=0,
                      int *tabarray=0, QTextParag **intern=0 ) const;

    int underlinePos() const;
    int overlinePos() const;
    int strikeOutPos() const;
    int lineWidth() const;

private:
    QFontMetrics( const QPainter * );

    friend class QWidget;
    friend class QPainter;
    friend class QTextFormat;




    QFontPrivate *d;
    QPainter *painter;
    int fscript;
};
# 48 "/coolo/prod/qt-copy/include/qwidget.h" 2
# 1 "/coolo/prod/qt-copy/include/qfontinfo.h" 1
# 39 "/coolo/prod/qt-copy/include/qfontinfo.h"






class QFontInfo
{
public:
    QFontInfo( const QFont & );
    QFontInfo( const QFont &, QFont::Script );
    QFontInfo( const QFontInfo & );
    ~QFontInfo();

    QFontInfo &operator=( const QFontInfo & );

    QString family() const;
    int pixelSize() const;
    int pointSize() const;
    bool italic() const;
    int weight() const;
    bool bold() const;
    bool underline() const;
    bool overline() const;
    bool strikeOut() const;
    bool fixedPitch() const;
    QFont::StyleHint styleHint() const;
    bool rawMode() const;

    bool exactMatch() const;


private:
    QFontInfo( const QPainter * );

    QFontPrivate *d;
    QPainter *painter;
    int fscript;

    friend class QWidget;
    friend class QPainter;
};


inline bool QFontInfo::bold() const
{ return weight() > QFont::Normal; }
# 49 "/coolo/prod/qt-copy/include/qwidget.h" 2
# 1 "/coolo/prod/qt-copy/include/qsizepolicy.h" 1
# 39 "/coolo/prod/qt-copy/include/qsizepolicy.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qsizepolicy.h" 2




class QSizePolicy
{
private:
    enum { HSize = 6, HMask = 0x3f, VMask = HMask << HSize,
           MayGrow = 1, ExpMask = 2, MayShrink = 4 };
public:
    enum SizeType { Fixed = 0,
                    Minimum = MayGrow,
                    Maximum = MayShrink,
                    Preferred = MayGrow | MayShrink,
                    MinimumExpanding = MayGrow | ExpMask,
                    Expanding = MayGrow | MayShrink | ExpMask,
                    Ignored = ExpMask };

    enum ExpandData { NoDirection = 0,
                      Horizontally = 1,
                      Vertically = 2,




                      BothDirections = Horizontally | Vertically };

    QSizePolicy() : data( 0 ) { }

    QSizePolicy( SizeType hor, SizeType ver, bool hfw = FALSE )
        : data( hor | (ver<<HSize) | (hfw ? (Q_UINT32)(1<<2*HSize) : 0) ) { }
    QSizePolicy( SizeType hor, SizeType ver, uchar hors, uchar vers, bool hfw = FALSE );

    SizeType horData() const { return (SizeType)( data & HMask ); }
    SizeType verData() const { return (SizeType)( (data & VMask) >> HSize ); }

    bool mayShrinkHorizontally() const { return horData() & MayShrink || horData() == Ignored; }
    bool mayShrinkVertically() const { return verData() & MayShrink || verData() == Ignored; }
    bool mayGrowHorizontally() const { return horData() & MayGrow || horData() == Ignored; }
    bool mayGrowVertically() const { return verData() & MayGrow || verData() == Ignored; }

    ExpandData expanding() const
    {
        return (ExpandData)( (int)(verData() & ExpMask ? Vertically : 0) |
                             (int)(horData() & ExpMask ? Horizontally : 0) );
    }

    void setHorData( SizeType d ) { data = (Q_UINT32)(data & ~HMask) | d; }
    void setVerData( SizeType d ) { data = (Q_UINT32)(data & ~(HMask << HSize)) |
                                           (d << HSize); }

    void setHeightForWidth( bool b ) { data = b ? (Q_UINT32)( data | ( 1 << 2*HSize ) )
                                              : (Q_UINT32)( data & ~( 1 << 2*HSize ) ); }
    bool hasHeightForWidth() const { return data & ( 1 << 2*HSize ); }

    bool operator==( const QSizePolicy& s ) const { return data == s.data; }
    bool operator!=( const QSizePolicy& s ) const { return data != s.data; }


    uint horStretch() const { return data >> 24; }
    uint verStretch() const { return (data >> 16) & 0xff; }
    void setHorStretch( uchar sf ) { data = (data&0x00ffffff) | (uint(sf)<<24); }
    void setVerStretch( uchar sf ) { data = (data&0xff00ffff) | (uint(sf)<<16); }
    inline void transpose();

private:
    QSizePolicy( int i ) : data( (Q_UINT32)i ) { }

    Q_UINT32 data;
};

inline QSizePolicy::QSizePolicy( SizeType hor, SizeType ver, uchar hors, uchar vers, bool hfw )
    : data( hor | (ver<<HSize) | (hfw ? (Q_UINT32)(1<<2*HSize) : 0) ) {
    setHorStretch( hors );
    setVerStretch( vers );
}

inline void QSizePolicy::transpose() {
    *this = QSizePolicy( verData(), horData(), verStretch(), horStretch(),
                         hasHeightForWidth() );
}
# 50 "/coolo/prod/qt-copy/include/qwidget.h" 2


class QLayout;
struct QWExtra;
struct QTLWExtra;
class QFocusData;
class QCursor;
class QWSRegionManager;
class QStyle;

class QWidget : public QObject, public QPaintDevice
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

   
   


   
   
   

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

public:
    explicit QWidget( QWidget* parent=0, const char* name=0, WFlags f=0 );
    ~QWidget();

    WId winId() const;
    void setName( const char *name );



    QStyle &style() const;
    void setStyle( QStyle * );
    QStyle* setStyle( const QString& );



    bool isTopLevel() const;
    bool isDialog() const;
    bool isPopup() const;
    bool isDesktop() const;
    bool isModal() const;

    bool isEnabled() const;
    bool isEnabledTo(QWidget*) const;
    bool isEnabledToTLW() const;

public :
    virtual void setEnabled( bool );
    void setDisabled( bool );



public:
    QRect frameGeometry() const;
    const QRect &geometry() const;
    int x() const;
    int y() const;
    QPoint pos() const;
    QSize frameSize() const;
    QSize size() const;
    int width() const;
    int height() const;
    QRect rect() const;
    QRect childrenRect() const;
    QRegion childrenRegion() const;

    QSize minimumSize() const;
    QSize maximumSize() const;
    int minimumWidth() const;
    int minimumHeight() const;
    int maximumWidth() const;
    int maximumHeight() const;
    void setMinimumSize( const QSize & );
    virtual void setMinimumSize( int minw, int minh );
    void setMaximumSize( const QSize & );
    virtual void setMaximumSize( int maxw, int maxh );
    void setMinimumWidth( int minw );
    void setMinimumHeight( int minh );
    void setMaximumWidth( int maxw );
    void setMaximumHeight( int maxh );

    QSize sizeIncrement() const;
    void setSizeIncrement( const QSize & );
    virtual void setSizeIncrement( int w, int h );
    QSize baseSize() const;
    void setBaseSize( const QSize & );
    void setBaseSize( int basew, int baseh );

    void setFixedSize( const QSize & );
    void setFixedSize( int w, int h );
    void setFixedWidth( int w );
    void setFixedHeight( int h );



    QPoint mapToGlobal( const QPoint & ) const;
    QPoint mapFromGlobal( const QPoint & ) const;
    QPoint mapToParent( const QPoint & ) const;
    QPoint mapFromParent( const QPoint & ) const;
    QPoint mapTo( QWidget *, const QPoint & ) const;
    QPoint mapFrom( QWidget *, const QPoint & ) const;

    QWidget *topLevelWidget() const;



    BackgroundMode backgroundMode() const;
    virtual void setBackgroundMode( BackgroundMode );
    void setBackgroundMode( BackgroundMode, BackgroundMode );

    const QColor & foregroundColor() const;

    const QColor & eraseColor() const;
    virtual void setEraseColor( const QColor & );

    const QPixmap * erasePixmap() const;
    virtual void setErasePixmap( const QPixmap & );


    const QColorGroup & colorGroup() const;
    const QPalette & palette() const;
    bool ownPalette() const;
    virtual void setPalette( const QPalette & );
    void unsetPalette();


    const QColor & paletteForegroundColor() const;
    void setPaletteForegroundColor( const QColor & );

    const QColor & paletteBackgroundColor() const;
    virtual void setPaletteBackgroundColor( const QColor & );

    const QPixmap * paletteBackgroundPixmap() const;
    virtual void setPaletteBackgroundPixmap( const QPixmap & );

    const QBrush& backgroundBrush() const;

    QFont font() const;
    bool ownFont() const;
    virtual void setFont( const QFont & );
    void unsetFont();
    QFontMetrics fontMetrics() const;
    QFontInfo fontInfo() const;


    const QCursor &cursor() const;
    bool ownCursor() const;
    virtual void setCursor( const QCursor & );
    virtual void unsetCursor();


    QString caption() const;
    const QPixmap *icon() const;
    QString iconText() const;

    bool hasMouseTracking() const;
    bool hasMouse() const;

    virtual void setMask( const QBitmap & );
    virtual void setMask( const QRegion & );
    void clearMask();

    const QColor & backgroundColor() const;
    virtual void setBackgroundColor( const QColor & );
    const QPixmap * backgroundPixmap() const;
    virtual void setBackgroundPixmap( const QPixmap & );

public :

    virtual void setCaption( const QString &);
    virtual void setIcon( const QPixmap & );
    virtual void setIconText( const QString &);

    virtual void setMouseTracking( bool enable );



    virtual void setFocus();
    void clearFocus();

public:
    enum FocusPolicy {
        NoFocus = 0,
        TabFocus = 0x1,
        ClickFocus = 0x2,
        StrongFocus = TabFocus | ClickFocus | 0x8,
        WheelFocus = StrongFocus | 0x4
    };

    bool isActiveWindow() const;
    virtual void setActiveWindow();
    bool isFocusEnabled() const;

    FocusPolicy focusPolicy() const;
    virtual void setFocusPolicy( FocusPolicy );
    bool hasFocus() const;
    static void setTabOrder( QWidget *, QWidget * );
    virtual void setFocusProxy( QWidget * );
    QWidget * focusProxy() const;

    void setInputMethodEnabled( bool b );
    bool isInputMethodEnabled() const;


    void grabMouse();

    void grabMouse( const QCursor & );

    void releaseMouse();
    void grabKeyboard();
    void releaseKeyboard();
    static QWidget * mouseGrabber();
    static QWidget * keyboardGrabber();



    bool isUpdatesEnabled() const;




public :
    virtual void setUpdatesEnabled( bool enable );
    void update();
    void update( int x, int y, int w, int h );
    void update( const QRect& );
    void repaint();
    void repaint( bool erase );
    void repaint( int x, int y, int w, int h, bool erase=TRUE );
    void repaint( const QRect &, bool erase = TRUE );
    void repaint( const QRegion &, bool erase = TRUE );



    virtual void show();
    virtual void hide();
    void setShown( bool show );
    void setHidden( bool hide );



    virtual void showMinimized();
    virtual void showMaximized();
    void showFullScreen();
    virtual void showNormal();
    virtual void polish();
    void constPolish() const;
    bool close();

    void raise();
    void lower();
    void stackUnder( QWidget* );
    virtual void move( int x, int y );
    void move( const QPoint & );
    virtual void resize( int w, int h );
    void resize( const QSize & );
    virtual void setGeometry( int x, int y, int w, int h );
    virtual void setGeometry( const QRect & );

public:
    virtual bool close( bool alsoDelete );
    bool isVisible() const;
    bool isVisibleTo(QWidget*) const;
    bool isVisibleToTLW() const;
    QRect visibleRect() const;
    bool isHidden() const;
    bool isShown() const;
    bool isMinimized() const;
    bool isMaximized() const;
    bool isFullScreen() const;

    virtual QSize sizeHint() const;
    virtual QSize minimumSizeHint() const;
    virtual QSizePolicy sizePolicy() const;
    virtual void setSizePolicy( QSizePolicy );
    void setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw = FALSE );
    virtual int heightForWidth(int) const;

    QRegion clipRegion() const;


public :
    virtual void adjustSize();

public:

    QLayout * layout() const { return lay_out; }

    void updateGeometry();
    virtual void reparent( QWidget *parent, WFlags, const QPoint &,
                                  bool showIt=FALSE );
    void reparent( QWidget *parent, const QPoint &,
                                  bool showIt=FALSE );





    void erase();
    void erase( int x, int y, int w, int h );
    void erase( const QRect & );
    void erase( const QRegion & );
    void scroll( int dx, int dy );
    void scroll( int dx, int dy, const QRect& );

    void drawText( int x, int y, const QString &);
    void drawText( const QPoint &, const QString &);



    QWidget * focusWidget() const;
    QRect microFocusHint() const;



    bool acceptDrops() const;
    virtual void setAcceptDrops( bool on );



    virtual void setAutoMask(bool);
    bool autoMask() const;

    enum BackgroundOrigin { WidgetOrigin, ParentOrigin, WindowOrigin, AncestorOrigin };

    virtual void setBackgroundOrigin( BackgroundOrigin );
    BackgroundOrigin backgroundOrigin() const;
    QPoint backgroundOffset() const;


    virtual bool customWhatsThis() const;

    QWidget * parentWidget( bool sameWindow = FALSE ) const;
    WState testWState( WState s ) const;
    WFlags testWFlags( WFlags f ) const;
    static QWidget * find( WId );
    static QWidgetMapper *wmapper();

    QWidget *childAt( int x, int y, bool includeThis = FALSE ) const;
    QWidget *childAt( const QPoint &, bool includeThis = FALSE ) const;
# 464 "/coolo/prod/qt-copy/include/qwidget.h"
protected:

    bool event( QEvent * );
    virtual void mousePressEvent( QMouseEvent * );
    virtual void mouseReleaseEvent( QMouseEvent * );
    virtual void mouseDoubleClickEvent( QMouseEvent * );
    virtual void mouseMoveEvent( QMouseEvent * );

    virtual void wheelEvent( QWheelEvent * );

    virtual void keyPressEvent( QKeyEvent * );
    virtual void keyReleaseEvent( QKeyEvent * );
    virtual void focusInEvent( QFocusEvent * );
    virtual void focusOutEvent( QFocusEvent * );
    virtual void enterEvent( QEvent * );
    virtual void leaveEvent( QEvent * );
    virtual void paintEvent( QPaintEvent * );
    virtual void moveEvent( QMoveEvent * );
    virtual void resizeEvent( QResizeEvent * );
    virtual void closeEvent( QCloseEvent * );
    virtual void contextMenuEvent( QContextMenuEvent * );
    virtual void imStartEvent( QIMEvent * );
    virtual void imComposeEvent( QIMEvent * );
    virtual void imEndEvent( QIMEvent * );
    virtual void tabletEvent( QTabletEvent * );


    virtual void dragEnterEvent( QDragEnterEvent * );
    virtual void dragMoveEvent( QDragMoveEvent * );
    virtual void dragLeaveEvent( QDragLeaveEvent * );
    virtual void dropEvent( QDropEvent * );


    virtual void showEvent( QShowEvent * );
    virtual void hideEvent( QHideEvent * );
# 507 "/coolo/prod/qt-copy/include/qwidget.h"
    virtual bool x11Event( XEvent * );







    virtual void updateMask();




    virtual void styleChange( QStyle& );

    virtual void enabledChange( bool oldEnabled );

    virtual void paletteChange( const QPalette & );

    virtual void fontChange( const QFont & );
    virtual void windowActivationChange( bool oldActive );

    int metric( int ) const;

    void resetInputContext();

    virtual void create( WId = 0, bool initializeWindow = TRUE,
                         bool destroyOldWindow = TRUE );
    virtual void destroy( bool destroyWindow = TRUE,
                          bool destroySubWindows = TRUE );
    uint getWState() const;
    virtual void setWState( uint );
    void clearWState( uint n );
    WFlags getWFlags() const;
    virtual void setWFlags( WFlags );
    void clearWFlags( WFlags n );

    virtual bool focusNextPrevChild( bool next );

    QWExtra *extraData();
    QTLWExtra *topData();
    QFocusData *focusData();

    virtual void setKeyCompression(bool);
    virtual void setMicroFocusHint(int x, int y, int w, int h, bool text=TRUE, QFont *f = 0);
# 560 "/coolo/prod/qt-copy/include/qwidget.h"
private :
    void focusProxyDestroyed();

private:
    void setFontSys( QFont *f = 0 );

    void createInputContext();
    void destroyInputContext();
    void focusInputContext();
    void checkChildrenDnd();
# 590 "/coolo/prod/qt-copy/include/qwidget.h"
    void setLayout( QLayout *l );

    void setWinId( WId );
    void showWindow();
    void hideWindow();
    void showChildren( bool spontaneous );
    void hideChildren( bool spontaneous );
    void reparentSys( QWidget *parent, WFlags, const QPoint &, bool showIt);
    void createTLExtra();
    void createExtra();
    void deleteExtra();
    void createSysExtra();
    void deleteSysExtra();
    void createTLSysExtra();
    void deleteTLSysExtra();
    void deactivateWidgetCleanup();
    void internalSetGeometry( int, int, int, int, bool );
    void reparentFocusWidgets( QWidget * );
    QFocusData *focusData( bool create );
    void setBackgroundFromMode();
    void setBackgroundColorDirect( const QColor & );
    void setBackgroundPixmapDirect( const QPixmap & );
    void setBackgroundModeDirect( BackgroundMode );
    void setBackgroundEmpty();
    void updateFrameStrut() const;

    void setBackgroundX11Relative();


    WId winid;
    uint widget_state;
    uint widget_flags;
    uint focus_policy : 4;
    uint own_font :1;
    uint own_palette :1;
    uint sizehint_forced :1;
    uint is_closing :1;
    uint in_show : 1;
    uint in_show_maximized : 1;
    uint fstrut_dirty : 1;
    uint im_enabled : 1;
    QRect crect;
    QColor bg_col;

    QPalette pal;

    QFont fnt;

    QLayout *lay_out;

    QWExtra *extra;
# 674 "/coolo/prod/qt-copy/include/qwidget.h"
    static int instanceCounter;
    static int maxInstances;

    static void createMapper();
    static void destroyMapper();
    static QWidgetList *wList();
    static QWidgetList *tlwList();
    static QWidgetMapper *mapper;
    friend class QApplication;
    friend class QBaseApplication;
    friend class QPainter;
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QETWidget;
    friend class QLayout;

private:

    QWidget( const QWidget & );
    QWidget &operator=( const QWidget & );


public:

    void setPalette( const QPalette &p, bool ) { setPalette( p ); }

    void setFont( const QFont &f, bool ) { setFont( f ); }
};


inline Qt::WState QWidget::testWState( WState s ) const
{ return (widget_state & s); }

inline Qt::WFlags QWidget::testWFlags( WFlags f ) const
{ return (widget_flags & f); }


inline WId QWidget::winId() const
{ return winid; }

inline bool QWidget::isTopLevel() const
{ return testWFlags(WType_TopLevel); }

inline bool QWidget::isDialog() const
{ return testWFlags(WType_Dialog); }

inline bool QWidget::isPopup() const
{ return testWFlags(WType_Popup); }

inline bool QWidget::isDesktop() const
{ return testWFlags(WType_Desktop); }

inline bool QWidget::isEnabled() const
{ return !testWState(WState_Disabled); }

inline bool QWidget::isModal() const
{ return testWFlags(WShowModal); }

inline bool QWidget::isEnabledToTLW() const
{ return isEnabled(); }

inline const QRect &QWidget::geometry() const
{ return crect; }

inline QSize QWidget::size() const
{ return crect.size(); }

inline int QWidget::width() const
{ return crect.width(); }

inline int QWidget::height() const
{ return crect.height(); }

inline QRect QWidget::rect() const
{ return QRect(0,0,crect.width(),crect.height()); }

inline int QWidget::minimumWidth() const
{ return minimumSize().width(); }

inline int QWidget::minimumHeight() const
{ return minimumSize().height(); }

inline int QWidget::maximumWidth() const
{ return maximumSize().width(); }

inline int QWidget::maximumHeight() const
{ return maximumSize().height(); }

inline void QWidget::setMinimumSize( const QSize &s )
{ setMinimumSize(s.width(),s.height()); }

inline void QWidget::setMaximumSize( const QSize &s )
{ setMaximumSize(s.width(),s.height()); }

inline void QWidget::setSizeIncrement( const QSize &s )
{ setSizeIncrement(s.width(),s.height()); }

inline void QWidget::setBaseSize( const QSize &s )
{ setBaseSize(s.width(),s.height()); }

inline const QColor &QWidget::eraseColor() const
{ return bg_col; }


inline const QPalette &QWidget::palette() const
{ return pal; }


inline QFont QWidget::font() const
{ return fnt; }

inline QFontMetrics QWidget::fontMetrics() const
{ return QFontMetrics(font()); }

inline QFontInfo QWidget::fontInfo() const
{ return QFontInfo(font()); }

inline bool QWidget::hasMouseTracking() const
{ return testWState(WState_MouseTracking); }

inline bool QWidget::hasMouse() const
{ return testWState(WState_HasMouse); }

inline bool QWidget::isFocusEnabled() const
{ return (FocusPolicy)focus_policy != NoFocus; }

inline QWidget::FocusPolicy QWidget::focusPolicy() const
{ return (FocusPolicy)focus_policy; }

inline bool QWidget::isUpdatesEnabled() const
{ return !testWState(WState_BlockUpdates); }

inline void QWidget::update( const QRect &r )
{ update( r.x(), r.y(), r.width(), r.height() ); }

inline void QWidget::repaint()
{ repaint( TRUE ); }

inline void QWidget::repaint( const QRect &r, bool erase )
{ repaint( r.x(), r.y(), r.width(), r.height(), erase ); }

inline void QWidget::erase()
{ erase( 0, 0, crect.width(), crect.height() ); }

inline void QWidget::erase( const QRect &r )
{ erase( r.x(), r.y(), r.width(), r.height() ); }

inline bool QWidget::close()
{ return close( FALSE ); }

inline bool QWidget::isVisible() const
{ return testWState(WState_Visible); }

inline bool QWidget::isVisibleToTLW() const
{ return isVisible(); }

inline bool QWidget::isHidden() const
{ return testWState(WState_ForceHide); }

inline bool QWidget::isShown() const
{ return !testWState(WState_ForceHide); }

inline void QWidget::move( const QPoint &p )
{ move( p.x(), p.y() ); }

inline void QWidget::resize( const QSize &s )
{ resize( s.width(), s.height()); }

inline void QWidget::setGeometry( const QRect &r )
{ setGeometry( r.left(), r.top(), r.width(), r.height() ); }

inline void QWidget::drawText( const QPoint &p, const QString &s )
{ drawText( p.x(), p.y(), s ); }

inline QWidget *QWidget::parentWidget( bool sameWindow ) const
{
    if ( sameWindow )
        return isTopLevel() ? 0 : (QWidget *)QObject::parent();
    return (QWidget *)QObject::parent();
}

inline QWidgetMapper *QWidget::wmapper()
{ return mapper; }

inline uint QWidget::getWState() const
{ return widget_state; }

inline void QWidget::setWState( uint f )
{ widget_state |= f; }

inline void QWidget::clearWState( uint f )
{ widget_state &= ~f; }

inline Qt::WFlags QWidget::getWFlags() const
{ return widget_flags; }

inline void QWidget::setWFlags( WFlags f )
{ widget_flags |= f; }

inline void QWidget::clearWFlags( WFlags f )
{ widget_flags &= ~f; }

inline void QWidget::constPolish() const
{
    if ( !testWState(WState_Polished) ) {
        QWidget* that = (QWidget*) this;
        that->polish();
        that->setWState(WState_Polished);
    }
}

inline bool QWidget::ownCursor() const
{
    return testWState( WState_OwnCursor );
}

inline bool QWidget::ownFont() const
{
    return own_font;
}

inline bool QWidget::ownPalette() const
{
    return own_palette;
}


inline void QWidget::setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw )
{
    setSizePolicy( QSizePolicy( hor, ver, hfw) );
}

inline bool QWidget::isInputMethodEnabled() const
{
    return (bool)im_enabled;
}





class QFocusData;
class QWSManager;







struct QTLWExtra {

    QString caption;
    QString iconText;
    QPixmap *icon;

    QFocusData *focusData;
    short incw, inch;

    ulong fleft, fright, ftop, fbottom;
    uint iconic: 1;
    uint fullscreen : 1;
    uint showMode: 2;
    uint savedFlags;
    short basew, baseh;

    WId parentWinId;
    uint embedded : 1;
    uint spont_unmapped: 1;
    uint reserved: 1;
    uint dnd : 1;
    uint uspos : 1;
    uint ussize : 1;
    void *xic;
# 961 "/coolo/prod/qt-copy/include/qwidget.h"
    QRect normalGeometry;
};





struct QWExtra {
    Q_INT16 minw, minh;
    Q_INT16 maxw, maxh;
    QPixmap *bg_pix;
    QWidget *focus_proxy;

    QCursor *curs;

    QTLWExtra *topextra;




    WId xDndProxy;
# 995 "/coolo/prod/qt-copy/include/qwidget.h"
    uint bg_origin : 2;

    uint children_use_dnd : 1;
    uint compress_events : 1;




    char bg_mode;
    char bg_mode_visual;

    QStyle* style;

    QRect micro_focus_hint;
    QSizePolicy size_policy;
};

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 1014 "/coolo/prod/qt-copy/include/qwidget.h" 2
# 43 "/coolo/prod/qt-copy/include/qwidgetlist.h" 2



class QWidgetList : public QPtrList<QWidget>
{
public:
    QWidgetList() : QPtrList<QWidget>() {}
    QWidgetList( const QWidgetList &list ) : QPtrList<QWidget>(list) {}
   ~QWidgetList() { clear(); }
    QWidgetList &operator=(const QWidgetList &list)
        { return (QWidgetList&)QPtrList<QWidget>::operator=(list); }
};

class QWidgetListIt : public QPtrListIterator<QWidget>
{
public:
    QWidgetListIt( const QWidgetList &l ) : QPtrListIterator<QWidget>(l) {}
    QWidgetListIt &operator=(const QWidgetListIt &i)
        { return (QWidgetListIt&)QPtrListIterator<QWidget>::operator=(i); }
};
# 31 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2


# 1 "/coolo/prod/qt-copy/include/qmessagebox.h" 1
# 39 "/coolo/prod/qt-copy/include/qmessagebox.h"


# 1 "/coolo/prod/qt-copy/include/qdialog.h" 1
# 39 "/coolo/prod/qt-copy/include/qdialog.h"
# 49 "/coolo/prod/qt-copy/include/qdialog.h"
class QPushButton;
class QDialogPrivate;

class QDialog : public QWidget
{
friend class QPushButton;
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   

public:
    explicit QDialog( QWidget* parent=0, const char* name=0, bool modal=FALSE,
             WFlags f=0 );
    ~QDialog();

    enum DialogCode { Rejected, Accepted };

    int result() const { return rescode; }

    void show();
    void hide();
    void move( int x, int y );
    void move( const QPoint &p );
    void resize( int w, int h );
    void resize( const QSize & );
    void setGeometry( int x, int y, int w, int h );
    void setGeometry( const QRect & );

    void setOrientation( Orientation orientation );
    Orientation orientation() const;

    void setExtension( QWidget* extension );
    QWidget* extension() const;

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void setSizeGripEnabled( bool );
    bool isSizeGripEnabled() const;

    void setModal( bool modal );
    bool isModal() const;

public :
    int exec();

protected :
    virtual void done( int );
    virtual void accept();
    virtual void reject();

    void showExtension( bool );

protected:
    void setResult( int r ) { rescode = r; }
    void keyPressEvent( QKeyEvent * );
    void closeEvent( QCloseEvent * );
    void resizeEvent( QResizeEvent * );
    void contextMenuEvent( QContextMenuEvent * );
    bool eventFilter( QObject *, QEvent * );
    void adjustPosition( QWidget*);

private:
    void setDefault( QPushButton * );
    void hideDefault();
    int rescode;
    uint did_move : 1;
    uint has_relpos : 1;
    uint did_resize : 1;
    uint in_loop: 1;
    void adjustPositionInternal( QWidget*, bool useRelPos = FALSE );
    QDialogPrivate* d;

private:

    QDialog( const QDialog & );
    QDialog &operator=( const QDialog & );

};
# 43 "/coolo/prod/qt-copy/include/qmessagebox.h" 2




class QLabel;
class QPushButton;
struct QMessageBoxData;

class QMessageBox : public QDialog
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   

public:
    enum Icon { NoIcon = 0, Information = 1, Warning = 2, Critical = 3,
                Question = 4 };

    QMessageBox( QWidget* parent=0, const char* name=0 );
    QMessageBox( const QString& caption, const QString &text, Icon icon,
                 int button0, int button1, int button2,
                 QWidget* parent=0, const char* name=0, bool modal=TRUE,
                 WFlags f=WStyle_DialogBorder );
    ~QMessageBox();

    enum { NoButton = 0, Ok = 1, Cancel = 2, Yes = 3, No = 4, Abort = 5,
           Retry = 6, Ignore = 7, YesAll = 8, NoAll = 9, ButtonMask = 0xff,
           Default = 0x100, Escape = 0x200, FlagMask = 0x300 };

    static int information( QWidget *parent, const QString &caption,
                            const QString& text,
                            int button0, int button1=0, int button2=0 );
    static int information( QWidget *parent, const QString &caption,
                            const QString& text,
                            const QString& button0Text = QString::null,
                            const QString& button1Text = QString::null,
                            const QString& button2Text = QString::null,
                            int defaultButtonNumber = 0,
                            int escapeButtonNumber = -1 );

    static int question( QWidget *parent, const QString &caption,
                         const QString& text,
                         int button0, int button1=0, int button2=0 );
    static int question( QWidget *parent, const QString &caption,
                         const QString& text,
                         const QString& button0Text = QString::null,
                         const QString& button1Text = QString::null,
                         const QString& button2Text = QString::null,
                         int defaultButtonNumber = 0,
                         int escapeButtonNumber = -1 );

    static int warning( QWidget *parent, const QString &caption,
                        const QString& text,
                        int button0, int button1, int button2=0 );
    static int warning( QWidget *parent, const QString &caption,
                        const QString& text,
                        const QString& button0Text = QString::null,
                        const QString& button1Text = QString::null,
                        const QString& button2Text = QString::null,
                        int defaultButtonNumber = 0,
                        int escapeButtonNumber = -1 );

    static int critical( QWidget *parent, const QString &caption,
                         const QString& text,
                         int button0, int button1, int button2=0 );
    static int critical( QWidget *parent, const QString &caption,
                         const QString& text,
                         const QString& button0Text = QString::null,
                         const QString& button1Text = QString::null,
                         const QString& button2Text = QString::null,
                         int defaultButtonNumber = 0,
                         int escapeButtonNumber = -1 );

    static void about( QWidget *parent, const QString &caption,
                       const QString& text );

    static void aboutQt( QWidget *parent,
                         const QString& caption=QString::null );


    static int message( const QString &caption,
                        const QString& text,
                        const QString& buttonText=QString::null,
                        QWidget *parent=0, const char * =0 ) {
        return QMessageBox::information( parent, caption, text,
                                     buttonText.isEmpty()
                                     ? tr("OK") : buttonText ) == 0;
    }


    static bool query( const QString &caption,
                       const QString& text,
                       const QString& yesButtonText=QString::null,
                       const QString& noButtonText=QString::null,
                       QWidget *parent=0, const char * = 0 ) {
        return QMessageBox::information( parent, caption, text,
                                     yesButtonText.isEmpty()
                                     ? tr("OK") : yesButtonText,
                                     noButtonText ) == 0;
    }

    QString text() const;
    void setText( const QString &);

    Icon icon() const;

    void setIcon( Icon );
    void setIcon( const QPixmap & );

    const QPixmap *iconPixmap() const;
    void setIconPixmap( const QPixmap & );

    QString buttonText( int button ) const;
    void setButtonText( int button, const QString &);

    void adjustSize();


    static QPixmap standardIcon( Icon icon, GUIStyle );

    static QPixmap standardIcon( Icon icon );

    TextFormat textFormat() const;
    void setTextFormat( TextFormat );

protected:
    void resizeEvent( QResizeEvent * );
    void showEvent( QShowEvent * );
    void closeEvent( QCloseEvent * );
    void keyPressEvent( QKeyEvent * );
    void styleChanged( QStyle& );

private :
    void buttonClicked();

private:
    void init( int, int, int );
    int indexOf( int ) const;
    void resizeButtons();
    QLabel *label;
    QMessageBoxData *mbd;
    void *reserved1;
    void *reserved2;

private:

    QMessageBox( const QMessageBox & );
    QMessageBox &operator=( const QMessageBox & );

};
# 208 "/coolo/prod/qt-copy/include/qmessagebox.h"
# 34 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qregexp.h" 1
# 39 "/coolo/prod/qt-copy/include/qregexp.h"






class QRegExpEngine;
struct QRegExpPrivate;

class QRegExp
{
public:
    enum CaretMode { CaretAtZero, CaretAtOffset, CaretWontMatch };

    QRegExp();
    QRegExp( const QString& pattern, bool caseSensitive = TRUE,
             bool wildcard = FALSE );
    QRegExp( const QRegExp& rx );
    ~QRegExp();
    QRegExp& operator=( const QRegExp& rx );

    bool operator==( const QRegExp& rx ) const;
    bool operator!=( const QRegExp& rx ) const { return !operator==( rx ); }

    bool isEmpty() const;
    bool isValid() const;
    QString pattern() const;
    void setPattern( const QString& pattern );
    bool caseSensitive() const;
    void setCaseSensitive( bool sensitive );

    bool wildcard() const;
    void setWildcard( bool wildcard );

    bool minimal() const;
    void setMinimal( bool minimal );

    bool exactMatch( const QString& str ) const;
# 90 "/coolo/prod/qt-copy/include/qregexp.h"
    int search( const QString& str, int offset = 0 ) const;
    int search( const QString& str, int offset, CaretMode caretMode ) const;
    int searchRev( const QString& str, int offset = -1 ) const;
    int searchRev( const QString& str, int offset, CaretMode caretMode ) const;

    int matchedLength() const;

    int numCaptures() const;
    QStringList capturedTexts();
    QString cap( int nth = 0 );
    int pos( int nth = 0 );
    QString errorString();


    static QString escape( const QString& str );

private:
    void prepareEngine() const;
    void prepareEngineForMatch( const QString& str ) const;
    void invalidateEngine();

    static int caretIndex( int offset, CaretMode caretMode );

    QRegExpEngine *eng;
    QRegExpPrivate *priv;
};
# 36 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qlineedit.h" 1
# 39 "/coolo/prod/qt-copy/include/qlineedit.h"

struct QLineEditPrivate;

class QValidator;
class QPopupMenu;


# 1 "/coolo/prod/qt-copy/include/qframe.h" 1
# 39 "/coolo/prod/qt-copy/include/qframe.h"







class QFrame : public QWidget
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   
   
   

public:
    QFrame( QWidget* parent=0, const char* name=0, WFlags f=0 );

    int frameStyle() const;
    virtual void setFrameStyle( int );

    int frameWidth() const;
    QRect contentsRect() const;


    bool lineShapesOk() const { return TRUE; }


    QSize sizeHint() const;

    enum Shape { NoFrame = 0,
                 Box = 0x0001,
                 Panel = 0x0002,
                 WinPanel = 0x0003,
                 HLine = 0x0004,
                 VLine = 0x0005,
                 StyledPanel = 0x0006,
                 PopupPanel = 0x0007,
                 MenuBarPanel = 0x0008,
                 ToolBarPanel = 0x0009,
                 LineEditPanel = 0x000a,
                 TabWidgetPanel = 0x000b,
                 GroupBoxPanel = 0x000c,
                 MShape = 0x000f
    };
    enum Shadow { Plain = 0x0010,
                  Raised = 0x0020,
                  Sunken = 0x0030,
                  MShadow = 0x00f0 };

    Shape frameShape() const;
    void setFrameShape( Shape );
    Shadow frameShadow() const;
    void setFrameShadow( Shadow );

    int lineWidth() const;
    virtual void setLineWidth( int );

    int margin() const;
    virtual void setMargin( int );

    int midLineWidth() const;
    virtual void setMidLineWidth( int );

    QRect frameRect() const;
    virtual void setFrameRect( const QRect & );

protected:
    void paintEvent( QPaintEvent * );
    void resizeEvent( QResizeEvent * );
    virtual void drawFrame( QPainter * );
    virtual void drawContents( QPainter * );
    virtual void frameChanged();
    void styleChange( QStyle& );

private:
    void updateFrameWidth(bool=FALSE);
    QRect frect;
    int fstyle;
    short lwidth;
    short mwidth;
    short mlwidth;
    short fwidth;

    void * d;
private:

    QFrame( const QFrame & );
    QFrame &operator=( const QFrame & );

};


inline int QFrame::frameStyle() const
{ return fstyle; }

inline QFrame::Shape QFrame::frameShape() const
{ return (Shape) ( fstyle & MShape ); }

inline QFrame::Shadow QFrame::frameShadow() const
{ return (Shadow) ( fstyle & MShadow ); }

inline void QFrame::setFrameShape( QFrame::Shape s )
{ setFrameStyle( ( fstyle & MShadow ) | s ); }

inline void QFrame::setFrameShadow( QFrame::Shadow s )
{ setFrameStyle( ( fstyle & MShape ) | s ); }

inline int QFrame::lineWidth() const
{ return lwidth; }

inline int QFrame::midLineWidth() const
{ return mlwidth; }

inline int QFrame::margin() const
{ return mwidth; }

inline int QFrame::frameWidth() const
{ return fwidth; }
# 48 "/coolo/prod/qt-copy/include/qlineedit.h" 2





class QTextParagraph;
class QTextCursor;

class QLineEdit : public QFrame
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

public:
    QLineEdit( QWidget* parent, const char* name=0 );
    QLineEdit( const QString &, QWidget* parent, const char* name=0 );
    QLineEdit( const QString &, const QString &, QWidget* parent, const char* name=0 );
    ~QLineEdit();

    QString text() const;

    QString displayText() const;

    int maxLength() const;

    bool frame() const;

    enum EchoMode { Normal, NoEcho, Password };
    EchoMode echoMode() const;

    bool isReadOnly() const;

    const QValidator * validator() const;

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    int cursorPosition() const;
    bool validateAndSet( const QString &, int, int, int );

    int alignment() const;





    void cursorForward( bool mark, int steps = 1 );
    void cursorBackward( bool mark, int steps = 1 );
    void cursorWordForward( bool mark );
    void cursorWordBackward( bool mark );
    void backspace();
    void del();
    void home( bool mark );
    void end( bool mark );

    bool isModified() const;
    void clearModified();

    bool edited() const;
    void setEdited( bool );

    bool hasSelectedText() const;
    QString selectedText() const;
    int selectionStart() const;

    bool isUndoAvailable() const;
    bool isRedoAvailable() const;






    bool dragEnabled() const;

    QString inputMask() const;
    void setInputMask( const QString &inputMask );
    bool hasAcceptableInput() const;

public :
    virtual void setText( const QString &);
    virtual void selectAll();
    virtual void deselect();
    virtual void clearValidator();
    virtual void insert( const QString &);
    virtual void clear();
    virtual void undo();
    virtual void redo();
    virtual void setMaxLength( int );
    virtual void setFrame( bool );
    virtual void setEchoMode( EchoMode );
    virtual void setReadOnly( bool );
    virtual void setValidator( const QValidator * );
    virtual void setFont( const QFont & );
    virtual void setPalette( const QPalette & );
    virtual void setSelection( int, int );
    virtual void setCursorPosition( int );
    virtual void setAlignment( int flag );

    virtual void cut();
    virtual void copy() const;
    virtual void paste();

    virtual void setDragEnabled( bool b );

protected:
    void textChanged( const QString &);
    void returnPressed();
    void lostFocus();
    void selectionChanged();

protected:
    bool event( QEvent * );
    void mousePressEvent( QMouseEvent * );
    void mouseMoveEvent( QMouseEvent * );
    void mouseReleaseEvent( QMouseEvent * );
    void mouseDoubleClickEvent( QMouseEvent * );
    void keyPressEvent( QKeyEvent * );
    void imStartEvent( QIMEvent * );
    void imComposeEvent( QIMEvent * );
    void imEndEvent( QIMEvent * );
    void focusInEvent( QFocusEvent * );
    void focusOutEvent( QFocusEvent * );
    void resizeEvent( QResizeEvent * );
    void drawContents( QPainter * );

    void dragEnterEvent( QDragEnterEvent * );
    void dragMoveEvent( QDragMoveEvent *e );
    void dragLeaveEvent( QDragLeaveEvent *e );
    void dropEvent( QDropEvent * );

    void contextMenuEvent( QContextMenuEvent * );
    virtual QPopupMenu *createPopupMenu();
    void windowActivationChange( bool );




private :
    void clipboardChanged();

public:
    void setPasswordChar( QChar c );
    QChar passwordChar() const;
    int characterAt( int, QChar* ) const;
    bool getSelection( int *, int * );

private:
    friend struct QLineEditPrivate;
    QLineEditPrivate * d;

private:

    QLineEdit( const QLineEdit & );
    QLineEdit &operator=( const QLineEdit & );

};
# 37 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qtextedit.h" 1
# 39 "/coolo/prod/qt-copy/include/qtextedit.h"


# 1 "/coolo/prod/qt-copy/include/qscrollview.h" 1
# 38 "/coolo/prod/qt-copy/include/qscrollview.h"



# 1 "/coolo/prod/qt-copy/include/qscrollbar.h" 1
# 39 "/coolo/prod/qt-copy/include/qscrollbar.h"

class QTimer;



# 1 "/coolo/prod/qt-copy/include/qrangecontrol.h" 1
# 39 "/coolo/prod/qt-copy/include/qrangecontrol.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qrangecontrol.h" 2






class QRangeControlPrivate;


class QRangeControl
{
public:
    QRangeControl();
    QRangeControl( int minValue, int maxValue,
                   int lineStep, int pageStep, int value );
    virtual ~QRangeControl();
    int value() const;
    void setValue( int );
    void addPage();
    void subtractPage();
    void addLine();
    void subtractLine();

    int minValue() const;
    int maxValue() const;
    void setRange( int minValue, int maxValue );
    void setMinValue( int minVal );
    void setMaxValue( int minVal );

    int lineStep() const;
    int pageStep() const;
    void setSteps( int line, int page );

    int bound( int ) const;

protected:
    int positionFromValue( int val, int space ) const;
    int valueFromPosition( int pos, int space ) const;
    void directSetValue( int val );
    int prevValue() const;

    virtual void valueChange();
    virtual void rangeChange();
    virtual void stepChange();

private:
    int minVal, maxVal;
    int line, page;
    int val, prevVal;

    QRangeControlPrivate * d;

private:

    QRangeControl( const QRangeControl & );
    QRangeControl &operator=( const QRangeControl & );

};


inline int QRangeControl::value() const
{ return val; }

inline int QRangeControl::prevValue() const
{ return prevVal; }

inline int QRangeControl::minValue() const
{ return minVal; }

inline int QRangeControl::maxValue() const
{ return maxVal; }

inline int QRangeControl::lineStep() const
{ return line; }

inline int QRangeControl::pageStep() const
{ return page; }






class QSpinWidgetPrivate;
class QSpinWidget : public QWidget
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QSpinWidget( QWidget* parent=0, const char* name=0 );
    ~QSpinWidget();

    void setEditWidget( QWidget * widget );
    QWidget * editWidget();

    QRect upRect() const;
    QRect downRect() const;

    void setUpEnabled( bool on );
    void setDownEnabled( bool on );

    bool isUpEnabled() const;
    bool isDownEnabled() const;

    enum ButtonSymbols { UpDownArrows, PlusMinus };
    virtual void setButtonSymbols( ButtonSymbols bs );
    ButtonSymbols buttonSymbols() const;

    void arrange();

protected:
    void stepUpPressed();
    void stepDownPressed();

public :
    void stepUp();
    void stepDown();

protected:
    void mousePressEvent( QMouseEvent *e );
    void resizeEvent( QResizeEvent* ev );
    void mouseReleaseEvent( QMouseEvent *e );
    void mouseMoveEvent( QMouseEvent *e );

    void wheelEvent( QWheelEvent * );

    void styleChange( QStyle& );
    void paintEvent( QPaintEvent * );
    void enableChanged( bool old );
    void windowActivationChange( bool );

private :
    void timerDone();
    void timerDoneEx();

private:
    QSpinWidgetPrivate * d;

    void updateDisplay();

private:

    QSpinWidget( const QSpinWidget& );
    QSpinWidget& operator=( const QSpinWidget& );

};
# 46 "/coolo/prod/qt-copy/include/qscrollbar.h" 2




class QScrollBar : public QWidget, public QRangeControl
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   
   

public:
    QScrollBar( QWidget *parent, const char* name = 0 );
    QScrollBar( Orientation, QWidget *parent, const char* name = 0 );
    QScrollBar( int minValue, int maxValue, int lineStep, int pageStep,
                int value, Orientation, QWidget *parent, const char* name = 0 );
    ~QScrollBar();

    virtual void setOrientation( Orientation );
    Orientation orientation() const;
    virtual void setTracking( bool enable );
    bool tracking() const;
    bool draggingSlider() const;

    virtual void setPalette( const QPalette & );
    virtual QSize sizeHint() const;
    virtual void setSizePolicy( QSizePolicy sp );
    void setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw = FALSE );

    int minValue() const;
    int maxValue() const;
    void setMinValue( int );
    void setMaxValue( int );
    int lineStep() const;
    int pageStep() const;
    void setLineStep( int );
    void setPageStep( int );
    int value() const;

    int sliderStart() const;
    QRect sliderRect() const;

public :
    void setValue( int );

protected:
    void valueChanged( int value );
    void sliderPressed();
    void sliderMoved( int value );
    void sliderReleased();
    void nextLine();
    void prevLine();
    void nextPage();
    void prevPage();

protected:

    void wheelEvent( QWheelEvent * );

    void keyPressEvent( QKeyEvent * );
    void resizeEvent( QResizeEvent * );
    void paintEvent( QPaintEvent * );

    void mousePressEvent( QMouseEvent * );
    void mouseReleaseEvent( QMouseEvent * );
    void mouseMoveEvent( QMouseEvent * );
    void contextMenuEvent( QContextMenuEvent * );
    void hideEvent( QHideEvent* );

    void valueChange();
    void stepChange();
    void rangeChange();

    void styleChange( QStyle& );

private :
    void doAutoRepeat();

private:
    void init();
    void positionSliderFromValue();
    int calculateValueFromSlider() const;

    void startAutoRepeat();
    void stopAutoRepeat();

    int rangeValueToSliderPos( int val ) const;
    int sliderPosToRangeValue( int val ) const;

    void action( int control );

    void drawControls( uint controls, uint activeControl ) const;
    void drawControls( uint controls, uint activeControl,
                       QPainter *p ) const;

    uint pressedControl;
    bool track;
    bool clickedAt;
    Orientation orient;

    int slidePrevVal;
    QCOORD sliderPos;
    QCOORD clickOffset;

    QTimer * repeater;
    void * d;

private:

    QScrollBar( const QScrollBar & );
    QScrollBar &operator=( const QScrollBar & );

};


inline void QScrollBar::setTracking( bool t )
{
    track = t;
}

inline bool QScrollBar::tracking() const
{
    return track;
}

inline QScrollBar::Orientation QScrollBar::orientation() const
{
    return orient;
}

inline int QScrollBar::sliderStart() const
{
    return sliderPos;
}

inline void QScrollBar::setSizePolicy( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw )
{
    QWidget::setSizePolicy( hor, ver, hfw );
}
# 43 "/coolo/prod/qt-copy/include/qscrollview.h" 2




class QScrollViewData;

class QScrollView : public QFrame
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   
   
   
   

   


public:
    QScrollView(QWidget* parent=0, const char* name=0, WFlags f=0);
    ~QScrollView();

    enum ResizePolicy { Default, Manual, AutoOne, AutoOneFit };
    virtual void setResizePolicy( ResizePolicy );
    ResizePolicy resizePolicy() const;

    void styleChange( QStyle & );
    void removeChild(QWidget* child);
    virtual void addChild( QWidget* child, int x=0, int y=0 );
    virtual void moveChild( QWidget* child, int x, int y );
    int childX(QWidget* child);
    int childY(QWidget* child);
    bool childIsVisible(QWidget* child) { return child->isVisible(); }
    void showChild(QWidget* child, bool yes=TRUE) {
        if ( yes )
            child->show();
        else
            child->hide();
    }

    enum ScrollBarMode { Auto, AlwaysOff, AlwaysOn };

    ScrollBarMode vScrollBarMode() const;
    virtual void setVScrollBarMode( ScrollBarMode );

    ScrollBarMode hScrollBarMode() const;
    virtual void setHScrollBarMode( ScrollBarMode );

    QWidget* cornerWidget() const;
    virtual void setCornerWidget(QWidget*);



    QScrollBar* horizontalScrollBar() const;
    QScrollBar* verticalScrollBar() const;
    QWidget* viewport() const;
    QWidget* clipper() const;

    int visibleWidth() const;
    int visibleHeight() const;

    int contentsWidth() const;
    int contentsHeight() const;
    int contentsX() const;
    int contentsY() const;

    void resize( int w, int h );
    void resize( const QSize& );
    void show();

    void updateContents( int x, int y, int w, int h );
    void updateContents( const QRect& r );
    void updateContents();
    void repaintContents( int x, int y, int w, int h, bool erase=TRUE );
    void repaintContents( const QRect& r, bool erase=TRUE );
    void repaintContents( bool erase=TRUE );
    void contentsToViewport( int x, int y, int& vx, int& vy ) const;
    void viewportToContents( int vx, int vy, int& x, int& y ) const;
    QPoint contentsToViewport( const QPoint& ) const;
    QPoint viewportToContents( const QPoint& ) const;
    void enableClipper( bool y );

    void setStaticBackground( bool y );
    bool hasStaticBackground() const;

    QSize viewportSize( int, int ) const;
    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void removeChild(QObject* child);

    bool isHorizontalSliderPressed();
    bool isVerticalSliderPressed();


    virtual void setDragAutoScroll( bool b );
    bool dragAutoScroll() const;


protected:
    void contentsMoving(int x, int y);
    void horizontalSliderPressed();
    void horizontalSliderReleased();
    void verticalSliderPressed();
    void verticalSliderReleased();

public :
    virtual void resizeContents( int w, int h );
    void scrollBy( int dx, int dy );
    virtual void setContentsPos( int x, int y );
    void ensureVisible(int x, int y);
    void ensureVisible(int x, int y, int xmargin, int ymargin);
    void center(int x, int y);
    void center(int x, int y, float xmargin, float ymargin);

    void updateScrollBars();
    void setEnabled( bool enable );

protected:
    virtual void drawContents(QPainter*, int cx, int cy, int cw, int ch);
    virtual void drawContentsOffset(QPainter*, int ox, int oy,
                    int cx, int cy, int cw, int ch);


    virtual void contentsMousePressEvent( QMouseEvent* );
    virtual void contentsMouseReleaseEvent( QMouseEvent* );
    virtual void contentsMouseDoubleClickEvent( QMouseEvent* );
    virtual void contentsMouseMoveEvent( QMouseEvent* );

    virtual void contentsDragEnterEvent( QDragEnterEvent * );
    virtual void contentsDragMoveEvent( QDragMoveEvent * );
    virtual void contentsDragLeaveEvent( QDragLeaveEvent * );
    virtual void contentsDropEvent( QDropEvent * );


    virtual void contentsWheelEvent( QWheelEvent * );

    virtual void contentsContextMenuEvent( QContextMenuEvent * );


    virtual void viewportPaintEvent( QPaintEvent* );
    virtual void viewportResizeEvent( QResizeEvent* );
    virtual void viewportMousePressEvent( QMouseEvent* );
    virtual void viewportMouseReleaseEvent( QMouseEvent* );
    virtual void viewportMouseDoubleClickEvent( QMouseEvent* );
    virtual void viewportMouseMoveEvent( QMouseEvent* );

    virtual void viewportDragEnterEvent( QDragEnterEvent * );
    virtual void viewportDragMoveEvent( QDragMoveEvent * );
    virtual void viewportDragLeaveEvent( QDragLeaveEvent * );
    virtual void viewportDropEvent( QDropEvent * );


    virtual void viewportWheelEvent( QWheelEvent * );

    virtual void viewportContextMenuEvent( QContextMenuEvent * );

    void frameChanged();

    virtual void setMargins(int left, int top, int right, int bottom);
    int leftMargin() const;
    int topMargin() const;
    int rightMargin() const;
    int bottomMargin() const;

    bool focusNextPrevChild( bool next );

    virtual void setHBarGeometry(QScrollBar& hbar, int x, int y, int w, int h);
    virtual void setVBarGeometry(QScrollBar& vbar, int x, int y, int w, int h);

    void resizeEvent(QResizeEvent*);
    void mousePressEvent( QMouseEvent * );
    void mouseReleaseEvent( QMouseEvent * );
    void mouseDoubleClickEvent( QMouseEvent * );
    void mouseMoveEvent( QMouseEvent * );

    void wheelEvent( QWheelEvent * );

    void contextMenuEvent( QContextMenuEvent * );
    bool eventFilter( QObject *, QEvent *e );

    void setCachedSizeHint( const QSize &sh ) const;
    QSize cachedSizeHint() const;
    void fontChange( const QFont & );

private:
    void drawContents( QPainter* );
    void moveContents(int x, int y);

    QScrollViewData* d;

private :
    void hslide(int);
    void vslide(int);
    void hbarIsPressed();
    void hbarIsReleased();
    void vbarIsPressed();
    void vbarIsReleased();

    void doDragAutoScroll();
    void startDragAutoScroll();
    void stopDragAutoScroll();


private:

    QScrollView( const QScrollView & );
    QScrollView &operator=( const QScrollView & );

    void changeFrameRect(const QRect&);

public:
    void disableSizeHintCaching();

};
# 43 "/coolo/prod/qt-copy/include/qtextedit.h" 2
# 1 "/coolo/prod/qt-copy/include/qstylesheet.h" 1
# 39 "/coolo/prod/qt-copy/include/qstylesheet.h"




# 1 "/coolo/prod/qt-copy/include/qptrvector.h" 1
# 39 "/coolo/prod/qt-copy/include/qptrvector.h"


# 1 "/coolo/prod/qt-copy/include/qgvector.h" 1
# 39 "/coolo/prod/qt-copy/include/qgvector.h"






class QGVector : public QPtrCollection
{
friend class QGList;
public:

    QDataStream &read( QDataStream & );
    QDataStream &write( QDataStream & ) const;

    virtual int compareItems( Item, Item );

protected:
    QGVector();
    QGVector( uint size );
    QGVector( const QGVector &v );
   ~QGVector();

    QGVector &operator=( const QGVector &v );
    bool operator==( const QGVector &v ) const;

    Item *data() const { return vec; }
    uint size() const { return len; }
    uint count() const { return numItems; }

    bool insert( uint index, Item );
    bool remove( uint index );
    Item take( uint index );

    void clear();
    bool resize( uint newsize );

    bool fill( Item, int flen );

    void sort();
    int bsearch( Item ) const;

    int findRef( Item, uint index ) const;
    int find( Item, uint index ) const;
    uint containsRef( Item ) const;
    uint contains( Item ) const;

    Item at( uint index ) const
    {

        if ( index >= len )
            warningIndexRange( index );

        return vec[index];
    }

    bool insertExpand( uint index, Item );

    void toList( QGList * ) const;


    virtual QDataStream &read( QDataStream &, Item & );
    virtual QDataStream &write( QDataStream &, Item ) const;

private:
    Item *vec;
    uint len;
    uint numItems;

    static void warningIndexRange( uint );
};







 QDataStream &operator>>( QDataStream &, QGVector & );
 QDataStream &operator<<( QDataStream &, const QGVector & );
# 43 "/coolo/prod/qt-copy/include/qptrvector.h" 2


template<class type>
class QPtrVector



        : public QGVector

{
public:
    QPtrVector() { }
    QPtrVector( uint size ) : QGVector(size) { }
    QPtrVector( const QPtrVector<type> &v ) : QGVector( v ) { }
    ~QPtrVector() { clear(); }
    QPtrVector<type> &operator=(const QPtrVector<type> &v)
                        { return (QPtrVector<type>&)QGVector::operator=(v); }
    bool operator==( const QPtrVector<type> &v ) const { return QGVector::operator==(v); }
    type **data() const { return (type **)QGVector::data(); }
    uint size() const { return QGVector::size(); }
    uint count() const { return QGVector::count(); }
    bool isEmpty() const { return QGVector::count() == 0; }
    bool isNull() const { return QGVector::size() == 0; }
    bool resize( uint size ) { return QGVector::resize(size); }
    bool insert( uint i, const type *d){ return QGVector::insert(i,(Item)d); }
    bool remove( uint i ) { return QGVector::remove(i); }
    type *take( uint i ) { return (type *)QGVector::take(i); }
    void clear() { QGVector::clear(); }
    bool fill( const type *d, int size=-1 )
                                        { return QGVector::fill((Item)d,size);}
    void sort() { QGVector::sort(); }
    int bsearch( const type *d ) const{ return QGVector::bsearch((Item)d); }
    int findRef( const type *d, uint i=0 ) const
                                        { return QGVector::findRef((Item)d,i);}
    int find( const type *d, uint i= 0 ) const
                                        { return QGVector::find((Item)d,i); }
    uint containsRef( const type *d ) const
                                { return QGVector::containsRef((Item)d); }
    uint contains( const type *d ) const
                                        { return QGVector::contains((Item)d); }
    type *operator[]( int i ) const { return (type *)QGVector::at(i); }
    type *at( uint i ) const { return (type *)QGVector::at(i); }
    void toList( QGList *list ) const { QGVector::toList(list); }
# 94 "/coolo/prod/qt-copy/include/qptrvector.h"
private:
    void deleteItem( Item d );
};


template<> inline void QPtrVector<void>::deleteItem( QPtrCollection::Item )
{
}


template<class type> inline void QPtrVector<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}





# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 115 "/coolo/prod/qt-copy/include/qptrvector.h" 2
# 45 "/coolo/prod/qt-copy/include/qstylesheet.h" 2
# 1 "/coolo/prod/qt-copy/include/qdict.h" 1
# 39 "/coolo/prod/qt-copy/include/qdict.h"


# 1 "/coolo/prod/qt-copy/include/qgdict.h" 1
# 39 "/coolo/prod/qt-copy/include/qgdict.h"






class QGDictIterator;
class QGDItList;


class QBaseBucket
{
public:
    QPtrCollection::Item getData() { return data; }
    QPtrCollection::Item setData( QPtrCollection::Item d ) { return data = d; }
    QBaseBucket *getNext() { return next; }
    void setNext( QBaseBucket *n) { next = n; }
protected:
    QBaseBucket( QPtrCollection::Item d, QBaseBucket *n ) : data(d), next(n) {}
    QPtrCollection::Item data;
    QBaseBucket *next;
};

class QStringBucket : public QBaseBucket
{
public:
    QStringBucket( const QString &k, QPtrCollection::Item d, QBaseBucket *n )
        : QBaseBucket(d,n), key(k) {}
    const QString &getKey() const { return key; }
private:
    QString key;
};

class QAsciiBucket : public QBaseBucket
{
public:
    QAsciiBucket( const char *k, QPtrCollection::Item d, QBaseBucket *n )
        : QBaseBucket(d,n), key(k) {}
    const char *getKey() const { return key; }
private:
    const char *key;
};

class QIntBucket : public QBaseBucket
{
public:
    QIntBucket( long k, QPtrCollection::Item d, QBaseBucket *n )
        : QBaseBucket(d,n), key(k) {}
    long getKey() const { return key; }
private:
    long key;
};

class QPtrBucket : public QBaseBucket
{
public:
    QPtrBucket( void *k, QPtrCollection::Item d, QBaseBucket *n )
        : QBaseBucket(d,n), key(k) {}
    void *getKey() const { return key; }
private:
    void *key;
};


class QGDict : public QPtrCollection
{
public:
    uint count() const { return numItems; }
    uint size() const { return vlen; }
    QPtrCollection::Item look_string( const QString& key, QPtrCollection::Item,
                                   int );
    QPtrCollection::Item look_ascii( const char *key, QPtrCollection::Item, int );
    QPtrCollection::Item look_int( long key, QPtrCollection::Item, int );
    QPtrCollection::Item look_ptr( void *key, QPtrCollection::Item, int );

    QDataStream &read( QDataStream & );
    QDataStream &write( QDataStream & ) const;

protected:
    enum KeyType { StringKey, AsciiKey, IntKey, PtrKey };

    QGDict( uint len, KeyType kt, bool cs, bool ck );
    QGDict( const QGDict & );
   ~QGDict();

    QGDict &operator=( const QGDict & );

    bool remove_string( const QString &key, QPtrCollection::Item item=0 );
    bool remove_ascii( const char *key, QPtrCollection::Item item=0 );
    bool remove_int( long key, QPtrCollection::Item item=0 );
    bool remove_ptr( void *key, QPtrCollection::Item item=0 );
    QPtrCollection::Item take_string( const QString &key );
    QPtrCollection::Item take_ascii( const char *key );
    QPtrCollection::Item take_int( long key );
    QPtrCollection::Item take_ptr( void *key );

    void clear();
    void resize( uint );

    int hashKeyString( const QString & );
    int hashKeyAscii( const char * );

    void statistics() const;


    virtual QDataStream &read( QDataStream &, QPtrCollection::Item & );
    virtual QDataStream &write( QDataStream &, QPtrCollection::Item ) const;

private:
    QBaseBucket **vec;
    uint vlen;
    uint numItems;
    uint keytype : 2;
    uint cases : 1;
    uint copyk : 1;
    QGDItList *iterators;
    void unlink_common( int, QBaseBucket *, QBaseBucket * );
    QStringBucket *unlink_string( const QString &,
                                  QPtrCollection::Item item = 0 );
    QAsciiBucket *unlink_ascii( const char *, QPtrCollection::Item item = 0 );
    QIntBucket *unlink_int( long, QPtrCollection::Item item = 0 );
    QPtrBucket *unlink_ptr( void *, QPtrCollection::Item item = 0 );
    void init( uint, KeyType, bool, bool );
    friend class QGDictIterator;
};


class QGDictIterator
{
friend class QGDict;
public:
    QGDictIterator( const QGDict & );
    QGDictIterator( const QGDictIterator & );
    QGDictIterator &operator=( const QGDictIterator & );
   ~QGDictIterator();

    QPtrCollection::Item toFirst();

    QPtrCollection::Item get() const;
    QString getKeyString() const;
    const char *getKeyAscii() const;
    long getKeyInt() const;
    void *getKeyPtr() const;

    QPtrCollection::Item operator()();
    QPtrCollection::Item operator++();
    QPtrCollection::Item operator+=(uint);

protected:
    QGDict *dict;

private:
    QBaseBucket *curNode;
    uint curIndex;
};

inline QPtrCollection::Item QGDictIterator::get() const
{
    return curNode ? curNode->getData() : 0;
}

inline QString QGDictIterator::getKeyString() const
{
    return curNode ? ((QStringBucket*)curNode)->getKey() : QString::null;
}

inline const char *QGDictIterator::getKeyAscii() const
{
    return curNode ? ((QAsciiBucket*)curNode)->getKey() : 0;
}

inline long QGDictIterator::getKeyInt() const
{
    return curNode ? ((QIntBucket*)curNode)->getKey() : 0;
}

inline void *QGDictIterator::getKeyPtr() const
{
    return curNode ? ((QPtrBucket*)curNode)->getKey() : 0;
}
# 43 "/coolo/prod/qt-copy/include/qdict.h" 2


template<class type>
class QDict



        : public QGDict

{
public:
    QDict( int size = 17, bool caseSensitive = TRUE )
        : QGDict( size, StringKey, caseSensitive, FALSE ) { }
    QDict( const QDict<type> &d ) : QGDict( d ) { }
    ~QDict() { clear(); }
    QDict<type> &operator=(const QDict<type> &d)
                        { return (QDict<type>&)QGDict::operator=(d); }
    uint count() const { return QGDict::count(); }
    uint size() const { return QGDict::size(); }
    bool isEmpty() const { return QGDict::count() == 0; }

    void insert( const QString &k, const type *d )
                                        { QGDict::look_string(k,(Item)d,1); }
    void replace( const QString &k, const type *d )
                                        { QGDict::look_string(k,(Item)d,2); }
    bool remove( const QString &k ) { return QGDict::remove_string(k); }
    type *take( const QString &k ) { return (type *)QGDict::take_string(k); }
    type *find( const QString &k ) const
                { return (type *)((QGDict*)this)->QGDict::look_string(k,0,0); }
    type *operator[]( const QString &k ) const
                { return (type *)((QGDict*)this)->QGDict::look_string(k,0,0); }

    void clear() { QGDict::clear(); }
    void resize( uint n ) { QGDict::resize(n); }
    void statistics() const { QGDict::statistics(); }







private:
        void deleteItem( Item d );
};


template<> inline void QDict<void>::deleteItem( Item )
{
}


template<class type> inline void QDict<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}

template<class type>
class QDictIterator : public QGDictIterator
{
public:
    QDictIterator(const QDict<type> &d) : QGDictIterator((QGDict &)d) { }
    ~QDictIterator() {}
    uint count() const { return dict->count(); }
    bool isEmpty() const { return dict->count() == 0; }
    type *toFirst() { return (type *)QGDictIterator::toFirst(); }
    operator type *() const { return (type *)QGDictIterator::get(); }
    type *operator*() { return (type *)QGDictIterator::get(); }
    type *current() const { return (type *)QGDictIterator::get(); }
    QString currentKey() const{ return QGDictIterator::getKeyString(); }
    type *operator()() { return (type *)QGDictIterator::operator()(); }
    type *operator++() { return (type *)QGDictIterator::operator++(); }
    type *operator+=(uint j) { return (type *)QGDictIterator::operator+=(j); }
};

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 120 "/coolo/prod/qt-copy/include/qdict.h" 2
# 46 "/coolo/prod/qt-copy/include/qstylesheet.h" 2





class QStyleSheet;
class QTextDocument;
template<class Key, class T> class QMap;
class QStyleSheetItemData;

class QStyleSheetItem : public Qt
{
public:
    QStyleSheetItem( QStyleSheet* parent, const QString& name );
    QStyleSheetItem( const QStyleSheetItem & );
    ~QStyleSheetItem();

    QStyleSheetItem& operator=( const QStyleSheetItem& other );

    QString name() const;

    QStyleSheet* styleSheet();
    const QStyleSheet* styleSheet() const;

    enum AdditionalStyleValues { Undefined = - 1};

    enum DisplayMode {
        DisplayBlock,
        DisplayInline,
        DisplayListItem,
        DisplayNone
    };

    DisplayMode displayMode() const;
    void setDisplayMode(DisplayMode m);

    int alignment() const;
    void setAlignment( int f);

    enum VerticalAlignment {
        VAlignBaseline,
        VAlignSub,
        VAlignSuper
    };

    VerticalAlignment verticalAlignment() const;
    void setVerticalAlignment( VerticalAlignment valign );

    int fontWeight() const;
    void setFontWeight(int w);

    int logicalFontSize() const;
    void setLogicalFontSize(int s);

    int logicalFontSizeStep() const;
    void setLogicalFontSizeStep( int s );

    int fontSize() const;
    void setFontSize(int s);

    QString fontFamily() const;
    void setFontFamily( const QString& );

    int numberOfColumns() const;
    void setNumberOfColumns(int ncols);

    QColor color() const;
    void setColor( const QColor &);

    bool fontItalic() const;
    void setFontItalic( bool );
    bool definesFontItalic() const;

    bool fontUnderline() const;
    void setFontUnderline( bool );
    bool definesFontUnderline() const;

    bool fontStrikeOut() const;
    void setFontStrikeOut( bool );
    bool definesFontStrikeOut() const;

    bool isAnchor() const;
    void setAnchor(bool anc);

    enum WhiteSpaceMode { WhiteSpaceNormal, WhiteSpacePre, WhiteSpaceNoWrap };
    WhiteSpaceMode whiteSpaceMode() const;
    void setWhiteSpaceMode(WhiteSpaceMode m);

    enum Margin {
        MarginLeft,
        MarginRight,
        MarginTop,
        MarginBottom,
        MarginFirstLine,
        MarginAll,
        MarginVertical,
        MarginHorizontal
    };

    int margin( Margin m) const;
    void setMargin( Margin, int);

    enum ListStyle {
        ListDisc,
        ListCircle,
        ListSquare,
        ListDecimal,
        ListLowerAlpha,
        ListUpperAlpha
    };

    ListStyle listStyle() const;
    void setListStyle( ListStyle );

    QString contexts() const;
    void setContexts( const QString& );
    bool allowedInContext( const QStyleSheetItem* ) const;

    bool selfNesting() const;
    void setSelfNesting( bool );

    void setLineSpacing( int ls );
    int lineSpacing() const;

private:
    void init();
    QStyleSheetItemData* d;
};
# 186 "/coolo/prod/qt-copy/include/qstylesheet.h"
class QTextCustomItem;


class QStyleSheet : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QStyleSheet( QObject *parent=0, const char *name=0 );
    virtual ~QStyleSheet();

    static QStyleSheet* defaultSheet();
    static void setDefaultSheet( QStyleSheet* );


    QStyleSheetItem* item( const QString& name);
    const QStyleSheetItem* item( const QString& name) const;

    void insert( QStyleSheetItem* item);


    virtual QTextCustomItem* tag( const QString& name,
                                  const QMap<QString, QString> &attr,
                                  const QString& context,
                                  const QMimeSourceFactory& factory,
                                  bool emptyTag, QTextDocument *doc ) const;

    static QString escape( const QString& );
    static QString convertFromPlainText( const QString&,
                                         QStyleSheetItem::WhiteSpaceMode mode = QStyleSheetItem::WhiteSpacePre );
    static bool mightBeRichText( const QString& );

    virtual void scaleFont( QFont& font, int logicalSize ) const;

    virtual void error( const QString& ) const;

private:
    void init();
    QDict<QStyleSheetItem> styles;
    QStyleSheetItem* nullstyle;
private:

    QStyleSheet( const QStyleSheet & );
    QStyleSheet &operator=( const QStyleSheet & );

};
# 44 "/coolo/prod/qt-copy/include/qtextedit.h" 2
# 52 "/coolo/prod/qt-copy/include/qtextedit.h"

class QPainter;
class QTextDocument;
class QTextCursor;
class QKeyEvent;
class QResizeEvent;
class QMouseEvent;
class QTimer;
class QTextString;
class QTextCommand;
class QTextParagraph;
class QTextFormat;
class QFont;
class QColor;
class QTextEdit;
class QTextBrowser;
class QTextString;
struct QUndoRedoInfoPrivate;
class QPopupMenu;
class QTextEditPrivate;
class QSyntaxHighlighter;


class QTextEditOptimPrivate
{
public:


    enum TagType { Color = 0, Format = 1 };
    struct Tag {
        TagType type:2;
        bool bold:1;
        bool italic:1;
        bool underline:1;
        int line;
        int index;
        Tag * leftTag;
        Tag * parent;
        Tag * prev;
        Tag * next;
        QString tag;
    };
    QTextEditOptimPrivate()
    {
        len = numLines = maxLineWidth = 0;
        selStart.line = selStart.index = -1;
        selEnd.line = selEnd.index = -1;
        search.line = search.index = 0;
        tags = lastTag = 0;
    }
    ~QTextEditOptimPrivate()
    {
        clearTags();
    }
    void clearTags()
    {
        Tag * itr = tags;
        while ( tags ) {
            itr = tags;
            tags = tags->next;
            delete itr;
        }
        tags = lastTag = 0;
        tagIndex.clear();
    }
    int len;
    int numLines;
    int maxLineWidth;
    struct Selection {
        int line;
        int index;
    };
    Selection selStart, selEnd, search;
    Tag * tags, * lastTag;
    QMap<int, QString> lines;
    QMap<int, Tag *> tagIndex;
};


class QTextEdit : public QScrollView
{
    friend class QTextBrowser;
    friend class QSyntaxHighlighter;

    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

public:
    enum WordWrap {
        NoWrap,
        WidgetWidth,
        FixedPixelWidth,
        FixedColumnWidth
    };

    enum WrapPolicy {
        AtWordBoundary,
        AtWhiteSpace = AtWordBoundary,
        Anywhere,
        AtWordOrDocumentBoundary
    };

    enum AutoFormatting {
        AutoNone = 0,
        AutoBulletList = 0x00000001,
        AutoAll = 0xffffffff
    };

    enum KeyboardAction {
        ActionBackspace,
        ActionDelete,
        ActionReturn,
        ActionKill,
        ActionWordBackspace,
        ActionWordDelete
    };

    enum CursorAction {
        MoveBackward,
        MoveForward,
        MoveWordBackward,
        MoveWordForward,
        MoveUp,
        MoveDown,
        MoveLineStart,
        MoveLineEnd,
        MoveHome,
        MoveEnd,
        MovePgUp,
        MovePgDown
    };

    enum VerticalAlignment {
        AlignNormal,
        AlignSuperScript,
        AlignSubScript
    };

    enum TextInsertionFlags {
        RedoIndentation = 0x0001,
        CheckNewLines = 0x0002,
        RemoveSelected = 0x0004
    };

    QTextEdit( const QString& text, const QString& context = QString::null,
               QWidget* parent=0, const char* name=0);
    QTextEdit( QWidget* parent=0, const char* name=0 );
    virtual ~QTextEdit();
    void setPalette( const QPalette & );

    QString text() const;
    QString text( int para ) const;
    TextFormat textFormat() const;
    QString context() const;
    QString documentTitle() const;

    void getSelection( int *paraFrom, int *indexFrom,
                    int *paraTo, int *indexTo, int selNum = 0 ) const;
    virtual bool find( const QString &expr, bool cs, bool wo, bool forward = TRUE,
                       int *para = 0, int *index = 0 );

    int paragraphs() const;
    int lines() const;
    int linesOfParagraph( int para ) const;
    int lineOfChar( int para, int chr );
    int length() const;
    QRect paragraphRect( int para ) const;
    int paragraphAt( const QPoint &pos ) const;
    int charAt( const QPoint &pos, int *para ) const;
    int paragraphLength( int para ) const;

    QStyleSheet* styleSheet() const;

    QMimeSourceFactory* mimeSourceFactory() const;

    QBrush paper() const;
    bool linkUnderline() const;

    int heightForWidth( int w ) const;

    bool hasSelectedText() const;
    QString selectedText() const;
    bool isUndoAvailable() const;
    bool isRedoAvailable() const;

    WordWrap wordWrap() const;
    int wrapColumnOrWidth() const;
    WrapPolicy wrapPolicy() const;

    int tabStopWidth() const;

    QString anchorAt( const QPoint& pos );
    QString anchorAt( const QPoint& pos, AnchorAttribute a );

    QSize sizeHint() const;

    bool isReadOnly() const { return readonly; }

    void getCursorPosition( int *parag, int *index ) const;

    bool isModified() const;
    bool italic() const;
    bool bold() const;
    bool underline() const;
    QString family() const;
    int pointSize() const;
    QColor color() const;
    QFont font() const;
    QFont currentFont() const;
    int alignment() const;
    int undoDepth() const;


    virtual bool getFormat( int para, int index, QFont *font, QColor *color, VerticalAlignment *verticalAlignment );

    virtual bool getParagraphFormat( int para, QFont *font, QColor *color,
                                     VerticalAlignment *verticalAlignment, int *alignment,
                                     QStyleSheetItem::DisplayMode *displayMode,
                                     QStyleSheetItem::ListStyle *listStyle,
                                     int *listDepth );


    bool isOverwriteMode() const { return overWrite; }
    QColor paragraphBackgroundColor( int para ) const;

    bool isUndoRedoEnabled() const;
    bool eventFilter( QObject *o, QEvent *e );
    bool tabChangesFocus() const;

    void setAutoFormatting( uint features );
    uint autoFormatting() const;

public :
    void setEnabled( bool );

    virtual void setMimeSourceFactory( QMimeSourceFactory* factory );

    virtual void setStyleSheet( QStyleSheet* styleSheet );
    virtual void scrollToAnchor( const QString& name );
    virtual void setPaper( const QBrush& pap );
    virtual void setLinkUnderline( bool );

    virtual void setWordWrap( WordWrap mode );
    virtual void setWrapColumnOrWidth( int );
    virtual void setWrapPolicy( WrapPolicy policy );

    virtual void copy();
    virtual void append( const QString& text );

    void setText( const QString &txt ) { setText( txt, QString::null ); }
    virtual void setText( const QString &txt, const QString &context );
    virtual void setTextFormat( TextFormat f );

    virtual void selectAll( bool select = TRUE );
    virtual void setTabStopWidth( int ts );
    virtual void zoomIn( int range );
    virtual void zoomIn() { zoomIn( 1 ); }
    virtual void zoomOut( int range );
    virtual void zoomOut() { zoomOut( 1 ); }
    virtual void zoomTo( int size );

    virtual void sync();
    virtual void setReadOnly( bool b );

    virtual void undo();
    virtual void redo();
    virtual void cut();
    virtual void paste();

    virtual void pasteSubType( const QCString &subtype );

    virtual void clear();
    virtual void del();
    virtual void indent();
    virtual void setItalic( bool b );
    virtual void setBold( bool b );
    virtual void setUnderline( bool b );
    virtual void setFamily( const QString &f );
    virtual void setPointSize( int s );
    virtual void setColor( const QColor &c );
    virtual void setFont( const QFont &f );
    virtual void setVerticalAlignment( VerticalAlignment a );
    virtual void setAlignment( int a );


    virtual void setParagType( QStyleSheetItem::DisplayMode dm, QStyleSheetItem::ListStyle listStyle );

    virtual void setCursorPosition( int parag, int index );
    virtual void setSelection( int parag_from, int index_from, int parag_to, int index_to, int selNum = 0 );
    virtual void setSelectionAttributes( int selNum, const QColor &back, bool invertText );
    virtual void setModified( bool m );
    virtual void resetFormat();
    virtual void setUndoDepth( int d );
    virtual void setFormat( QTextFormat *f, int flags );
    virtual void ensureCursorVisible();
    virtual void placeCursor( const QPoint &pos, QTextCursor *c = 0 );
    virtual void moveCursor( CursorAction action, bool select );
    virtual void doKeyboardAction( KeyboardAction action );
    virtual void removeSelectedText( int selNum = 0 );
    virtual void removeSelection( int selNum = 0 );
    virtual void setCurrentFont( const QFont &f );
    virtual void setOverwriteMode( bool b ) { overWrite = b; }

    virtual void scrollToBottom();

    void insert( const QString &text, uint insertionFlags = CheckNewLines | RemoveSelected );


    virtual void insert( const QString &text, bool, bool = TRUE, bool = TRUE );

    virtual void insertAt( const QString &text, int para, int index );
    virtual void removeParagraph( int para );
    virtual void insertParagraph( const QString &text, int para );

    virtual void setParagraphBackgroundColor( int para, const QColor &bg );
    virtual void clearParagraphBackground( int para );

    virtual void setUndoRedoEnabled( bool b );
    void setTabChangesFocus( bool b );


    void polish();
    void setMaxLogLines( int numLines );
    int maxLogLines();


protected:
    void textChanged();
    void selectionChanged();
    void copyAvailable( bool );
    void undoAvailable( bool yes );
    void redoAvailable( bool yes );
    void currentFontChanged( const QFont &f );
    void currentColorChanged( const QColor &c );
    void currentAlignmentChanged( int a );
    void currentVerticalAlignmentChanged( VerticalAlignment a );
    void cursorPositionChanged( QTextCursor *c );
    void cursorPositionChanged( int para, int pos );
    void returnPressed();
    void modificationChanged( bool m );
    void clicked( int parag, int index );
    void doubleClicked( int parag, int index );

protected:
    void repaintChanged();
    void updateStyles();
    void drawContents( QPainter *p, int cx, int cy, int cw, int ch );
    bool event( QEvent *e );
    void keyPressEvent( QKeyEvent *e );
    void resizeEvent( QResizeEvent *e );
    void viewportResizeEvent( QResizeEvent* );
    void contentsMousePressEvent( QMouseEvent *e );
    void contentsMouseMoveEvent( QMouseEvent *e );
    void contentsMouseReleaseEvent( QMouseEvent *e );
    void contentsMouseDoubleClickEvent( QMouseEvent *e );

    void contentsWheelEvent( QWheelEvent *e );

    void imStartEvent( QIMEvent * );
    void imComposeEvent( QIMEvent * );
    void imEndEvent( QIMEvent * );

    void contentsDragEnterEvent( QDragEnterEvent *e );
    void contentsDragMoveEvent( QDragMoveEvent *e );
    void contentsDragLeaveEvent( QDragLeaveEvent *e );
    void contentsDropEvent( QDropEvent *e );

    void contentsContextMenuEvent( QContextMenuEvent *e );
    bool focusNextPrevChild( bool next );
    QTextDocument *document() const;
    QTextCursor *textCursor() const;
    void setDocument( QTextDocument *doc );
    virtual QPopupMenu *createPopupMenu( const QPoint& pos );
    virtual QPopupMenu *createPopupMenu();
    void drawCursor( bool visible );

    void windowActivationChange( bool );

protected :
    virtual void doChangeInterval();
    void sliderReleased();




private :
    void formatMore();
    void doResize();
    void autoScrollTimerDone();
    void blinkCursor();
    void setModified();
    void startDrag();
    void documentWidthChanged( int w );
    void clipboardChanged();

private:
    struct UndoRedoInfo {
        enum Type { Invalid, Insert, Delete, Backspace, Return, RemoveSelected, Format, Style };

        UndoRedoInfo( QTextDocument *dc );
        ~UndoRedoInfo();
        void clear();
        bool valid() const;

        QUndoRedoInfoPrivate *d;
        int id;
        int index;
        int eid;
        int eindex;
        QTextFormat *format;
        int flags;
        Type type;
        QTextDocument *doc;
        QByteArray styleInformation;
    };

private:
    void updateCursor( const QPoint & pos );
    void handleMouseMove( const QPoint& pos );
    void drawContents( QPainter * );
    virtual bool linksEnabled() const { return FALSE; }
    void init();
    void checkUndoRedoInfo( UndoRedoInfo::Type t );
    void updateCurrentFormat();
    bool handleReadOnlyKeyEvent( QKeyEvent *e );
    void makeParagVisible( QTextParagraph *p );
    void normalCopy();
    void copyToClipboard();

    QCString pickSpecial(QMimeSource* ms, bool always_ask, const QPoint&);
    QTextDrag *dragObject( QWidget *parent = 0 ) const;


    void pasteSpecial(const QPoint&);

    void setFontInternal( const QFont &f );

    virtual void emitHighlighted( const QString & ) {}
    virtual void emitLinkClicked( const QString & ) {}

    void readFormats( QTextCursor &c1, QTextCursor &c2, QTextString &text, bool fillStyles = FALSE );
    void clearUndoRedo();
    void paintDocument( bool drawAll, QPainter *p, int cx = -1, int cy = -1, int cw = -1, int ch = -1 );
    void moveCursor( CursorAction action );
    void ensureFormatted( QTextParagraph *p );
    void placeCursor( const QPoint &pos, QTextCursor *c, bool link );
    void updateMicroFocusHint();


    bool checkOptimMode();
    QString optimText() const;
    void optimSetText( const QString &str );
    void optimAppend( const QString &str );
    void optimInsert( const QString &str, int line, int index );
    void optimDrawContents( QPainter * p, int cx, int cy, int cw, int ch );
    void optimMousePressEvent( QMouseEvent * e );
    void optimMouseReleaseEvent( QMouseEvent * e );
    void optimMouseMoveEvent( QMouseEvent * e );
    int optimCharIndex( const QString &str, int mx ) const;
    void optimSelectAll();
    void optimRemoveSelection();
    void optimSetSelection( int startLine, int startIdx, int endLine,
                            int endIdx );
    bool optimHasSelection() const;
    QString optimSelectedText() const;
    bool optimFind( const QString & str, bool, bool, bool, int *, int * );
    void optimParseTags( QString * str, int lineNo = -1, int indexOffset = 0 );
    QTextEditOptimPrivate::Tag * optimPreviousLeftTag( int line );
    void optimSetTextFormat( QTextDocument *, QTextCursor *, QTextFormat * f,
                             int, int, QTextEditOptimPrivate::Tag * t );
    QTextEditOptimPrivate::Tag * optimAppendTag( int index, const QString & tag );
    QTextEditOptimPrivate::Tag * optimInsertTag( int line, int index, const QString & tag );
    void optimCheckLimit( const QString& str );

private :
    void optimDoAutoScroll();


private:

    void pasteSubType( const QCString &subtype, QMimeSource *m );


private:
    QTextDocument *doc;
    QTextCursor *cursor;
    QTimer *formatTimer, *scrollTimer, *changeIntervalTimer, *blinkTimer, *dragStartTimer;
    QTextParagraph *lastFormatted;
    int interval;
    UndoRedoInfo undoRedoInfo;
    QTextFormat *currentFormat;
    int currentAlignment;
    QPoint oldMousePos, mousePos;
    QPoint dragStartPos;
    QString onLink;
    WordWrap wrapMode;
    WrapPolicy wPolicy;
    int wrapWidth;
    QString pressedLink;
    QTextEditPrivate *d;
    bool inDoubleClick : 1;
    bool mousePressed : 1;
    bool cursorVisible : 1;
    bool blinkCursorVisible : 1;
    bool readOnly : 1;
    bool modified : 1;
    bool mightStartDrag : 1;
    bool inDnD : 1;
    bool readonly : 1;
    bool undoEnabled : 1;
    bool overWrite : 1;

private:

    QTextEdit( const QTextEdit & );
    QTextEdit &operator=( const QTextEdit & );

};

inline QTextDocument *QTextEdit::document() const
{
    return doc;
}

inline QTextCursor *QTextEdit::textCursor() const
{
    return cursor;
}

inline void QTextEdit::setCurrentFont( const QFont &f )
{
    QTextEdit::setFontInternal( f );
}
# 38 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qsessionmanager.h" 1
# 39 "/coolo/prod/qt-copy/include/qsessionmanager.h"
# 49 "/coolo/prod/qt-copy/include/qsessionmanager.h"
class QSessionManagerData;

class QSessionManager : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    QSessionManager( QApplication *app, QString &id, QString &key );
    ~QSessionManager();
public:
    QString sessionId() const;
    QString sessionKey() const;

    void* handle() const;


    bool allowsInteraction();
    bool allowsErrorInteraction();
    void release();

    void cancel();

    enum RestartHint {
        RestartIfRunning,
        RestartAnyway,
        RestartImmediately,
        RestartNever
    };
    void setRestartHint( RestartHint );
    RestartHint restartHint() const;

    void setRestartCommand( const QStringList& );
    QStringList restartCommand() const;
    void setDiscardCommand( const QStringList& );
    QStringList discardCommand() const;

    void setManagerProperty( const QString& name, const QString& value );
    void setManagerProperty( const QString& name, const QStringList& value );

    bool isPhase2() const;
    void requestPhase2();

private:
    friend class QApplication;
    friend class QBaseApplication;
    QSessionManagerData* d;
};
# 39 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qtimer.h" 1
# 39 "/coolo/prod/qt-copy/include/qtimer.h"






class QTimer : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QTimer( QObject *parent=0, const char *name=0 );
   ~QTimer();

    bool isActive() const;

    int start( int msec, bool sshot = FALSE );
    void changeInterval( int msec );
    void stop();

    static void singleShot( int msec, QObject *receiver, const char *member );

    int timerId() const { return id; }

protected:
    void timeout();

protected:
    bool event( QEvent * );

private:
    int id;
    uint single : 1;
    uint nulltimer : 1;

private:

    QTimer( const QTimer & );
    QTimer &operator=( const QTimer & );

};


inline bool QTimer::isActive() const
{
    return id >= 0;
}
# 41 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qpixmapcache.h" 1
# 39 "/coolo/prod/qt-copy/include/qpixmapcache.h"


# 1 "/coolo/prod/qt-copy/include/qpixmap.h" 1
# 39 "/coolo/prod/qt-copy/include/qpixmap.h"
# 48 "/coolo/prod/qt-copy/include/qpixmap.h"
class QGfx;
class QPixmapPrivate;







class QPixmap : public QPaintDevice, public Qt
{
public:
    enum ColorMode { Auto, Color, Mono };
    enum Optimization { DefaultOptim, NoOptim, MemoryOptim=NoOptim,
                        NormalOptim, BestOptim };

    QPixmap();
    QPixmap( const QImage& image );
    QPixmap( int w, int h, int depth = -1, Optimization = DefaultOptim );
    QPixmap( const QSize &, int depth = -1, Optimization = DefaultOptim );

    QPixmap( const QString& fileName, const char *format=0,
             ColorMode mode=Auto );
    QPixmap( const QString& fileName, const char *format,
             int conversion_flags );
    QPixmap( const char *xpm[] );
    QPixmap( const QByteArray &data );

    QPixmap( const QPixmap & );
   ~QPixmap();

    QPixmap &operator=( const QPixmap & );
    QPixmap &operator=( const QImage & );

    bool isNull() const;

    int width() const { return data->w; }
    int height() const { return data->h; }
    QSize size() const { return QSize(data->w,data->h); }
    QRect rect() const { return QRect(0,0,data->w,data->h); }
    int depth() const { return data->d; }
    static int defaultDepth();

    void fill( const QColor &fillColor = Qt::white );
    void fill( const QWidget *, int xofs, int yofs );
    void fill( const QWidget *, const QPoint &ofs );
    void resize( int width, int height );
    void resize( const QSize & );

    const QBitmap *mask() const;
    void setMask( const QBitmap & );
    bool selfMask() const;
    bool hasAlpha() const;
    bool hasAlphaChannel() const;

    QBitmap createHeuristicMask( bool clipTight = TRUE ) const;


    static QPixmap fromMimeSource( const QString& abs_name );

    static QPixmap grabWindow( WId, int x=0, int y=0, int w=-1, int h=-1 );
    static QPixmap grabWidget( QWidget * widget,
                                int x=0, int y=0, int w=-1, int h=-1 );


    QPixmap xForm( const QWMatrix & ) const;
    static QWMatrix trueMatrix( const QWMatrix &, int w, int h );


    QImage convertToImage() const;
    bool convertFromImage( const QImage &, ColorMode mode=Auto );
    bool convertFromImage( const QImage &, int conversion_flags );

    static const char* imageFormat( const QString &fileName );
    bool load( const QString& fileName, const char *format=0,
                      ColorMode mode=Auto );
    bool load( const QString& fileName, const char *format,
                      int conversion_flags );
    bool loadFromData( const uchar *buf, uint len,
                              const char* format=0,
                              ColorMode mode=Auto );
    bool loadFromData( const uchar *buf, uint len,
                              const char* format,
                              int conversion_flags );
    bool loadFromData( const QByteArray &data,
                              const char* format=0,
                              int conversion_flags=0 );
    bool save( const QString& fileName, const char* format, int quality = -1 ) const;
    bool save( QIODevice* device, const char* format, int quality = -1 ) const;






    int serialNumber() const;

    Optimization optimization() const;
    void setOptimization( Optimization );
    static Optimization defaultOptimization();
    static void setDefaultOptimization( Optimization );

    virtual void detach();

    bool isQBitmap() const;
# 171 "/coolo/prod/qt-copy/include/qpixmap.h"
    static int x11SetDefaultScreen( int screen );
    void x11SetScreen( int screen );


   

protected:
    QPixmap( int w, int h, const uchar *data, bool isXbitmap );
    int metric( int ) const;
# 188 "/coolo/prod/qt-copy/include/qpixmap.h"
    struct QPixmapData : public QShared {
        QCOORD w, h;
        short d;
        uint uninit : 1;
        uint bitmap : 1;
        uint selfmask : 1;



        int ser_no;
        QBitmap *mask;
# 210 "/coolo/prod/qt-copy/include/qpixmap.h"
        void *ximage;
        void *maskgc;
        QPixmap *alphapm;
# 224 "/coolo/prod/qt-copy/include/qpixmap.h"
        Optimization optim;



    } *data;
private:

    bool doImageIO( QImageIO* io, int quality ) const;

    QPixmap( int w, int h, int depth, bool, Optimization );
    void init( int, int, int, bool, Optimization );
    void deref();
    QPixmap copy( bool ignoreMask = FALSE ) const;







    static Optimization defOptim;
    friend void bitBlt( QPaintDevice *, int, int,
                                 const QPaintDevice *,
                                 int, int, int, int, RasterOp, bool );
    friend void bitBlt( QPaintDevice *, int, int,
                                 const QImage* src,
                                 int, int, int, int, int conversion_flags );
    friend void copyBlt( QPixmap *dst, int dx, int dy,
                                  const QPixmap *src, int sx, int sy,
                                  int sw, int sh );







    friend class QBitmap;
    friend class QPaintDevice;
    friend class QPainter;
};


inline bool QPixmap::isNull() const
{
    return data->w == 0;
}

inline void QPixmap::fill( const QWidget *w, const QPoint &ofs )
{
    fill( w, ofs.x(), ofs.y() );
}

inline void QPixmap::resize( const QSize &s )
{
    resize( s.width(), s.height() );
}

inline const QBitmap *QPixmap::mask() const
{
    return data->mask;
}

inline bool QPixmap::selfMask() const
{
    return data->selfmask;
}
# 299 "/coolo/prod/qt-copy/include/qpixmap.h"
inline int QPixmap::serialNumber() const
{
    return data->ser_no;
}

inline QPixmap::Optimization QPixmap::optimization() const
{
    return data->optim;
}

inline bool QPixmap::isQBitmap() const
{
    return data->bitmap;
}
# 327 "/coolo/prod/qt-copy/include/qpixmap.h"
 QDataStream &operator<<( QDataStream &, const QPixmap & );
 QDataStream &operator>>( QDataStream &, QPixmap & );










bool qt_xForm_helper( const QWMatrix&, int, int, int, uchar*, int, int, int, uchar*, int, int, int );


 void copyBlt( QPixmap *dst, int dx, int dy,
                       const QPixmap *src, int sx = 0, int sy = 0,
                       int sw = -1, int sh = -1 );
# 43 "/coolo/prod/qt-copy/include/qpixmapcache.h" 2



class QPixmapCache
{
public:
    static int cacheLimit();
    static void setCacheLimit( int );
    static QPixmap *find( const QString &key );
    static bool find( const QString &key, QPixmap& );
    static bool insert( const QString &key, QPixmap * );
    static bool insert( const QString &key, const QPixmap& );
    static void remove( const QString &key );
    static void clear();
};
# 43 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qtooltip.h" 1
# 37 "/coolo/prod/qt-copy/include/qtooltip.h"
# 46 "/coolo/prod/qt-copy/include/qtooltip.h"
class QTipManager;
class QIconViewToolTip;
class QListViewToolTip;

class QToolTipGroup: public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   

public:
    QToolTipGroup( QObject *parent, const char *name = 0 );
   ~QToolTipGroup();

    bool delay() const;
    bool enabled() const;

public :
    void setDelay( bool );
    void setEnabled( bool );

protected:
    void showTip( const QString &);
    void removeTip();

private:
    uint del:1;
    uint ena:1;

    friend class QTipManager;

private:

    QToolTipGroup( const QToolTipGroup & );
    QToolTipGroup& operator=( const QToolTipGroup & );

};


class QToolTip: public Qt
{
public:
    QToolTip( QWidget *, QToolTipGroup * = 0 );


    static void add( QWidget *, const QString &);
    static void add( QWidget *, const QString &,
                     QToolTipGroup *, const QString& );
    static void remove( QWidget * );

    static void add( QWidget *, const QRect &, const QString &);
    static void add( QWidget *, const QRect &, const QString &,
                     QToolTipGroup *, const QString& );
    static void remove( QWidget *, const QRect & );

    static QString textFor( QWidget *, const QPoint & pos = QPoint() );

    static void hide();

    static QFont font();
    static void setFont( const QFont & );
    static QPalette palette();
    static void setPalette( const QPalette & );





    static void setGloballyEnabled( bool );
    static bool isGloballyEnabled();
    static void setWakeUpDelay(int);

protected:
    virtual void maybeTip( const QPoint & ) = 0;
    void tip( const QRect &, const QString &);
    void tip( const QRect &, const QString& , const QString &);
    void tip( const QRect &, const QString &, const QRect & );
    void tip( const QRect &, const QString&, const QString &, const QRect &);

    void clear();

public:
    QWidget *parentWidget() const { return p; }
    QToolTipGroup *group() const { return g; }

private:
    QWidget *p;
    QToolTipGroup *g;
    static QFont *ttFont;
    static QPalette *ttPalette;

    friend class QTipManager;
};
# 44 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qstylefactory.h" 1
# 37 "/coolo/prod/qt-copy/include/qstylefactory.h"







class QString;
class QStyle;

class QStyleFactory
{
public:

    static QStringList keys();

    static QStyle *create( const QString& );
};
# 45 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qmetaobject.h" 1
# 39 "/coolo/prod/qt-copy/include/qmetaobject.h"


# 1 "/coolo/prod/qt-copy/include/qconnection.h" 1
# 39 "/coolo/prod/qt-copy/include/qconnection.h"





class QConnection
{
public:
    QConnection( const QObject *, int, const char *memberName, int memberType );
   ~QConnection() {}

    bool isConnected() const { return obj != 0; }

    QObject *object() const { return obj; }
    int member() const { return mbr; }
    const char *memberName() const { return mbr_name; }
    int memberType() const { return mbr_type; }
    int numArgs() const { return nargs; }

private:
    QObject *obj;
    int mbr;
    const char *mbr_name;
    int mbr_type;
    int nargs;

private:

    QConnection( const QConnection & );
    QConnection &operator=( const QConnection & );

};

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 75 "/coolo/prod/qt-copy/include/qconnection.h" 2
# 43 "/coolo/prod/qt-copy/include/qmetaobject.h" 2






class QObject;
struct QUMethod;
class QMetaObjectPrivate;

struct QMetaData
{
    const char *name;
    const QUMethod* method;
    enum Access { Private, Protected, Public };
    Access access;
};


struct QMetaEnum
{
    const char *name;
    uint count;
    struct Item
    {
        const char *key;
        int value;
    };
    const Item *items;
    bool set;
};




class QMetaProperty
{
public:
    const char* type() const { return t; }
    const char* name() const { return n; }

    bool writable() const;
    bool isValid() const;

    bool isSetType() const;
    bool isEnumType() const;
    QStrList enumKeys() const;

    int keyToValue( const char* key ) const;
    const char* valueToKey( int value ) const;
    int keysToValue( const QStrList& keys ) const;
    QStrList valueToKeys( int value ) const;

    bool designable( QObject* = 0 ) const;
    bool scriptable( QObject* = 0 ) const;
    bool stored( QObject* = 0 ) const;

    bool reset( QObject* ) const;

    const char* t;
    const char* n;

    enum Flags {
        Invalid = 0x00000000,
        Readable = 0x00000001,
        Writable = 0x00000002,
        EnumOrSet = 0x00000004,
        UnresolvedEnum = 0x00000008,
        StdSet = 0x00000100,
        Override = 0x00000200
    };

    uint flags;
    bool testFlags( uint f ) const;
    bool stdSet() const;
    int id() const;

    QMetaObject** meta;

    const QMetaEnum* enumData;
    int _id;
    void clear();
};

inline bool QMetaProperty::testFlags( uint f ) const
{ return (flags & (uint)f) != (uint)0; }



struct QClassInfo
{
    const char* name;
    const char* value;
};

class QMetaObject
{
public:
    QMetaObject( const char * const class_name, QMetaObject *superclass,
                 const QMetaData * const slot_data, int n_slots,
                 const QMetaData * const signal_data, int n_signals,

                 const QMetaProperty *const prop_data, int n_props,
                 const QMetaEnum *const enum_data, int n_enums,

                 const QClassInfo *const class_info, int n_info );


    QMetaObject( const char * const class_name, QMetaObject *superclass,
                 const QMetaData * const slot_data, int n_slots,
                 const QMetaData * const signal_data, int n_signals,
                 const QMetaProperty *const prop_data, int n_props,
                 const QMetaEnum *const enum_data, int n_enums,
                 bool (*qt_static_property)(QObject*, int, int, QVariant*),
                 const QClassInfo *const class_info, int n_info );



    virtual ~QMetaObject();

    const char *className() const { return classname; }
    const char *superClassName() const { return superclassname; }

    QMetaObject *superClass() const { return superclass; }

    bool inherits( const char* clname ) const;

    int numSlots( bool super = FALSE ) const;
    int numSignals( bool super = FALSE ) const;

    int findSlot( const char *, bool super = FALSE ) const;
    int findSignal( const char *, bool super = FALSE ) const;

    const QMetaData *slot( int index, bool super = FALSE ) const;
    const QMetaData *signal( int index, bool super = FALSE ) const;

    QStrList slotNames( bool super = FALSE ) const;
    QStrList signalNames( bool super = FALSE ) const;

    int slotOffset() const;
    int signalOffset() const;
    int propertyOffset() const;

    int numClassInfo( bool super = FALSE ) const;
    const QClassInfo *classInfo( int index, bool super = FALSE ) const;
    const char *classInfo( const char* name, bool super = FALSE ) const;


    const QMetaProperty *property( int index, bool super = FALSE ) const;
    int findProperty( const char *name, bool super = FALSE ) const;
    int indexOfProperty( const QMetaProperty*, bool super = FALSE ) const;
    const QMetaProperty* resolveProperty( const QMetaProperty* ) const;
    int resolveProperty( int ) const;
    QStrList propertyNames( bool super = FALSE ) const;
    int numProperties( bool super = FALSE ) const;





    static QMetaObject *new_metaobject( const char *, QMetaObject *,
                                        const QMetaData *const, int,
                                        const QMetaData *const, int,

                                        const QMetaProperty *const prop_data, int n_props,
                                        const QMetaEnum *const enum_data, int n_enums,

                                        const QClassInfo *const class_info, int n_info );

    static QMetaObject *new_metaobject( const char *, QMetaObject *,
                                        const QMetaData *const, int,
                                        const QMetaData *const, int,
                                        const QMetaProperty *const prop_data, int n_props,
                                        const QMetaEnum *const enum_data, int n_enums,
                                         bool (*qt_static_property)(QObject*, int, int, QVariant*),
                                        const QClassInfo *const class_info, int n_info );
    QStrList enumeratorNames( bool super = FALSE ) const;
    int numEnumerators( bool super = FALSE ) const;
    const QMetaEnum *enumerator( const char* name, bool super = FALSE ) const;


    static QMetaObject *metaObject( const char *class_name );
    static bool hasMetaObject( const char *class_name );

private:
    QMemberDict *init( const QMetaData *, int );

    const char *classname;
    const char *superclassname;
    QMetaObject *superclass;
    QMetaObjectPrivate *d;
    void *reserved;
    const QMetaData *slotData;
    QMemberDict *slotDict;
    const QMetaData *signalData;
    QMemberDict *signalDict;
    int signaloffset;
    int slotoffset;

    int propertyoffset;
public:
    bool qt_static_property( QObject* o, int id, int f, QVariant* v);
private:
    friend class QMetaProperty;


private:

    QMetaObject( const QMetaObject & );
    QMetaObject &operator=( const QMetaObject & );

};

inline int QMetaObject::slotOffset() const
{ return slotoffset; }

inline int QMetaObject::signalOffset() const
{ return signaloffset; }


inline int QMetaObject::propertyOffset() const
{ return propertyoffset; }


typedef QMetaObject *(*QtStaticMetaObjectFunction)();

class QMetaObjectCleanUp
{
public:
    QMetaObjectCleanUp( const char *mo_name, QtStaticMetaObjectFunction );
    QMetaObjectCleanUp();
    ~QMetaObjectCleanUp();

    void setMetaObject( QMetaObject *&mo );

private:
    QMetaObject **metaObject;
};
# 46 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qsqlpropertymap.h" 1
# 38 "/coolo/prod/qt-copy/include/qsqlpropertymap.h"


# 1 "/coolo/prod/qt-copy/include/qvariant.h" 1
# 39 "/coolo/prod/qt-copy/include/qvariant.h"






class QString;
class QCString;
class QFont;
class QPixmap;
class QBrush;
class QRect;
class QPoint;
class QImage;
class QSize;
class QColor;
class QPalette;
class QColorGroup;
class QIconSet;
class QDataStream;
class QPointArray;
class QRegion;
class QBitmap;
class QCursor;
class QStringList;
class QSizePolicy;
class QDate;
class QTime;
class QDateTime;
class QBitArray;
class QKeySequence;
class QPen;

class QVariant;

template <class T> class QValueList;
template <class T> class QValueListConstIterator;
template <class T> class QValueListNode;
template <class Key, class T> class QMap;
template <class Key, class T> class QMapConstIterator;


class QVariant
{
public:
    enum Type {
        Invalid,
        Map,
        List,
        String,
        StringList,
        Font,
        Pixmap,
        Brush,
        Rect,
        Size,
        Color,
        Palette,
        ColorGroup,
        IconSet,
        Point,
        Image,
        Int,
        UInt,
        Bool,
        Double,
        CString,
        PointArray,
        Region,
        Bitmap,
        Cursor,
        SizePolicy,
        Date,
        Time,
        DateTime,
        ByteArray,
        BitArray,
        KeySequence,
        Pen,
        LongLong,
        ULongLong
    };

    QVariant();
    ~QVariant();
    QVariant( const QVariant& );

    QVariant( QDataStream& s );

    QVariant( const QString& );
    QVariant( const QCString& );
    QVariant( const char* );

    QVariant( const QStringList& );

    QVariant( const QFont& );
    QVariant( const QPixmap& );
    QVariant( const QImage& );
    QVariant( const QBrush& );
    QVariant( const QPoint& );
    QVariant( const QRect& );
    QVariant( const QSize& );
    QVariant( const QColor& );
    QVariant( const QPalette& );
    QVariant( const QColorGroup& );
    QVariant( const QIconSet& );
    QVariant( const QPointArray& );
    QVariant( const QRegion& );
    QVariant( const QBitmap& );
    QVariant( const QCursor& );
    QVariant( const QDate& );
    QVariant( const QTime& );
    QVariant( const QDateTime& );
    QVariant( const QByteArray& );
    QVariant( const QBitArray& );

    QVariant( const QKeySequence& );

    QVariant( const QPen& );

    QVariant( const QValueList<QVariant>& );
    QVariant( const QMap<QString,QVariant>& );

    QVariant( int );
    QVariant( uint );
    QVariant( Q_LLONG );
    QVariant( Q_ULLONG );

    QVariant( bool, int );
    QVariant( double );
    QVariant( QSizePolicy );

    QVariant& operator= ( const QVariant& );
    bool operator==( const QVariant& ) const;
    bool operator!=( const QVariant& ) const;

    Type type() const;
    const char* typeName() const;

    bool canCast( Type ) const;
    bool cast( Type );

    bool isValid() const;
    bool isNull() const;

    void clear();

    const QString toString() const;
    const QCString toCString() const;

    const QStringList toStringList() const;

    const QFont toFont() const;
    const QPixmap toPixmap() const;
    const QImage toImage() const;
    const QBrush toBrush() const;
    const QPoint toPoint() const;
    const QRect toRect() const;
    const QSize toSize() const;
    const QColor toColor() const;
    const QPalette toPalette() const;
    const QColorGroup toColorGroup() const;
    const QIconSet toIconSet() const;
    const QPointArray toPointArray() const;
    const QBitmap toBitmap() const;
    const QRegion toRegion() const;
    const QCursor toCursor() const;
    const QDate toDate() const;
    const QTime toTime() const;
    const QDateTime toDateTime() const;
    const QByteArray toByteArray() const;
    const QBitArray toBitArray() const;

    const QKeySequence toKeySequence() const;

    const QPen toPen() const;
    int toInt( bool * ok=0 ) const;
    uint toUInt( bool * ok=0 ) const;
    Q_LLONG toLongLong( bool * ok=0 ) const;
    Q_ULLONG toULongLong( bool * ok=0 ) const;
    bool toBool() const;
    double toDouble( bool * ok=0 ) const;

    const QValueList<QVariant> toList() const;
    const QMap<QString,QVariant> toMap() const;

    QSizePolicy toSizePolicy() const;


    QValueListConstIterator<QString> stringListBegin() const;
    QValueListConstIterator<QString> stringListEnd() const;
    QValueListConstIterator<QVariant> listBegin() const;
    QValueListConstIterator<QVariant> listEnd() const;
    QMapConstIterator<QString,QVariant> mapBegin() const;
    QMapConstIterator<QString,QVariant> mapEnd() const;
    QMapConstIterator<QString,QVariant> mapFind( const QString& ) const;

    QString& asString();
    QCString& asCString();

    QStringList& asStringList();

    QFont& asFont();
    QPixmap& asPixmap();
    QImage& asImage();
    QBrush& asBrush();
    QPoint& asPoint();
    QRect& asRect();
    QSize& asSize();
    QColor& asColor();
    QPalette& asPalette();
    QColorGroup& asColorGroup();
    QIconSet& asIconSet();
    QPointArray& asPointArray();
    QBitmap& asBitmap();
    QRegion& asRegion();
    QCursor& asCursor();
    QDate& asDate();
    QTime& asTime();
    QDateTime& asDateTime();
    QByteArray& asByteArray();
    QBitArray& asBitArray();

    QKeySequence& asKeySequence();

    QPen& asPen();
    int& asInt();
    uint& asUInt();
    Q_LLONG& asLongLong();
    Q_ULLONG& asULongLong();
    bool& asBool();
    double& asDouble();

    QValueList<QVariant>& asList();
    QMap<QString,QVariant>& asMap();

    QSizePolicy& asSizePolicy();


    void load( QDataStream& );
    void save( QDataStream& ) const;

    static const char* typeToName( Type typ );
    static Type nameToType( const char* name );

private:
    void detach();

    class Private : public QShared
    {
    public:
        Private();
        Private( Private* );
        ~Private();

        void clear();

        Type typ;
        union
        {
            uint u;
            int i;
            Q_LLONG ll;
            Q_ULLONG ull;
            bool b;
            double d;
            void *ptr;
        } value;
        uint is_null : 1;
    };

    Private* d;

public:
    void* rawAccess( void* ptr = 0, Type typ = Invalid, bool deepCopy = FALSE );
};
# 324 "/coolo/prod/qt-copy/include/qvariant.h"
inline QVariant::Type QVariant::type() const
{
    return d->typ;
}

inline bool QVariant::isValid() const
{
    return (d->typ != Invalid);
}


inline QValueListConstIterator<QString> QVariant::stringListBegin() const
{
    if ( d->typ != StringList )
        return QValueListConstIterator<QString>();
    return ((const QStringList*)d->value.ptr)->begin();
}

inline QValueListConstIterator<QString> QVariant::stringListEnd() const
{
    if ( d->typ != StringList )
        return QValueListConstIterator<QString>();
    return ((const QStringList*)d->value.ptr)->end();
}

inline QValueListConstIterator<QVariant> QVariant::listBegin() const
{
    if ( d->typ != List )
        return QValueListConstIterator<QVariant>();
    return ((const QValueList<QVariant>*)d->value.ptr)->begin();
}

inline QValueListConstIterator<QVariant> QVariant::listEnd() const
{
    if ( d->typ != List )
        return QValueListConstIterator<QVariant>();
    return ((const QValueList<QVariant>*)d->value.ptr)->end();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapBegin() const
{
    if ( d->typ != Map )
        return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->begin();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapEnd() const
{
    if ( d->typ != Map )
        return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->end();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapFind( const QString& key ) const
{
    if ( d->typ != Map )
        return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->find( key );
}



 QDataStream& operator>> ( QDataStream& s, QVariant& p );
 QDataStream& operator<< ( QDataStream& s, const QVariant& p );
 QDataStream& operator>> ( QDataStream& s, QVariant::Type& p );
 QDataStream& operator<< ( QDataStream& s, const QVariant::Type p );
# 42 "/coolo/prod/qt-copy/include/qsqlpropertymap.h" 2





class QWidget;
class QSqlPropertyMapPrivate;

class QSqlPropertyMap {
public:
    QSqlPropertyMap();
    virtual ~QSqlPropertyMap();

    QVariant property( QWidget * widget );
    virtual void setProperty( QWidget * widget, const QVariant & value );

    void insert( const QString & classname, const QString & property );
    void remove( const QString & classname );

    static QSqlPropertyMap * defaultMap();
    static void installDefaultMap( QSqlPropertyMap * map );

private:

    QSqlPropertyMap( const QSqlPropertyMap & );
    QSqlPropertyMap &operator=( const QSqlPropertyMap & );

    QSqlPropertyMapPrivate* d;

};
# 48 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2


#undef QT_NO_TRANSLATION
# 1 "/coolo/prod/kdelibs/kdecore/kapplication.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kapplication.h"


# 1 "/coolo/prod/kdelibs/kdecore/kdeversion.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kdeversion.h"








namespace KDE
{
# 49 "/coolo/prod/kdelibs/kdecore/kdeversion.h"
    unsigned int version();






    unsigned int versionMajor();






    unsigned int versionMinor();






    unsigned int versionRelease();





    const char *versionString();
}
# 28 "/coolo/prod/kdelibs/kdecore/kapplication.h" 2
# 1 "/coolo/prod/kdelibs/kdecore/kdemacros.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kdemacros.h"


# 75 "/coolo/prod/kdelibs/kdecore/kdemacros.h"
# 29 "/coolo/prod/kdelibs/kdecore/kapplication.h" 2

class KConfig;
class KCharsets;
class DCOPClient;
class DCOPObject;

typedef unsigned long Atom;




# 1 "/coolo/prod/qt-copy/include/qapplication.h" 1
# 39 "/coolo/prod/qt-copy/include/qapplication.h"


# 1 "/coolo/prod/qt-copy/include/qdesktopwidget.h" 1
# 37 "/coolo/prod/qt-copy/include/qdesktopwidget.h"





class QApplication;
class QDesktopWidgetPrivate;

class QDesktopWidget : public QWidget
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QDesktopWidget();
    ~QDesktopWidget();

    bool isVirtualDesktop() const;

    int numScreens() const;
    int primaryScreen() const;

    int screenNumber( QWidget *widget = 0 ) const;
    int screenNumber( const QPoint & ) const;

    QWidget *screen( int screen = -1 );

    const QRect& screenGeometry( int screen = -1 ) const;
    const QRect& screenGeometry( QWidget *widget ) const
    { return screenGeometry( screenNumber( widget ) ); }
    const QRect& screenGeometry( const QPoint &point ) const
    { return screenGeometry( screenNumber( point ) ); }

    const QRect& availableGeometry( int screen = -1 ) const;
    const QRect& availableGeometry( QWidget *widget ) const
    { return availableGeometry( screenNumber( widget ) ); }
    const QRect& availableGeometry( const QPoint &point ) const
    { return availableGeometry( screenNumber( point ) ); }

    void insertChild( QObject * );

protected:
    void resized( int );

protected:
    void resizeEvent( QResizeEvent *e );

private:
    QDesktopWidgetPrivate *d;


    QDesktopWidget( const QDesktopWidget & );
    QDesktopWidget &operator=( const QDesktopWidget & );


    friend class QApplication;
};
# 43 "/coolo/prod/qt-copy/include/qapplication.h" 2
# 1 "/coolo/prod/qt-copy/include/qasciidict.h" 1
# 39 "/coolo/prod/qt-copy/include/qasciidict.h"





template<class type>
class QAsciiDict



        : public QGDict

{
public:
    QAsciiDict(int size=17, bool caseSensitive=TRUE, bool copyKeys=TRUE )
        : QGDict(size,AsciiKey,caseSensitive,copyKeys) {}
    QAsciiDict( const QAsciiDict<type> &d ) : QGDict(d) {}
   ~QAsciiDict() { clear(); }
    QAsciiDict<type> &operator=(const QAsciiDict<type> &d)
                        { return (QAsciiDict<type>&)QGDict::operator=(d); }
    uint count() const { return QGDict::count(); }
    uint size() const { return QGDict::size(); }
    bool isEmpty() const { return QGDict::count() == 0; }

    void insert( const char *k, const type *d )
                                        { QGDict::look_ascii(k,(Item)d,1); }
    void replace( const char *k, const type *d )
                                        { QGDict::look_ascii(k,(Item)d,2); }
    bool remove( const char *k ) { return QGDict::remove_ascii(k); }
    type *take( const char *k ) { return (type *)QGDict::take_ascii(k); }
    type *find( const char *k ) const
                { return (type *)((QGDict*)this)->QGDict::look_ascii(k,0,0); }
    type *operator[]( const char *k ) const
                { return (type *)((QGDict*)this)->QGDict::look_ascii(k,0,0); }

    void clear() { QGDict::clear(); }
    void resize( uint n ) { QGDict::resize(n); }
    void statistics() const { QGDict::statistics(); }







private:
    void deleteItem( Item d );
};


template<> inline void QAsciiDict<void>::deleteItem( QPtrCollection::Item )
{
}


template<class type> inline void QAsciiDict<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}

template<class type>
class QAsciiDictIterator : public QGDictIterator
{
public:
    QAsciiDictIterator(const QAsciiDict<type> &d)
        : QGDictIterator((QGDict &)d) {}
   ~QAsciiDictIterator() {}
    uint count() const { return dict->count(); }
    bool isEmpty() const { return dict->count() == 0; }
    type *toFirst() { return (type *)QGDictIterator::toFirst(); }
    operator type *() const { return (type *)QGDictIterator::get(); }
    type *current() const { return (type *)QGDictIterator::get(); }
    const char *currentKey() const { return QGDictIterator::getKeyAscii(); }
    type *operator()() { return (type *)QGDictIterator::operator()(); }
    type *operator++() { return (type *)QGDictIterator::operator++(); }
    type *operator+=(uint j) { return (type *)QGDictIterator::operator+=(j);}
};

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 120 "/coolo/prod/qt-copy/include/qasciidict.h" 2
# 44 "/coolo/prod/qt-copy/include/qapplication.h" 2






class QSessionManager;
class QStyle;
class QTranslator;
class QEventLoop;





class QMutex;



class QApplication;
extern QApplication *qApp;


class QApplication : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QApplication( int &argc, char **argv );
    QApplication( int &argc, char **argv, bool GUIenabled );
    enum Type { Tty, GuiClient, GuiServer };
    QApplication( int &argc, char **argv, Type );

    QApplication( Display* dpy, HANDLE visual = 0, HANDLE cmap = 0 );
    QApplication( Display *dpy, int argc, char **argv,
                  HANDLE visual = 0, HANDLE cmap= 0 );

    virtual ~QApplication();

    int argc() const;
    char **argv() const;

    Type type() const;


    static QStyle &style();
    static void setStyle( QStyle* );
    static QStyle* setStyle( const QString& );


    enum ColorMode { NormalColors, CustomColors };
    static ColorMode colorMode();
    static void setColorMode( QApplication::ColorMode );


    enum ColorSpec { NormalColor=0, CustomColor=1, ManyColor=2 };
    static int colorSpec();
    static void setColorSpec( int );

    static QCursor *overrideCursor();
    static void setOverrideCursor( const QCursor &, bool replace=FALSE );
    static void restoreOverrideCursor();

    static bool hasGlobalMouseTracking();
    static void setGlobalMouseTracking( bool enable );

    static QPalette palette( const QWidget* = 0 );
    static void setPalette( const QPalette &, bool informWidgets=FALSE,
                                 const char* className = 0 );

    static QFont font( const QWidget* = 0 );
    static void setFont( const QFont &, bool informWidgets=FALSE,
                              const char* className = 0 );
    static QFontMetrics fontMetrics();

    QWidget *mainWidget() const;
    virtual void setMainWidget( QWidget * );
    virtual void polish( QWidget * );

    static QWidgetList *allWidgets();
    static QWidgetList *topLevelWidgets();

    static QDesktopWidget *desktop();

    static QWidget *activePopupWidget();
    static QWidget *activeModalWidget();

    static QClipboard *clipboard();

    QWidget *focusWidget() const;
    QWidget *activeWindow() const;

    static QWidget *widgetAt( int x, int y, bool child=FALSE );
    static QWidget *widgetAt( const QPoint &, bool child=FALSE );

    static QEventLoop *eventLoop();

    int exec();
    void processEvents();
    void processEvents( int maxtime );
    void processOneEvent();
    bool hasPendingEvents();
    int enter_loop();
    void exit_loop();
    int loopLevel() const;
    static void exit( int retcode=0 );

    static bool sendEvent( QObject *receiver, QEvent *event );
    static void postEvent( QObject *receiver, QEvent *event );
    static void sendPostedEvents( QObject *receiver, int event_type );
    static void sendPostedEvents();

    static void removePostedEvents( QObject *receiver );

    virtual bool notify( QObject *, QEvent * );

    static bool startingUp();
    static bool closingDown();

    static void flushX();
    static void flush();
    static void syncX();

    static void beep();



    void setDefaultCodec( QTextCodec * );
    QTextCodec* defaultCodec() const;

    void installTranslator( QTranslator * );
    void removeTranslator( QTranslator * );

    enum Encoding { DefaultCodec, UnicodeUTF8 };
    QString translate( const char * context,
                                const char * key,
                                const char * comment = 0,
                                Encoding encoding = DefaultCodec ) const;

    QString applicationDirPath();
    QString applicationFilePath();



    static void setWinStyleHighlightColor( const QColor &c ) {
        QPalette p( palette() );
        p.setColor( QColorGroup::Highlight, c );
        setPalette( p, TRUE);
    }
    static const QColor &winStyleHighlightColor() {
        return palette().active().highlight();
    }

    static void setDesktopSettingsAware( bool );
    static bool desktopSettingsAware();

    static void setCursorFlashTime( int );
    static int cursorFlashTime();

    static void setDoubleClickInterval( int );
    static int doubleClickInterval();

    static void setWheelScrollLines( int );
    static int wheelScrollLines();

    static void setGlobalStrut( const QSize & );
    static QSize globalStrut();


    static void setLibraryPaths( const QStringList & );
    static QStringList libraryPaths();
    static void addLibraryPath( const QString & );
    static void removeLibraryPath( const QString & );

    static void setStartDragTime( int ms );
    static int startDragTime();
    static void setStartDragDistance( int l );
    static int startDragDistance();

    static void setReverseLayout( bool b );
    static bool reverseLayout();

    static int horizontalAlignment( int align );

    static bool isEffectEnabled( Qt::UIEffect );
    static void setEffectEnabled( Qt::UIEffect, bool enable = TRUE );
# 237 "/coolo/prod/qt-copy/include/qapplication.h"
    virtual bool x11EventFilter( XEvent * );
    virtual int x11ClientMessage( QWidget*, XEvent*, bool passive_only);
    int x11ProcessEvent( XEvent* );
# 263 "/coolo/prod/qt-copy/include/qapplication.h"
    bool isSessionRestored() const;
    QString sessionId() const;
    QString sessionKey() const;
    virtual void commitData( QSessionManager& sm );
    virtual void saveState( QSessionManager& sm );


    static void create_xim();
    static void close_xim();
    static bool x11_apply_settings();

    void wakeUpGuiThread();

    void lock();
    void unlock(bool wakeUpGui = TRUE);
    bool locked();
    bool tryLock();


protected:
    void lastWindowClosed();
    void aboutToQuit();
    void guiThreadAwake();

public :
    void quit();
    void closeAllWindows();
    void aboutQt();






protected:
    bool event(QEvent *);

private:
    void construct( int &argc, char **argv, Type );
    void initialize( int, char ** );
    void init_precmdline();
    void process_cmdline( int* argcptr, char ** argv );
    bool internalNotify( QObject *, QEvent * );
# 326 "/coolo/prod/qt-copy/include/qapplication.h"
    static QMutex *qt_mutex;


    int app_argc;
    char **app_argv;
    bool quit_now;
    int quit_code;
    static QStyle *app_style;
    static int app_cspec;

    static QPalette *app_pal;

    static QFont *app_font;

    static QCursor *app_cursor;

    static QEventLoop* eventloop;
    static int app_tracking;
    static bool is_app_running;
    static bool is_app_closing;
    static bool app_exit_loop;
    static int loop_level;
    static QWidget *main_widget;
    static QWidget *focus_widget;
    static QWidget *active_window;
    static bool obey_desktop_settings;
    static int cursor_flash_time;
    static int mouse_double_click_time;
    static int wheel_scroll_lines;
    static int composedUnicode;

    static bool animate_ui;
    static bool animate_menu;
    static bool animate_tooltip;
    static bool animate_combo;
    static bool fade_menu;
    static bool fade_tooltip;
    static bool animate_toolbox;
    static bool widgetCount;
    static bool metaComposeUnicode;

    QValueList<QTranslator*> *translators;

    QSessionManager *session_manager;
    QString session_id;
    static QString* session_key;
    bool is_session_restored;


    static void x11_initialize_style();


    static QSize app_strut;

    static QStringList *app_libpaths;

    static QAsciiDict<QPalette> *app_palettes;
    static QAsciiDict<QFont> *app_fonts;

    static QWidgetList *popupWidgets;
    bool inPopupMode() const;
    void closePopup( QWidget *popup );
    void openPopup( QWidget *popup );
    void setActiveWindow( QWidget* act );

    static bool sendSpontaneousEvent( QObject *receiver, QEvent *event );
    static void removePostedEvent( QEvent * );

    friend class QWidget;
    friend class QETWidget;
    friend class QDialog;
    friend class QAccelManager;
    friend class QEvent;
    friend class QTranslator;
    friend class QEventLoop;
    friend void qt_ucm_initialize( QApplication * );






private:

    QApplication( const QApplication & );
    QApplication &operator=( const QApplication & );

};

inline int QApplication::argc() const
{
    return app_argc;
}

inline char **QApplication::argv() const
{
    return app_argv;
}
# 434 "/coolo/prod/qt-copy/include/qapplication.h"
inline QCursor *QApplication::overrideCursor()
{
    return app_cursor;
}

inline bool QApplication::hasGlobalMouseTracking()
{
    return app_tracking > 0;
}

inline QWidget *QApplication::mainWidget() const
{
    return main_widget;
}

inline QWidget *QApplication::focusWidget() const
{
    return focus_widget;
}

inline QWidget *QApplication::activeWindow() const
{
    return active_window;
}

inline QWidget *QApplication::widgetAt( const QPoint &p, bool child )
{
    return widgetAt( p.x(), p.y(), child );
}

inline bool QApplication::inPopupMode() const
{
    return popupWidgets != 0;
}

inline bool QApplication::isSessionRestored() const
{
    return is_session_restored;
}

inline QString QApplication::sessionId() const
{
    return session_id;
}

inline QString QApplication::sessionKey() const
{
    return session_key ? *session_key : QString::null;
}

inline QSize QApplication::globalStrut()
{
    return app_strut;
}

inline bool QApplication::sendEvent( QObject *receiver, QEvent *event )
{ if ( event ) event->spont = FALSE; return qApp ? qApp->notify( receiver, event ) : FALSE; }

inline bool QApplication::sendSpontaneousEvent( QObject *receiver, QEvent *event )
{ if ( event ) event->spont = TRUE; return qApp ? qApp->notify( receiver, event ) : FALSE; }
# 509 "/coolo/prod/qt-copy/include/qapplication.h"
inline int QApplication::horizontalAlignment( int align )
{
    align &= AlignHorizontal_Mask;
    if ( align == AlignAuto ) {
        if ( reverseLayout() )
            align = AlignRight;
        else
            align = AlignLeft;
    }
    return align;
}
# 41 "/coolo/prod/kdelibs/kdecore/kapplication.h" 2

# 1 "/coolo/prod/kdelibs/kdecore/kinstance.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/kinstance.h"

class KStandardDirs;
class KAboutData;
class KConfig;
class KIconLoader;
class KCharsets;
class QFont;
class KInstancePrivate;
class KMimeSourceFactory;
# 42 "/coolo/prod/kdelibs/kdecore/kinstance.h"
class KInstance
{
    friend class KStandardDirs;

 public:




    KInstance( const QCString& instanceName) ;
# 63 "/coolo/prod/kdelibs/kdecore/kinstance.h"
    KInstance( const KAboutData * aboutData );







    KInstance( KInstance* src );




    virtual ~KInstance();





    KStandardDirs *dirs() const;





    KConfig *config() const;





    KIconLoader *iconLoader() const;




    void newIconLoader() const;

    KCharsets *charsets() const;







    const KAboutData *aboutData() const;






    QCString instanceName() const;






    KMimeSourceFactory* mimeSourceFactory () const;

protected:



    KInstance( const KInstance& );






    void setConfigName(const QString &name);

private:
    mutable KStandardDirs *_dirs;

    mutable KConfig *_config;
    mutable KIconLoader *_iconLoader;

    QCString _name;
    const KAboutData *_aboutData;

protected:
    virtual void virtual_hook( int id, void* data );
private:
    KInstancePrivate *d;
};
# 43 "/coolo/prod/kdelibs/kdecore/kapplication.h" 2

struct _IceConn;
class QPopupMenu;
class QStrList;
class KSessionManaged;
class KStyle;
class KURL;


class KApplicationPrivate;
# 96 "/coolo/prod/kdelibs/kdecore/kapplication.h"
class KApplication : public QApplication, public KInstance
{

  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
  enum CaptionLayout { CaptionAppLast=1, CaptionAppFirst, CaptionNoApp };
# 116 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  KApplication( bool allowStyles=true, bool GUIenabled=true);
# 143 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  KApplication(Display *display, int& argc, char** argv, const QCString& rAppName,
               bool allowStyles=true, bool GUIenabled=true);
# 171 "/coolo/prod/kdelibs/kdecore/kapplication.h"
 KApplication(int& argc, char** argv,
              const QCString& rAppName, bool allowStyles=true, bool GUIenabled=true) ;




  static void addCmdLineOptions();

  virtual ~KApplication();
# 191 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static KApplication* kApplication() { return KApp; }
# 200 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  KConfig* sessionConfig();
# 210 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  bool isRestored() const { return QApplication::isSessionRestored(); }







  void disableSessionManagement();







  void enableSessionManagement();




  enum ShutdownConfirm {



    ShutdownConfirmDefault = -1,



    ShutdownConfirmNo = 0,



    ShutdownConfirmYes = 1
  };




  enum ShutdownType {



    ShutdownTypeDefault = -1,



    ShutdownTypeNone = 0,



    ShutdownTypeReboot = 1,



    ShutdownTypeHalt = 2
  };




  enum ShutdownMode {



    ShutdownModeDefault = -1,




    ShutdownModeSchedule = 0,



    ShutdownModeTryNow = 1,



    ShutdownModeForceNow = 2,



    ShutdownModeInteractive = 3
  };
# 310 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  bool requestShutDown( ShutdownConfirm confirm = ShutdownConfirmDefault,
                        ShutdownType sdtype = ShutdownTypeDefault,
                        ShutdownMode sdmode = ShutdownModeDefault );
# 327 "/coolo/prod/kdelibs/kdecore/kapplication.h"
    void propagateSessionManager();






  void commitData( QSessionManager& sm );






  void saveState( QSessionManager& sm );
# 352 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  bool sessionSaving() const;







  static DCOPClient *dcopClient();





  static void disableAutoDcopRegistration();





  QPixmap icon() const;





  QString iconName() const;





  QPixmap miniIcon() const;





  QString miniIconName() const;
# 402 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void setTopWidget( QWidget *topWidget );
# 414 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void invokeHelp( const QString& anchor = QString::null,
                   const QString& appname = QString::null ) const;
# 431 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void invokeHTMLHelp( const QString& aFilename, const QString& aTopic = QString::null ) const __attribute__ ((deprecated));







  void invokeMailer( const QString &address, const QString &subject );






  void invokeMailer( const KURL &mailtoURL );
# 461 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void invokeMailer(const QString &to, const QString &cc, const QString &bcc,
                    const QString &subject, const QString &body,
                    const QString &messageFile = QString::null, const QStringList &attachURLs = QStringList());

public :
# 474 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void invokeBrowser( const QString &url );
# 483 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void cut();
# 492 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void copy();
# 501 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void paste();
# 528 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void clear();
# 537 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void selectAll();

public:





  static QCString launcher();
# 567 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static int startServiceByName( const QString& _name, const QString &URL,
                QString *error=0, QCString *dcopService=0, int *pid=0, const QCString &startup_id = "", bool noWait = false );
# 590 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static int startServiceByName( const QString& _name, const QStringList &URLs=QStringList(),
                QString *error=0, QCString *dcopService=0, int *pid=0, const QCString &startup_id = "", bool noWait = false );
# 613 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static int startServiceByDesktopPath( const QString& _name, const QString &URL,
                QString *error=0, QCString *dcopService=0, int *pid = 0, const QCString &startup_id = "", bool noWait = false );
# 636 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static int startServiceByDesktopPath( const QString& _name, const QStringList &URLs=QStringList(),
                QString *error=0, QCString *dcopService=0, int *pid = 0, const QCString &startup_id = "", bool noWait = false );
# 659 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static int startServiceByDesktopName( const QString& _name, const QString &URL,
                QString *error=0, QCString *dcopService=0, int *pid = 0, const QCString &startup_id = "", bool noWait = false );
# 682 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static int startServiceByDesktopName( const QString& _name, const QStringList &URLs=QStringList(),
                QString *error=0, QCString *dcopService=0, int *pid = 0, const QCString &startup_id = "", bool noWait = false );
# 702 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static int kdeinitExec( const QString& name, const QStringList &args=QStringList(),
                QString *error=0, int *pid = 0 );
# 720 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static int kdeinitExecWait( const QString& name, const QStringList &args=QStringList(),
                QString *error=0, int *pid = 0 );
# 731 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  QString caption() const;




  __attribute__ ((deprecated)) KStyle* kstyle() const { return 0; }
# 755 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  QString makeStdCaption( const QString &userCaption,
                          bool withAppName=true, bool modified=false ) const;
# 765 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  QString tempSaveName( const QString& pFilename ) const;
# 776 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  QString checkRecoverFile( const QString& pFilename, bool& bRecover ) const;






  Display *getDisplay() { return display; }
# 793 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void enableStyles();
# 802 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void disableStyles();
# 813 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void installX11EventFilter( QWidget* filter );





  void removeX11EventFilter( const QWidget* filter );





  static int random();






  static QString randomString(int length);
# 843 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void addKipcEventMask(int id);
# 853 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void removeKipcEventMask(int id);






  QCString startupId() const;






  void setStartupId( const QCString& startup_id );






  QString geometryArgument() const;





  void installKDEPropertyMap();






  bool authorize(const QString &genericAction);
# 896 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  bool authorizeKAction(const char *action);
# 911 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  bool authorizeURLAction(const QString &action, const KURL &baseURL, const KURL &destURL);



  enum { ShiftModifier = 1<<0,
         LockModifier = 1<<1,
         ControlModifier = 1<<2,
         Modifier1 = 1<<3,
         Modifier2 = 1<<4,
         Modifier3 = 1<<5,
         Modifier4 = 1<<6,
         Modifier5 = 1<<7 };
# 933 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static uint keyboardModifiers();


  enum { Button1Pressed = 1<<8,
         Button2Pressed = 1<<9,
         Button3Pressed = 1<<10,
         Button4Pressed = 1<<11,
         Button5Pressed = 1<<12 };
# 950 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static uint mouseState();


public :






  void ref();





  void deref();

protected:



  KApplication( bool allowStyles, bool GUIenabled, KInstance* _instance );





  bool x11EventFilter( XEvent * );

  Display *display;

  Atom kipcCommAtom;
  int kipcEventMask;


  static KApplication *KApp;
  int pArgc;
# 1020 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void invokeEditSlot( const char *slot );

private :
  void dcopFailure(const QString &);
  void dcopBlockUserInput( bool );
  void x11FilterDestroyed();

private:
  QString sessionConfigName() const;
  KConfig* pSessionConfig;
  static DCOPClient *s_DCOPClient;
  static bool s_dcopClientNeedsPostInit;
  QString aCaption;
  bool bSessionManagement;
  QPixmap aIconPixmap;
  QPixmap aMiniIconPixmap;
  QString aIconName;
  QString aMiniIconName;
  bool useStyles;
  QWidget *smw;

  void init( bool GUIenabled );

  void parseCommandLine( );

  void read_app_startup_id();

  void dcopAutoRegistration();
  void dcopClientPostInit();
  void initUrlActionRestrictions();

public:



  bool notify(QObject *receiver, QEvent *event);




  int xErrhandler( Display*, void* );




  int xioErrhandler( Display* );




  void iceIOErrorHandler( _IceConn *conn );




  static bool loadedByKdeinit;




  static void startKdeinit();




  enum SettingsCategory { SETTINGS_MOUSE, SETTINGS_COMPLETION, SETTINGS_PATHS,
         SETTINGS_POPUPMENU, SETTINGS_QT, SETTINGS_SHORTCUTS };
# 1096 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static QPalette createApplicationPalette();





  static QPalette createApplicationPalette( KConfig *config, int contrast );
# 1111 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  static void installSigpipeHandler();

protected:






  void kdisplayPaletteChanged();
# 1129 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void kdisplayStyleChanged();
# 1142 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void kdisplayFontChanged();






  void appearanceChanged();




  void toolbarAppearanceChanged(int);






  void backgroundChanged(int desk);







  void settingsChanged(int category);





  void iconChanged(int group);
# 1186 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void kipcMessage(int id, int data);
# 1217 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void saveYourself();
# 1226 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  void shutDown();

private:
  void propagateSettings(SettingsCategory category);
  void kdisplaySetPalette();
  void kdisplaySetStyle();
  void kdisplaySetFont();
  void applyGUIStyle();
  static void sigpipeHandler(int);

  int captionLayout;

  KApplication(const KApplication&);
  KApplication& operator=(const KApplication&);
protected:
  virtual void virtual_hook( int id, void* data );
private:
  KApplicationPrivate* d;
};
# 1264 "/coolo/prod/kdelibs/kdecore/kapplication.h"
bool checkAccess(const QString& pathname, int mode);

class KSessionManagedPrivate;
# 1284 "/coolo/prod/kdelibs/kdecore/kapplication.h"
class KSessionManaged
{
public:
  KSessionManaged();
  virtual ~KSessionManaged();
# 1299 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  virtual bool saveState( QSessionManager& sm );
# 1309 "/coolo/prod/kdelibs/kdecore/kapplication.h"
  virtual bool commitData( QSessionManager& sm );

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KSessionManagedPrivate *d;
};
# 52 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kglobal.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/kglobal.h"




class KCharsets;
class KConfig;
class KIconLoader;
class KLocale;
class KStandardDirs;
class KStaticDeleterBase;
class KStaticDeleterList;
class KStringDict;
class QString;
# 44 "/coolo/prod/kdelibs/kdecore/kglobal.h"
class KGlobal
{
public:







    static KInstance *instance();





    static KStandardDirs *dirs();





    static KConfig *config();





    static KIconLoader *iconLoader();





    static KLocale *locale();





    static KCharsets *charsets();
# 103 "/coolo/prod/kdelibs/kdecore/kglobal.h"
    static const QString &staticQString(const char *str);
# 122 "/coolo/prod/kdelibs/kdecore/kglobal.h"
    static const QString &staticQString(const QString &str);







    static void registerStaticDeleter(KStaticDeleterBase *d);







    static void unregisterStaticDeleter(KStaticDeleterBase *d);







    static void deleteStaticDeleters();


    static KStringDict *_stringDict;
    static KInstance *_instance;
    static KLocale *_locale;
    static KCharsets *_charsets;
    static KStaticDeleterList *_staticDeleters;







    static void setActiveInstance(KInstance *d);
    static KInstance *activeInstance() { return _activeInstance; }

    static KInstance *_activeInstance;
};














template<class T>
inline const T& kMin (const T& a, const T& b) { return a < b ? a : b; }

template<class T>
inline const T& kMax (const T& a, const T& b) { return b < a ? a : b; }

template<class T>
inline T kAbs (const T& a) { return a < 0 ? -a : a; }
# 54 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"






class KConfig;
class KStandardDirsPrivate;
# 125 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
class KStandardDirs
{
public:



        KStandardDirs( );




        virtual ~KStandardDirs();
# 147 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        void addPrefix( const QString& dir );
# 156 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        void addXdgConfigPrefix( const QString& dir );
# 165 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        void addXdgDataPrefix( const QString& dir );
# 186 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        bool addResourceType( const char *type,
                              const QString& relativename );
# 204 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        bool addResourceDir( const char *type,
                             const QString& absdir);
# 225 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        QString findResource( const char *type,
                              const QString& filename ) const;
# 243 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        bool isRestrictedResource( const char *type,
                              const QString& relPath=QString::null ) const;
# 258 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        Q_UINT32 calcResourceHash( const char *type,
                              const QString& filename, bool deep) const;
# 277 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        QStringList findDirs( const char *type,
                              const QString& reldir ) const;
# 300 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        QString findResourceDir( const char *type,
                                 const QString& filename) const;
# 323 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        QStringList findAllResources( const char *type,
                                       const QString& filter = QString::null,
                                       bool recursive = false,
                                       bool uniq = false) const;
# 350 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        QStringList findAllResources( const char *type,
                                       const QString& filter,
                                       bool recursive,
                                       bool uniq,
                                       QStringList &relPaths) const;
# 373 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        static QString findExe( const QString& appname,
                                const QString& pathstr=QString::null,
                                bool ignoreExecBit=false );
# 395 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        static int findAllExe( QStringList& list, const QString& appname,
                               const QString& pathstr=QString::null,
                               bool ignoreExecBit=false );
# 408 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        void addKDEDefaults();
# 419 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        bool addCustomized(KConfig *config);
# 432 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        QStringList resourceDirs(const char *type) const;







        QStringList allTypes() const;
# 459 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
         QString saveLocation(const char *type,
                              const QString& suffix = QString::null,
                              bool create = true) const;
# 478 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
         QString relativeLocation(const char *type, const QString &absPath);
# 490 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        static bool makeDir(const QString& dir, int mode = 0755);
# 519 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        static QString kde_default(const char *type);




        QString kfsstnd_prefixes();







        QString localkdedir() const;





        QString localxdgdatadir() const;





        QString localxdgconfdir() const;







        static bool exists(const QString &fullPath);
# 562 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
        static QString realPath(const QString &dirname);
 private:

        QStringList prefixes;


        QDict<QStringList> absolutes;
        QDict<QStringList> relatives;

        mutable QDict<QStringList> dircache;
        mutable QDict<QString> savelocations;


        KStandardDirs( const KStandardDirs& );
        KStandardDirs& operator= ( const KStandardDirs& );

        bool addedCustoms;

        class KStandardDirsPrivate;
        KStandardDirsPrivate *d;

        void checkConfig() const;
        void applyDataRestrictions(const QString &) const;
        void createSpecialResource(const char*);
};
# 644 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
QString locate( const char *type, const QString& filename, const KInstance* instance = KGlobal::instance() );
# 655 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
QString locateLocal( const char *type, const QString& filename, const KInstance* instance = KGlobal::instance() );
# 666 "/coolo/prod/kdelibs/kdecore/kstandarddirs.h"
QString locateLocal( const char *type, const QString& filename, bool createDir, const KInstance* instance = KGlobal::instance() );
# 55 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kdebug.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kdebug.h"



class QWidget;
class QDateTime;
class QDate;
class QTime;
class QPoint;
class QSize;
class QRect;
class QRegion;
class KURL;
class QStringList;
class QColor;
class QPen;
class QBrush;

class kdbgstream;
class kndbgstream;
# 51 "/coolo/prod/kdelibs/kdecore/kdebug.h"
typedef kdbgstream & (*KDBGFUNC)(kdbgstream &);
typedef kndbgstream & (*KNDBGFUNC)(kndbgstream &);







class kdbgstreamprivate;
# 76 "/coolo/prod/kdelibs/kdecore/kdebug.h"
class kdbgstream {
 public:



    kdbgstream(unsigned int _area, unsigned int _level, bool _print = true) :
      area(_area), level(_level), print(_print) { }
    kdbgstream(const char * initialString, unsigned int _area, unsigned int _level, bool _print = true) :
      output(QString::fromLatin1(initialString)), area(_area), level(_level), print(_print) { }

    kdbgstream(kdbgstream &str) :
      output(str.output), area(str.area), level(str.level), print(str.print) { str.output.truncate(0); }
    kdbgstream(const kdbgstream &str) :
      output(str.output), area(str.area), level(str.level), print(str.print) {}
    ~kdbgstream();





    kdbgstream &operator<<(bool i) {
        if (!print) return *this;
        output += QString::fromLatin1(i ? "true" : "false");
        return *this;
    }





    kdbgstream &operator<<(short i) {
        if (!print) return *this;
        QString tmp; tmp.setNum(i); output += tmp;
        return *this;
    }





    kdbgstream &operator<<(unsigned short i) {
        if (!print) return *this;
        QString tmp; tmp.setNum(i); output += tmp;
        return *this;
    }





    kdbgstream &operator<<(char i);





    kdbgstream &operator<<(unsigned char i) {
        return operator<<( static_cast<char>( i ) );
    }





    kdbgstream &operator<<(int i) {
        if (!print) return *this;
        QString tmp; tmp.setNum(i); output += tmp;
        return *this;
    }





    kdbgstream &operator<<(unsigned int i) {
        if (!print) return *this;
        QString tmp; tmp.setNum(i); output += tmp;
        return *this;
    }





    kdbgstream &operator<<(long i) {
        if (!print) return *this;
        QString tmp; tmp.setNum(i); output += tmp;
        return *this;
    }





    kdbgstream &operator<<(unsigned long i) {
        if (!print) return *this;
        QString tmp; tmp.setNum(i); output += tmp;
        return *this;
    }



    void flush();






    kdbgstream &operator<<(const QString& string) {
        if (!print) return *this;
        output += string;
        if (output.at(output.length() -1 ) == '\n')
            flush();
        return *this;
    }





    kdbgstream &operator<<(const char *string) {
        if (!print) return *this;
        output += QString::fromUtf8(string);
        if (output.at(output.length() - 1) == '\n')
            flush();
        return *this;
    }





    kdbgstream &operator<<(const QCString& string) {
        *this << string.data();
        return *this;
    }





    kdbgstream& operator<<(const void * p) {
        form("%p", p);
        return *this;
    }





    kdbgstream& operator<<(KDBGFUNC f) {
        if (!print) return *this;
        return (*f)(*this);
    }





    kdbgstream& operator<<(double d) {
      QString tmp; tmp.setNum(d); output += tmp;
      return *this;
    }






    kdbgstream &form(const char *format, ...)

      __attribute__ ( ( format ( printf, 2, 3 ) ) )

     ;






    kdbgstream& operator << (const QWidget* widget);
    kdbgstream& operator << (QWidget* widget);






    kdbgstream& operator << ( const QDateTime& dateTime );






    kdbgstream& operator << ( const QDate& date );






    kdbgstream& operator << ( const QTime& time );






    kdbgstream& operator << ( const QPoint& point );






    kdbgstream& operator << ( const QSize& size );






    kdbgstream& operator << ( const QRect& rect);






    kdbgstream& operator << ( const QRegion& region);






    kdbgstream& operator << ( const KURL& url );






    kdbgstream& operator << ( const QStringList& list);






    kdbgstream& operator << ( const QColor& color);







    kdbgstream& operator << ( const QPen& pen );






    kdbgstream& operator << ( const QBrush& brush );


 private:
    QString output;
    unsigned int area, level;
    bool print;
    kdbgstreamprivate* d;
};







inline kdbgstream &endl( kdbgstream &s) { s << "\n"; return s; }







inline kdbgstream &flush( kdbgstream &s) { s.flush(); return s; }

kdbgstream &perror( kdbgstream &s);







class kndbgstream {
 public:

    kndbgstream() {}
    ~kndbgstream() {}




    kndbgstream &operator<<(short int ) { return *this; }




    kndbgstream &operator<<(unsigned short int ) { return *this; }




    kndbgstream &operator<<(char ) { return *this; }




    kndbgstream &operator<<(unsigned char ) { return *this; }




    kndbgstream &operator<<(int ) { return *this; }




    kndbgstream &operator<<(unsigned int ) { return *this; }



    void flush() {}




    kndbgstream &operator<<(const QString& ) { return *this; }




    kndbgstream &operator<<(const QCString& ) { return *this; }




    kndbgstream &operator<<(const char *) { return *this; }




    kndbgstream& operator<<(const void *) { return *this; }




    kndbgstream& operator<<(void *) { return *this; }




    kndbgstream& operator<<(double) { return *this; }




    kndbgstream& operator<<(long) { return *this; }




    kndbgstream& operator<<(unsigned long) { return *this; }




    kndbgstream& operator<<(KNDBGFUNC) { return *this; }




    kndbgstream& operator << (const QWidget*) { return *this; }
    kndbgstream& operator << (QWidget*) { return *this; }




    kndbgstream &form(const char *, ...) { return *this; }

    kndbgstream& operator<<( const QDateTime& ) { return *this; }
    kndbgstream& operator<<( const QDate& ) { return *this; }
    kndbgstream& operator<<( const QTime& ) { return *this; }
    kndbgstream& operator<<( const QPoint & ) { return *this; }
    kndbgstream& operator<<( const QSize & ) { return *this; }
    kndbgstream& operator<<( const QRect & ) { return *this; }
    kndbgstream& operator<<( const QRegion & ) { return *this; }
    kndbgstream& operator<<( const KURL & ) { return *this; }
    kndbgstream& operator<<( const QStringList & ) { return *this; }
    kndbgstream& operator<<( const QColor & ) { return *this; }
    kndbgstream& operator<<( const QPen & ) { return *this; }
    kndbgstream& operator<<( const QBrush & ) { return *this; }
};






inline kndbgstream &endl( kndbgstream & s) { return s; }





inline kndbgstream &flush( kndbgstream & s) { return s; }
inline kndbgstream &perror( kndbgstream & s) { return s; }
# 508 "/coolo/prod/kdelibs/kdecore/kdebug.h"
kdbgstream kdDebug(int area = 0);
kdbgstream kdDebug(bool cond, int area = 0);





QString kdBacktrace();







QString kdBacktrace(int levels);





inline kndbgstream kndDebug(int area = 0) { (void)area;; return kndbgstream(); }
inline kndbgstream kndDebug(bool , int = 0) { return kndbgstream(); }
inline QString kndBacktrace() { return QString::null; }
inline QString kndBacktrace(int) { return QString::null; }







kdbgstream kdWarning(int area = 0);
kdbgstream kdWarning(bool cond, int area = 0);






kdbgstream kdError(int area = 0);
kdbgstream kdError(bool cond, int area = 0);






kdbgstream kdFatal(int area = 0);
kdbgstream kdFatal(bool cond, int area = 0);






void kdClearDebugConfig();
# 56 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/klocale.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/klocale.h"




class QStringList;
class QTextCodec;
class QDate;
class QTime;
class QDateTime;

class KGlobal;
class KConfig;
class KConfigBase;
class KLocalePrivate;
class KCatalogue;
class KCalendarSystem;







# 62 "/coolo/prod/kdelibs/kdecore/klocale.h"
QString i18n(const char *text);
# 71 "/coolo/prod/kdelibs/kdecore/klocale.h"
QString i18n(const char *index, const char *text);







QString i18n(const char *singular, const char *plural, unsigned long n);







inline QString tr2i18n(const char* message, const char* =0) {
  return i18n(message);
}
# 103 "/coolo/prod/kdelibs/kdecore/klocale.h"
class KLocale
{
  friend class KGlobal;
public:
# 123 "/coolo/prod/kdelibs/kdecore/klocale.h"
  KLocale( const QString& catalogue, KConfig *config = 0 );




  KLocale( const KLocale & rhs );




  KLocale& operator= ( const KLocale & rhs );




  ~KLocale();
# 158 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString translate( const char *index ) const;
# 185 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString translate( const char *index, const char *fallback) const;
# 197 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString translate( const char *singular, const char *plural,
                     unsigned long n) const;
# 207 "/coolo/prod/kdelibs/kdecore/klocale.h"
  bool setEncoding(int mibEnum);
# 218 "/coolo/prod/kdelibs/kdecore/klocale.h"
  bool setLanguage(const QString & language);
# 229 "/coolo/prod/kdelibs/kdecore/klocale.h"
  bool setLanguage(const QStringList & languages);
# 240 "/coolo/prod/kdelibs/kdecore/klocale.h"
  bool setCountry(const QString & country);





  enum SignPosition { ParensAround = 0, BeforeQuantityMoney = 1,
                      AfterQuantityMoney = 2,
                      BeforeMoney = 3, AfterMoney = 4 };







  QString decimalSymbol() const;
# 265 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString thousandsSeparator() const;







  QString currencySymbol() const;
# 282 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString monetaryDecimalSymbol() const;
# 291 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString monetaryThousandsSeparator() const;







  QString positiveSign() const;







  QString negativeSign() const;







  int fracDigits() const;







  bool positivePrefixCurrencySymbol() const;







  bool negativePrefixCurrencySymbol() const;
# 340 "/coolo/prod/kdelibs/kdecore/klocale.h"
  SignPosition positiveMonetarySignPosition() const;
# 349 "/coolo/prod/kdelibs/kdecore/klocale.h"
  SignPosition negativeMonetarySignPosition() const;
# 365 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString formatMoney(double num,
                      const QString & currency = QString::null,
                      int digits = -1) const;
# 381 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString formatNumber(double num, int precision = -1) const;
# 394 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString formatLong(long num) const;
# 404 "/coolo/prod/kdelibs/kdecore/klocale.h"
   bool nounDeclension() const;
# 415 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString formatDate(const QDate &pDate, bool shortFormat = false) const;
# 424 "/coolo/prod/kdelibs/kdecore/klocale.h"
  bool dateMonthNamePossessive() const;
# 436 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString formatTime(const QTime &pTime, bool includeSecs = false) const;






  bool use12Clock() const;
# 454 "/coolo/prod/kdelibs/kdecore/klocale.h"
  bool weekStartsMonday() const ;







  int weekStartDay() const;
# 474 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString monthName(int i, bool shortName = false) const ;
# 489 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString monthNamePossessive(int i, bool shortName = false) const ;
# 501 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString weekDayName(int i, bool shortName = false) const ;







  const KCalendarSystem * calendar() const;
# 518 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString calendarType() const;
# 528 "/coolo/prod/kdelibs/kdecore/klocale.h"
  void setCalendar(const QString & calendarType);
# 540 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString formatDateTime(const QDateTime &pDateTime,
                         bool shortFormat = true,
                         bool includeSecs = false) const;
# 553 "/coolo/prod/kdelibs/kdecore/klocale.h"
  double readMoney(const QString &numStr, bool * ok = 0) const;
# 564 "/coolo/prod/kdelibs/kdecore/klocale.h"
  double readNumber(const QString &numStr, bool * ok = 0) const;
# 576 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QDate readDate(const QString &str, bool* ok = 0) const;





  QDate readDate( const QString &intstr, const QString &fmt, bool* ok = 0) const;

  enum ReadDateFlags {
      NormalFormat = 1,
      ShortFormat = 2
  };
# 602 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QDate readDate(const QString &str, ReadDateFlags flags, bool *ok = 0) const;
# 615 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QTime readTime(const QString &str, bool* ok = 0) const;

  enum ReadTimeFlags {
      WithSeconds = 0,
      WithoutSeconds = 1
  };
# 635 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QTime readTime(const QString &str, ReadTimeFlags flags, bool *ok = 0) const;
# 644 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString language() const;







  QString country() const;
# 667 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QStringList languagesTwoAlpha() const;
# 677 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QStringList languageList() const;
# 687 "/coolo/prod/kdelibs/kdecore/klocale.h"
  const char * encoding() const;
# 697 "/coolo/prod/kdelibs/kdecore/klocale.h"
  int encodingMib() const;
# 706 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QTextCodec * codecForEncoding() const;
# 716 "/coolo/prod/kdelibs/kdecore/klocale.h"
  int fileEncodingMib() const;
# 738 "/coolo/prod/kdelibs/kdecore/klocale.h"
  void setDateFormat(const QString & format);
# 759 "/coolo/prod/kdelibs/kdecore/klocale.h"
  void setDateFormatShort(const QString & format);






  void setDateMonthNamePossessive(bool possessive);
# 785 "/coolo/prod/kdelibs/kdecore/klocale.h"
  void setTimeFormat(const QString & format);
# 796 "/coolo/prod/kdelibs/kdecore/klocale.h"
  void setWeekStartsMonday(bool start) ;







  void setWeekStartDay(int day);






  QString dateFormat() const;






  QString dateFormatShort() const;






  QString timeFormat() const;






  void setDecimalSymbol(const QString & symbol);





  void setThousandsSeparator(const QString & separator);






  void setPositiveSign(const QString & sign);





  void setNegativeSign(const QString & sign);





  void setPositiveMonetarySignPosition(SignPosition signpos);





  void setNegativeMonetarySignPosition(SignPosition signpos);







  void setPositivePrefixCurrencySymbol(bool prefix);







  void setNegativePrefixCurrencySymbol(bool prefix);





  void setFracDigits(int digits);





  void setMonetaryThousandsSeparator(const QString & separator);






  void setMonetaryDecimalSymbol(const QString & symbol);





  void setCurrencySymbol(const QString & symbol);






  int pageSize() const;






  void setPageSize(int paperFormat);





  enum MeasureSystem { Metric, Imperial };






  MeasureSystem measureSystem() const;






  void setMeasureSystem(MeasureSystem value);
# 950 "/coolo/prod/kdelibs/kdecore/klocale.h"
  void insertCatalogue(const QString& catalogue);






  void removeCatalogue(const QString &catalogue);





  void setActiveCatalogue(const QString &catalogue);







  QString translateQt(const char *context,
                      const char *sourceText,
                      const char *message) const;






  QStringList allLanguagesTwoAlpha() const;







  QString twoAlphaToLanguageName(const QString &code) const;






  QStringList allCountriesTwoAlpha() const;







  QString twoAlphaToCountryName(const QString &code) const;
# 1014 "/coolo/prod/kdelibs/kdecore/klocale.h"
  static void splitLocale(const QString & str,
                          QString & language,
                          QString & country,
                          QString & charset);
# 1028 "/coolo/prod/kdelibs/kdecore/klocale.h"
  static void setMainCatalogue(const char *catalogue);







  static QString langLookup(const QString &fname, const char *rtype = "html");






  static QString defaultLanguage();






  static QString defaultCountry();





  static QString _initLanguage(KConfigBase *config);
# 1065 "/coolo/prod/kdelibs/kdecore/klocale.h"
  QString formatMoney(const QString &numStr) const ;





  QString formatNumber(const QString &numStr) const;







  QString languages() const __attribute__ ((deprecated));





  bool setCharset(const QString & charset) __attribute__ ((deprecated));





  QString charset() const __attribute__ ((deprecated));

protected:




  static void initInstance();

private:






  void initFormat(KConfig *config);
# 1116 "/coolo/prod/kdelibs/kdecore/klocale.h"
  void initLanguage(KConfig * config, bool useEnv);






  void initEncoding(KConfig * config);






  void initCatalogue(const QString & catalogue);





  void initFileNameEncoding(KConfig *config);




  static QCString encodeFileNameUTF8( const QString & fileName );




  static QString decodeFileNameUTF8( const QCString & localFileName );





  void initCatalogue( KCatalogue & catalogue );




  void doBindInit();




  void doFormatInit() const;




  void initFormat();




  QString translate_priv(const char *index,
                         const char *text,
                         const char ** original = 0) const;




  bool useDefaultLanguage() const;




  bool isLanguageInstalled(const QString & language) const;





  static QString catalogueFileName(const QString & language,
                                   const KCatalogue & catalogue);

private:

  QString m_decimalSymbol;
  QString m_thousandsSeparator;
  QString m_currencySymbol;
  QString m_monetaryDecimalSymbol;
  QString m_monetaryThousandsSeparator;
  QString m_positiveSign;
  QString m_negativeSign;
  int m_fracDigits;
  SignPosition m_positiveMonetarySignPosition;
  SignPosition m_negativeMonetarySignPosition;


  QString m_timeFormat;
  QString m_dateFormat;
  QString m_dateFormatShort;

  QString m_language;
  QString m_country;

  bool m_weekStartsMonday;
  bool m_positivePrefixCurrencySymbol;
  bool m_negativePrefixCurrencySymbol;

  KLocalePrivate *d;
};
# 57 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdefx/kstyle.h" 1
# 28 "/coolo/prod/kdelibs/kdefx/kstyle.h"






# 1 "/coolo/prod/qt-copy/include/qcommonstyle.h" 1
# 39 "/coolo/prod/qt-copy/include/qcommonstyle.h"


# 1 "/coolo/prod/qt-copy/include/qstyle.h" 1
# 38 "/coolo/prod/qt-copy/include/qstyle.h"
# 47 "/coolo/prod/qt-copy/include/qstyle.h"
class QPopupMenu;
class QStylePrivate;
class QMenuItem;
class QTab;
class QListViewItem;
class QCheckListItem;

class QStyleOption {
public:
    enum StyleOptionDefault { Default };

    QStyleOption(StyleOptionDefault=Default) : def(TRUE) {}



    QStyleOption(int in1) :
        def(FALSE), i1(in1) {}
    QStyleOption(int in1, int in2) :
        def(FALSE), i1(in1), i2(in2) {}
    QStyleOption(int in1, int in2, int in3, int in4) :
        def(FALSE), i1(in1), i2(in2), i3(in3), i4(in4) {}
    QStyleOption(QMenuItem* m) : def(FALSE), mi(m) {}
    QStyleOption(QMenuItem* m, int in1) : def(FALSE), mi(m), i1(in1) {}
    QStyleOption(QMenuItem* m, int in1, int in2) : def(FALSE), mi(m), i1(in1), i2(in2) {}
    QStyleOption(const QColor& c) : def(FALSE), cl(&c) {}
    QStyleOption(QTab* t) : def(FALSE), tb(t) {}
    QStyleOption(QListViewItem* i) : def(FALSE), li(i) {}
    QStyleOption(QCheckListItem* i) : def(FALSE), cli(i) {}
    QStyleOption(Qt::ArrowType a) : def(FALSE), i1((int)a) {}
    QStyleOption(const QRect& r) : def(FALSE), i1(r.x()), i2(r.y()), i3(r.width()),i4(r.height()){}
    QStyleOption(QWidget *w) : def(FALSE), p1((void*)w) {}

    bool isDefault() const { return def; }

    int lineWidth() const { return i1; }
    int midLineWidth() const { return i2; }
    int frameShape() const { return i3; }
    int frameShadow() const { return i4; }

    int headerSection() const { return i1; }
    QMenuItem* menuItem() const { return mi; }
    int maxIconWidth() const { return i1; }
    int tabWidth() const { return i2; }

    const QColor& color() const { return *cl; }

    QTab* tab() const { return tb; }

    QCheckListItem* checkListItem() const { return cli; }
    QListViewItem* listViewItem() const { return li; }

    Qt::ArrowType arrowType() const { return (Qt::ArrowType)i1; }
    QRect rect() const { return QRect( i1, i2, i3, i4 ); }
    QWidget* widget() const { return (QWidget*)p1; }

private:

    bool def;
    bool b1,b2,b3;
    QMenuItem* mi;
    QTab* tb;
    QListViewItem* li;
    const QColor* cl;
    int i1, i2, i3, i4;
    int i5, i6;
    QCheckListItem* cli;
    void *p1, *p2, *p3, *p4;

};

class QStyleHintReturn;

class QStyle: public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
    QStyle();
    virtual ~QStyle();



    virtual void polish( QWidget * );
    virtual void unPolish( QWidget * );

    virtual void polish( QApplication * );
    virtual void unPolish( QApplication * );

    virtual void polish( QPalette & );

    virtual void polishPopupMenu( QPopupMenu* ) = 0;

    virtual QRect itemRect( QPainter *p, const QRect &r,
                            int flags, bool enabled,
                            const QPixmap *pixmap,
                            const QString &text, int len = -1 ) const;

    virtual void drawItem( QPainter *p, const QRect &r,
                           int flags, const QColorGroup &g, bool enabled,
                           const QPixmap *pixmap, const QString &text,
                           int len = -1, const QColor *penColor = 0 ) const;


    enum PrimitiveElement {
        PE_ButtonCommand,
        PE_ButtonDefault,
        PE_ButtonBevel,
        PE_ButtonTool,
        PE_ButtonDropDown,

        PE_FocusRect,

        PE_ArrowUp,
        PE_ArrowDown,
        PE_ArrowRight,
        PE_ArrowLeft,

        PE_SpinWidgetUp,
        PE_SpinWidgetDown,
        PE_SpinWidgetPlus,
        PE_SpinWidgetMinus,

        PE_Indicator,
        PE_IndicatorMask,
        PE_ExclusiveIndicator,
        PE_ExclusiveIndicatorMask,

        PE_DockWindowHandle,
        PE_DockWindowSeparator,
        PE_DockWindowResizeHandle,

        PE_Splitter,

        PE_Panel,
        PE_PanelPopup,
        PE_PanelMenuBar,
        PE_PanelDockWindow,

        PE_TabBarBase,

        PE_HeaderSection,
        PE_HeaderArrow,
        PE_StatusBarSection,

        PE_GroupBoxFrame,

        PE_Separator,

        PE_SizeGrip,

        PE_CheckMark,

        PE_ScrollBarAddLine,
        PE_ScrollBarSubLine,
        PE_ScrollBarAddPage,
        PE_ScrollBarSubPage,
        PE_ScrollBarSlider,
        PE_ScrollBarFirst,
        PE_ScrollBarLast,

        PE_ProgressBarChunk,

        PE_PanelLineEdit,
        PE_PanelTabWidget,

        PE_WindowFrame,

        PE_CheckListController,
        PE_CheckListIndicator,
        PE_CheckListExclusiveIndicator,

        PE_PanelGroupBox,


        PE_CustomBase = 0xf000000
    };

    enum StyleFlags {
        Style_Default = 0x00000000,
        Style_Enabled = 0x00000001,
        Style_Raised = 0x00000002,
        Style_Sunken = 0x00000004,
        Style_Off = 0x00000008,
        Style_NoChange = 0x00000010,
        Style_On = 0x00000020,
        Style_Down = 0x00000040,
        Style_Horizontal = 0x00000080,
        Style_HasFocus = 0x00000100,
        Style_Top = 0x00000200,
        Style_Bottom = 0x00000400,
        Style_FocusAtBorder = 0x00000800,
        Style_AutoRaise = 0x00001000,
        Style_MouseOver = 0x00002000,
        Style_Up = 0x00004000,
        Style_Selected = 0x00008000,
        Style_Active = 0x00010000,
        Style_ButtonDefault = 0x00020000
    };
    typedef uint SFlags;

    virtual void drawPrimitive( PrimitiveElement pe,
                                QPainter *p,
                                const QRect &r,
                                const QColorGroup &cg,
                                SFlags flags = Style_Default,
                                const QStyleOption& = QStyleOption::Default ) const = 0;


    enum ControlElement {
        CE_PushButton,
        CE_PushButtonLabel,

        CE_CheckBox,
        CE_CheckBoxLabel,

        CE_RadioButton,
        CE_RadioButtonLabel,

        CE_TabBarTab,
        CE_TabBarLabel,

        CE_ProgressBarGroove,
        CE_ProgressBarContents,
        CE_ProgressBarLabel,

        CE_PopupMenuItem,
        CE_MenuBarItem,

        CE_ToolButtonLabel,
        CE_MenuBarEmptyArea,
        CE_PopupMenuScroller,
        CE_DockWindowEmptyArea,
        CE_PopupMenuVerticalExtra,
        CE_PopupMenuHorizontalExtra,

        CE_ToolBoxTab,
        CE_HeaderLabel,


        CE_CustomBase = 0xf0000000
    };

    virtual void drawControl( ControlElement element,
                              QPainter *p,
                              const QWidget *widget,
                              const QRect &r,
                              const QColorGroup &cg,
                              SFlags how = Style_Default,
                              const QStyleOption& = QStyleOption::Default ) const = 0;
    virtual void drawControlMask( ControlElement element,
                                  QPainter *p,
                                  const QWidget *widget,
                                  const QRect &r,
                                  const QStyleOption& = QStyleOption::Default ) const = 0;

    enum SubRect {
        SR_PushButtonContents,
        SR_PushButtonFocusRect,

        SR_CheckBoxIndicator,
        SR_CheckBoxContents,
        SR_CheckBoxFocusRect,

        SR_RadioButtonIndicator,
        SR_RadioButtonContents,
        SR_RadioButtonFocusRect,

        SR_ComboBoxFocusRect,

        SR_SliderFocusRect,

        SR_DockWindowHandleRect,

        SR_ProgressBarGroove,
        SR_ProgressBarContents,
        SR_ProgressBarLabel,

        SR_ToolButtonContents,

        SR_DialogButtonAccept,
        SR_DialogButtonReject,
        SR_DialogButtonApply,
        SR_DialogButtonHelp,
        SR_DialogButtonAll,
        SR_DialogButtonAbort,
        SR_DialogButtonIgnore,
        SR_DialogButtonRetry,
        SR_DialogButtonCustom,

        SR_ToolBoxTabContents,


        SR_CustomBase = 0xf0000000
    };

    virtual QRect subRect( SubRect r, const QWidget *widget ) const = 0;


    enum ComplexControl{
        CC_SpinWidget,
        CC_ComboBox,
        CC_ScrollBar,
        CC_Slider,
        CC_ToolButton,
        CC_TitleBar,
        CC_ListView,


        CC_CustomBase = 0xf0000000
    };

    enum SubControl {
        SC_None = 0x00000000,

        SC_ScrollBarAddLine = 0x00000001,
        SC_ScrollBarSubLine = 0x00000002,
        SC_ScrollBarAddPage = 0x00000004,
        SC_ScrollBarSubPage = 0x00000008,
        SC_ScrollBarFirst = 0x00000010,
        SC_ScrollBarLast = 0x00000020,
        SC_ScrollBarSlider = 0x00000040,
        SC_ScrollBarGroove = 0x00000080,

        SC_SpinWidgetUp = 0x00000001,
        SC_SpinWidgetDown = 0x00000002,
        SC_SpinWidgetFrame = 0x00000004,
        SC_SpinWidgetEditField = 0x00000008,
        SC_SpinWidgetButtonField = 0x00000010,

        SC_ComboBoxFrame = 0x00000001,
        SC_ComboBoxEditField = 0x00000002,
        SC_ComboBoxArrow = 0x00000004,
        SC_ComboBoxListBoxPopup = 0x00000008,

        SC_SliderGroove = 0x00000001,
        SC_SliderHandle = 0x00000002,
        SC_SliderTickmarks = 0x00000004,

        SC_ToolButton = 0x00000001,
        SC_ToolButtonMenu = 0x00000002,

        SC_TitleBarLabel = 0x00000001,
        SC_TitleBarSysMenu = 0x00000002,
        SC_TitleBarMinButton = 0x00000004,
        SC_TitleBarMaxButton = 0x00000008,
        SC_TitleBarCloseButton = 0x00000010,
        SC_TitleBarNormalButton = 0x00000020,
        SC_TitleBarShadeButton = 0x00000040,
        SC_TitleBarUnshadeButton = 0x00000080,

        SC_ListView = 0x00000001,
        SC_ListViewBranch = 0x00000002,
        SC_ListViewExpand = 0x00000004,

        SC_All = 0xffffffff
    };
    typedef uint SCFlags;


    virtual void drawComplexControl( ComplexControl control,
                                     QPainter *p,
                                     const QWidget *widget,
                                     const QRect &r,
                                     const QColorGroup &cg,
                                     SFlags how = Style_Default,
                                     SCFlags sub = SC_All,
                                     SCFlags subActive = SC_None,
                                     const QStyleOption& = QStyleOption::Default ) const = 0;
    virtual void drawComplexControlMask( ComplexControl control,
                                         QPainter *p,
                                         const QWidget *widget,
                                         const QRect &r,
                                         const QStyleOption& = QStyleOption::Default ) const = 0;

    virtual QRect querySubControlMetrics( ComplexControl control,
                                          const QWidget *widget,
                                          SubControl sc,
                                          const QStyleOption& = QStyleOption::Default ) const = 0;
    virtual SubControl querySubControl( ComplexControl control,
                                        const QWidget *widget,
                                        const QPoint &pos,
                                        const QStyleOption& = QStyleOption::Default ) const = 0;


    enum PixelMetric {
        PM_ButtonMargin,
        PM_ButtonDefaultIndicator,
        PM_MenuButtonIndicator,
        PM_ButtonShiftHorizontal,
        PM_ButtonShiftVertical,

        PM_DefaultFrameWidth,
        PM_SpinBoxFrameWidth,

        PM_MaximumDragDistance,

        PM_ScrollBarExtent,
        PM_ScrollBarSliderMin,

        PM_SliderThickness,
        PM_SliderControlThickness,
        PM_SliderLength,
        PM_SliderTickmarkOffset,
        PM_SliderSpaceAvailable,

        PM_DockWindowSeparatorExtent,
        PM_DockWindowHandleExtent,
        PM_DockWindowFrameWidth,

        PM_MenuBarFrameWidth,

        PM_TabBarTabOverlap,
        PM_TabBarTabHSpace,
        PM_TabBarTabVSpace,
        PM_TabBarBaseHeight,
        PM_TabBarBaseOverlap,

        PM_ProgressBarChunkWidth,

        PM_SplitterWidth,
        PM_TitleBarHeight,

        PM_IndicatorWidth,
        PM_IndicatorHeight,
        PM_ExclusiveIndicatorWidth,
        PM_ExclusiveIndicatorHeight,
        PM_PopupMenuScrollerHeight,
        PM_CheckListButtonSize,
        PM_CheckListControllerSize,
        PM_PopupMenuFrameHorizontalExtra,
        PM_PopupMenuFrameVerticalExtra,

        PM_DialogButtonsSeparator,
        PM_DialogButtonsButtonWidth,
        PM_DialogButtonsButtonHeight,

        PM_MDIFrameWidth,
        PM_MDIMinimizedWidth,
        PM_HeaderMargin,
        PM_HeaderMarkSize,
        PM_HeaderGripMargin,
        PM_TabBarTabShiftHorizontal,
        PM_TabBarTabShiftVertical,



        PM_CustomBase = 0xf0000000
    };

    virtual int pixelMetric( PixelMetric metric,
                             const QWidget *widget = 0 ) const = 0;


    enum ContentsType {
        CT_PushButton,
        CT_CheckBox,
        CT_RadioButton,
        CT_ToolButton,
        CT_ComboBox,
        CT_Splitter,
        CT_DockWindow,
        CT_ProgressBar,
        CT_PopupMenuItem,
        CT_TabBarTab,
        CT_Slider,
        CT_Header,
        CT_LineEdit,
        CT_MenuBar,
        CT_SpinBox,
        CT_SizeGrip,
        CT_TabWidget,
        CT_DialogButtons,


        CT_CustomBase = 0xf0000000
    };

    virtual QSize sizeFromContents( ContentsType contents,
                                    const QWidget *widget,
                                    const QSize &contentsSize,
                                    const QStyleOption& = QStyleOption::Default ) const = 0;

    enum StyleHint {




        SH_EtchDisabledText,


        SH_GUIStyle,




        SH_ScrollBar_BackgroundMode,
        SH_ScrollBar_MiddleClickAbsolutePosition,
        SH_ScrollBar_ScrollWhenPointerLeavesControl,


        SH_TabBar_SelectMouseType,

        SH_TabBar_Alignment,

        SH_Header_ArrowAlignment,


        SH_Slider_SnapToValue,



        SH_Slider_SloppyKeyEvents,



        SH_ProgressDialog_CenterCancelButton,



        SH_ProgressDialog_TextLabelAlignment,


        SH_PrintDialog_RightAlignButtons,



        SH_MainWindow_SpaceBelowMenuBar,



        SH_FontDialog_SelectAssociatedText,


        SH_PopupMenu_AllowActiveAndDisabled,


        SH_PopupMenu_SpaceActivatesItem,



        SH_PopupMenu_SubMenuPopupDelay,



        SH_ScrollView_FrameOnlyAroundContents,



        SH_MenuBar_AltKeyNavigation,


        SH_ComboBox_ListMouseTracking,


        SH_PopupMenu_MouseTracking,


        SH_MenuBar_MouseTracking,


        SH_ItemView_ChangeHighlightOnFocus,


        SH_Widget_ShareActivation,


        SH_Workspace_FillSpaceOnMaximize,


        SH_ComboBox_Popup,


        SH_TitleBar_NoBorder,


        SH_ScrollBar_StopMouseOverSlider,


        SH_BlinkCursorWhenTextSelected,


        SH_RichText_FullWidthSelection,


        SH_PopupMenu_Scrollable,



        SH_GroupBox_TextLabelVerticalAlignment,


        SH_GroupBox_TextLabelColor,


        SH_PopupMenu_SloppySubMenus,


        SH_Table_GridLineColor,


        SH_LineEdit_PasswordCharacter,


        SH_DialogButtons_DefaultButton,


        SH_ToolBox_SelectedPageTitleBold,


        SH_TabBar_PreferNoArrows,


        SH_ScrollBar_LeftClickAbsolutePosition,


        SH_ListViewExpand_SelectMouseType,


        SH_CustomBase = 0xf0000000
    };

    virtual int styleHint( StyleHint stylehint,
                           const QWidget *widget = 0,
                           const QStyleOption& = QStyleOption::Default,
                           QStyleHintReturn* returnData = 0
                           ) const = 0;


    enum StylePixmap {
        SP_TitleBarMinButton,
        SP_TitleBarMaxButton,
        SP_TitleBarCloseButton,
        SP_TitleBarNormalButton,
        SP_TitleBarShadeButton,
        SP_TitleBarUnshadeButton,
        SP_DockWindowCloseButton,
        SP_MessageBoxInformation,
        SP_MessageBoxWarning,
        SP_MessageBoxCritical,
        SP_MessageBoxQuestion,


        SP_CustomBase = 0xf0000000
    };

    virtual QPixmap stylePixmap( StylePixmap stylepixmap,
                                 const QWidget *widget = 0,
                                 const QStyleOption& = QStyleOption::Default ) const = 0;


    static QRect visualRect( const QRect &logical, const QWidget *w );

    static QRect visualRect( const QRect &logical, const QRect &bounding );
# 726 "/coolo/prod/qt-copy/include/qstyle.h"
private:
    QStylePrivate * d;


    QStyle( const QStyle & );
    QStyle& operator=( const QStyle & );

};
# 43 "/coolo/prod/qt-copy/include/qcommonstyle.h" 2




class QCommonStyle: public QStyle
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
    QCommonStyle();
    ~QCommonStyle();

    void drawPrimitive( PrimitiveElement pe,
                        QPainter *p,
                        const QRect &r,
                        const QColorGroup &cg,
                        SFlags flags = Style_Default,
                        const QStyleOption& = QStyleOption::Default ) const;

    void drawControl( ControlElement element,
                      QPainter *p,
                      const QWidget *widget,
                      const QRect &r,
                      const QColorGroup &cg,
                      SFlags how = Style_Default,
                      const QStyleOption& = QStyleOption::Default ) const;

    void drawControlMask( ControlElement element,
                          QPainter *p,
                          const QWidget *widget,
                          const QRect &r,
                          const QStyleOption& = QStyleOption::Default ) const;

    QRect subRect( SubRect r, const QWidget *widget ) const;

    void drawComplexControl( ComplexControl control,
                             QPainter *p,
                             const QWidget *widget,
                             const QRect &r,
                             const QColorGroup &cg,
                             SFlags how = Style_Default,
                             SCFlags sub = SC_All,
                             SCFlags subActive = SC_None,
                             const QStyleOption& = QStyleOption::Default ) const;

    void drawComplexControlMask( ComplexControl control,
                                 QPainter *p,
                                 const QWidget *widget,
                                 const QRect &r,
                                 const QStyleOption& = QStyleOption::Default ) const;

    QRect querySubControlMetrics( ComplexControl control,
                                  const QWidget *widget,
                                  SubControl sc,
                                  const QStyleOption& = QStyleOption::Default ) const;

    SubControl querySubControl( ComplexControl control,
                                const QWidget *widget,
                                const QPoint &pos,
                                const QStyleOption& = QStyleOption::Default ) const;

    int pixelMetric( PixelMetric m, const QWidget *widget = 0 ) const;

    QSize sizeFromContents( ContentsType s,
                            const QWidget *widget,
                            const QSize &contentsSize,
                            const QStyleOption& = QStyleOption::Default ) const;

    int styleHint(StyleHint sh, const QWidget *, const QStyleOption &, QStyleHintReturn *) const;

    QPixmap stylePixmap( StylePixmap sp,
                         const QWidget *widget = 0,
                         const QStyleOption& = QStyleOption::Default ) const;


private:


    QCommonStyle( const QCommonStyle & );
    QCommonStyle &operator=( const QCommonStyle & );

};
# 36 "/coolo/prod/kdelibs/kdefx/kstyle.h" 2

class KPixmap;

class KStylePrivate;
# 55 "/coolo/prod/kdelibs/kdefx/kstyle.h"
class KStyle: public QCommonStyle
{
        public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

        public:
# 77 "/coolo/prod/kdelibs/kdefx/kstyle.h"
                typedef uint KStyleFlags;
                enum KStyleOption {
                        Default = 0x00000000,
                        AllowMenuTransparency = 0x00000001,
                        FilledFrameWorkaround = 0x00000002
                };
# 105 "/coolo/prod/kdelibs/kdefx/kstyle.h"
                enum KStyleScrollBarType {
                        WindowsStyleScrollBar = 0x00000000,
                        PlatinumStyleScrollBar = 0x00000001,
                        ThreeButtonScrollBar = 0x00000002,
                        NextStyleScrollBar = 0x00000004
                };
# 129 "/coolo/prod/kdelibs/kdefx/kstyle.h"
                KStyle( KStyleFlags flags = KStyle::Default,
                                KStyleScrollBarType sbtype = KStyle::WindowsStyleScrollBar );




                ~KStyle();




                static QString defaultStyle();
# 151 "/coolo/prod/kdelibs/kdefx/kstyle.h"
                void setScrollBarType(KStyleScrollBarType sbtype);






                KStyleFlags styleFlags() const;
# 173 "/coolo/prod/kdelibs/kdefx/kstyle.h"
                virtual void renderMenuBlendPixmap( KPixmap& pix, const QColorGroup& cg,
                                                                                        const QPopupMenu* popup ) const;
# 219 "/coolo/prod/kdelibs/kdefx/kstyle.h"
                enum KStylePrimitive {
                        KPE_DockWindowHandle,
                        KPE_ToolBarHandle,
                        KPE_GeneralHandle,

                        KPE_SliderGroove,
                        KPE_SliderHandle,

                        KPE_ListViewExpander,
                        KPE_ListViewBranch
                };
# 240 "/coolo/prod/kdelibs/kdefx/kstyle.h"
                virtual void drawKStylePrimitive( KStylePrimitive kpe,
                                        QPainter* p,
                                        const QWidget* widget,
                                        const QRect &r,
                                        const QColorGroup &cg,
                                        SFlags flags = Style_Default,
                                        const QStyleOption& = QStyleOption::Default ) const;


                enum KStylePixelMetric {
                        KPM_MenuItemSeparatorHeight = 0x00000001,
                        KPM_MenuItemHMargin = 0x00000002,
                        KPM_MenuItemVMargin = 0x00000004,
                        KPM_MenuItemHFrame = 0x00000008,
                        KPM_MenuItemVFrame = 0x00000010,
                        KPM_MenuItemCheckMarkHMargin = 0x00000020,
                        KPM_MenuItemArrowHMargin = 0x00000040,
                        KPM_MenuItemTabSpacing = 0x00000080,

                        KPM_ListViewBranchThickness = 0x00000100
                };

                int kPixelMetric( KStylePixelMetric kpm, const QWidget* widget = 0 ) const;



                void polish( QWidget* widget );
                void unPolish( QWidget* widget );
                void polishPopupMenu( QPopupMenu* );

                void drawPrimitive( PrimitiveElement pe,
                                        QPainter* p,
                                        const QRect &r,
                                        const QColorGroup &cg,
                                        SFlags flags = Style_Default,
                                        const QStyleOption& = QStyleOption::Default ) const;

                void drawControl( ControlElement element,
                                        QPainter* p,
                                        const QWidget* widget,
                                        const QRect &r,
                                        const QColorGroup &cg,
                                        SFlags flags = Style_Default,
                                        const QStyleOption& = QStyleOption::Default ) const;

                void drawComplexControl( ComplexControl control,
                                        QPainter *p,
                                        const QWidget* widget,
                                        const QRect &r,
                                        const QColorGroup &cg,
                                        SFlags flags = Style_Default,
                                        SCFlags controls = SC_All,
                                        SCFlags active = SC_None,
                                        const QStyleOption& = QStyleOption::Default ) const;

                SubControl querySubControl( ComplexControl control,
                                        const QWidget* widget,
                                        const QPoint &pos,
                                        const QStyleOption& = QStyleOption::Default ) const;

                QRect querySubControlMetrics( ComplexControl control,
                                        const QWidget* widget,
                                        SubControl sc,
                                        const QStyleOption& = QStyleOption::Default ) const;

                int pixelMetric( PixelMetric m,
                                        const QWidget* widget = 0 ) const;

                QRect subRect( SubRect r,
                                        const QWidget* widget ) const;

                QPixmap stylePixmap( StylePixmap stylepixmap,
                                        const QWidget* widget = 0,
                                        const QStyleOption& = QStyleOption::Default ) const;

                int styleHint( StyleHint sh,
                                        const QWidget* w = 0,
                                        const QStyleOption &opt = QStyleOption::Default,
                                        QStyleHintReturn* shr = 0 ) const;

        protected:
                bool eventFilter( QObject* object, QEvent* event );

        private:

                KStyle( const KStyle & );
                KStyle& operator=( const KStyle & );

        protected:
                virtual void virtual_hook( int id, void* data );
        private:
                KStylePrivate *d;
};
# 58 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kiconloader.h" 1
# 15 "/coolo/prod/kdelibs/kdecore/kiconloader.h"



# 1 "/coolo/prod/qt-copy/include/qiconset.h" 1
# 39 "/coolo/prod/qt-copy/include/qiconset.h"
# 48 "/coolo/prod/qt-copy/include/qiconset.h"
class QIconFactory;
class QIconSetPrivate;


class QIconSet
{
public:

    enum Size { Automatic, Small, Large };
    enum Mode { Normal, Disabled, Active };
    enum State { On, Off };

    QIconSet();
    QIconSet( const QPixmap& pixmap, Size size = Automatic );
    QIconSet( const QPixmap& smallPix, const QPixmap& largePix );
    QIconSet( const QIconSet& other );
    virtual ~QIconSet();

    void reset( const QPixmap& pixmap, Size size );

    virtual void setPixmap( const QPixmap& pixmap, Size size,
                            Mode mode = Normal, State state = Off );
    virtual void setPixmap( const QString& fileName, Size size,
                            Mode mode = Normal, State state = Off );
    QPixmap pixmap( Size size, Mode mode, State state = Off ) const;
    QPixmap pixmap( Size size, bool enabled, State state = Off ) const;
    QPixmap pixmap() const;
    bool isGenerated( Size size, Mode mode, State state = Off ) const;
    void clearGenerated();
    void installIconFactory( QIconFactory *factory );

    bool isNull() const;

    void detach();

    QIconSet& operator=( const QIconSet& other );


    static void setIconSize( Size which, const QSize& size );
    static const QSize& iconSize( Size which );

   

private:
    void normalize( Size& which, const QSize& pixSize );
    QPixmap *createScaled( Size size, const QPixmap *suppliedPix ) const;
    QPixmap *createDisabled( Size size, State state ) const;

    QIconSetPrivate *d;
};

class QIconFactory : private QShared
{
public:
    QIconFactory();
    virtual ~QIconFactory();

    virtual QPixmap *createPixmap( const QIconSet& iconSet, QIconSet::Size size,
                                   QIconSet::Mode mode, QIconSet::State state );
    void setAutoDelete( bool autoDelete ) { autoDel = autoDelete; }
    bool autoDelete() const { return autoDel; }

    static QIconFactory *defaultFactory();
    static void installDefaultFactory( QIconFactory *factory );

private:

    QIconFactory( const QIconFactory & );
    QIconFactory &operator=( const QIconFactory & );


    friend class QIconSet;
    friend class QIconSetPrivate;

    uint autoDel : 1;
    uint unused : 31;
};
# 20 "/coolo/prod/kdelibs/kdecore/kiconloader.h" 2






# 1 "/coolo/prod/qt-copy/include/qmovie.h" 1
# 39 "/coolo/prod/qt-copy/include/qmovie.h"







class QDataSource;
class QObject;
class QMoviePrivate;

class QMovie {
public:
    QMovie();
    QMovie(int bufsize);
    QMovie(QDataSource*, int bufsize=1024);
    QMovie(const QString &fileName, int bufsize=1024);
    QMovie(QByteArray data, int bufsize=1024);
    QMovie(const QMovie&);
    ~QMovie();

    QMovie& operator=(const QMovie&);

    int pushSpace() const;
    void pushData(const uchar* data, int length);

    const QColor& backgroundColor() const;
    void setBackgroundColor(const QColor&);

    const QRect& getValidRect() const;
    const QPixmap& framePixmap() const;
    const QImage& frameImage() const;

    bool isNull() const;

    int frameNumber() const;
    int steps() const;
    bool paused() const;
    bool finished() const;
    bool running() const;

    void unpause();
    void pause();
    void step();
    void step(int);
    void restart();

    int speed() const;
    void setSpeed(int);

    void connectResize(QObject* receiver, const char *member);
    void disconnectResize(QObject* receiver, const char *member=0);

    void connectUpdate(QObject* receiver, const char *member);
    void disconnectUpdate(QObject* receiver, const char *member=0);






    enum Status { SourceEmpty=-2,
                  UnrecognizedFormat=-1,
                  Paused=1,
                  EndOfFrame=2,
                  EndOfLoop=3,
                  EndOfMovie=4,
                  SpeedChanged=5 };
    void connectStatus(QObject* receiver, const char *member);
    void disconnectStatus(QObject* receiver, const char *member=0);

private:
    QMoviePrivate *d;
};
# 27 "/coolo/prod/kdelibs/kdecore/kiconloader.h" 2







# 1 "/coolo/prod/kdelibs/kdecore/kicontheme.h" 1
# 16 "/coolo/prod/kdelibs/kdecore/kicontheme.h"





class KConfig;
class KIconThemeDir;

class KIconThemePrivate;

class KIconPrivate;
# 36 "/coolo/prod/kdelibs/kdecore/kicontheme.h"
class KIcon
{
public:
    KIcon() { size = 0; }




    bool isValid() const { return size != 0; }




    enum Context {
      Any,
      Action,
      Application,
      Device,
      FileSystem,
      MimeType
    };




    enum Type {
      Fixed,
      Scalable,
      Threshold
    };




    enum MatchType {
      MatchExact,
      MatchBest

    };






    enum Group { NoGroup=-1, Desktop=0, FirstGroup=Desktop, Toolbar,
        MainToolbar, Small, Panel, LastGroup, User };




    enum StdSizes {

        SizeSmall=16,

        SizeMedium=32,

        SizeLarge=48 };




    enum States { DefaultState,
                  ActiveState,
                  DisabledState,
                  LastState
    };






    enum Overlays {
      LockOverlay=0x100,
      ZipOverlay=0x200,
      LinkOverlay=0x400,
      HiddenOverlay=0x800,
      ShareOverlay=0x1000,
      OverlayMask = ~0xff
    };




    int size;




    Context context;




    Type type;




    int threshold;




    QString path;

private:
    KIconPrivate *d;
};

inline KIcon::Group& operator++(KIcon::Group& group) { group = static_cast<KIcon::Group>(group+1); return group; }
inline KIcon::Group operator++(KIcon::Group& group,int) { KIcon::Group ret = group; ++group; return ret; }






class KIconTheme
{
public:






    KIconTheme(const QString& name, const QString& appName=QString::null);
    ~KIconTheme();





    QString name() const { return mName; }






    QString description() const { return mDesc; }






    QString example() const;





    QString screenshot() const;





    QString linkOverlay() const;





    QString zipOverlay() const;





    QString lockOverlay() const;






    QString shareOverlay () const;





    QString dir() const { return mDir; }





    QStringList inherits() const { return mInherits; }





    bool isValid() const;






    bool isHidden() const;






    int depth() const { return mDepth; }






    int defaultSize(KIcon::Group group) const;






    QValueList<int> querySizes(KIcon::Group group) const;







    QStringList queryIcons(int size, KIcon::Context context = KIcon::Any) const;







    QStringList queryIconsByContext(int size, KIcon::Context context = KIcon::Any) const;
# 291 "/coolo/prod/kdelibs/kdecore/kicontheme.h"
    KIcon iconPath(const QString& name, int size, KIcon::MatchType match) const;





    static QStringList list();





    static QString current();




    static void reconfigure();






    static QString defaultThemeName();

private:
    int mDefSize[8];
    QValueList<int> mSizes[8];

    int mDepth;
    QString mDir, mName, mDesc;
    QStringList mInherits;
    QPtrList<KIconThemeDir> mDirs;
    KIconThemePrivate *d;

    static QString *_theme;
    static QStringList *_theme_list;
};
# 35 "/coolo/prod/kdelibs/kdecore/kiconloader.h" 2

class KIconGroup;
class KIconThemeNode;
class KConfig;
class KIconLoaderPrivate;
class KStandardDirs;
class KIconEffect;
# 79 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
class KIconLoader
{
public:
# 97 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    KIconLoader(const QString& appname=QString::null, KStandardDirs *dirs = 0);




    ~KIconLoader();





    void addAppDir(const QString& appname);
# 131 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QPixmap loadIcon(const QString& name, KIcon::Group group, int size=0,
                     int state=KIcon::DefaultState, QString *path_store=0L,
                     bool canReturnNull=false) const;
# 151 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QIconSet loadIconSet(const QString& name, KIcon::Group group, int size,
                         bool canReturnNull);
# 166 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QIconSet loadIconSet(const QString& name, KIcon::Group group, int size=0);
# 182 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QString iconPath(const QString& name, int group_or_size,
                     bool canReturnNull=false) const;
# 193 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QMovie loadMovie(const QString& name, KIcon::Group group, int size=0) const;
# 204 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QString moviePath(const QString& name, KIcon::Group group, int size=0) const;
# 216 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QStringList loadAnimated(const QString& name, KIcon::Group group, int size=0) const;
# 228 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QStringList queryIcons(int group_or_size, KIcon::Context context=KIcon::Any) const;
# 241 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QStringList queryIconsByContext(int group_or_size,
                                    KIcon::Context context=KIcon::Any) const;
# 251 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    QStringList queryIconsByDir( const QString& iconsDir ) const;






    int currentSize(KIcon::Group group) const;






    KIconTheme *theme() const;





    KIconEffect *iconEffect() const;







    void reconfigure( const QString& _appname, KStandardDirs *_dirs );






    static QPixmap unknown();
# 295 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    bool alphaBlending( KIcon::Group group ) const;






    void addExtraDesktopThemes();






    bool extraDesktopThemesAdded() const;
# 330 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    void enableDelayedIconSetLoading( bool enable );
# 339 "/coolo/prod/kdelibs/kdecore/kiconloader.h"
    bool isDelayedIconSetLoadingEnabled() const;


 private:



    void init( const QString& _appname, KStandardDirs *_dirs );






    KIcon findMatchingIcon(const QString& name, int size) const;





     QImage *loadOverlay(const QString& name, int size) const;





    void addAppThemes(const QString& appname);






    void addBaseThemes(KIconThemeNode *node, const QString &appname);






    QString unknownIconPath( int size ) const;






    QString removeIconExtension(const QString &name) const;




    QIconSet loadIconSetNonDelayed( const QString& name, KIcon::Group group,
                                    int size, bool canReturnNull );


    KIconLoaderPrivate *d;
};





QPixmap DesktopIcon(const QString& name, int size=0,
                    int state=KIcon::DefaultState,
                    KInstance *instance=KGlobal::instance());





QPixmap DesktopIcon(const QString& name, KInstance *instance);





QIconSet DesktopIconSet(const QString& name, int size=0,
                    KInstance *instance=KGlobal::instance());





QPixmap BarIcon(const QString& name, int size=0, int state=KIcon::DefaultState,
        KInstance *instance=KGlobal::instance());





QPixmap BarIcon(const QString& name, KInstance *instance);





QIconSet BarIconSet(const QString& name, int size=0,
                    KInstance *instance=KGlobal::instance());





QPixmap SmallIcon(const QString& name, int size=0,
                  int state=KIcon::DefaultState,
                  KInstance *instance=KGlobal::instance());





QPixmap SmallIcon(const QString& name, KInstance *instance);





QIconSet SmallIconSet(const QString& name, int size=0,
                    KInstance *instance=KGlobal::instance());





QPixmap MainBarIcon(const QString& name, int size=0,
                    int state=KIcon::DefaultState,
                    KInstance *instance=KGlobal::instance());





QPixmap MainBarIcon(const QString& name, KInstance *instance);





QIconSet MainBarIconSet(const QString& name, int size=0,
                    KInstance *instance=KGlobal::instance());





QPixmap UserIcon(const QString& name, int state=KIcon::DefaultState,
        KInstance *instance=KGlobal::instance());





QPixmap UserIcon(const QString& name, KInstance *instance);





QIconSet UserIconSet(const QString& name,
        KInstance *instance=KGlobal::instance());





int IconSize(KIcon::Group group, KInstance *instance=KGlobal::instance());
# 59 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kclipboard.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/kclipboard.h"

# 1 "/coolo/prod/qt-copy/include/qclipboard.h" 1
# 39 "/coolo/prod/qt-copy/include/qclipboard.h"
# 48 "/coolo/prod/qt-copy/include/qclipboard.h"
class QMimeSource;

class QClipboard : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
private:
    QClipboard( QObject *parent=0, const char *name=0 );
    ~QClipboard();

public:
    enum Mode { Clipboard, Selection };

    void clear( Mode mode );
    void clear();

    bool supportsSelection() const;
    bool ownsSelection() const;
    bool ownsClipboard() const;

    void setSelectionMode(bool enable);
    bool selectionModeEnabled() const;


    QString text( Mode mode ) const;
    QString text( QCString& subtype, Mode mode ) const;
    void setText( const QString &, Mode mode );


    QMimeSource *data( Mode mode ) const;
    void setData( QMimeSource*, Mode mode );

    QImage image( Mode mode ) const;
    QPixmap pixmap( Mode mode ) const;
    void setImage( const QImage &, Mode mode );
    void setPixmap( const QPixmap &, Mode mode );



    QString text() const;
    QString text(QCString& subtype) const;
    void setText( const QString &);


    QMimeSource *data() const;
    void setData( QMimeSource* );

    QImage image() const;
    QPixmap pixmap() const;
    void setImage( const QImage & );
    void setPixmap( const QPixmap & );


protected:
    void selectionChanged();
    void dataChanged();

private :
    void ownerDestroyed();

protected:
    void connectNotify( const char * );
    bool event( QEvent * );

    friend class QApplication;
    friend class QBaseApplication;
    friend class QDragManager;
    friend class QMimeSource;

private:







    QClipboard( const QClipboard & );
    QClipboard &operator=( const QClipboard & );

};
# 23 "/coolo/prod/kdelibs/kdecore/kclipboard.h" 2
# 34 "/coolo/prod/kdelibs/kdecore/kclipboard.h"
class KClipboardSynchronizer : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
    friend class KlipperWidget;
    friend class KApplication;





    static KClipboardSynchronizer *self();
# 55 "/coolo/prod/kdelibs/kdecore/kclipboard.h"
    static void setSynchronizing( bool sync );







    static bool isSynchronizing()
    {
        return s_sync;
    }
# 77 "/coolo/prod/kdelibs/kdecore/kclipboard.h"
    static void setReverseSynchronizing( bool enable );
# 86 "/coolo/prod/kdelibs/kdecore/kclipboard.h"
    static bool isReverseSynchronizing()
    {
        return s_reverse_sync;
    }


protected:
    ~KClipboardSynchronizer();

private :
    void slotSelectionChanged();
    void slotClipboardChanged();

private:
    KClipboardSynchronizer( QObject *parent = 0, const char *name = 0L );
    void setupSignals();

    static void setClipboard( QMimeSource* data, QClipboard::Mode mode );

    static KClipboardSynchronizer *s_self;
    static bool s_sync;
    static bool s_reverse_sync;
    static bool s_blocked;

    class MimeSource;

private:

    enum Configuration { Synchronize = 1 };

    static void newConfiguration( int config );

};
# 60 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kconfig.h" 1
# 25 "/coolo/prod/kdelibs/kdecore/kconfig.h"

class QTimer;

# 1 "/coolo/prod/kdelibs/kdecore/kconfigbase.h" 1
# 26 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
# 37 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
# 1 "/coolo/prod/kdelibs/kdecore/kconfigdata.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kconfigdata.h"







struct KEntry
{
  KEntry()
    : mValue(0), bDirty(false), bNLS(false),
      bGlobal(false), bImmutable(false), bDeleted(false), bExpand(false) {}
  QCString mValue;



  bool bDirty :1;



  bool bNLS :1;



  bool bGlobal:1;



  bool bImmutable:1;



  bool bDeleted:1;



  bool bExpand:1;
};






struct KEntryKey
{
  KEntryKey(const QCString& _group = 0,
            const QCString& _key = 0)
      : mGroup(_group), mKey(_key), bLocal(false), bDefault(false),
        c_key(_key.data()) {}



  QCString mGroup;



  QCString mKey;



  bool bLocal :1;



  bool bDefault:1;

  const char *c_key;
};





inline bool operator <(const KEntryKey &k1, const KEntryKey &k2)
{

   int result=qstrcmp(k1.mGroup.data(),k2.mGroup.data());
   if (result!=0)
      return (result<0);

  if (!k1.c_key && k2.c_key)
    return true;

  result = 0;
  if (k1.c_key && k2.c_key)
     result = strcmp(k1.c_key, k2.c_key);
  if (result != 0)
     return result < 0;
  if (!k1.bLocal && k2.bLocal)
    return true;
  if (k1.bLocal && !k2.bLocal)
    return false;
  return (!k1.bDefault && k2.bDefault);
}
# 127 "/coolo/prod/kdelibs/kdecore/kconfigdata.h"
typedef QMap<KEntryKey, KEntry> KEntryMap;






typedef QMap<KEntryKey, KEntry>::Iterator KEntryMapIterator;
# 143 "/coolo/prod/kdelibs/kdecore/kconfigdata.h"
typedef QMap<KEntryKey, KEntry>::ConstIterator KEntryMapConstIterator;
# 38 "/coolo/prod/kdelibs/kdecore/kconfigbase.h" 2

class KConfigBackEnd;
class KConfigBasePrivate;
class KConfigGroup;
# 70 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
class KConfigBase : public QObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

  friend class KConfigBackEnd;
  friend class KConfigINIBackEnd;
  friend class KConfigGroup;

public:



  KConfigBase();




  virtual ~KConfigBase();
# 99 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void setGroup( const QString& group );





  void setDesktopGroup();







  QString group() const;







  bool hasGroup(const QString &group) const;






  virtual QStringList groupList() const = 0;






  QString locale() const;
# 144 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
   QString readEntry(const QString& pKey,
                     const QString& aDefault = QString::null ) const;
# 154 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
   QString readEntry(const char *pKey,
                     const QString& aDefault = QString::null ) const;
# 170 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QVariant readPropertyEntry( const QString& pKey, QVariant::Type ) const;
# 186 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QVariant readPropertyEntry( const char *pKey, QVariant::Type ) const;
# 202 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QVariant readPropertyEntry( const QString& pKey,
                              const QVariant &aDefault) const;
# 219 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QVariant readPropertyEntry( const char *pKey,
                              const QVariant &aDefault) const;
# 232 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  int readListEntry( const QString& pKey, QStrList &list, char sep = ',' ) const;
# 244 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  int readListEntry( const char *pKey, QStrList &list, char sep = ',' ) const;
# 253 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QStringList readListEntry( const QString& pKey, char sep = ',' ) const;
# 262 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QStringList readListEntry( const char *pKey, char sep = ',' ) const;







  QValueList<int> readIntListEntry( const QString& pKey ) const;







  QValueList<int> readIntListEntry( const char *pKey ) const;
# 291 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QString readPathEntry( const QString& pKey, const QString & aDefault = QString::null ) const;
# 304 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QString readPathEntry( const char *pKey, const QString & aDefault = QString::null ) const;
# 318 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QStringList readPathListEntry( const QString& pKey, char sep = ',' ) const;
# 332 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QStringList readPathListEntry( const char *pKey, char sep = ',' ) const;
# 346 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  int readNumEntry( const QString& pKey, int nDefault = 0 ) const;
# 359 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  int readNumEntry( const char *pKey, int nDefault = 0 ) const;
# 372 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  unsigned int readUnsignedNumEntry( const QString& pKey, unsigned int nDefault = 0 ) const;
# 385 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  unsigned int readUnsignedNumEntry( const char *pKey, unsigned int nDefault = 0 ) const;
# 399 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  long readLongNumEntry( const QString& pKey, long nDefault = 0 ) const;
# 412 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  long readLongNumEntry( const char *pKey, long nDefault = 0 ) const;
# 425 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  unsigned long readUnsignedLongNumEntry( const QString& pKey, unsigned long nDefault = 0 ) const;
# 438 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  unsigned long readUnsignedLongNumEntry( const char *pKey, unsigned long nDefault = 0 ) const;
# 451 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  double readDoubleNumEntry( const QString& pKey, double nDefault = 0.0 ) const;
# 464 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  double readDoubleNumEntry( const char *pKey, double nDefault = 0.0 ) const;
# 477 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QFont readFontEntry( const QString& pKey, const QFont* pDefault = 0L ) const;
# 490 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QFont readFontEntry( const char *pKey, const QFont* pDefault = 0L ) const;
# 503 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  bool readBoolEntry( const QString& pKey, const bool bDefault = false ) const;
# 516 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  bool readBoolEntry( const char *pKey, const bool bDefault = false ) const;
# 529 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QRect readRectEntry( const QString& pKey, const QRect* pDefault = 0L ) const;
# 542 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QRect readRectEntry( const char *pKey, const QRect* pDefault = 0L ) const;
# 555 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QPoint readPointEntry( const QString& pKey, const QPoint* pDefault = 0L ) const;
# 568 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QPoint readPointEntry( const char *pKey, const QPoint* pDefault = 0L ) const;
# 581 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QSize readSizeEntry( const QString& pKey, const QSize* pDefault = 0L ) const;
# 594 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QSize readSizeEntry( const char *pKey, const QSize* pDefault = 0L ) const;
# 608 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QColor readColorEntry( const QString& pKey, const QColor* pDefault = 0L ) const;
# 621 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QColor readColorEntry( const char *pKey, const QColor* pDefault = 0L ) const;
# 635 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QDateTime readDateTimeEntry( const QString& pKey, const QDateTime* pDefault = 0L ) const;
# 649 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  QDateTime readDateTimeEntry( const char *pKey, const QDateTime* pDefault = 0L ) const;
# 659 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
   QString readEntryUntranslated( const QString& pKey,
                     const QString& aDefault = QString::null ) const;
# 670 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
   QString readEntryUntranslated( const char *pKey,
                     const QString& aDefault = QString::null ) const;
# 690 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QString& pValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 711 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QString& pValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 734 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QVariant& rValue,
                    bool bPersistent = true, bool bGlobal = false,
                    bool bNLS = false );
# 756 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QVariant& rValue,
                    bool bPersistent = true, bool bGlobal = false,
                    bool bNLS = false );
# 779 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QStrList &rValue,
                   char sep = ',', bool bPersistent = true, bool bGlobal = false, bool bNLS = false );
# 800 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QStrList &rValue,
                   char sep = ',', bool bPersistent = true, bool bGlobal = false, bool bNLS = false );
# 822 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QStringList &rValue,
                   char sep = ',', bool bPersistent = true, bool bGlobal = false, bool bNLS = false );
# 843 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QStringList &rValue,
                   char sep = ',', bool bPersistent = true, bool bGlobal = false, bool bNLS = false );
# 866 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QValueList<int>& rValue,
                   bool bPersistent = true, bool bGlobal = false, bool bNLS = false );
# 887 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QValueList<int>& rValue,
                   bool bPersistent = true, bool bGlobal = false, bool bNLS = false );
# 907 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const char *pValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false )
    { writeEntry(pKey, QString::fromLatin1(pValue), bPersistent, bGlobal, bNLS); }
# 928 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const char *pValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false )
    { writeEntry(pKey, QString::fromLatin1(pValue), bPersistent, bGlobal, bNLS); }
# 948 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, int nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 966 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, int nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 985 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, unsigned int nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1003 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, unsigned int nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1021 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, long nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1038 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, long nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1056 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, unsigned long nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1073 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, unsigned long nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1094 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, double nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      char format = 'g', int precision = 6,
                      bool bNLS = false );
# 1115 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, double nValue,
                      bool bPersistent = true, bool bGlobal = false,
                      char format = 'g', int precision = 6,
                      bool bNLS = false );
# 1134 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, bool bValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1151 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, bool bValue,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1169 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QFont& rFont,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1186 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QFont& rFont,
                      bool bPersistent = true, bool bGlobal = false,
                      bool bNLS = false );
# 1207 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QColor& rColor,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1227 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QColor& rColor,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1248 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QDateTime& rDateTime,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1268 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QDateTime& rDateTime,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1290 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QRect& rValue,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1310 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QRect& rValue,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1331 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QPoint& rValue,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1351 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QPoint& rValue,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1372 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const QString& pKey, const QSize& rValue,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1392 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writeEntry( const char *pKey, const QSize& rValue,
                   bool bPersistent = true, bool bGlobal = false,
                   bool bNLS = false );
# 1413 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writePathEntry( const QString& pKey, const QString & path,
                       bool bPersistent = true, bool bGlobal = false,
                       bool bNLS = false );
# 1433 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writePathEntry( const char *pKey, const QString & path,
                       bool bPersistent = true, bool bGlobal = false,
                       bool bNLS = false );
# 1459 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writePathEntry( const QString& pKey, const QStringList &rValue,
                   char sep = ',', bool bPersistent = true, bool bGlobal = false, bool bNLS = false );
# 1483 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void writePathEntry( const char *pKey, const QStringList &rValue,
                   char sep = ',', bool bPersistent = true, bool bGlobal = false, bool bNLS = false );
# 1495 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
   void deleteEntry( const QString& pKey,
                   bool bNLS = false, bool bGlobal = false);
# 1505 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
   void deleteEntry( const char *pKey,
                   bool bNLS = false, bool bGlobal = false);
# 1525 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  bool deleteGroup( const QString& group, bool bDeep = true, bool bGlobal = false );
# 1535 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void setDollarExpansion( bool _bExpand = true ) { bExpand = _bExpand; }






  bool isDollarExpansion() const { return bExpand; }
# 1558 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual void rollback( bool bDeep = true );
# 1573 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual void sync();





  bool isDirty() const { return bDirty; }
# 1588 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual void setReadOnly(bool _ro) { bReadOnly = _ro; }






  bool isReadOnly() const { return bReadOnly; }
# 1606 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  bool hasKey( const QString& key ) const;
# 1618 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual QMap<QString, QString> entryMap(const QString &group) const = 0;
# 1632 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual void reparseConfiguration() = 0;





  bool isImmutable() const;







  bool groupIsImmutable(const QString &group) const;







  bool entryIsImmutable(const QString &key) const;






  enum ConfigState { NoAccess, ReadOnly, ReadWrite };
# 1676 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  ConfigState getConfigState() const;






  bool checkConfigFilesWritable(bool warnUser);







  void setReadDefaults(bool b);






  bool readDefaults() const;
# 1711 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  void revertToDefault(const QString &key);
# 1733 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  bool hasDefault(const QString &key) const;

protected:





  void setLocale();






  virtual void setDirty(bool _bDirty = true) { bDirty = _bDirty; }






  virtual void parseConfigFiles();
# 1772 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual KEntryMap internalEntryMap( const QString& pGroup ) const = 0;
# 1785 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual KEntryMap internalEntryMap() const = 0;
# 1802 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual void putData(const KEntryKey &_key, const KEntry &_data, bool _checkGroup = true) = 0;
# 1818 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  virtual KEntry lookupData(const KEntryKey &_key) const = 0;

  virtual bool internalHasGroup(const QCString &group) const = 0;




  KConfigBackEnd *backEnd;
public:



  void setGroup( const QCString &pGroup );
  void setGroup( const char *pGroup );
  bool hasGroup(const QCString &_pGroup) const;
  bool hasGroup(const char *_pGroup) const;
  bool hasKey( const char *pKey ) const;

protected:
  QCString readEntryUtf8( const char *pKey) const;



  QCString mGroup;



  QCString aLocaleString;




  bool bDirty;

  bool bLocaleInitialized;
  bool bReadOnly;
  mutable bool bExpand;

protected:
  virtual void virtual_hook( int id, void* data );
private:
  class KConfigBasePrivate;
  KConfigBasePrivate *d;
};

class KConfigGroupSaverPrivate;
# 1898 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
class KConfigGroupSaver
{
public:
# 1910 "/coolo/prod/kdelibs/kdecore/kconfigbase.h"
  KConfigGroupSaver( KConfigBase* config, QString group )

      : _config(config), _oldgroup(config->group())
        { _config->setGroup( group ); }

  KConfigGroupSaver( KConfigBase* config, const char *group )
      : _config(config), _oldgroup(config->group())
        { _config->setGroup( group ); }

  KConfigGroupSaver( KConfigBase* config, const QCString &group )
      : _config(config), _oldgroup(config->group())
        { _config->setGroup( group ); }

  ~KConfigGroupSaver() { _config->setGroup( _oldgroup ); }

    KConfigBase* config() { return _config; };

private:
  KConfigBase* _config;
  QString _oldgroup;

  KConfigGroupSaver(const KConfigGroupSaver&);
  KConfigGroupSaver& operator=(const KConfigGroupSaver&);

  KConfigGroupSaverPrivate *d;
};

class KConfigGroupPrivate;




class KConfigGroup: public KConfigBase
{
public:




   KConfigGroup(KConfigBase *master, const QCString &group);






   KConfigGroup(KConfigBase *master, const QString &group);







   KConfigGroup(KConfigBase *master, const char * group);







   void deleteGroup(bool bGlobal = false);


   virtual void setDirty(bool b);
   virtual void putData(const KEntryKey &_key, const KEntry &_data, bool _checkGroup = true);
   virtual KEntry lookupData(const KEntryKey &_key) const;
   virtual void sync();

private:

   void setGroup() { }
   void setDesktopGroup() { }
   void group() { }
   void hasGroup() { }
   void setReadOnly(bool) { }
   void isDirty() { }


   virtual QStringList groupList() const { return QStringList(); }
   virtual void rollback(bool) { }
   virtual void reparseConfiguration() { }
   virtual QMap<QString, QString> entryMap(const QString &) const
    { return QMap<QString,QString>(); }
   virtual KEntryMap internalEntryMap( const QString&) const
    { return KEntryMap(); }
   virtual KEntryMap internalEntryMap() const
    { return KEntryMap(); }
   virtual bool internalHasGroup(const QCString &) const
    { return false; }

   void getConfigState() { }

   KConfigBase *mMaster;
protected:
   virtual void virtual_hook( int id, void* data );
private:
   KConfigGroupPrivate* d;
};
# 30 "/coolo/prod/kdelibs/kdecore/kconfig.h" 2

class KConfigPrivate;
# 43 "/coolo/prod/kdelibs/kdecore/kconfig.h"
class KConfig : public KConfigBase
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
# 61 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  KConfig( const QString& fileName = QString::null,
          bool bReadOnly = false, bool bUseKDEGlobals = true, const char *resType="config");

  KConfig(KConfigBackEnd *backEnd, bool bReadOnly = false);







  virtual ~KConfig();
# 86 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  virtual void rollback(bool bDeep = true);






  virtual QStringList groupList() const;
# 106 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  virtual QMap<QString, QString> entryMap(const QString &pGroup) const;





  virtual void reparseConfiguration();







  void setFileWriteMode(int mode);







  void setForceGlobal( bool force ) { bForceGlobal = force; }






  bool forceGlobal() const { return bForceGlobal; }
# 151 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  void checkUpdate(const QString &id, const QString &updateFile);
# 162 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  KConfig* copyTo(const QString &file);

protected:







  virtual bool internalHasGroup(const QCString &group) const;
# 184 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  virtual KEntryMap internalEntryMap(const QString &pGroup) const;
# 195 "/coolo/prod/kdelibs/kdecore/kconfig.h"
   virtual KEntryMap internalEntryMap() const { return aEntryMap; }
# 207 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  virtual void putData(const KEntryKey &_key, const KEntry &_data, bool _checkGroup=true);
# 217 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  virtual KEntry lookupData(const KEntryKey &_key) const;
# 226 "/coolo/prod/kdelibs/kdecore/kconfig.h"
  KEntryMap aEntryMap;

private:




  KConfig( const KConfig& );




  KConfig& operator= ( const KConfig& rConfig );

private:
  bool bGroupImmutable : 1;
  bool bFileImmutable : 1;
  bool bForceGlobal : 1;
protected:
  virtual void virtual_hook( int id, void* data );
private:
  KConfigPrivate *d;
};
# 61 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.h"



class KSimpleConfigPrivate;
# 43 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.h"
class KSimpleConfig : public KConfig
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
# 58 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.h"
  KSimpleConfig( const QString &fileName, bool bReadOnly = false);

  KSimpleConfig(KConfigBackEnd *backEnd, bool bReadOnly = false);






  virtual ~KSimpleConfig();

  virtual void sync();

private:


  KSimpleConfig( const KSimpleConfig& );
  KSimpleConfig& operator= ( const KSimpleConfig& rConfig );

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KSimpleConfigPrivate *d;
};
# 62 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"


# 1 "/coolo/prod/kdelibs/kdecore/kurl.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kurl.h"





class QUrl;
class QStringList;
template <typename K, typename V> class QMap;

class KURLPrivate;
# 118 "/coolo/prod/kdelibs/kdecore/kurl.h"
class KURL
{
public:
  enum AdjustementFlags
  {
    NoAdjustements = 0,
    StripFileProtocol = 1
  };







  class List : public QValueList<KURL>
  {
  public:



      List() { }





      List(const KURL &url);





      List(const QStringList &list);




      QStringList toStringList() const;
  };



  KURL();




  ~KURL();
# 184 "/coolo/prod/kdelibs/kdecore/kurl.h"
  KURL( const QString& url, int encoding_hint = 0 );
# 194 "/coolo/prod/kdelibs/kdecore/kurl.h"
  KURL( const char * url, int encoding_hint = 0 );
# 204 "/coolo/prod/kdelibs/kdecore/kurl.h"
  KURL( const QCString& url, int encoding_hint = 0 );




  KURL( const KURL& u );




  KURL( const QUrl &u );
# 227 "/coolo/prod/kdelibs/kdecore/kurl.h"
  KURL( const KURL& _baseurl, const QString& _rel_url, int encoding_hint=0 );






  QString protocol() const { return m_bIsMalformed ? QString::null : m_strProtocol; }




  void setProtocol( const QString& _txt );





  QString user() const { return m_strUser; }






  void setUser( const QString& _txt );




  bool hasUser() const { return !m_strUser.isEmpty(); }





  QString pass() const { return m_strPass; }
# 274 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void setPass( const QString& _txt );




  bool hasPass() const { return !m_strPass.isEmpty(); }





  QString host() const { return m_strHost; }







  void setHost( const QString& _txt );




  bool hasHost() const { return !m_strHost.isEmpty(); }






  unsigned short int port() const { return m_iPort; }




  void setPort( unsigned short int _p );






  QString path() const { return m_strPath; }
# 332 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString path( int _trailing ) const;
# 342 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void setPath( const QString& path );





  bool hasPath() const { return !m_strPath.isEmpty(); }
# 358 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void cleanPath(bool cleanDirSeparator = true);
# 371 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void adjustPath(int _trailing);
# 380 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void setEncodedPathAndQuery( const QString& _txt, int encoding_hint = 0 );







  void setEncodedPath(const QString& _txt, int encoding_hint = 0 );
# 407 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString encodedPathAndQuery( int _trailing = 0, bool _no_empty_path = false, int encoding_hint = 0) const;
# 417 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void setQuery( const QString& _txt, int encoding_hint = 0);
# 427 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString query() const;





  QString ref() const { return m_strRef_encoded; }





  void setRef( const QString& _txt ) { m_strRef_encoded = _txt; }







  bool hasRef() const { return !m_strRef_encoded.isNull(); }
# 456 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString htmlRef() const;






  QString encodedHtmlRef() const;
# 472 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void setHTMLRef( const QString& _ref );






  bool hasHTMLRef() const;






  bool isValid() const { return !m_bIsMalformed; }



  __attribute__ ((deprecated)) bool isMalformed() const { return !isValid(); }






  bool isLocalFile() const;







  void setFileEncoding(const QString &encoding);







  QString fileEncoding() const;







  bool hasSubURL() const;
# 533 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void addPath( const QString& txt );





  QString queryItem( const QString& item ) const;
# 550 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString queryItem( const QString& item, int encoding_hint ) const;
# 560 "/coolo/prod/kdelibs/kdecore/kurl.h"
  enum QueryItemsOptions { CaseInsensitiveKeys = 1 };




  QMap< QString, QString > queryItems( int options=0 ) const;
# 578 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QMap< QString, QString > queryItems( int options, int encoding_hint ) const;
# 590 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void addQueryItem( const QString& _item, const QString& _value, int encoding_hint = 0 );






  void removeQueryItem( const QString& _item );
# 612 "/coolo/prod/kdelibs/kdecore/kurl.h"
  void setFileName( const QString&_txt );
# 624 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString fileName( bool _ignore_trailing_slash_in_path = true ) const;
# 637 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString directory( bool _strip_trailing_slash_from_result = true,
                     bool _ignore_trailing_slash_in_path = true ) const;




  void setDirectory(const QString &dir);
# 658 "/coolo/prod/kdelibs/kdecore/kurl.h"
  bool cd( const QString& _dir );
# 678 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString url( int _trailing = 0, int encoding_hint = 0) const;
# 693 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString prettyURL( int _trailing = 0) const;
# 704 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString prettyURL( int _trailing, AdjustementFlags _flags) const;
# 713 "/coolo/prod/kdelibs/kdecore/kurl.h"
  QString htmlURL() const;






  bool isEmpty() const;
# 730 "/coolo/prod/kdelibs/kdecore/kurl.h"
  KURL upURL( ) const;

  bool operator<(const KURL& _u) const;

  KURL& operator=( const KURL& _u );
  KURL& operator=( const QString& _url );
  KURL& operator=( const char * _url );
  KURL& operator=( const QUrl & u );

  bool operator==( const KURL& _u ) const;
  bool operator==( const QString& _u ) const;
  bool operator!=( const KURL& _u ) const { return !( *this == _u ); }
  bool operator!=( const QString& _u ) const { return !( *this == _u ); }
# 753 "/coolo/prod/kdelibs/kdecore/kurl.h"
  bool cmp( const KURL &u, bool ignore_trailing = false ) const __attribute__ ((deprecated));
# 763 "/coolo/prod/kdelibs/kdecore/kurl.h"
  bool equals( const KURL &u, bool ignore_trailing = false ) const;






  bool isParentOf( const KURL& u ) const;
# 787 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static List split( const QString& _url );
# 804 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static List split( const KURL& _url );
# 813 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static KURL join( const List& _list );
# 828 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static KURL fromPathOrURL( const QString& text );
# 840 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static QString encode_string(const QString &str, int encoding_hint = 0);
# 852 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static QString encode_string_no_slash(const QString &str, int encoding_hint = 0);
# 864 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static QString decode_string(const QString &str, int encoding_hint = 0);
# 874 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static bool isRelativeURL(const QString &_url);
# 890 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static QString relativeURL(const KURL &base_url, const KURL &url, int encoding_hint = 0);
# 899 "/coolo/prod/kdelibs/kdecore/kurl.h"
  static QString relativePath(const QString &base_dir, const QString &path, bool *isParent=0);




  QString filename( bool _ignore_trailing_slash_in_path = true ) const
  {
    return fileName(_ignore_trailing_slash_in_path);
  }

protected:
  void reset();
  void parse( const QString& _url, int encoding_hint = 0);

private:
  QString m_strProtocol;
  QString m_strUser;
  QString m_strPass;
  QString m_strHost;
  QString m_strPath;
  QString m_strRef_encoded;
  QString m_strQuery_encoded;
  bool m_bIsMalformed : 1;
  uint freeForUse : 7;
  unsigned short int m_iPort;
  QString m_strPath_encoded;

  friend QDataStream & operator<< (QDataStream & s, const KURL & a);
  friend QDataStream & operator>> (QDataStream & s, KURL & a);
private:
  KURLPrivate* d;
};
# 939 "/coolo/prod/kdelibs/kdecore/kurl.h"
bool urlcmp( const QString& _url1, const QString& _url2 );
# 951 "/coolo/prod/kdelibs/kdecore/kurl.h"
bool urlcmp( const QString& _url1, const QString& _url2, bool _ignore_trailing, bool _ignore_ref );

QDataStream & operator<< (QDataStream & s, const KURL & a);
QDataStream & operator>> (QDataStream & s, KURL & a);
# 24 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h" 2





typedef QValueList<QCString> QCStringList;







struct KCmdLineOptions
{
# 52 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
   const char *name;




   const char *description;



   const char *def;
};


class KCmdLineArgsList;
class KApplication;
class KUniqueApplication;
class KCmdLineParsedOptions;
class KCmdLineParsedArgs;
class KAboutData;
class KCmdLineArgsPrivate;
# 214 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
class KCmdLineArgs
{
  friend class KApplication;
  friend class KUniqueApplication;
  friend class QPtrList<KCmdLineArgs>;
public:
# 237 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
   static void init(int _argc, char **_argv, const char *_appname,
                    const char* programName, const char *_description,
                    const char *_version, bool noKApp = false);



  static void init(int _argc, char **_argv,
                   const char *_appname, const char *_description,
                   const char *_version, bool noKApp = false) __attribute__ ((deprecated));
# 257 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  static void init(int _argc, char **_argv,
                   const KAboutData *about, bool noKApp = false);
# 270 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  static void init(const KAboutData *about);
# 332 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  static void addCmdLineOptions( const KCmdLineOptions *options,
                                 const char *name=0, const char *id = 0,
                                 const char *afterId=0);
# 345 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  static KCmdLineArgs *parsedArgs(const char *id=0);
# 356 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  static QString cwd();





  static const char *appName();
# 371 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  static void usage(const char *id = 0);





  static void usage(const QString &error);







  static void enable_i18n();
# 406 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  QCString getOption(const char *option) const;
# 422 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  QCStringList getOptionList(const char *option) const;
# 440 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  bool isSet(const char *option) const;







  int count() const;
# 458 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  const char *arg(int n) const;
# 473 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  KURL url(int n) const;







  static KURL makeURL( const char * urlArg );







  static void setCwd( char * cwd ) { mCwd = cwd; }




  void clear();


protected:




  KCmdLineArgs( const KCmdLineOptions *_options, const char *_id,
                const char *_name);
# 512 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  ~KCmdLineArgs();

private:





  static void findOption(const char *_opt, QCString opt, int &i, bool enabled, bool &moreOptions);







  static void parseAllArgs();






  static int *qt_argc();







  static char ***qt_argv();
# 552 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  static void removeArgs(const char *id);







  static void saveAppArgs( QDataStream &);






  static void loadAppArgs( QDataStream &);






  void setOption(const QCString &option, bool enabled);






  void setOption(const QCString &option, const char *value);






  void addArgument(const char *argument);






  void save( QDataStream &) const;






  void load( QDataStream &);
# 619 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.h"
  static void initIgnore(int _argc, char **_argv, const char *_appname);

  static void printQ(const QString &msg);

  const KCmdLineOptions *options;
  const char *name;
  const char *id;
  KCmdLineParsedOptions *parsedOptionList;
  KCmdLineParsedArgs *parsedArgList;
  bool isQt;

  static KCmdLineArgsList *argsList;
  static const KAboutData *about;

  static int argc;
  static char **argv;
  static bool parsed;
  static bool ignoreUnknown;
  static char *mCwd;
  static bool parseArgs;

  KCmdLineArgsPrivate *d;
};
# 63 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaboutdata.h" 1
# 27 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"

class KAboutPersonPrivate;
class KAboutDataPrivate;
# 39 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
class KAboutPerson
{
public:
# 55 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
    KAboutPerson( const char *name, const char *task,
                  const char *emailAddress, const char *webAddress )
    {
      mName = name;
      mTask = task;
      mEmailAddress = emailAddress;
      mWebAddress = webAddress;
    }



    KAboutPerson() {}






    QString name() const;






    QString task() const;






    QString emailAddress() const;






    QString webAddress() const;

private:
    const char *mName;
    const char *mTask;
    const char *mEmailAddress;
    const char *mWebAddress;

    KAboutPersonPrivate *d;
};

class KAboutTranslatorPrivate;
# 118 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
class KAboutTranslator
{
public:







    KAboutTranslator(const QString & name=QString::null,
                     const QString & emailAddress=QString::null);






    QString name() const;






    QString emailAddress() const;

private:
    QString mName;
    QString mEmail;
    KAboutTranslatorPrivate* d;
};
# 167 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
class KAboutData
{
  public:



    enum LicenseKey
    {
      License_Custom = -2,
      License_File = -1,
      License_Unknown = 0,
      License_GPL = 1,
      License_GPL_V2 = 1,
      License_LGPL = 2,
      License_LGPL_V2 = 2,
      License_BSD = 3,
      License_Artistic = 4,
      License_QPL = 5,
      License_QPL_V1_0 = 5
    };

  public:
# 223 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
    KAboutData( const char *appName,
                const char *programName,
                const char *version,
                const char *shortDescription = 0,
                int licenseType = License_Unknown,
                const char *copyrightStatement = 0,
                const char *text = 0,
                const char *homePageAddress = 0,
                const char *bugsEmailAddress = "submit@bugs.kde.org"
                );

     ~KAboutData();
# 255 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
    void addAuthor( const char *name,
                    const char *task=0,
                    const char *emailAddress=0,
                    const char *webAddress=0 );
# 279 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
    void addCredit( const char *name,
                    const char *task=0,
                    const char *emailAddress=0,
                    const char *webAddress=0 );
# 308 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
    void setTranslator(const char* name, const char* emailAddress);
# 325 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
    void setLicenseText( const char *license );






    void setLicenseTextFile( const QString &file );





    const char *appName() const;





    QString programName() const;





    QString version() const;






    QString shortDescription() const;






    QString homepage() const;





    QString bugAddress() const;





    const QValueList<KAboutPerson> authors() const;





    const QValueList<KAboutPerson> credits() const;





    const QValueList<KAboutTranslator> translators() const;





    static QString aboutTranslationTeam();





    QString otherText() const;
# 409 "/coolo/prod/kdelibs/kdecore/kaboutdata.h"
    QString license() const;





    QString copyrightStatement() const;

  private:
    const char *mAppName;
    const char *mProgramName;
    const char *mVersion;
    const char *mShortDescription;
    int mLicenseKey;
    const char *mCopyrightStatement;
    const char *mOtherText;
    const char *mHomepageAddress;
    const char *mBugEmailAddress;
    QValueList<KAboutPerson> mAuthorList;
    QValueList<KAboutPerson> mCreditList;
    const char *mLicenseText;

    KAboutDataPrivate *d;
};
# 64 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"






class KURL;







class KGlobalSettings
{
  public:
# 90 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static int dndEventDelay();







    static bool singleClick();







    enum TearOffHandle {
      Disable = 0,
      ApplicationLevel,
      Enable
    };






    static TearOffHandle insertTearOffHandle();





    static bool changeCursorOverIcon();






    static bool visualActivate();






    static unsigned int visualActivateSpeed();






    static int autoSelectDelay();







    static int contextMenuKey ();







    static bool showContextMenusOnPress ();






   enum Completion {



       CompletionNone=1,



       CompletionAuto,



       CompletionMan,



       CompletionShell,



       CompletionPopup,




       CompletionPopupAuto
   };






    static Completion completionMode();




    struct KMouseSettings
    {
        enum { RightHanded = 0, LeftHanded = 1 };
        int handed;
    };





    static KMouseSettings & mouseSettings();





    static QString desktopPath() { initStatic(); return *s_desktopPath; }





    static QString autostartPath() { initStatic(); return *s_autostartPath; }





    static QString trashPath() { initStatic(); return *s_trashPath; }





    static QString documentPath() { initStatic(); return *s_documentPath; }






    static QColor toolBarHighlightColor();





    static QColor inactiveTitleColor();





    static QColor inactiveTextColor();





    static QColor activeTitleColor();





    static QColor activeTextColor();






    static int contrast();






    static QColor baseColor();






    static QColor textColor();





    static QColor linkColor();





    static QColor visitedLinkColor();






    static QColor highlightedTextColor();






    static QColor highlightColor();
# 327 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static QColor alternateBackgroundColor();
# 336 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static QColor calculateAlternateBackgroundColor(const QColor& base);






    static QFont generalFont();





    static QFont fixedFont();





    static QFont toolBarFont();





    static QFont menuFont();





    static QFont windowTitleFont();





    static QFont taskbarFont();







    static QFont largeFont(const QString &text = QString::null);







    static bool isMultiHead();
# 403 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static bool wheelMouseZooms();
# 415 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static QRect splashScreenDesktopGeometry();
# 433 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static QRect desktopGeometry(const QPoint& point);
# 448 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static QRect desktopGeometry(QWidget* w);
# 458 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static bool showIconsOnPushButtons();
# 468 "/coolo/prod/kdelibs/kdecore/kglobalsettings.h"
    static bool showFilePreview(const KURL &);

private:



    static void initStatic();



    static void initColors();



    static void rereadFontSettings();



    static void rereadPathSettings();



    static void rereadMouseSettings();


    static QString* s_desktopPath;
    static QString* s_autostartPath;
    static QString* s_trashPath;
    static QString* s_documentPath;
    static QFont *_generalFont;
    static QFont *_fixedFont;
    static QFont *_toolBarFont;
    static QFont *_menuFont;
    static QFont *_windowTitleFont;
    static QFont *_taskbarFont;
    static QFont *_largeFont;
    static QColor * kde2Gray;
    static QColor * kde2Blue;
    static QColor * kde2AlternateColor;
    static KMouseSettings *s_mouseSettings;

    friend class KApplication;
};
# 65 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcrash.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kcrash.h"
# 36 "/coolo/prod/kdelibs/kdecore/kcrash.h"
class KCrash
{
 private:
  static const char *appName;
  static const char *appPath;

 public:




  static void defaultCrashHandler (int signal);





  typedef void (*HandlerType)(int);
# 66 "/coolo/prod/kdelibs/kdecore/kcrash.h"
  static void setCrashHandler (HandlerType handler = defaultCrashHandler);





  static HandlerType crashHandler() { return _crashHandler; }
# 81 "/coolo/prod/kdelibs/kdecore/kcrash.h"
  static void setEmergencySaveFunction (HandlerType saveFunction = (HandlerType)0);




  static HandlerType emergencySaveFunction() { return _emergencySaveFunction; }






  static void setApplicationPath (QString path) { appPath = qstrdup(path.local8Bit().data()); }







  static void setApplicationName (QString name) { appName = qstrdup(name.local8Bit().data()); }


 protected:



  static HandlerType _crashHandler;



  static HandlerType _emergencySaveFunction;
};
# 66 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/dcop/kdatastream.h" 1




inline QDataStream & operator << (QDataStream & str, bool b)
{
  str << Q_INT8(b);
  return str;
}

inline QDataStream & operator >> (QDataStream & str, bool & b)
{
  Q_INT8 l;
  str >> l;
  b = bool(l);
  return str;
}
# 67 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/klibloader.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/klibloader.h"
# 30 "/coolo/prod/kdelibs/kdecore/klibloader.h"
class KInstance;
class QTimer;
class KLibrary;
class KLibFactory;
class KLibFactoryPrivate;
class KLibLoaderPrivate;
class KLibraryPrivate;

# 50 "/coolo/prod/kdelibs/kdecore/klibloader.h"
class KLibrary : public QObject
{
    friend class KLibLoader;
    friend class QAsciiDict<KLibrary>;

    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:




    KLibrary( const QString& libname, const QString& filename, void * handle );





    QString name() const;





    QString fileName() const;





    KLibFactory* factory();
# 90 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    void* symbol( const char* name ) const;
# 101 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    bool hasSymbol( const char* name ) const;






    void unload() const;

private :
    void slotObjectCreated( QObject *obj );
    void slotObjectDestroyed();
    void slotTimeout();

private:




    ~KLibrary();

    QString m_libname;
    QString m_filename;
    KLibFactory* m_factory;
    void * m_handle;
    QPtrList<QObject> m_objs;
    QTimer *m_timer;
    KLibraryPrivate *d;
};

class KLibWrapPrivate;
# 143 "/coolo/prod/kdelibs/kdecore/klibloader.h"
class KLibLoader : public QObject
{
    friend class KLibrary;

    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:





    ~KLibLoader();
# 176 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    KLibFactory* factory( const char* libname );
# 198 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    virtual KLibrary* library( const char* libname );
# 222 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    KLibrary* globalLibrary( const char *name );
# 231 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    QString lastErrorMessage() const;
# 247 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    virtual void unloadLibrary( const char *libname );







    static KLibLoader* self();
# 265 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    static void cleanUp();
# 277 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    static QString findLibrary( const char * name, const KInstance * instance = KGlobal::instance() );

protected:
    KLibLoader( QObject* parent = 0, const char* name = 0 );

private :
    void slotLibraryDestroyed();
private:
    void close_pending( KLibWrapPrivate * );
    QAsciiDict<KLibWrapPrivate> m_libs;

    static KLibLoader* s_self;

protected:
    virtual void virtual_hook( int id, void* data );
private:
    KLibLoaderPrivate *d;
};
# 331 "/coolo/prod/kdelibs/kdecore/klibloader.h"
class KLibFactory : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:





    KLibFactory( QObject* parent = 0, const char* name = 0 );
    virtual ~KLibFactory();
# 364 "/coolo/prod/kdelibs/kdecore/klibloader.h"
     QObject* create( QObject* parent = 0, const char* name = 0, const char* classname = "QObject", const QStringList &args = QStringList() );

protected:




    void objectCreated( QObject *obj );


protected:
# 392 "/coolo/prod/kdelibs/kdecore/klibloader.h"
    virtual QObject* createObject( QObject* parent = 0, const char* name = 0,
                                   const char* classname = "QObject",
                                   const QStringList &args = QStringList() ) = 0;


protected:
    virtual void virtual_hook( int id, void* data );
private:
    KLibFactoryPrivate *d;
};
# 68 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kmimesourcefactory.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kmimesourcefactory.h"




class KMimeSourceFactoryPrivate;
# 39 "/coolo/prod/kdelibs/kdecore/kmimesourcefactory.h"
class KMimeSourceFactory : public QMimeSourceFactory
{
public:






  KMimeSourceFactory (KIconLoader* loader = KGlobal::iconLoader());




  virtual ~KMimeSourceFactory();
# 69 "/coolo/prod/kdelibs/kdecore/kmimesourcefactory.h"
  virtual QString makeAbsolute (const QString& abs_or_rel_name, const QString& context) const;

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KMimeSourceFactoryPrivate* d;
};
# 69 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kstdaccel.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kstdaccel.h"


# 1 "/coolo/prod/kdelibs/kdecore/kshortcut.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kshortcut.h"

# 1 "/coolo/prod/qt-copy/include/qkeysequence.h" 1
# 39 "/coolo/prod/qt-copy/include/qkeysequence.h"
# 54 "/coolo/prod/qt-copy/include/qkeysequence.h"
class QKeySequence;
 QDataStream &operator<<( QDataStream &, const QKeySequence & );
 QDataStream &operator>>( QDataStream &, QKeySequence & );


class QKeySequencePrivate;

class QKeySequence : public Qt
{
public:
    QKeySequence();
    QKeySequence( const QString& key );
    QKeySequence( int key );
    QKeySequence( int k1, int k2, int k3 = 0, int k4 = 0 );
    QKeySequence( const QKeySequence & );
    ~QKeySequence();

    uint count() const;
    bool isEmpty() const;
    Qt::SequenceMatch matches( const QKeySequence & ) const;

    operator QString() const;
    operator int () const;
    int operator[]( uint ) const;
    QKeySequence &operator=( const QKeySequence & );
    bool operator==( const QKeySequence& ) const;
    bool operator!= ( const QKeySequence& ) const;

private:
    static int decodeString( const QString & );
    static QString encodeString( int );
    int assign( QString );
    void setKey( int key, int index );

    QKeySequencePrivate* d;

    friend QDataStream &operator<<( QDataStream &, const QKeySequence & );
    friend QDataStream &operator>>( QDataStream &, QKeySequence & );
    friend class QAccelManager;
};
# 24 "/coolo/prod/kdelibs/kdecore/kshortcut.h" 2


class QKeyEvent;
class KKeyNative;
# 39 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
class KKey
{
 public:




        enum { MOD_FLAG_COUNT = 4 };
        enum { QtWIN = (Qt::ALT << 1) };




        enum ModFlag {
                SHIFT = 0x01,
                CTRL = 0x02,
                ALT = 0x04,
                WIN = 0x08
        };







        KKey();






        KKey( int keyQt );





        KKey( const QKeySequence& keySeq );





        KKey( const QKeyEvent* keyEvent );




        KKey( const KKey& key );
# 99 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        KKey( const QString& key );



        KKey( uint key, uint mod );
        ~KKey();






        void clear();







        bool init( int keyQt );






        bool init( const QKeySequence& keySeq );






        bool init( const QKeyEvent* keyEvent );






        bool init( const KKey& key );
# 151 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool init( const QString& key);




        bool init( uint key, uint mod );




        KKey& operator =( const KKey& key )
                { init( key ); return *this; }
# 172 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool isNull() const;




        bool isValidQt() const;




        bool isValidNative() const;




        uint sym() const;



        uint modFlags() const;
# 204 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        int compare( const KKey& key ) const;





        bool operator == ( const KKey& key ) const
                { return compare( key ) == 0; }




        bool operator != ( const KKey& key ) const
                { return compare( key ) != 0; }




        bool operator < ( const KKey& key ) const
                { return compare( key ) < 0; }







        int keyCodeQt() const;






        QString toString() const;




        QString toStringInternal() const;





        void simplify();







        static KKey& null();






        static QString modFlagLabel( ModFlag f );

 private:
# 277 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        uint m_sym;



        uint m_mod;

 private:
        friend class KKeyNative;
};
# 294 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
class KKeySequence
{
 public:

        enum { MAX_KEYS = 4 };







        KKeySequence();





        KKeySequence( const QKeySequence& keySeq );





        KKeySequence( const KKey& key );





        KKeySequence( const KKeyNative& key );





        KKeySequence( const KKeySequence& keySeq );
# 340 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        KKeySequence( const QString& keySeq );

        ~KKeySequence();






        void clear();






        bool init( const QKeySequence& keySeq );






        bool init( const KKey& key );






        bool init( const KKeyNative& key );






        bool init( const KKeySequence& keySeq );
# 388 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool init( const QString& key );




        KKeySequence& operator =( const KKeySequence& seq )
                { init( seq ); return *this; }






        uint count() const;
# 411 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        const KKey& key( uint i ) const;




        bool isTriggerOnRelease() const;
# 426 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool setKey( uint i, const KKey& key );




        void setTriggerOnRelease( bool );
# 440 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool isNull() const;






        bool startsWith( const KKeySequence& keySeq ) const;
# 461 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        int compare( const KKeySequence& keySeq ) const;





        bool operator == ( const KKeySequence& seq ) const
                { return compare( seq ) == 0; }





        bool operator != ( const KKeySequence& seq ) const
                { return compare( seq ) != 0; }





        bool operator < ( const KKeySequence& seq ) const
                { return compare( seq ) < 0; }






        QKeySequence qt() const;







        int keyCodeQt() const;







        QString toString() const;




        QString toStringInternal() const;







        static KKeySequence& null();

 protected:
        uchar m_nKeys;
        uchar m_bTriggerOnRelease;

        KKey m_rgvar[MAX_KEYS];

 private:
        class KKeySequencePrivate* d;
        friend class KKeyNative;
};
# 539 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
class KShortcut
{
 public:




        enum { MAX_SEQUENCES = 2 };







        KShortcut();







        KShortcut( int keyQt );






        KShortcut( const QKeySequence& keySeq );






        KShortcut( const KKey& key );






        KShortcut( const KKeySequence& keySeq );





        KShortcut( const KShortcut& shortcut );
# 598 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        KShortcut( const char* shortcut );
# 607 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        KShortcut( const QString& shortcut );
        ~KShortcut();






        void clear();







        bool init( int keyQt );





        bool init( const QKeySequence& keySeq );





        bool init( const KKey& key );





        bool init( const KKeySequence& keySeq );





        bool init( const KShortcut& shortcut );
# 656 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool init( const QString& shortcut );




        KShortcut& operator =( const KShortcut& cut )
                { init( cut ); return *this; }







        uint count() const;
# 679 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        const KKeySequence& seq( uint i ) const;
# 688 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        int keyCodeQt() const;
# 697 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool isNull() const;
# 712 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        int compare( const KShortcut& shortcut ) const;





        bool operator == ( const KShortcut& cut ) const
                { return compare( cut ) == 0; }





        bool operator != ( const KShortcut& cut ) const
                { return compare( cut ) != 0; }





        bool operator < ( const KShortcut& cut ) const
                { return compare( cut ) < 0; }







        bool contains( const KKey& key ) const;







        bool contains( const KKeyNative& key ) const;






        bool contains( const KKeySequence& keySeq ) const;
# 767 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool setSeq( uint i, const KKeySequence& keySeq );
# 776 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool append( const KKeySequence& keySeq );
# 786 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool append( const KKey& spec );
# 795 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        bool append( const KShortcut& cut );





        operator QKeySequence () const;
# 810 "/coolo/prod/kdelibs/kdecore/kshortcut.h"
        QString toString() const;




        QString toStringInternal( const KShortcut* pcutDefault = 0 ) const;







        static KShortcut& null();

 protected:
        uint m_nSeqs;
        KKeySequence m_rgseq[MAX_SEQUENCES];

 private:
        class KShortcutPrivate* d;
        friend class KKeyNative;


 public:
        operator int () const { return keyCodeQt(); }

};
# 25 "/coolo/prod/kdelibs/kdecore/kstdaccel.h" 2


class QKeyEvent;
class KAccelActions;
# 41 "/coolo/prod/kdelibs/kdecore/kstdaccel.h"
namespace KStdAccel
{




  enum StdAccel {
    AccelNone,

    Open, New, Close, Save,

    Print,
    Quit,

    Undo, Redo, Cut, Copy, Paste, SelectAll, Deselect, DeleteWordBack,
    DeleteWordForward, Find, FindNext, FindPrev, Replace,

    Home, End, Prior, Next, GotoLine, AddBookmark, ZoomIn, ZoomOut,
    Up, Back, Forward, Reload, PopupMenuContext, ShowMenubar,

    Help, WhatsThis,

    TextCompletion, PrevCompletion, NextCompletion, SubstringCompletion,
    RotateUp, RotateDown,


    TabNext, TabPrev,

    FullScreen


    , WhatThis = WhatsThis

  };





  const KShortcut& shortcut(StdAccel id);






  QString name(StdAccel id);






  QString label(StdAccel id);






  QString whatsThis(StdAccel id);
# 111 "/coolo/prod/kdelibs/kdecore/kstdaccel.h"
  StdAccel findStdAccel( const KKeySequence &keySeq );







  KShortcut shortcutDefault(StdAccel id);






  KShortcut shortcutDefault3(StdAccel id);






  KShortcut shortcutDefault4(StdAccel id);





  const KShortcut& open();





  const KShortcut& openNew();





  const KShortcut& close();





  const KShortcut& save();





  const KShortcut& print();





  const KShortcut& quit();





  const KShortcut& undo();





  const KShortcut& redo();





  const KShortcut& cut();





  const KShortcut& copy();





  const KShortcut& paste();





  const KShortcut& selectAll();





  const KShortcut& deleteWordBack();





  const KShortcut& deleteWordForward();





  const KShortcut& find();





  const KShortcut& findNext();





  const KShortcut& findPrev();





  const KShortcut& replace();





  const KShortcut& zoomIn();





  const KShortcut& zoomOut();





  const KShortcut& insert();





  const KShortcut& home();





  const KShortcut& end();





  const KShortcut& prior();





  const KShortcut& next();





  const KShortcut& gotoLine();





  const KShortcut& addBookmark();






  const KShortcut& tabNext();






  const KShortcut& tabPrev();






  const KShortcut& fullScreen();





  const KShortcut& help();





  const KShortcut& completion();






  const KShortcut& prevCompletion();






  const KShortcut& nextCompletion();






  const KShortcut& substringCompletion();





  const KShortcut& rotateUp();





  const KShortcut& rotateDown();





  const KShortcut& popupMenuContext();





  const KShortcut& whatsThis();





  const KShortcut& reload();





  const KShortcut& up();





  const KShortcut& back();





  const KShortcut& forward();





  const KShortcut& showMenubar();






  QString action(StdAccel id) ;




  QString description(StdAccel id) ;




  int key(StdAccel) ;




  int defaultKey(StdAccel accel) ;
# 442 "/coolo/prod/kdelibs/kdecore/kstdaccel.h"
  bool isEqual(const QKeyEvent* pEvent, int keyQt) ;


}
# 70 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaccel.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kaccel.h"

# 1 "/coolo/prod/qt-copy/include/qaccel.h" 1
# 39 "/coolo/prod/qt-copy/include/qaccel.h"
# 48 "/coolo/prod/qt-copy/include/qaccel.h"
class QAccelPrivate;

class QAccel : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QAccel( QWidget *parent, const char *name=0 );
    QAccel( QWidget* watch, QObject *parent, const char *name=0 );
    ~QAccel();

    bool isEnabled() const;
    void setEnabled( bool );

    uint count() const;

    int insertItem( const QKeySequence& key, int id=-1);
    void removeItem( int id );
    void clear();

    QKeySequence key( int id );
    int findKey( const QKeySequence& key ) const;

    bool isItemEnabled( int id ) const;
    void setItemEnabled( int id, bool enable );

    bool connectItem( int id, const QObject *receiver, const char* member );
    bool disconnectItem( int id, const QObject *receiver, const char* member );

    void repairEventFilter();

    void setWhatsThis( int id, const QString& );
    QString whatsThis( int id ) const;
    void setIgnoreWhatsThis( bool );
    bool ignoreWhatsThis() const;

    static QKeySequence shortcutKey( const QString & );
    static QString keyToString(QKeySequence k );
    static QKeySequence stringToKey( const QString & );

protected:
    void activated( int id );
    void activatedAmbiguously( int id );

protected:
    bool eventFilter( QObject *, QEvent * );

private:
    QAccelPrivate * d;

private:

    QAccel( const QAccel & );
    QAccel &operator=( const QAccel & );

    friend class QAccelPrivate;
    friend class QAccelManager;
};
# 24 "/coolo/prod/kdelibs/kdecore/kaccel.h" 2




class QPopupMenu;
class QWidget;
class KAccelAction;
class KAccelActions;
class KConfigBase;

class KAccelPrivate;
# 94 "/coolo/prod/kdelibs/kdecore/kaccel.h"
class KAccel : public QAccel
{
        public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
 public:







        KAccel( QWidget* pParent, const char* psName = 0 );
# 114 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        KAccel( QWidget* watch, QObject* parent, const char* psName = 0 );
        virtual ~KAccel();






        KAccelActions& actions();






        const KAccelActions& actions() const;





        bool isEnabled();





        void setEnabled( bool bEnabled );






        bool getAutoUpdate();
# 160 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        bool setAutoUpdate( bool bAuto );
# 183 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        KAccelAction* insert( const QString& sAction, const QString& sLabel, const QString& sWhatsThis,
                         const KShortcut& cutDef,
                         const QObject* pObjSlot, const char* psMethodSlot,
                         bool bConfigurable = true, bool bEnabled = true );




        KAccelAction* insert( const QString& sAction, const QString& sLabel, const QString& sWhatsThis,
                         const KShortcut& cutDef3, const KShortcut& cutDef4,
                         const QObject* pObjSlot, const char* psMethodSlot,
                         bool bConfigurable = true, bool bEnabled = true );
# 208 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        KAccelAction* insert( const char* psAction, const KShortcut& cutDef,
                         const QObject* pObjSlot, const char* psMethodSlot,
                         bool bConfigurable = true, bool bEnabled = true );






        KAccelAction* insert( KStdAccel::StdAccel id,
                         const QObject* pObjSlot, const char* psMethodSlot,
                         bool bConfigurable = true, bool bEnabled = true );







        KAccelAction* insert( const QString& sName, const QString& sLabel );







        bool remove( const QString& sAction );
# 245 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        bool updateConnections();






        const KShortcut& shortcut( const QString& sAction ) const;







        bool setShortcut( const QString& sAction, const KShortcut &shortcut );
# 270 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        bool setSlot( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot );






        bool setEnabled( const QString& sAction, bool bEnabled );






        const QString& configGroup() const;






        void setConfigGroup( const QString &name );
# 304 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        bool readSettings( KConfigBase* pConfig = 0 );
# 313 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        bool writeSettings( KConfigBase* pConfig = 0 ) const;




        void emitKeycodeChanged();

 protected:



        void keycodeChanged();


 public:




        bool insertItem( const QString& sLabel, const QString& sAction,
                         const char* psKey,
                         int nIDMenu = 0, QPopupMenu* pMenu = 0, bool bConfigurable = true ) __attribute__ ((deprecated));



        bool insertItem( const QString& sLabel, const QString& sAction,
                         int key,
                         int nIDMenu = 0, QPopupMenu* pMenu = 0, bool bConfigurable = true ) __attribute__ ((deprecated));



        bool insertStdItem( KStdAccel::StdAccel id, const QString& descr = QString::null ) __attribute__ ((deprecated));



        bool connectItem( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot, bool bActivate = true ) __attribute__ ((deprecated));




        __attribute__ ((deprecated)) bool connectItem( KStdAccel::StdAccel accel, const QObject* pObjSlot, const char* psMethodSlot )
                { return insert( accel, pObjSlot, psMethodSlot ); }



        bool removeItem( const QString& sAction ) __attribute__ ((deprecated));



        bool setItemEnabled( const QString& sAction, bool bEnable ) __attribute__ ((deprecated));



        void changeMenuAccel( QPopupMenu *menu, int id, const QString& action ) ;



        void changeMenuAccel( QPopupMenu *menu, int id, KStdAccel::StdAccel accel ) ;



        static int stringToKey( const QString& ) __attribute__ ((deprecated));
# 383 "/coolo/prod/kdelibs/kdecore/kaccel.h"
        int currentKey( const QString& action ) const __attribute__ ((deprecated));







        QString findKey( int key ) const __attribute__ ((deprecated));


 protected:

        virtual void virtual_hook( int id, void* data );
 private:
        class KAccelPrivate* d;
        friend class KAccelPrivate;
};
# 71 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.h"

# 1 "/coolo/prod/qt-copy/include/qguardedptr.h" 1
# 39 "/coolo/prod/qt-copy/include/qguardedptr.h"






class QGuardedPtrPrivate : public QObject, public QShared
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QGuardedPtrPrivate( QObject* );
    ~QGuardedPtrPrivate();

    QObject* object() const;
    void reconnect( QObject* );

private :
    void objectDestroyed();

private:
    QObject* obj;

    QGuardedPtrPrivate( const QGuardedPtrPrivate & );
    QGuardedPtrPrivate &operator=( const QGuardedPtrPrivate & );

};

template <class T>
class QGuardedPtr
{
public:
    QGuardedPtr() : priv( new QGuardedPtrPrivate( 0 ) ) {}

    QGuardedPtr( T* o) {
        priv = new QGuardedPtrPrivate( (QObject*)o );
    }

    QGuardedPtr(const QGuardedPtr<T> &p) {
        priv = p.priv;
        ref();
    }

    ~QGuardedPtr() { deref(); }

    QGuardedPtr<T> &operator=(const QGuardedPtr<T> &p) {
        if ( priv != p.priv ) {
            deref();
            priv = p.priv;
            ref();
        }
        return *this;
    }

    QGuardedPtr<T> &operator=(T* o) {
        if ( priv->count == 1 ) {
            priv->reconnect( (QObject*)o );
        } else {
            deref();
            priv = new QGuardedPtrPrivate( (QObject*)o );
        }
        return *this;
    }

    bool operator==( const QGuardedPtr<T> &p ) const {
        return priv->object() == p.priv->object();
    }

    bool operator!= ( const QGuardedPtr<T>& p ) const {
        return !( *this == p );
    }

    bool isNull() const { return !priv->object(); }

    T* operator->() const { return (T*) priv->object(); }

    T& operator*() const { return *( (T*)priv->object() ); }

    operator T*() const { return (T*) priv->object(); }

private:

    void ref() { priv->ref(); }

    void deref() {
        if ( priv->deref() )
            delete priv;
    }

    QGuardedPtrPrivate* priv;
};




inline QObject* QGuardedPtrPrivate::object() const
{
    return obj;
}

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 141 "/coolo/prod/qt-copy/include/qguardedptr.h" 2
# 27 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.h" 2






class QMenuData;
class QTextView;
# 66 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.h"
class KCheckAccelerators : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:




    KCheckAccelerators( QObject* parent );



    bool eventFilter( QObject * , QEvent * e);

private:
    void checkAccelerators( bool automatic );
    int key;
    bool alwaysShow;
    bool autoCheck;
    bool block;
    QTimer autoCheckTimer;
    void createDialog(QWidget *parent, bool automatic);
    QGuardedPtr<QDialog> drklash;
    QTextView *drklash_view;

private :
    void autoCheckSlot();
    void slotDisableCheck(bool);
};
# 72 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qptrdict.h" 1
# 39 "/coolo/prod/qt-copy/include/qptrdict.h"





template<class type>
class QPtrDict



        : public QGDict

{
public:
    QPtrDict(int size=17) : QGDict(size,PtrKey,0,0) {}
    QPtrDict( const QPtrDict<type> &d ) : QGDict(d) {}
   ~QPtrDict() { clear(); }
    QPtrDict<type> &operator=(const QPtrDict<type> &d)
                        { return (QPtrDict<type>&)QGDict::operator=(d); }
    uint count() const { return QGDict::count(); }
    uint size() const { return QGDict::size(); }
    bool isEmpty() const { return QGDict::count() == 0; }
    void insert( void *k, const type *d )
                                        { QGDict::look_ptr(k,(Item)d,1); }
    void replace( void *k, const type *d )
                                        { QGDict::look_ptr(k,(Item)d,2); }
    bool remove( void *k ) { return QGDict::remove_ptr(k); }
    type *take( void *k ) { return (type*)QGDict::take_ptr(k); }
    type *find( void *k ) const
                { return (type *)((QGDict*)this)->QGDict::look_ptr(k,0,0); }
    type *operator[]( void *k ) const
                { return (type *)((QGDict*)this)->QGDict::look_ptr(k,0,0); }
    void clear() { QGDict::clear(); }
    void resize( uint n ) { QGDict::resize(n); }
    void statistics() const { QGDict::statistics(); }







private:
    void deleteItem( Item d );
};


template<> inline void QPtrDict<void>::deleteItem( QPtrCollection::Item )
{
}


template<class type>
inline void QPtrDict<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}

template<class type>
class QPtrDictIterator : public QGDictIterator
{
public:
    QPtrDictIterator(const QPtrDict<type> &d) :QGDictIterator((QGDict &)d) {}
   ~QPtrDictIterator() {}
    uint count() const { return dict->count(); }
    bool isEmpty() const { return dict->count() == 0; }
    type *toFirst() { return (type *)QGDictIterator::toFirst(); }
    operator type *() const { return (type *)QGDictIterator::get(); }
    type *current() const { return (type *)QGDictIterator::get(); }
    void *currentKey() const { return QGDictIterator::getKeyPtr(); }
    type *operator()() { return (type *)QGDictIterator::operator()(); }
    type *operator++() { return (type *)QGDictIterator::operator++(); }
    type *operator+=(uint j) { return (type *)QGDictIterator::operator+=(j);}
};
# 73 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
# 36 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
class KMacroExpanderBase {

public:




    KMacroExpanderBase( QChar c = '%' );




    virtual ~KMacroExpanderBase();






    void expandMacros( QString &str );
# 85 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
    bool expandMacrosShellQuote( QString &str, uint &pos );





    bool expandMacrosShellQuote( QString &str );





    void setEscapeChar( QChar c );





    QChar escapeChar() const;

protected:
# 119 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
    virtual int expandPlainMacro( const QString &str, uint pos, QStringList &ret );
# 135 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
    virtual int expandEscapedMacro( const QString &str, uint pos, QStringList &ret );

private:
    QChar escapechar;
};






namespace KMacroExpander {
# 167 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
    QString expandMacros( const QString &str, const QMap<QChar,QString> &map, QChar c = '%' );
# 192 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
    QString expandMacrosShellQuote( const QString &str, const QMap<QChar,QString> &map, QChar c = '%' );
# 217 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
    QString expandMacros( const QString &str, const QMap<QString,QString> &map, QChar c = '%' );
# 245 "/coolo/prod/kdelibs/kdecore/kmacroexpander.h"
    QString expandMacrosShellQuote( const QString &str, const QMap<QString,QString> &map, QChar c = '%' );





    QString expandMacros( const QString &str, const QMap<QChar,QStringList> &map, QChar c = '%' );
    QString expandMacros( const QString &str, const QMap<QString,QStringList> &map, QChar c = '%' );







    QString expandMacrosShellQuote( const QString &str, const QMap<QChar,QStringList> &map, QChar c = '%' );
    QString expandMacrosShellQuote( const QString &str, const QMap<QString,QStringList> &map, QChar c = '%' );
}
# 74 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kshell.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kshell.h"
# 32 "/coolo/prod/kdelibs/kdecore/kshell.h"
namespace KShell {




    enum Options {
        NoOptions = 0,




        TildeExpand = 1,
# 55 "/coolo/prod/kdelibs/kdecore/kshell.h"
        AbortOnMeta = 2
    };




    enum Errors {



        NoError = 0,




        BadQuoting,





        FoundMeta
    };
# 90 "/coolo/prod/kdelibs/kdecore/kshell.h"
    QStringList splitArgs( const QString &cmd, int flags = 0, int *err = 0 );







    QString joinArgs( const QStringList &args );
# 110 "/coolo/prod/kdelibs/kdecore/kshell.h"
    QString joinArgsDQ( const QStringList &args );
# 121 "/coolo/prod/kdelibs/kdecore/kshell.h"
    QString joinArgs( const char * const *argv, int argc = -1 );
# 130 "/coolo/prod/kdelibs/kdecore/kshell.h"
    QString tildeExpand( const QString &path );
# 139 "/coolo/prod/kdelibs/kdecore/kshell.h"
    QString homeDir( const QString &user );

}
# 75 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h" 1
# 20 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"




# 1 "/coolo/prod/kdelibs/kdecore/ksycocaentry.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/ksycocaentry.h"

# 1 "/coolo/prod/kdelibs/kdecore/ksycocatype.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/ksycocatype.h"
# 31 "/coolo/prod/kdelibs/kdecore/ksycocatype.h"
enum KSycocaType { KST_KSycocaEntry = 0, KST_KService = 1, KST_KServiceType = 2, KST_KMimeType = 3,
                 KST_KFolderType = 4, KST_KDEDesktopMimeType = 5, KST_KExecMimeType = 6,
                 KST_KServiceGroup = 7, KST_KImageIOFormat = 8, KST_KProtocolInfo = 9,
                 KST_KCustom = 1000 };

# 49 "/coolo/prod/kdelibs/kdecore/ksycocatype.h"
enum KSycocaFactoryId { KST_KServiceFactory = 1,
                        KST_KServiceTypeFactory = 2,
                        KST_KServiceGroupFactory = 3,
                        KST_KImageIO = 4,
                        KST_KProtocolInfoFactory = 5,
                        KST_CTimeInfo = 100 };

# 23 "/coolo/prod/kdelibs/kdecore/ksycocaentry.h" 2


# 1 "/coolo/prod/kdelibs/kdecore/ksharedptr.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/ksharedptr.h"
# 39 "/coolo/prod/kdelibs/kdecore/ksharedptr.h"
class KShared {
public:




   KShared() : count(0) { }





   KShared( const KShared & ) : count(0) { }




   KShared &operator=(const KShared & ) { return *this; }




   void _KShared_ref() const { count++; }





   void _KShared_unref() const { if (!--count) delete this; }






   int _KShared_count() const { return count; }

protected:
   virtual ~KShared() { }
private:
   mutable int count;
};
# 95 "/coolo/prod/kdelibs/kdecore/ksharedptr.h"
template< class T >
struct KSharedPtr
{
public:



  KSharedPtr()
    : ptr(0) { }




  KSharedPtr( T* t )
    : ptr(t) { if ( ptr ) ptr->_KShared_ref(); }





  KSharedPtr( const KSharedPtr& p )
    : ptr(p.ptr) { if ( ptr ) ptr->_KShared_ref(); }





  ~KSharedPtr() { if ( ptr ) ptr->_KShared_unref(); }

  KSharedPtr<T>& operator= ( const KSharedPtr<T>& p ) {
    if ( ptr == p.ptr ) return *this;
    if ( ptr ) ptr->_KShared_unref();
    ptr = p.ptr;
    if ( ptr ) ptr->_KShared_ref();
    return *this;
  }
  KSharedPtr<T>& operator= ( T* p ) {
    if ( ptr == p ) return *this;
    if ( ptr ) ptr->_KShared_unref();
    ptr = p;
    if ( ptr ) ptr->_KShared_ref();
    return *this;
  }
  bool operator== ( const KSharedPtr<T>& p ) const { return ( ptr == p.ptr ); }
  bool operator!= ( const KSharedPtr<T>& p ) const { return ( ptr != p.ptr ); }
  bool operator== ( const T* p ) const { return ( ptr == p ); }
  bool operator!= ( const T* p ) const { return ( ptr != p ); }
  bool operator!() const { return ( ptr == 0 ); }
  operator T*() const { return ptr; }





  T* data() { return ptr; }





  const T* data() const { return ptr; }

  const T& operator*() const { return *ptr; }
  T& operator*() { return *ptr; }
  const T* operator->() const { return ptr; }
  T* operator->() { return ptr; }





  int count() const { return ptr->_KShared_count(); }
private:
  T* ptr;
};
# 26 "/coolo/prod/kdelibs/kdecore/ksycocaentry.h" 2
class QDataStream;
# 37 "/coolo/prod/kdelibs/kdecore/ksycocaentry.h"
class KSycocaEntry : public KShared
{

public:
   virtual bool isType(KSycocaType t) const { return (t == KST_KSycocaEntry); }
   virtual KSycocaType sycocaType() const { return KST_KSycocaEntry; }

public:
  typedef KSharedPtr<KSycocaEntry> Ptr;
  typedef QValueList<Ptr> List;
public:



   KSycocaEntry(const QString &path) : mOffset(0), m_bDeleted(false), mPath(path) { }




   static void read( QDataStream &s, QString &str );
   static void read( QDataStream &s, QStringList &list );





   KSycocaEntry( QDataStream &_str, int offset ) :
              mOffset( offset ), m_bDeleted(false)
   {
     read(_str, mPath);
   }




   virtual QString name() const = 0;






   QString entryPath() const { return mPath; }




   virtual bool isValid() const = 0;




   virtual bool isDeleted() const { return m_bDeleted; }





   int offset() { return mOffset; }






   virtual void save(QDataStream &s)
     {
       mOffset = s.device()->at();
       s << (Q_INT32) sycocaType() << mPath;
     }





   virtual void load(QDataStream &) = 0;

private:
   int mOffset;
protected:
   bool m_bDeleted;
   QString mPath;
protected:
   virtual void virtual_hook( int id, void* data );
};
# 26 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h" 2
# 44 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
class KProtocolInfo : public KSycocaEntry
{
  friend class KProtocolInfoFactory;
  public: virtual bool isType(KSycocaType t) const { if (t == KST_KProtocolInfo) return true; return KSycocaEntry::isType(t);} virtual KSycocaType sycocaType() const { return KST_KProtocolInfo; } private:

public:
  typedef KSharedPtr<KProtocolInfo> Ptr;

public:




  KProtocolInfo( const QString & path);





  virtual bool isValid() const { return !m_name.isEmpty(); }
# 73 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  virtual QString name() const { return m_name; }
# 83 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static QStringList protocols();
# 92 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool isKnownProtocol( const KURL &url );
# 105 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static QString exec( const QString& protocol );




  enum Type { T_STREAM,
              T_FILESYSTEM,
              T_NONE,
              T_ERROR
  };
# 126 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static Type inputType( const KURL &url );
# 138 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static Type outputType( const KURL &url );
# 152 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static QStringList listing( const KURL &url );





  struct ExtraField {
    ExtraField() {}
    ExtraField(const QString& _name, const QString& _type )
      : name(_name), type(_type) {
    }
    QString name;
    QString type;
  };
  typedef QValueList<ExtraField > ExtraFieldList;







  static ExtraFieldList extraFields( const KURL& url );
# 189 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool isSourceProtocol( const KURL &url );
# 203 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool isHelperProtocol( const KURL &url );
# 221 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool isFilterProtocol( const KURL &url );
# 238 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool supportsListing( const KURL &url );
# 249 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool supportsReading( const KURL &url );
# 260 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool supportsWriting( const KURL &url );
# 271 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool supportsMakeDir( const KURL &url );
# 282 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool supportsDeleting( const KURL &url );
# 293 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool supportsLinking( const KURL &url );
# 305 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool supportsMoving( const KURL &url );
# 319 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool canCopyFromFile( const KURL &url );
# 333 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool canCopyToFile( const KURL &url );
# 343 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static QString defaultMimetype( const KURL& url );
# 353 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static QString icon( const QString& protocol );
# 366 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static QString config( const QString& protocol );
# 380 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static int maxSlaves( const QString& protocol );
# 393 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static bool determineMimetypeFromExtension( const QString &protocol );
# 404 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static QString docPath( const QString& protocol );
# 422 "/coolo/prod/kdelibs/kio/kio/kprotocolinfo.h"
  static QString protocolClass( const QString& protocol );


public:




  KProtocolInfo( QDataStream& _str, int offset);

  virtual ~KProtocolInfo();





  virtual void load(QDataStream& );





  virtual void save(QDataStream& );





  static Type inputType( const QString& protocol ) __attribute__ ((deprecated));

  static Type outputType( const QString& protocol ) __attribute__ ((deprecated));






  static QStringList listing( const QString& protocol ) __attribute__ ((deprecated));

  static bool isSourceProtocol( const QString& protocol ) __attribute__ ((deprecated));

  static bool isHelperProtocol( const QString& protocol ) __attribute__ ((deprecated));

  static bool isFilterProtocol( const QString& protocol ) __attribute__ ((deprecated));

  static bool isKnownProtocol( const QString& protocol ) __attribute__ ((deprecated));

  static bool supportsListing( const QString& protocol ) __attribute__ ((deprecated));

  static bool supportsReading( const QString& protocol ) __attribute__ ((deprecated));

  static bool supportsWriting( const QString& protocol ) __attribute__ ((deprecated));

  static bool supportsMakeDir( const QString& protocol ) __attribute__ ((deprecated));

  static bool supportsDeleting( const QString& protocol ) __attribute__ ((deprecated));

  static bool supportsLinking( const QString& protocol ) __attribute__ ((deprecated));

  static bool supportsMoving( const QString& protocol ) __attribute__ ((deprecated));

  static bool canCopyFromFile( const QString& protocol ) __attribute__ ((deprecated));

  static bool canCopyToFile( const QString& protocol ) __attribute__ ((deprecated));

  static QString defaultMimetype( const QString& protocol) __attribute__ ((deprecated));


protected:
  QString m_name;
  QString m_exec;
  Type m_inputType;
  Type m_outputType;
  QStringList m_listing;
  bool m_isSourceProtocol;
  bool m_isHelperProtocol;
  bool m_supportsListing;
  bool m_supportsReading;
  bool m_supportsWriting;
  bool m_supportsMakeDir;
  bool m_supportsDeleting;
  bool m_supportsLinking;
  bool m_supportsMoving;
  QString m_defaultMimetype;
  bool m_determineMimetypeFromExtension;
  QString m_icon;
  bool m_canCopyFromFile;
  bool m_canCopyToFile;
  QString m_config;
  int m_maxSlaves;
protected:
  virtual void virtual_hook( int id, void* data );
private:
  class KProtocolInfoPrivate;
  KProtocolInfoPrivate* d;
};

QDataStream& operator>>( QDataStream& s, KProtocolInfo::ExtraField& field );
QDataStream& operator<<( QDataStream& s, const KProtocolInfo::ExtraField& field );
# 76 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h" 1
# 28 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"




# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 34 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h" 2






class KStartupInfoId;
class KStartupInfoData;

class KStartupInfoPrivate;
# 66 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
class KStartupInfo
    : public QObject
    {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    public:
        enum {
            CleanOnCantDetect = 1 << 0,
            DisableKWinModule = 1 << 1,
            AnnounceSilenceChanges = 1 << 2
            };
# 95 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        KStartupInfo( int flags, QObject* parent = __null, const char* name = __null );
# 107 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        KStartupInfo( bool clean_on_cantdetect, QObject* parent = 0, const char* name = 0 );
        virtual ~KStartupInfo();
# 120 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        static bool sendStartup( const KStartupInfoId& id, const KStartupInfoData& data );
# 129 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        static bool sendStartupX( Display* dpy, const KStartupInfoId& id,
            const KStartupInfoData& data );
# 142 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        static bool sendChange( const KStartupInfoId& id, const KStartupInfoData& data );
# 151 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        static bool sendChangeX( Display* dpy, const KStartupInfoId& id,
            const KStartupInfoData& data );






        static bool sendFinish( const KStartupInfoId& id );







        static bool sendFinishX( Display* dpy, const KStartupInfoId& id );
# 176 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        static bool sendFinish( const KStartupInfoId& id, const KStartupInfoData& data );
# 185 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        static bool sendFinishX( Display* dpy, const KStartupInfoId& id,
            const KStartupInfoData& data );







        static KStartupInfoId currentStartupIdEnv();



        static void resetStartupEnv();







        static void appStarted();






        enum startup_t { NoMatch, Match, CantDetect };







        startup_t checkStartup( WId w );
# 230 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        startup_t checkStartup( WId w, KStartupInfoId& id );
# 240 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        startup_t checkStartup( WId w, KStartupInfoData& data );
# 251 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        startup_t checkStartup( WId w, KStartupInfoId& id, KStartupInfoData& data );




        void setTimeout( unsigned int secs );





        static void setWindowStartupId( WId window, const QCString& id );





        static QCString windowStartupId( WId w );



        class Data;
    protected:






        void gotNewStartup( const KStartupInfoId& id, const KStartupInfoData& data );





        void gotStartupChange( const KStartupInfoId& id, const KStartupInfoData& data );






        void gotRemoveStartup( const KStartupInfoId& id, const KStartupInfoData& data );
    protected:
        virtual void customEvent( QCustomEvent* e_P );
    private :
        void startups_cleanup();
        void startups_cleanup_no_age();
        void got_message( const QString& msg );
        void window_added( WId w );
        void slot_window_added( WId w );
    private:
        void init( int flags );
        friend class KStartupInfoPrivate;
        void got_startup_info( const QString& msg_P, bool update_only_P );
        void got_remove_startup_info( const QString& msg_P );
        void new_startup_info_internal( const KStartupInfoId& id_P,
            Data& data_P, bool update_only_P );
        void remove_startup_info_internal( const KStartupInfoId& id_P );
        void remove_startup_pids( const KStartupInfoId& id, const KStartupInfoData& data );
        void remove_startup_pids( const KStartupInfoData& data );
        startup_t check_startup_internal( WId w, KStartupInfoId* id, KStartupInfoData* data,
            bool remove );
        bool find_id( const QCString& id_P, KStartupInfoId* id_O,
            KStartupInfoData* data_O, bool remove );
        bool find_pid( pid_t pid_P, const QCString& hostname, KStartupInfoId* id_O,
            KStartupInfoData* data_O, bool remove );
        bool find_wclass( QCString res_name_P, QCString res_class_P,
            KStartupInfoId* id_O, KStartupInfoData* data_O, bool remove );
        static QCString get_window_hostname( WId w_P );
        void startups_cleanup_internal( bool age_P );
        void clean_all_noncompliant();
        bool clean_on_cantdetect_;
        unsigned int timeout;
        KStartupInfoPrivate* d;
    };

class KStartupInfoIdPrivate;
# 342 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
class KStartupInfoId
    {
    public:




        bool operator==( const KStartupInfoId& id ) const;




        bool operator!=( const KStartupInfoId& id ) const;




        bool none() const;







        void initId( const QCString& id = "" );




        const QCString& id() const;




        bool setupStartupEnv() const;



        KStartupInfoId();



        KStartupInfoId( const KStartupInfoId& data );
        ~KStartupInfoId();
        KStartupInfoId& operator=( const KStartupInfoId& data );
        bool operator<( const KStartupInfoId& id ) const;
    private:
        KStartupInfoId( const QString& txt );
        QString to_text() const;
        friend class KStartupInfo;
        KStartupInfoIdPrivate* d;
    };

class KStartupInfoDataPrivate;
# 410 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
class KStartupInfoData
    {
    public:




        void setBin( const QString& bin );




        const QString& bin() const;



        void setName( const QString& name );






        const QString& findName() const;





        const QString& name() const;




        void setIcon( const QString& icon );






        const QString& findIcon() const;




        const QString& icon() const;





        void setDesktop( int desktop );




        int desktop() const;






        void setWMClass( const QCString& wmclass );






        const QCString findWMClass() const;





        const QCString& WMClass() const;







        void addPid( pid_t pid );




        const QValueList< pid_t >& pids() const;





        bool is_pid( pid_t pid ) const;





        void setHostname( const QCString& hostname = QCString());




        const QCString& hostname() const;

        enum TriState { Yes, No, Unknown };






        void setSilent( TriState state );






        TriState silent() const;
# 542 "/coolo/prod/kdelibs/kdecore/kstartupinfo.h"
        void setTimestamp( unsigned long time );





        unsigned long timestamp() const;






        void update( const KStartupInfoData& data );




        KStartupInfoData();




        KStartupInfoData( const KStartupInfoData& data );
        ~KStartupInfoData();
        KStartupInfoData& operator=( const KStartupInfoData& data );
    private:
        KStartupInfoData( const QString& txt );
        QString to_text() const;
        void remove_pid( pid_t pid );
        friend class KStartupInfo;
        friend class KStartupInfo::Data;
        KStartupInfoDataPrivate* d;
    };
# 79 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2


# 1 "/coolo/prod/kdelibs/dcop/dcopclient.h" 1
# 24 "/coolo/prod/kdelibs/dcop/dcopclient.h"
# 33 "/coolo/prod/kdelibs/dcop/dcopclient.h"
class DCOPObjectProxy;
class DCOPClientPrivate;
class DCOPClientTransaction;

typedef QValueList<QCString> QCStringList;
# 68 "/coolo/prod/kdelibs/dcop/dcopclient.h"
class DCOPClient : public QObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

 public:


  DCOPClient();




  virtual ~DCOPClient();
# 89 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  static void setServerAddress(const QCString &addr);
# 109 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool attach();







  void bindToApp();





  bool detach();





  bool isAttached() const;






  bool isAttachedToForeignServer() const;





  bool acceptCalls() const;







  void setAcceptCalls(bool b);







  bool qtBridgeEnabled();
# 167 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void setQtBridgeEnabled(bool b);
# 194 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  QCString registerAs( const QCString &appId, bool addPID = true );





  bool isRegistered() const;






  QCString appId() const;





  int socket() const;
# 227 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void suspend();






  void resume();







  bool isSuspended() const;
# 254 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool send(const QCString &remApp, const QCString &remObj,
            const QCString &remFun, const QByteArray &data);
# 268 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool send(const QCString &remApp, const QCString &remObj,
            const QCString &remFun, const QString &data);
# 300 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool call(const QCString &remApp, const QCString &remObj,
            const QCString &remFun, const QByteArray &data,
            QCString& replyType, QByteArray &replyData,
            bool useEventLoop , int timeout );




  bool call(const QCString &remApp, const QCString &remObj,
            const QCString &remFun, const QByteArray &data,
            QCString& replyType, QByteArray &replyData,
            bool useEventLoop=false);
# 341 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  int callAsync(const QCString &remApp, const QCString &remObj,
                const QCString &remFun, const QByteArray &data,
                QObject *callBackObj, const char *callBackSlot);
# 381 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool findObject(const QCString &remApp, const QCString &remObj,
            const QCString &remFun, const QByteArray &data,
            QCString &foundApp, QCString &foundObj,
            bool useEventLoop , int timeout );





  bool findObject(const QCString &remApp, const QCString &remObj,
            const QCString &remFun, const QByteArray &data,
            QCString &foundApp, QCString &foundObj,
            bool useEventLoop=false);






  void emitDCOPSignal( const QCString &object, const QCString &signal,
                       const QByteArray &data);


  void emitDCOPSignal( const QCString &signal, const QByteArray &data);
# 426 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool connectDCOPSignal( const QCString &sender, const QCString &senderObj,
                          const QCString &signal,
                          const QCString &receiverObj, const QCString &slot,
                          bool Volatile);





  bool connectDCOPSignal( const QCString &sender, const QCString &signal,
                          const QCString &receiverObj, const QCString &slot,
                          bool Volatile) __attribute__ ((deprecated));
# 456 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool disconnectDCOPSignal( const QCString &sender, const QCString &senderObj,
                          const QCString &signal,
                          const QCString &receiverObj, const QCString &slot);





  bool disconnectDCOPSignal( const QCString &sender, const QCString &signal,
                          const QCString &receiverObj, const QCString &slot) __attribute__ ((deprecated));
# 482 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  virtual bool process(const QCString &fun, const QByteArray &data,
                       QCString& replyType, QByteArray &replyData);
# 494 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  DCOPClientTransaction *beginTransaction( );
# 503 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void endTransaction( DCOPClientTransaction *t, QCString& replyType, QByteArray &replyData);
# 514 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  Q_INT32 transactionId() const;






  bool isApplicationRegistered( const QCString& remApp);






  QCStringList registeredApplications();
# 537 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  QCStringList remoteObjects( const QCString& remApp, bool *ok = 0 );
# 548 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  QCStringList remoteInterfaces( const QCString& remApp, const QCString& remObj , bool *ok = 0 );
# 559 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  QCStringList remoteFunctions( const QCString& remApp, const QCString& remObj , bool *ok = 0 );
# 573 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool receive(const QCString &app, const QCString &obj,
               const QCString &fun, const QByteArray& data,
               QCString& replyType, QByteArray &replyData);
# 588 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  bool find(const QCString &app, const QCString &obj,
            const QCString &fun, const QByteArray& data,
            QCString& replyType, QByteArray &replyData);
# 609 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  static QCString normalizeFunctionSignature( const QCString& fun );







  QCString senderId() const;
# 627 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void setDefaultObject( const QCString& objId );
# 637 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  QCString defaultObject() const;
# 650 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void setNotifications( bool enabled );
# 660 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void setDaemonMode( bool daemonMode );
# 669 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  static DCOPClient* mainClient();
# 678 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  static void setMainClient( DCOPClient* mainClient);




  static void emergencyClose();






  static const char *postMortemSender();

  static const char *postMortemObject();

  static const char *postMortemFunction();
# 703 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  static QCString dcopServerFile(const QCString &hostname=0);





  static QCString dcopServerFileOld(const QCString &hostname=0) __attribute__ ((deprecated));




  static QCString iceauthPath();

protected:
# 725 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void applicationRegistered( const QCString& appId );
# 734 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void applicationRemoved( const QCString& appId );
# 744 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void attachFailed(const QString &msg);
# 763 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void blockUserInput( bool block );
# 774 "/coolo/prod/kdelibs/dcop/dcopclient.h"
  void callBack(int, const QCString&, const QByteArray &);

public :

protected :




  void processSocketData(int socknum);

private :
  void processPostedMessagesInternal();
  void asyncReplyReady();

public:
  class ReplyStruct;




  void handleAsyncReply(ReplyStruct *replyStruct);

private:

  bool isLocalTransactionFinished(Q_INT32 id, QCString &replyType, QByteArray &replyData);

  bool attachInternal( bool registerAsAnonymous = true );

  bool callInternal(const QCString &remApp, const QCString &remObj,
            const QCString &remFun, const QByteArray &data,
            QCString& replyType, QByteArray &replyData,
            bool useEventLoop, int timeout, int minor_opcode);


  bool callInternal(const QCString &remApp, const QCString &remObjId,
            const QCString &remFun, const QByteArray &data,
            ReplyStruct *replyStruct,
            bool useEventLoop, int timeout, int minor_opcode);

protected:
  virtual void virtual_hook( int id, void* data );
private:
  DCOPClientPrivate *d;
};
# 82 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/dcop/dcopref.h" 1
# 24 "/coolo/prod/kdelibs/dcop/dcopref.h"


# 1 "/coolo/prod/kdelibs/dcop/dcoptypes.h" 1
# 23 "/coolo/prod/kdelibs/dcop/dcoptypes.h"

# 1 "/coolo/prod/kdelibs/dcop/dcopref.h" 1
# 26 "/coolo/prod/kdelibs/dcop/dcoptypes.h" 2


inline const char* dcopTypeName( bool ) { return "bool"; }
inline const char* dcopTypeName( char ) { return "char"; }
inline const char* dcopTypeName( uchar ) { return "uchar"; }
inline const char* dcopTypeName( int ) { return "int"; }
inline const char* dcopTypeName( uint ) { return "uint"; }
inline const char* dcopTypeName( long ) { return "long"; }
inline const char* dcopTypeName( ulong ) { return "ulong"; }
inline const char* dcopTypeName( double ) { return "double"; }
inline const char* dcopTypeName( float ) { return "float"; }
inline const char* dcopTypeName( const char* ) { return "QCString"; }


class DCOPRef; inline const char* dcopTypeName( const DCOPRef& ) { return "DCOPRef"; }


class QString; inline const char* dcopTypeName( const QString& ) { return "QString"; }
class QCString; inline const char* dcopTypeName( const QCString& ) { return "QCString"; }
class QFont; inline const char* dcopTypeName( const QFont& ) { return "QFont"; }
class QPixmap; inline const char* dcopTypeName( const QPixmap& ) { return "QPixmap"; }
class QBrush; inline const char* dcopTypeName( const QBrush& ) { return "QBrush"; }
class QRect; inline const char* dcopTypeName( const QRect& ) { return "QRect"; }
class QPoint; inline const char* dcopTypeName( const QPoint& ) { return "QPoint"; }
class QImage; inline const char* dcopTypeName( const QImage& ) { return "QImage"; }
class QSize; inline const char* dcopTypeName( const QSize& ) { return "QSize"; }
class QColor; inline const char* dcopTypeName( const QColor& ) { return "QColor"; }
class QPalette; inline const char* dcopTypeName( const QPalette& ) { return "QPalette"; }
class QColorGroup; inline const char* dcopTypeName( const QColorGroup& ) { return "QColorGroup"; }
class QIconSet; inline const char* dcopTypeName( const QIconSet& ) { return "QIconSet"; }
class QDataStream; inline const char* dcopTypeName( const QDataStream& ) { return "QDataStream"; }
class QPointArray; inline const char* dcopTypeName( const QPointArray& ) { return "QPointArray"; }
class QRegion; inline const char* dcopTypeName( const QRegion& ) { return "QRegion"; }
class QBitmap; inline const char* dcopTypeName( const QBitmap& ) { return "QBitmap"; }
class QCursor; inline const char* dcopTypeName( const QCursor& ) { return "QCursor"; }
class QStringList; inline const char* dcopTypeName( const QStringList& ) { return "QStringList"; }
class QSizePolicy; inline const char* dcopTypeName( const QSizePolicy& ) { return "QSizePolicy"; }
class QDate; inline const char* dcopTypeName( const QDate& ) { return "QDate"; }
class QTime; inline const char* dcopTypeName( const QTime& ) { return "QTime"; }
class QDateTime; inline const char* dcopTypeName( const QDateTime& ) { return "QDateTime"; }
class QBitArray; inline const char* dcopTypeName( const QBitArray& ) { return "QBitArray"; }
class QKeySequence; inline const char* dcopTypeName( const QKeySequence& ) { return "QKeySequence"; }
class QVariant; inline const char* dcopTypeName( const QVariant& ) { return "QVariant"; }


class KURL; inline const char* dcopTypeName( const KURL& ) { return "KURL"; }


template <class T> inline const char* dcopTypeName( const T& ) { return "<unknown>"; }


inline void dcopTypeInit(bool& b){b=false;}
inline void dcopTypeInit(char& c){c=0;}
inline void dcopTypeInit(uchar& c){c=0;}
inline void dcopTypeInit(int& i){i=0;}
inline void dcopTypeInit(uint& i){i=0;}
inline void dcopTypeInit(long& l){l=0;}
inline void dcopTypeInit(ulong& l){l=0;}
inline void dcopTypeInit(float& f){f=0;}
inline void dcopTypeInit(double& d){d=0;}
inline void dcopTypeInit(const char* s ){s=0;}


template <class T> inline void dcopTypeInit(T&){}
# 28 "/coolo/prod/kdelibs/dcop/dcopref.h" 2


class QDataStream;
class DCOPObject;
class DCOPClient;
# 43 "/coolo/prod/kdelibs/dcop/dcopref.h"
class DCOPReply
{
public:






    template<class T>
    operator T() {
        T t;
        if ( typeCheck( dcopTypeName(t), true ) ) {
            QDataStream reply( data, 0x0001 );
            reply >> t;
        } else {
            dcopTypeInit(t);
        }
        return t;
    }







    template <class T> bool get( T& t, const char* tname ) {
        if ( typeCheck( tname, false ) ) {
            QDataStream reply( data, 0x0001 );
            reply >> t;
            return true;
        }
        return false;
    }
# 86 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T> bool get( T& t ) {
        if ( typeCheck( dcopTypeName(t), false ) ) {
            QDataStream reply( data, 0x0001 );
            reply >> t;
            return true;
        }
        return false;
    }





    inline bool isValid() const { return !type.isNull(); }


    QByteArray data;

    QCString type;
private:
    bool typeCheck( const char* t );
    bool typeCheck( const char* t, bool warn );
};
# 120 "/coolo/prod/kdelibs/dcop/dcopref.h"
class DCOPArg {
public:
# 130 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T> DCOPArg( const T& t, const char* tname_arg )
        : tname(tname_arg)
        {
            QDataStream ds( data, 0x0002 );
            ds << t;
        }
# 144 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T> DCOPArg( const T& t )
        : tname( dcopTypeName(t) )
        {
            QDataStream ds( data, 0x0002 );
            ds << t;
        }


    QByteArray data;

    const char* tname;
};

inline const char* dcopTypeName( const DCOPArg &arg ) { return arg.tname; }
inline QDataStream & operator << (QDataStream & str, const DCOPArg& arg )
   { str.writeRawBytes( arg.data.data(), arg.data.size() ); return str; }
# 278 "/coolo/prod/kdelibs/dcop/dcopref.h"
class DCOPRef
{
public:




    DCOPRef();




    DCOPRef( const DCOPRef& ref );







    DCOPRef( const QCString& app, const QCString& obj = "" );






    DCOPRef( DCOPObject *object );
# 316 "/coolo/prod/kdelibs/dcop/dcopref.h"
    DCOPRef( const QCString& app, const QCString& obj, const QCString& type );






    bool isNull() const;





    QCString app() const;






    QCString obj() const;




    QCString object() const;





    QCString type() const;





    DCOPRef& operator=( const DCOPRef& );







    void setRef( const QCString& app, const QCString& obj = "" );







    void setRef( const QCString& app, const QCString& obj, const QCString& type );






    void clear();
# 385 "/coolo/prod/kdelibs/dcop/dcopref.h"
    DCOPClient* dcopClient() const;







    void setDCOPClient( DCOPClient *client );
# 403 "/coolo/prod/kdelibs/dcop/dcopref.h"
    enum EventLoopFlag { NoEventLoop, UseEventLoop };
# 417 "/coolo/prod/kdelibs/dcop/dcopref.h"
    DCOPReply call( const QCString& fun ) {
        QByteArray data;
        return callInternal( fun, "()", data );
    }
# 435 "/coolo/prod/kdelibs/dcop/dcopref.h"
    DCOPReply callExt( const QCString& fun, EventLoopFlag useEventLoop=NoEventLoop,
                    int timeout=-1 ) {
        QByteArray data;
        return callInternal( fun, "()", data, useEventLoop, timeout );
    }
# 456 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1>
    DCOPReply call( const QCString& fun, const T1& t1 ) {
        QCString args;
        args.sprintf( "(%s)",
                     dcopTypeName(t1) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1;
        return callInternal( fun, args, data );
    }
# 482 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1>
    DCOPReply callExt( const QCString& fun,
                    EventLoopFlag useEventLoop, int timeout,
                    const T1& t1) {
        QCString args;
        args.sprintf( "(%s)",
                     dcopTypeName(t1) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1;
        return callInternal( fun, args, data, useEventLoop, timeout );
    }
# 512 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1, class T2>
    DCOPReply call( const QCString& fun,
                    const T1& t1,
                    const T2& t2 ) {
        QCString args;
        args.sprintf( "(%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2;
        return callInternal( fun, args, data );
    }
# 543 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1, class T2>
    DCOPReply callExt( const QCString& fun,
                    EventLoopFlag useEventLoop, int timeout,
                    const T1& t1,
                    const T2& t2) {
        QCString args;
        args.sprintf( "(%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2;
        return callInternal( fun, args, data, useEventLoop, timeout );
    }
# 577 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1, class T2, class T3>
    DCOPReply call( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3;
        return callInternal( fun, args, data );
    }
# 612 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1, class T2, class T3>
    DCOPReply callExt( const QCString& fun,
                    EventLoopFlag useEventLoop, int timeout,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3) {
        QCString args;
        args.sprintf( "(%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3;
        return callInternal( fun, args, data, useEventLoop, timeout );
    }
# 650 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4>
    DCOPReply call( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4;
        return callInternal( fun, args, data );
    }
# 689 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4>
    DCOPReply callExt( const QCString& fun,
                    EventLoopFlag useEventLoop, int timeout,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4;
        return callInternal( fun, args, data, useEventLoop, timeout );
    }
# 731 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5>
    DCOPReply call( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5;
        return callInternal( fun, args, data );
    }
# 774 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5>
    DCOPReply callExt( const QCString& fun,
                    EventLoopFlag useEventLoop, int timeout,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5;
        return callInternal( fun, args, data, useEventLoop, timeout );
    }
# 820 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6>
    DCOPReply call( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6;
        return callInternal( fun, args, data );
    }
# 867 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6>
    DCOPReply callExt( const QCString& fun,
                    EventLoopFlag useEventLoop, int timeout,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6;
        return callInternal( fun, args, data, useEventLoop, timeout );
    }
# 916 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
    DCOPReply call( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6,
                    const T7& t7 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6),
                     dcopTypeName(t7) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6 << t7;
        return callInternal( fun, args, data );
    }
# 967 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
    DCOPReply callExt( const QCString& fun,
                    EventLoopFlag useEventLoop, int timeout,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6,
                    const T7& t7) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6),
                     dcopTypeName(t7) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6 << t7;
        return callInternal( fun, args, data, useEventLoop, timeout );
    }
# 1021 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
    DCOPReply call( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6,
                    const T7& t7,
                    const T8& t8 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6),
                     dcopTypeName(t7),
                     dcopTypeName(t8) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6 << t7 << t8;
        return callInternal( fun, args, data );
    }
# 1076 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
    DCOPReply callExt( const QCString& fun,
                    EventLoopFlag useEventLoop, int timeout,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6,
                    const T7& t7,
                    const T8& t8) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6),
                     dcopTypeName(t7),
                     dcopTypeName(t8) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6 << t7 << t8;
        return callInternal( fun, args, data, useEventLoop, timeout );
    }
# 1116 "/coolo/prod/kdelibs/dcop/dcopref.h"
    bool send( const QCString& fun ) {
        QByteArray data;
        return sendInternal( fun, "()", data );
    }
# 1137 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1>
    bool send( const QCString& fun, const T1& t1 ) {
        QCString args;
        args.sprintf( "(%s)",
                     dcopTypeName(t1) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1;
        return sendInternal( fun, args, data );
    }
# 1165 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1, class T2>
    bool send( const QCString& fun,
                    const T1& t1,
                    const T2& t2 ) {
        QCString args;
        args.sprintf( "(%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2;
        return sendInternal( fun, args, data );
    }
# 1198 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1, class T2, class T3>
    bool send( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3;
        return sendInternal( fun, args, data );
    }
# 1235 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4>
    bool send( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4;
        return sendInternal( fun, args, data );
    }
# 1276 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5>
    bool send( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5;
        return sendInternal( fun, args, data );
    }
# 1321 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6>
    bool send( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6;
        return sendInternal( fun, args, data );
    }
# 1370 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
    bool send( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6,
                    const T7& t7 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6),
                     dcopTypeName(t7) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6 << t7;
        return sendInternal( fun, args, data );
    }
# 1423 "/coolo/prod/kdelibs/dcop/dcopref.h"
    template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
    bool send( const QCString& fun,
                    const T1& t1,
                    const T2& t2,
                    const T3& t3,
                    const T4& t4,
                    const T5& t5,
                    const T6& t6,
                    const T7& t7,
                    const T8& t8 ) {
        QCString args;
        args.sprintf( "(%s,%s,%s,%s,%s,%s,%s,%s)",
                     dcopTypeName(t1),
                     dcopTypeName(t2),
                     dcopTypeName(t3),
                     dcopTypeName(t4),
                     dcopTypeName(t5),
                     dcopTypeName(t6),
                     dcopTypeName(t7),
                     dcopTypeName(t8) );
        QByteArray data;
        QDataStream ds( data, 0x0002 );
        ds << t1 << t2 << t3 << t4 << t5 << t6 << t7 << t8;
        return sendInternal( fun, args, data );
    }



private:
    DCOPReply callInternal( const QCString& fun, const QCString& args, const QByteArray& data,
                            EventLoopFlag useEventLoop, int timeout );
    DCOPReply callInternal( const QCString& fun, const QCString& args, const QByteArray& data );
    bool sendInternal( const QCString& fun, const QCString& args, const QByteArray& data );

    QCString m_app;
    QCString m_obj;
    QCString m_type;

    class DCOPRefPrivate;
    DCOPRefPrivate *d;
};




QDataStream& operator<<( QDataStream&, const DCOPRef& ref );



QDataStream& operator>>( QDataStream&, DCOPRef& ref );
# 83 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2





# 1 "/usr/include/sys/wait.h" 1 3 4
# 24 "/usr/include/sys/wait.h" 3 4



extern "C" {

# 1 "/usr/include/signal.h" 1 3 4
# 26 "/usr/include/signal.h" 3 4




extern "C" {

# 1 "/usr/include/bits/sigset.h" 1 3 4
# 43 "/usr/include/bits/sigset.h" 3 4














# 72 "/usr/include/bits/sigset.h" 3 4






# 88 "/usr/include/bits/sigset.h" 3 4
# 103 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 34 "/usr/include/signal.h" 2 3 4






typedef __sig_atomic_t sig_atomic_t;

# 58 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
# 23 "/usr/include/bits/signum.h" 3 4












# 59 "/usr/include/signal.h" 2 3 4
# 73 "/usr/include/signal.h" 3 4
typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();







extern __sighandler_t signal (int __sig, __sighandler_t __handler) throw ();
# 102 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler) throw ();






extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();




extern int raise (int __sig) throw ();




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler) throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, __const char *__s) throw ();
# 146 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig) throw ();




extern int sigpause (int __mask) throw ();
# 171 "/usr/include/signal.h" 3 4


extern int sigblock (int __mask) throw ();


extern int sigsetmask (int __mask) throw ();


extern int siggetmask (void) throw ();







typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;






# 1 "/usr/include/time.h" 1 3 4
# 125 "/usr/include/time.h" 3 4
#undef __need_timespec
# 203 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 19 "/usr/include/bits/wordsize.h" 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4






typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;










typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
        int _pad[((128 / sizeof (int)) - 3)];


        struct
          {
            __pid_t si_pid;
            __uid_t si_uid;
          } _kill;


        struct
          {
            unsigned int _timer1;
            unsigned int _timer2;
          } _timer;


        struct
          {
            __pid_t si_pid;
            __uid_t si_uid;
            sigval_t si_sigval;
          } _rt;


        struct
          {
            __pid_t si_pid;
            __uid_t si_uid;
            int si_status;
            __clock_t si_utime;
            __clock_t si_stime;
          } _sigchld;


        struct
          {
            void *si_addr;
          } _sigfault;


        struct
          {
            long int si_band;
            int si_fd;
          } _sigpoll;
      } _sifields;
  } siginfo_t;







enum
{
  SI_ASYNCNL = -6,
  SI_SIGIO,
  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,
  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
};



enum
{
  ILL_ILLOPC = 1,
  ILL_ILLOPN,
  ILL_ILLADR,
  ILL_ILLTRP,
  ILL_PRVOPC,
  ILL_PRVREG,
  ILL_COPROC,
  ILL_BADSTK
};


enum
{
  FPE_INTDIV = 1,
  FPE_INTOVF,
  FPE_FLTDIV,
  FPE_FLTOVF,
  FPE_FLTUND,
  FPE_FLTRES,
  FPE_FLTINV,
  FPE_FLTSUB
};


enum
{
  SEGV_MAPERR = 1,
  SEGV_ACCERR
};


enum
{
  BUS_ADRALN = 1,
  BUS_ADRERR,
  BUS_OBJERR
};


enum
{
  TRAP_BRKPT = 1,
  TRAP_TRACE
};


enum
{
  CLD_EXITED = 1,
  CLD_KILLED,
  CLD_DUMPED,
  CLD_TRAPPED,
  CLD_STOPPED,
  CLD_CONTINUED
};


enum
{
  POLL_IN = 1,
  POLL_OUT,
  POLL_MSG,
  POLL_ERR,
  POLL_PRI,
  POLL_HUP
};















struct __pthread_attr_s;

typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
        int _pad[((64 / sizeof (int)) - 3)];

        struct
          {
            void (*_function) (sigval_t);
            void *_attribute;
          } _sigev_thread;
      } _sigev_un;
  } sigevent_t;




enum
{
  SIGEV_SIGNAL = 0,
  SIGEV_NONE,
  SIGEV_THREAD
};
# 206 "/usr/include/signal.h" 2 3 4



extern int sigemptyset (sigset_t *__set) throw ();


extern int sigfillset (sigset_t *__set) throw ();


extern int sigaddset (sigset_t *__set, int __signo) throw ();


extern int sigdelset (sigset_t *__set, int __signo) throw ();


extern int sigismember (__const sigset_t *__set, int __signo) throw ();



extern int sigisemptyset (__const sigset_t *__set) throw ();


extern int sigandset (sigset_t *__set, __const sigset_t *__left,
                      __const sigset_t *__right) throw ();


extern int sigorset (sigset_t *__set, __const sigset_t *__left,
                     __const sigset_t *__right) throw ();




# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

        __sighandler_t sa_handler;

        void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;





    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };












# 239 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
                        sigset_t *__restrict __oset) throw ();



extern int sigsuspend (__const sigset_t *__set) throw ();


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
                      struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw ();



extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     throw ();



extern int sigwaitinfo (__const sigset_t *__restrict __set,
                        siginfo_t *__restrict __info) throw ();



extern int sigtimedwait (__const sigset_t *__restrict __set,
                         siginfo_t *__restrict __info,
                         __const struct timespec *__restrict __timeout)
     throw ();



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     throw ();
# 284 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[64];
extern __const char *__const sys_siglist[64];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;
  };









extern int sigvec (int __sig, __const struct sigvec *__vec,
                   struct sigvec *__ovec) throw ();



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 26 "/usr/include/bits/sigcontext.h" 3 4

# 1 "/usr/include/asm/sigcontext.h" 1 3 4

# 18 "/usr/include/asm/sigcontext.h" 3 4
struct _fpreg {
        unsigned short significand[4];
        unsigned short exponent;
};

struct _fpxreg {
        unsigned short significand[4];
        unsigned short exponent;
        unsigned short padding[3];
};

struct _xmmreg {
        unsigned long element[4];
};

struct _fpstate {

        unsigned long cw;
        unsigned long sw;
        unsigned long tag;
        unsigned long ipoff;
        unsigned long cssel;
        unsigned long dataoff;
        unsigned long datasel;
        struct _fpreg _st[8];
        unsigned short status;
        unsigned short magic;


        unsigned long _fxsr_env[6];
        unsigned long mxcsr;
        unsigned long reserved;
        struct _fpxreg _fxsr_st[8];
        struct _xmmreg _xmm[8];
        unsigned long padding[56];
};


struct sigcontext {
        unsigned short gs, __gsh;
        unsigned short fs, __fsh;
        unsigned short es, __esh;
        unsigned short ds, __dsh;
        unsigned long edi;
        unsigned long esi;
        unsigned long ebp;
        unsigned long esp;
        unsigned long ebx;
        unsigned long edx;
        unsigned long ecx;
        unsigned long eax;
        unsigned long trapno;
        unsigned long err;
        unsigned long eip;
        unsigned short cs, __csh;
        unsigned long eflags;
        unsigned long esp_at_signal;
        unsigned short ss, __ssh;
        struct _fpstate * fpstate;
        unsigned long oldmask;
        unsigned long cr2;
};
# 29 "/usr/include/bits/sigcontext.h" 2 3 4
# 314 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) throw ();
# 326 "/usr/include/signal.h" 3 4
extern int siginterrupt (int __sig, int __interrupt) throw ();

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,
  SS_DISABLE
};







typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 329 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 20 "/usr/include/sys/ucontext.h" 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 24 "/usr/include/sys/ucontext.h" 2 3 4



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/sys/ucontext.h" 2 3 4



typedef int greg_t;




typedef greg_t gregset_t[19];



enum
{
  REG_GS = 0,
  REG_FS,
  REG_ES,
  REG_DS,
  REG_EDI,
  REG_ESI,
  REG_EBP,
  REG_ESP,
  REG_EBX,
  REG_EDX,
  REG_ECX,
  REG_EAX,
  REG_TRAPNO,
  REG_ERR,
  REG_EIP,
  REG_CS,
  REG_EFL,
  REG_UESP,
  REG_SS
};



struct _libc_fpreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
};

struct _libc_fpstate
{
  unsigned long int cw;
  unsigned long int sw;
  unsigned long int tag;
  unsigned long int ipoff;
  unsigned long int cssel;
  unsigned long int dataoff;
  unsigned long int datasel;
  struct _libc_fpreg _st[8];
  unsigned long int status;
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;


    fpregset_t fpregs;
    unsigned long int oldmask;
    unsigned long int cr2;
  } mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 332 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss) throw ();



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
                        struct sigaltstack *__restrict __oss) throw ();







extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 366 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 21 "/usr/include/bits/sigthread.h" 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
                            __const __sigset_t *__restrict __newmask,
                            __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();
# 367 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();



}
# 31 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 20 "/usr/include/sys/resource.h" 3 4




# 1 "/usr/include/bits/resource.h" 1 3 4
# 32 "/usr/include/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,


  RLIMIT_FSIZE = 1,


  RLIMIT_DATA = 2,


  RLIMIT_STACK = 3,


  RLIMIT_CORE = 4,





  RLIMIT_RSS = 5,


  RLIMIT_NOFILE = 7,
  RLIMIT_OFILE = RLIMIT_NOFILE,


  RLIMIT_AS = 9,


  RLIMIT_NPROC = 6,


  RLIMIT_MEMLOCK = 8,


  RLIMIT_LOCKS = 10,

  RLIMIT_NLIMITS = 11,
  RLIM_NLIMITS = RLIMIT_NLIMITS
};















typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,


  RUSAGE_CHILDREN = -1,


  RUSAGE_BOTH = -2
};

# 1 "/usr/include/bits/time.h" 1 3 4
# 60 "/usr/include/bits/time.h" 3 4
#undef __need_timeval
# 151 "/usr/include/bits/resource.h" 2 3 4


struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    long int ru_maxrss;


    long int ru_ixrss;

    long int ru_idrss;

    long int ru_isrss;


    long int ru_minflt;

    long int ru_majflt;

    long int ru_nswap;


    long int ru_inblock;

    long int ru_oublock;

    long int ru_msgsnd;

    long int ru_msgrcv;

    long int ru_nsignals;



    long int ru_nvcsw;


    long int ru_nivcsw;
  };





enum __priority_which
{
  PRIO_PROCESS = 0,
  PRIO_PGRP = 1,
  PRIO_USER = 2
};
# 26 "/usr/include/sys/resource.h" 2 3 4






extern "C" {
# 43 "/usr/include/sys/resource.h" 3 4
typedef int __rlimit_resource_t;
typedef int __rusage_who_t;
typedef int __priority_which_t;





extern int getrlimit (__rlimit_resource_t __resource,
                      struct rlimit *__rlimits) throw ();
# 63 "/usr/include/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
                        struct rlimit64 *__rlimits) throw ();






extern int setrlimit (__rlimit_resource_t __resource,
                      __const struct rlimit *__rlimits) throw ();
# 83 "/usr/include/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
                        __const struct rlimit64 *__rlimits) throw ();




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) throw ();





extern int getpriority (__priority_which_t __which, id_t __who) throw ();



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     throw ();

}
# 32 "/usr/include/sys/wait.h" 2 3 4
# 90 "/usr/include/sys/wait.h" 3 4




typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;





extern __pid_t wait (void * __stat_loc) throw ();



# 129 "/usr/include/sys/wait.h" 3 4
extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options) throw ();


# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 19 "/usr/include/bits/wordsize.h" 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4
# 134 "/usr/include/sys/wait.h" 2 3 4
# 142 "/usr/include/sys/wait.h" 3 4
extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
                   int __options) throw ();





struct rusage;






extern __pid_t wait3 (void * __stat_loc, int __options,
                      struct rusage * __usage) throw ();





struct rusage;


extern __pid_t wait4 (__pid_t __pid, void * __stat_loc, int __options,
                      struct rusage *__usage) throw ();



}
# 89 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

# 1 "/coolo/prod/kdelibs/kdecore/kwin.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/kwin.h"

# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 23 "/coolo/prod/kdelibs/kdecore/kwin.h" 2
# 34 "/coolo/prod/kdelibs/kdecore/kwin.h"
# 1 "/coolo/prod/kdelibs/kdecore/netwm_def.h" 1
# 27 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
# 42 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
struct NETPoint {



    NETPoint() : x(0), y(0) { }




    int x,
      y;
};
# 69 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
struct NETSize {



    NETSize() : width(0), height(0) { }




    int width,
      height;
};
# 92 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
struct NETRect {





    NETPoint pos;






    NETSize size;
};
# 120 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
struct NETIcon {



    NETIcon() : data(0) { }






    NETSize size;






    unsigned char *data;
};
# 150 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
struct NETStrut {



    NETStrut() : left(0), right(0), top(0), bottom(0) { }




    int left;




    int right;




    int top;




    int bottom;
};
# 190 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
class NET {
public:
# 202 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
    enum Role {
        Client,
        WindowManager
    };
# 237 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
    enum WindowType {
        Unknown = -1,
        Normal = 0,
        Desktop = 1,
        Dock = 2,
        Toolbar = 3,
        Menu = 4,
        Dialog = 5,
        Override = 6,
        TopMenu = 7,
        Tool = Toolbar,
        Utility = 8,
        Splash = 9
    };






    enum WindowTypeMask {
        NormalMask = 1<<0,
        DesktopMask = 1<<1,
        DockMask = 1<<2,
        ToolbarMask = 1<<3,
        MenuMask = 1<<4,
        DialogMask = 1<<5,
        OverrideMask = 1<<6,
        TopMenuMask = 1<<7,
        UtilityMask = 1<<8,
        SplashMask = 1<<9
    };
# 311 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
    enum State {
        Modal = 1<<0,
        Sticky = 1<<1,
        MaxVert = 1<<2,
        MaxHoriz = 1<<3,
        Max = MaxVert | MaxHoriz,
        Shaded = 1<<4,
        SkipTaskbar = 1<<5,
        KeepAbove = 1<<6,
        StaysOnTop = KeepAbove,
        SkipPager = 1<<7,
        Hidden = 1<<8,
        FullScreen = 1<<9,
        KeepBelow = 1<<10,
        DemandsAttention = 1<<11
    };
# 347 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
    enum Direction {
        TopLeft = 0,
        Top = 1,
        TopRight = 2,
        Right = 3,
        BottomRight = 4,
        Bottom = 5,
        BottomLeft = 6,
        Left = 7,
        Move = 8,



        KeyboardSize = 9,



        KeyboardMove = 10
    };
# 382 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
    enum MappingState {
        Visible,
        Withdrawn,
        Iconic
    };




    enum Action {
        ActionMove = 1<<0,
        ActionResize = 1<<1,
        ActionMinimize = 1<<2,
        ActionShade = 1<<3,
        ActionStick = 1<<4,
        ActionMaxVert = 1<<5,
        ActionMaxHoriz = 1<<6,
        ActionMax = ActionMaxVert | ActionMaxHoriz,
        ActionFullScreen = 1<<7,
        ActionChangeDesktop = 1<<8,
        ActionClose = 1<<9
    };
# 451 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
    enum Property {

        Supported = 1<<0,
        ClientList = 1<<1,
        ClientListStacking = 1<<2,
        NumberOfDesktops = 1<<3,
        DesktopGeometry = 1<<4,
        DesktopViewport = 1<<5,
        CurrentDesktop = 1<<6,
        DesktopNames = 1<<7,
        ActiveWindow = 1<<8,
        WorkArea = 1<<9,
        SupportingWMCheck = 1<<10,
        VirtualRoots = 1<<11,
        KDESystemTrayWindows = 1<<12,
        CloseWindow = 1<<13,
        WMMoveResize = 1<<14,


        WMName = 1<<15,
        WMVisibleName = 1<<16,
        WMDesktop = 1<<17,
        WMWindowType = 1<<18,
        WMState = 1<<19,
        WMStrut = 1<<20,
        WMIconGeometry = 1<<21,
        WMIcon = 1<<22,
        WMPid = 1<<23,
        WMHandledIcons = 1<<24,
        WMPing = 1<<25,
        WMKDESystemTrayWinFor = 1<<26,
        XAWMState = 1<<27,
        WMKDEFrameStrut = 1<<28,


        WMIconName = 1<<29,
        WMVisibleIconName = 1<<30,
        WMGeometry = 1<<31
    };
# 504 "/coolo/prod/kdelibs/kdecore/netwm_def.h"
    enum Property2 {
        WM2UserTime = 1<<0,
        WM2StartupId = 1<<1,
        WM2TransientFor = 1<<2,
        WM2GroupLeader = 1<<3,
        WM2AllowedActions = 1<<4
    };






    enum { OnAllDesktops = -1 };







    enum RequestSource {
        FromUnknown,
        FromApplication,
        FromTool
    };
};
# 35 "/coolo/prod/kdelibs/kdecore/kwin.h" 2
class NETWinInfo;
# 65 "/coolo/prod/kdelibs/kdecore/kwin.h"
class KWin
{
public:
# 91 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void activateWindow( WId win, long time = 0 );
# 107 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void setActiveWindow( WId win, long time );




    static void setActiveWindow( WId win );
# 125 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void demandAttention( WId win, bool set = true );
# 135 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void setUserTime( WId win, long time );




    static void invokeContextHelp();
# 152 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void setSystemTrayWindowFor( WId trayWin, WId forWin );

    class WindowInfo;
    class WindowInfoPrivate;
# 168 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static WindowInfo windowInfo( WId win, unsigned long properties = 0, unsigned long properties2 = 0 );
# 178 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static WId transientFor( WId window );





    static WId groupLeader( WId window );
# 202 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static QPixmap icon( WId win, int width = -1, int height = -1, bool scale = false );
# 212 "/coolo/prod/kdelibs/kdecore/kwin.h"
    enum IconSource { NETWM = 1, WMHints = 2, ClassHint = 4, XApp = 8 };
# 222 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static QPixmap icon( WId win, int width, int height, bool scale, int flags );







    static void setIcons( WId win, const QPixmap& icon, const QPixmap& miniIcon );
# 242 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void setType( WId win, NET::WindowType windowType );
# 255 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void setState( WId win, unsigned long state );
# 268 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void clearState( WId win, unsigned long state );
# 278 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void setOnAllDesktops( WId win, bool b );







    static void setOnDesktop( WId win, int desktop);
# 297 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void setStrut( WId win, int left, int right, int top, int bottom );





    static int currentDesktop();






    static int numberOfDesktops();






    static void setCurrentDesktop( int desktop );
# 327 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void iconifyWindow( WId win, bool animation = true );
# 337 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void deIconifyWindow( WId win, bool animation = true );






    static bool icccmCompliantMappingState();




    static bool allowedActionsSupported();





    static QString readNameProperty( WId window, unsigned long atom );




    struct Info
    {

        WId win;

        long unsigned int state;

        bool isMinimized() const;
        bool isIconified() const;
        NET::MappingState mappingState;

        NETStrut strut;

        NET::WindowType windowType;

        QString visibleName;

        QString name;

        int desktop;

        bool onAllDesktops;

        pid_t pid;

        QRect geometry;

        QRect frameGeometry;

        QString visibleNameWithState() const;
    };





    static Info info( WId win ) ;
# 405 "/coolo/prod/kdelibs/kdecore/kwin.h"
    static void appStarted() ;
};





class KWin::WindowInfo
{
public:



    WindowInfo( WId window, unsigned long properties, unsigned long properties2 );
    WindowInfo();
    ~WindowInfo();






    bool valid( bool withdrawn_is_valid = false ) const;



    WId win() const;




    unsigned long state() const;







    bool isMinimized() const;






    NET::MappingState mappingState() const;




    NETStrut strut() const;





    NET::WindowType windowType( int supported_types ) const;
# 474 "/coolo/prod/kdelibs/kdecore/kwin.h"
    QString visibleNameMatchingState() const;





    QString visibleName() const;
# 490 "/coolo/prod/kdelibs/kdecore/kwin.h"
    QString visibleNameWithState() const;





    QString name() const;






    QString visibleIconName() const;






    QString iconName() const;




    bool isOnCurrentDesktop() const;




    bool isOnDesktop( int desktop ) const;





    bool onAllDesktops() const;





    int desktop() const;




    QRect geometry() const;




    QRect frameGeometry() const;





    WId transientFor() const;




    WId groupLeader() const;






    bool actionSupported( NET::Action action ) const;

    WindowInfo( const WindowInfo& );
    WindowInfo& operator=( const WindowInfo& );
private:
    WindowInfoPrivate* d;
};
# 91 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2





# 1 "/usr/include/time.h" 1 3 4
# 27 "/usr/include/time.h" 3 4


extern "C" {





# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 408 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_NULL
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 26 "/usr/include/bits/time.h" 3 4







# 46 "/usr/include/bits/time.h" 3 4




# 43 "/usr/include/time.h" 2 3 4
# 129 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 178 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
                        __const char *__restrict __format,
                        __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
                       __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
                          __const char *__restrict __format,
                          __const struct tm *__restrict __tp,
                          __locale_t __loc) throw ();

extern char *strptime_l (__const char *__restrict __s,
                         __const char *__restrict __fmt, struct tm *__tp,
                         __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
                            struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
                               struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
                        char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
                      char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();





# 309 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));





extern int nanosleep (__const struct timespec *__requested_time,
                      struct timespec *__remaining) throw ();



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();



extern int clock_nanosleep (clockid_t __clock_id, int __flags,
                            __const struct timespec *__req,
                            struct timespec *__rem) throw ();


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
                         struct sigevent *__restrict __evp,
                         timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
                          __const struct itimerspec *__restrict __value,
                          struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 380 "/usr/include/time.h" 3 4
extern int getdate_err;





extern struct tm *getdate (__const char *__string) throw ();
# 395 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
                      struct tm *__restrict __resbufp) throw ();


}
# 97 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/usr/include/sys/time.h" 1 3 4
# 21 "/usr/include/sys/time.h" 3 4





# 1 "/usr/include/bits/time.h" 1 3 4
# 60 "/usr/include/bits/time.h" 3 4
#undef __need_timeval
# 30 "/usr/include/sys/time.h" 2 3 4
# 39 "/usr/include/sys/time.h" 3 4
extern "C" {






# 57 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 73 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
                         __timezone_ptr_t __tz) throw ();




extern int settimeofday (__const struct timeval *__tv,
                         __const struct timezone *__tz) throw ();





extern int adjtime (__const struct timeval *__delta,
                    struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,

    ITIMER_VIRTUAL = 1,


    ITIMER_PROF = 2
  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
                      struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
                      __const struct itimerval *__restrict __new,
                      struct itimerval *__restrict __old) throw ();




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     throw ();



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     throw ();


extern int futimes (int fd, __const struct timeval __tvp[2]) throw ();









# 171 "/usr/include/sys/time.h" 3 4
# 182 "/usr/include/sys/time.h" 3 4
}
# 98 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4



extern "C" {



# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4


# 1 "/usr/include/asm/errno.h" 1 3 4





# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4










extern int *__errno_location (void) throw () __attribute__ ((__const__));



# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 99 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

# 1 "/usr/include/netdb.h" 1 3 4
# 24 "/usr/include/netdb.h" 3 4



# 1 "/usr/include/netinet/in.h" 1 3 4
# 20 "/usr/include/netinet/in.h" 3 4


# 1 "/usr/include/stdint.h" 1 3 4
# 24 "/usr/include/stdint.h" 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 19 "/usr/include/bits/wordsize.h" 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;




__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 129 "/usr/include/stdint.h" 3 4
typedef unsigned int uintptr_t;
# 138 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 24 "/usr/include/netinet/in.h" 2 3 4



extern "C" {


enum
  {
    IPPROTO_IP = 0,
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_IPV6 = 41,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MTP = 92,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_RAW = 255,
    IPPROTO_MAX
  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };

























struct in6_addr
  {
    union
      {
        uint8_t u6_addr8[16];
        uint16_t u6_addr16[8];
        uint32_t u6_addr32[4];
      } in6_u;
  };

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;



# 1 "/usr/include/bits/socket.h" 1 3 4
# 21 "/usr/include/bits/socket.h" 3 4





# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 408 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_NULL
# 30 "/usr/include/bits/socket.h" 2 3 4

# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 1 3 4
# 32 "/usr/include/bits/socket.h" 2 3 4
# 41 "/usr/include/bits/socket.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,

  SOCK_DGRAM = 2,

  SOCK_RAW = 3,
  SOCK_RDM = 4,
  SOCK_SEQPACKET = 5,

  SOCK_PACKET = 10


};













# 1 "/usr/include/bits/sockaddr.h" 1 3 4
# 25 "/usr/include/bits/sockaddr.h" 3 4



typedef unsigned short int sa_family_t;







# 143 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };









struct sockaddr_storage
  {
    sa_family_t ss_family;
    __uint32_t __ss_align;
    char __ss_padding[(128 - (2 * sizeof (__uint32_t)))];
  };



enum
  {
    MSG_OOB = 0x01,
    MSG_PEEK = 0x02,
    MSG_DONTROUTE = 0x04,


    MSG_TRYHARD = MSG_DONTROUTE,

    MSG_CTRUNC = 0x08,
    MSG_PROXY = 0x10,
    MSG_TRUNC = 0x20,
    MSG_DONTWAIT = 0x40,
    MSG_EOR = 0x80,
    MSG_WAITALL = 0x100,
    MSG_FIN = 0x200,
    MSG_SYN = 0x400,
    MSG_CONFIRM = 0x800,
    MSG_RST = 0x1000,
    MSG_ERRQUEUE = 0x2000,
    MSG_NOSIGNAL = 0x4000,
    MSG_MORE = 0x8000
  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;

    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;

    int cmsg_level;
    int cmsg_type;



  };











extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
                                      struct cmsghdr *__cmsg) throw ();
# 284 "/usr/include/bits/socket.h" 3 4
enum
  {
    SCM_RIGHTS = 0x01,

    SCM_CREDENTIALS = 0x02,

    __SCM_CONNECT = 0x03
  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};


# 1 "/usr/include/asm/socket.h" 1 3 4


# 1 "/usr/include/asm/sockios.h" 1 3 4



# 5 "/usr/include/asm/socket.h" 2 3 4











# 306 "/usr/include/bits/socket.h" 2 3 4



struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 213 "/usr/include/netinet/in.h" 2 3 4



struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
                           (sizeof (unsigned short int)) -
                           sizeof (in_port_t) -
                           sizeof (struct in_addr)];
  };


struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };


struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };


# 1 "/usr/include/bits/in.h" 1 3 4
# 28 "/usr/include/bits/in.h" 3 4











struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreq
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_interface;
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };















# 251 "/usr/include/netinet/in.h" 2 3 4
# 259 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) throw () __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     throw () __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     throw () __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     throw () __attribute__ ((__const__));




# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 25 "/usr/include/bits/byteswap.h" 3 4






# 59 "/usr/include/bits/byteswap.h" 3 4
# 68 "/usr/include/bits/byteswap.h" 3 4
# 107 "/usr/include/bits/byteswap.h" 3 4
# 117 "/usr/include/bits/byteswap.h" 3 4
# 271 "/usr/include/netinet/in.h" 2 3 4
# 293 "/usr/include/netinet/in.h" 3 4
































extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) throw ();


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     throw ();


















struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };

}
# 29 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 37 "/usr/include/rpc/netdb.h" 3 4



# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 43 "/usr/include/rpc/netdb.h" 2 3 4

extern "C" {

struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) throw ();
extern void endrpcent (void) throw ();
extern struct rpcent *getrpcbyname (__const char *__name) throw ();
extern struct rpcent *getrpcbynumber (int __number) throw ();
extern struct rpcent *getrpcent (void) throw ();


extern int getrpcbyname_r (__const char *__name, struct rpcent *__result_buf,
                           char *__buffer, size_t __buflen,
                           struct rpcent **__result) throw ();

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
                             char *__buffer, size_t __buflen,
                             struct rpcent **__result) throw ();

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
                        size_t __buflen, struct rpcent **__result) throw ();


}
# 34 "/usr/include/netdb.h" 2 3 4



# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 19 "/usr/include/bits/wordsize.h" 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4
# 39 "/usr/include/netdb.h" 2 3 4



# 1 "/usr/include/bits/netdb.h" 1 3 4
# 27 "/usr/include/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 44 "/usr/include/netdb.h" 2 3 4




extern "C" {





extern int *__h_errno_location (void) throw () __attribute__ ((__const__));

















extern void herror (__const char *__str) throw ();


extern __const char *hstrerror (int __err_num) throw ();




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;
};



extern void sethostent (int __stay_open) throw ();


extern void endhostent (void) throw ();



extern struct hostent *gethostent (void) throw ();



extern struct hostent *gethostbyaddr (__const void *__addr, __socklen_t __len,
                                      int __type) throw ();


extern struct hostent *gethostbyname (__const char *__name) throw ();





extern struct hostent *gethostbyname2 (__const char *__name, int __af) throw ();






extern int gethostent_r (struct hostent *__restrict __result_buf,
                         char *__restrict __buf, size_t __buflen,
                         struct hostent **__restrict __result,
                         int *__restrict __h_errnop) throw ();

extern int gethostbyaddr_r (__const void *__restrict __addr, __socklen_t __len,
                            int __type,
                            struct hostent *__restrict __result_buf,
                            char *__restrict __buf, size_t __buflen,
                            struct hostent **__restrict __result,
                            int *__restrict __h_errnop) throw ();

extern int gethostbyname_r (__const char *__restrict __name,
                            struct hostent *__restrict __result_buf,
                            char *__restrict __buf, size_t __buflen,
                            struct hostent **__restrict __result,
                            int *__restrict __h_errnop) throw ();

extern int gethostbyname2_r (__const char *__restrict __name, int __af,
                             struct hostent *__restrict __result_buf,
                             char *__restrict __buf, size_t __buflen,
                             struct hostent **__restrict __result,
                             int *__restrict __h_errnop) throw ();





extern void setnetent (int __stay_open) throw ();


extern void endnetent (void) throw ();



extern struct netent *getnetent (void) throw ();



extern struct netent *getnetbyaddr (uint32_t __net, int __type)
     throw ();


extern struct netent *getnetbyname (__const char *__name) throw ();







extern int getnetent_r (struct netent *__restrict __result_buf,
                        char *__restrict __buf, size_t __buflen,
                        struct netent **__restrict __result,
                        int *__restrict __h_errnop) throw ();

extern int getnetbyaddr_r (uint32_t __net, int __type,
                           struct netent *__restrict __result_buf,
                           char *__restrict __buf, size_t __buflen,
                           struct netent **__restrict __result,
                           int *__restrict __h_errnop) throw ();

extern int getnetbyname_r (__const char *__restrict __name,
                           struct netent *__restrict __result_buf,
                           char *__restrict __buf, size_t __buflen,
                           struct netent **__restrict __result,
                           int *__restrict __h_errnop) throw ();




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};



extern void setservent (int __stay_open) throw ();


extern void endservent (void) throw ();



extern struct servent *getservent (void) throw ();



extern struct servent *getservbyname (__const char *__name,
                                      __const char *__proto) throw ();



extern struct servent *getservbyport (int __port, __const char *__proto)
     throw ();





extern int getservent_r (struct servent *__restrict __result_buf,
                         char *__restrict __buf, size_t __buflen,
                         struct servent **__restrict __result) throw ();

extern int getservbyname_r (__const char *__restrict __name,
                            __const char *__restrict __proto,
                            struct servent *__restrict __result_buf,
                            char *__restrict __buf, size_t __buflen,
                            struct servent **__restrict __result) throw ();

extern int getservbyport_r (int __port, __const char *__restrict __proto,
                            struct servent *__restrict __result_buf,
                            char *__restrict __buf, size_t __buflen,
                            struct servent **__restrict __result) throw ();




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};



extern void setprotoent (int __stay_open) throw ();


extern void endprotoent (void) throw ();



extern struct protoent *getprotoent (void) throw ();


extern struct protoent *getprotobyname (__const char *__name) throw ();


extern struct protoent *getprotobynumber (int __proto) throw ();





extern int getprotoent_r (struct protoent *__restrict __result_buf,
                          char *__restrict __buf, size_t __buflen,
                          struct protoent **__restrict __result) throw ();

extern int getprotobyname_r (__const char *__restrict __name,
                             struct protoent *__restrict __result_buf,
                             char *__restrict __buf, size_t __buflen,
                             struct protoent **__restrict __result) throw ();

extern int getprotobynumber_r (int __proto,
                               struct protoent *__restrict __result_buf,
                               char *__restrict __buf, size_t __buflen,
                               struct protoent **__restrict __result) throw ();




extern int setnetgrent (__const char *__netgroup) throw ();


extern void endnetgrent (void) throw ();



extern int getnetgrent (char **__restrict __hostp,
                        char **__restrict __userp,
                        char **__restrict __domainp) throw ();



extern int innetgr (__const char *__netgroup, __const char *__host,
                    __const char *__user, __const char *domain) throw ();


extern int getnetgrent_r (char **__restrict __hostp,
                          char **__restrict __userp,
                          char **__restrict __domainp,
                          char *__restrict __buffer, size_t __buflen) throw ();
# 334 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
                 __const char *__restrict __locuser,
                 __const char *__restrict __remuser,
                 __const char *__restrict __cmd, int *__restrict __fd2p)
     throw ();



extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
                    __const char *__restrict __locuser,
                    __const char *__restrict __remuser,
                    __const char *__restrict __cmd, int *__restrict __fd2p,
                    sa_family_t __af) throw ();






extern int rexec (char **__restrict __ahost, int __rport,
                  __const char *__restrict __name,
                  __const char *__restrict __pass,
                  __const char *__restrict __cmd, int *__restrict __fd2p)
     throw ();



extern int rexec_af (char **__restrict __ahost, int __rport,
                     __const char *__restrict __name,
                     __const char *__restrict __pass,
                     __const char *__restrict __cmd, int *__restrict __fd2p,
                     sa_family_t __af) throw ();




extern int ruserok (__const char *__rhost, int __suser,
                    __const char *__remuser, __const char *__locuser) throw ();



extern int ruserok_af (__const char *__rhost, int __suser,
                       __const char *__remuser, __const char *__locuser,
                       sa_family_t __af) throw ();




extern int rresvport (int *__alport) throw ();



extern int rresvport_af (int *__alport, sa_family_t __af) throw ();






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __unused[5];
};














extern int getaddrinfo (__const char *__restrict __name,
                        __const char *__restrict __service,
                        __const struct addrinfo *__restrict __req,
                        struct addrinfo **__restrict __pai) throw ();


extern void freeaddrinfo (struct addrinfo *__ai) throw ();


extern __const char *gai_strerror (int __ecode) throw ();


extern int getnameinfo (__const struct sockaddr *__restrict __sa,
                        socklen_t __salen, char *__restrict __host,
                        socklen_t __hostlen, char *__restrict __serv,
                        socklen_t __servlen, unsigned int __flags) throw ();





extern int getaddrinfo_a (int __mode, struct gaicb *__list[],
                          int __ent, struct sigevent *__restrict __sig)
     throw ();




extern int gai_suspend (__const struct gaicb *__const __list[], int __ent,
                        __const struct timespec *__timeout) throw ();


extern int gai_error (struct gaicb *__req) throw ();


extern int gai_cancel (struct gaicb *__gaicbp) throw ();



}
# 101 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/netwm.h" 1
# 28 "/coolo/prod/kdelibs/kdecore/netwm.h"




# 1 "/usr/X11R6/include/X11/Xlib.h" 1
# 36 "/usr/X11R6/include/X11/Xlib.h"

# 55 "/usr/X11R6/include/X11/Xlib.h"
# 1 "/usr/X11R6/include/X11/X.h" 1







# 58 "/usr/X11R6/include/X11/X.h"
# 70 "/usr/X11R6/include/X11/X.h"
typedef unsigned long XID;


typedef unsigned long Mask;


typedef unsigned long Atom;

typedef unsigned long VisualID;
typedef unsigned long Time;
# 101 "/usr/X11R6/include/X11/X.h"
typedef XID Window;
typedef XID Drawable;

typedef XID Font;

typedef XID Pixmap;
typedef XID Cursor;
typedef XID Colormap;
typedef XID GContext;
typedef XID KeySym;

typedef unsigned char KeyCode;





















# 155 "/usr/X11R6/include/X11/X.h"

































































# 369 "/usr/X11R6/include/X11/X.h"

# 387 "/usr/X11R6/include/X11/X.h"




















































































































































# 56 "/usr/X11R6/include/X11/Xlib.h" 2


# 1 "/usr/X11R6/include/X11/Xfuncproto.h" 1
# 32 "/usr/X11R6/include/X11/Xfuncproto.h"


























# 59 "/usr/X11R6/include/X11/Xlib.h" 2
# 1 "/usr/X11R6/include/X11/Xosdefs.h" 1
# 31 "/usr/X11R6/include/X11/Xosdefs.h"
# 60 "/usr/X11R6/include/X11/Xlib.h" 2
# 72 "/usr/X11R6/include/X11/Xlib.h"
# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 42 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4


# 140 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4



typedef int ptrdiff_t;
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 414 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
# 73 "/usr/X11R6/include/X11/Xlib.h" 2
# 92 "/usr/X11R6/include/X11/Xlib.h"

typedef char *XPointer;













typedef struct _XExtData {
        int number;
        struct _XExtData *next;
        int (*free_private)(

        struct _XExtData *extension

        );
        XPointer private_data;
} XExtData;




typedef struct {
        int extension;
        int major_opcode;
        int first_event;
        int first_error;
} XExtCodes;





typedef struct {
    int depth;
    int bits_per_pixel;
    int scanline_pad;
} XPixmapFormatValues;





typedef struct {
        int function;
        unsigned long plane_mask;
        unsigned long foreground;
        unsigned long background;
        int line_width;
        int line_style;
        int cap_style;

        int join_style;
        int fill_style;

        int fill_rule;
        int arc_mode;
        Pixmap tile;
        Pixmap stipple;
        int ts_x_origin;
        int ts_y_origin;
        Font font;
        int subwindow_mode;
        int graphics_exposures;
        int clip_x_origin;
        int clip_y_origin;
        Pixmap clip_mask;
        int dash_offset;
        char dashes;
} XGCValues;






typedef struct _XGC







*GC;




typedef struct {
        XExtData *ext_data;
        VisualID visualid;

        int c_class;



        unsigned long red_mask, green_mask, blue_mask;
        int bits_per_rgb;
        int map_entries;
} Visual;




typedef struct {
        int depth;
        int nvisuals;
        Visual *visuals;
} Depth;







struct _XDisplay;

typedef struct {
        XExtData *ext_data;
        struct _XDisplay *display;
        Window root;
        int width, height;
        int mwidth, mheight;
        int ndepths;
        Depth *depths;
        int root_depth;
        Visual *root_visual;
        GC default_gc;
        Colormap cmap;
        unsigned long white_pixel;
        unsigned long black_pixel;
        int max_maps, min_maps;
        int backing_store;
        int save_unders;
        long root_input_mask;
} Screen;




typedef struct {
        XExtData *ext_data;
        int depth;
        int bits_per_pixel;
        int scanline_pad;
} ScreenFormat;




typedef struct {
    Pixmap background_pixmap;
    unsigned long background_pixel;
    Pixmap border_pixmap;
    unsigned long border_pixel;
    int bit_gravity;
    int win_gravity;
    int backing_store;
    unsigned long backing_planes;
    unsigned long backing_pixel;
    int save_under;
    long event_mask;
    long do_not_propagate_mask;
    int override_redirect;
    Colormap colormap;
    Cursor cursor;
} XSetWindowAttributes;

typedef struct {
    int x, y;
    int width, height;
    int border_width;
    int depth;
    Visual *visual;
    Window root;

    int c_class;



    int bit_gravity;
    int win_gravity;
    int backing_store;
    unsigned long backing_planes;
    unsigned long backing_pixel;
    int save_under;
    Colormap colormap;
    int map_installed;
    int map_state;
    long all_event_masks;
    long your_event_mask;
    long do_not_propagate_mask;
    int override_redirect;
    Screen *screen;
} XWindowAttributes;






typedef struct {
        int family;
        int length;
        char *address;
} XHostAddress;




typedef struct _XImage {
    int width, height;
    int xoffset;
    int format;
    char *data;
    int byte_order;
    int bitmap_unit;
    int bitmap_bit_order;
    int bitmap_pad;
    int depth;
    int bytes_per_line;
    int bits_per_pixel;
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    XPointer obdata;
    struct funcs {

        struct _XImage *(*create_image)(
                struct _XDisplay* ,
                Visual* ,
                unsigned int ,
                int ,
                int ,
                char* ,
                unsigned int ,
                unsigned int ,
                int ,
                int );
        int (*destroy_image) (struct _XImage *);
        unsigned long (*get_pixel) (struct _XImage *, int, int);
        int (*put_pixel) (struct _XImage *, int, int, unsigned long);
        struct _XImage *(*sub_image)(struct _XImage *, int, int, unsigned int, unsigned int);
        int (*add_pixel) (struct _XImage *, long);
# 412 "/usr/X11R6/include/X11/Xlib.h"
        } f;
} XImage;




typedef struct {
    int x, y;
    int width, height;
    int border_width;
    Window sibling;
    int stack_mode;
} XWindowChanges;




typedef struct {
        unsigned long pixel;
        unsigned short red, green, blue;
        char flags;
        char pad;
} XColor;






typedef struct {
    short x1, y1, x2, y2;
} XSegment;

typedef struct {
    short x, y;
} XPoint;

typedef struct {
    short x, y;
    unsigned short width, height;
} XRectangle;

typedef struct {
    short x, y;
    unsigned short width, height;
    short angle1, angle2;
} XArc;




typedef struct {
        int key_click_percent;
        int bell_percent;
        int bell_pitch;
        int bell_duration;
        int led;
        int led_mode;
        int key;
        int auto_repeat_mode;
} XKeyboardControl;



typedef struct {
        int key_click_percent;
        int bell_percent;
        unsigned int bell_pitch, bell_duration;
        unsigned long led_mask;
        int global_auto_repeat;
        char auto_repeats[32];
} XKeyboardState;



typedef struct {
        Time time;
        short x, y;
} XTimeCoord;



typedef struct {
        int max_keypermod;
        KeyCode *modifiermap;
} XModifierKeymap;
# 506 "/usr/X11R6/include/X11/Xlib.h"
typedef struct _XDisplay Display;


struct _XPrivate;
struct _XrmHashBucketRec;

typedef struct



{
        XExtData *ext_data;
        struct _XPrivate *private1;
        int fd;
        int private2;
        int proto_major_version;
        int proto_minor_version;
        char *vendor;
        XID private3;
        XID private4;
        XID private5;
        int private6;
        XID (*resource_alloc)(

                struct _XDisplay*

        );
        int byte_order;
        int bitmap_unit;
        int bitmap_pad;
        int bitmap_bit_order;
        int nformats;
        ScreenFormat *pixmap_format;
        int private8;
        int release;
        struct _XPrivate *private9, *private10;
        int qlen;
        unsigned long last_request_read;
        unsigned long request;
        XPointer private11;
        XPointer private12;
        XPointer private13;
        XPointer private14;
        unsigned max_request_size;
        struct _XrmHashBucketRec *db;
        int (*private15)(

                struct _XDisplay*

                );
        char *display_name;
        int default_screen;
        int nscreens;
        Screen *screens;
        unsigned long motion_buffer;
        unsigned long private16;
        int min_keycode;
        int max_keycode;
        XPointer private17;
        XPointer private18;
        int private19;
        char *xdefaults;

}



*_XPrivDisplay;
# 582 "/usr/X11R6/include/X11/Xlib.h"
typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        Window root;
        Window subwindow;
        Time time;
        int x, y;
        int x_root, y_root;
        unsigned int state;
        unsigned int keycode;
        int same_screen;
} XKeyEvent;
typedef XKeyEvent XKeyPressedEvent;
typedef XKeyEvent XKeyReleasedEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        Window root;
        Window subwindow;
        Time time;
        int x, y;
        int x_root, y_root;
        unsigned int state;
        unsigned int button;
        int same_screen;
} XButtonEvent;
typedef XButtonEvent XButtonPressedEvent;
typedef XButtonEvent XButtonReleasedEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        Window root;
        Window subwindow;
        Time time;
        int x, y;
        int x_root, y_root;
        unsigned int state;
        char is_hint;
        int same_screen;
} XMotionEvent;
typedef XMotionEvent XPointerMovedEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        Window root;
        Window subwindow;
        Time time;
        int x, y;
        int x_root, y_root;
        int mode;
        int detail;




        int same_screen;
        int focus;
        unsigned int state;
} XCrossingEvent;
typedef XCrossingEvent XEnterWindowEvent;
typedef XCrossingEvent XLeaveWindowEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        int mode;
        int detail;





} XFocusChangeEvent;
typedef XFocusChangeEvent XFocusInEvent;
typedef XFocusChangeEvent XFocusOutEvent;


typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        char key_vector[32];
} XKeymapEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        int x, y;
        int width, height;
        int count;
} XExposeEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Drawable drawable;
        int x, y;
        int width, height;
        int count;
        int major_code;
        int minor_code;
} XGraphicsExposeEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Drawable drawable;
        int major_code;
        int minor_code;
} XNoExposeEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        int state;
} XVisibilityEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window parent;
        Window window;
        int x, y;
        int width, height;
        int border_width;
        int override_redirect;
} XCreateWindowEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window event;
        Window window;
} XDestroyWindowEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window event;
        Window window;
        int from_configure;
} XUnmapEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window event;
        Window window;
        int override_redirect;
} XMapEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window parent;
        Window window;
} XMapRequestEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window event;
        Window window;
        Window parent;
        int x, y;
        int override_redirect;
} XReparentEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window event;
        Window window;
        int x, y;
        int width, height;
        int border_width;
        Window above;
        int override_redirect;
} XConfigureEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window event;
        Window window;
        int x, y;
} XGravityEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        int width, height;
} XResizeRequestEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window parent;
        Window window;
        int x, y;
        int width, height;
        int border_width;
        Window above;
        int detail;
        unsigned long value_mask;
} XConfigureRequestEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window event;
        Window window;
        int place;
} XCirculateEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window parent;
        Window window;
        int place;
} XCirculateRequestEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        Atom atom;
        Time time;
        int state;
} XPropertyEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        Atom selection;
        Time time;
} XSelectionClearEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window owner;
        Window requestor;
        Atom selection;
        Atom target;
        Atom property;
        Time time;
} XSelectionRequestEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window requestor;
        Atom selection;
        Atom target;
        Atom property;
        Time time;
} XSelectionEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        Colormap colormap;

        int c_new;



        int state;
} XColormapEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        Atom message_type;
        int format;
        union {
                char b[20];
                short s[10];
                long l[5];
                } data;
} XClientMessageEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
        int request;

        int first_keycode;
        int count;
} XMappingEvent;

typedef struct {
        int type;
        Display *display;
        XID resourceid;
        unsigned long serial;
        unsigned char error_code;
        unsigned char request_code;
        unsigned char minor_code;
} XErrorEvent;

typedef struct {
        int type;
        unsigned long serial;
        int send_event;
        Display *display;
        Window window;
} XAnyEvent;





typedef union _XEvent {
        int type;
        XAnyEvent xany;
        XKeyEvent xkey;
        XButtonEvent xbutton;
        XMotionEvent xmotion;
        XCrossingEvent xcrossing;
        XFocusChangeEvent xfocus;
        XExposeEvent xexpose;
        XGraphicsExposeEvent xgraphicsexpose;
        XNoExposeEvent xnoexpose;
        XVisibilityEvent xvisibility;
        XCreateWindowEvent xcreatewindow;
        XDestroyWindowEvent xdestroywindow;
        XUnmapEvent xunmap;
        XMapEvent xmap;
        XMapRequestEvent xmaprequest;
        XReparentEvent xreparent;
        XConfigureEvent xconfigure;
        XGravityEvent xgravity;
        XResizeRequestEvent xresizerequest;
        XConfigureRequestEvent xconfigurerequest;
        XCirculateEvent xcirculate;
        XCirculateRequestEvent xcirculaterequest;
        XPropertyEvent xproperty;
        XSelectionClearEvent xselectionclear;
        XSelectionRequestEvent xselectionrequest;
        XSelectionEvent xselection;
        XColormapEvent xcolormap;
        XClientMessageEvent xclient;
        XMappingEvent xmapping;
        XErrorEvent xerror;
        XKeymapEvent xkeymap;
        long pad[24];
} XEvent;






typedef struct {
    short lbearing;
    short rbearing;
    short width;
    short ascent;
    short descent;
    unsigned short attributes;
} XCharStruct;





typedef struct {
    Atom name;
    unsigned long card32;
} XFontProp;

typedef struct {
    XExtData *ext_data;
    Font fid;
    unsigned direction;
    unsigned min_char_or_byte2;
    unsigned max_char_or_byte2;
    unsigned min_byte1;
    unsigned max_byte1;
    int all_chars_exist;
    unsigned default_char;
    int n_properties;
    XFontProp *properties;
    XCharStruct min_bounds;
    XCharStruct max_bounds;
    XCharStruct *per_char;
    int ascent;
    int descent;
} XFontStruct;




typedef struct {
    char *chars;
    int nchars;
    int delta;
    Font font;
} XTextItem;

typedef struct {
    unsigned char byte1;
    unsigned char byte2;
} XChar2b;

typedef struct {
    XChar2b *chars;
    int nchars;
    int delta;
    Font font;
} XTextItem16;


typedef union { Display *display;
                GC gc;
                Visual *visual;
                Screen *screen;
                ScreenFormat *pixmap_format;
                XFontStruct *font; } XEDataObject;

typedef struct {
    XRectangle max_ink_extent;
    XRectangle max_logical_extent;
} XFontSetExtents;





typedef struct _XOM *XOM;
typedef struct _XOC *XOC, *XFontSet;

typedef struct {
    char *chars;
    int nchars;
    int delta;
    XFontSet font_set;
} XmbTextItem;

typedef struct {
    wchar_t *chars;
    int nchars;
    int delta;
    XFontSet font_set;
} XwcTextItem;


typedef struct {
    int charset_count;
    char **charset_list;
} XOMCharSetList;

typedef enum {
    XOMOrientation_LTR_TTB,
    XOMOrientation_RTL_TTB,
    XOMOrientation_TTB_LTR,
    XOMOrientation_TTB_RTL,
    XOMOrientation_Context
} XOrientation;

typedef struct {
    int num_orientation;
    XOrientation *orientation;
} XOMOrientation;

typedef struct {
    int num_font;
    XFontStruct **font_struct_list;
    char **font_name_list;
} XOMFontInfo;

typedef struct _XIM *XIM;
typedef struct _XIC *XIC;

typedef void (*XIMProc)(

    XIM,
    XPointer,
    XPointer

);

typedef int (*XICProc)(

    XIC,
    XPointer,
    XPointer

);

typedef void (*XIDProc)(

    Display*,
    XPointer,
    XPointer

);

typedef unsigned long XIMStyle;

typedef struct {
    unsigned short count_styles;
    XIMStyle *supported_styles;
} XIMStyles;






typedef void *XVaNestedList;




typedef struct {
    XPointer client_data;
    XIMProc callback;
} XIMCallback;

typedef struct {
    XPointer client_data;
    XICProc callback;
} XICCallback;

typedef unsigned long XIMFeedback;


typedef struct _XIMText {
    unsigned short length;
    XIMFeedback *feedback;
    int encoding_is_wchar;
    union {
        char *multi_byte;
        wchar_t *wide_char;
    } string;
} XIMText;

typedef unsigned long XIMPreeditState;


typedef struct _XIMPreeditStateNotifyCallbackStruct {
    XIMPreeditState state;
} XIMPreeditStateNotifyCallbackStruct;

typedef unsigned long XIMResetState;


typedef unsigned long XIMStringConversionFeedback;


typedef struct _XIMStringConversionText {
    unsigned short length;
    XIMStringConversionFeedback *feedback;
    int encoding_is_wchar;
    union {
        char *mbs;
        wchar_t *wcs;
    } string;
} XIMStringConversionText;

typedef unsigned short XIMStringConversionPosition;

typedef unsigned short XIMStringConversionType;


typedef unsigned short XIMStringConversionOperation;


typedef enum {
    XIMForwardChar, XIMBackwardChar,
    XIMForwardWord, XIMBackwardWord,
    XIMCaretUp, XIMCaretDown,
    XIMNextLine, XIMPreviousLine,
    XIMLineStart, XIMLineEnd,
    XIMAbsolutePosition,
    XIMDontChange
} XIMCaretDirection;

typedef struct _XIMStringConversionCallbackStruct {
    XIMStringConversionPosition position;
    XIMCaretDirection direction;
    XIMStringConversionOperation operation;
    unsigned short factor;
    XIMStringConversionText *text;
} XIMStringConversionCallbackStruct;

typedef struct _XIMPreeditDrawCallbackStruct {
    int caret;
    int chg_first;
    int chg_length;
    XIMText *text;
} XIMPreeditDrawCallbackStruct;

typedef enum {
    XIMIsInvisible,
    XIMIsPrimary,
    XIMIsSecondary
} XIMCaretStyle;

typedef struct _XIMPreeditCaretCallbackStruct {
    int position;
    XIMCaretDirection direction;
    XIMCaretStyle style;
} XIMPreeditCaretCallbackStruct;

typedef enum {
    XIMTextType,
    XIMBitmapType
} XIMStatusDataType;

typedef struct _XIMStatusDrawCallbackStruct {
    XIMStatusDataType type;
    union {
        XIMText *text;
        Pixmap bitmap;
    } data;
} XIMStatusDrawCallbackStruct;

typedef struct _XIMHotKeyTrigger {
    KeySym keysym;
    int modifier;
    int modifier_mask;
} XIMHotKeyTrigger;

typedef struct _XIMHotKeyTriggers {
    int num_hot_key;
    XIMHotKeyTrigger *key;
} XIMHotKeyTriggers;

typedef unsigned long XIMHotKeyState;


typedef struct {
    unsigned short count_values;
    char **supported_values;
} XIMValuesList;

extern "C" {





extern int _Xdebug;

extern XFontStruct *XLoadQueryFont(

    Display* ,
    const char*

);

extern XFontStruct *XQueryFont(

    Display* ,
    XID

);


extern XTimeCoord *XGetMotionEvents(

    Display* ,
    Window ,
    Time ,
    Time ,
    int*

);

extern XModifierKeymap *XDeleteModifiermapEntry(

    XModifierKeymap* ,

    unsigned int ,



    int

);

extern XModifierKeymap *XGetModifierMapping(

    Display*

);

extern XModifierKeymap *XInsertModifiermapEntry(

    XModifierKeymap* ,

    unsigned int ,



    int

);

extern XModifierKeymap *XNewModifiermap(

    int

);

extern XImage *XCreateImage(

    Display* ,
    Visual* ,
    unsigned int ,
    int ,
    int ,
    char* ,
    unsigned int ,
    unsigned int ,
    int ,
    int

);
extern int XInitImage(

    XImage*

);
extern XImage *XGetImage(

    Display* ,
    Drawable ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    int

);
extern XImage *XGetSubImage(

    Display* ,
    Drawable ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    int ,
    XImage* ,
    int ,
    int

);




extern Display *XOpenDisplay(

    const char*

);

extern void XrmInitialize(

    void

);

extern char *XFetchBytes(

    Display* ,
    int*

);
extern char *XFetchBuffer(

    Display* ,
    int* ,
    int

);
extern char *XGetAtomName(

    Display* ,
    Atom

);
extern int XGetAtomNames(

    Display* ,
    Atom* ,
    int ,
    char**

);
extern char *XGetDefault(

    Display* ,
    const char* ,
    const char*

);
extern char *XDisplayName(

    const char*

);
extern char *XKeysymToString(

    KeySym

);

extern int (*XSynchronize(

    Display* ,
    int

))(

    Display*

);
extern int (*XSetAfterFunction(

    Display* ,
    int (*) (

             Display*

            )

))(

    Display*

);
extern Atom XInternAtom(

    Display* ,
    const char* ,
    int

);
extern int XInternAtoms(

    Display* ,
    char** ,
    int ,
    int ,
    Atom*

);
extern Colormap XCopyColormapAndFree(

    Display* ,
    Colormap

);
extern Colormap XCreateColormap(

    Display* ,
    Window ,
    Visual* ,
    int

);
extern Cursor XCreatePixmapCursor(

    Display* ,
    Pixmap ,
    Pixmap ,
    XColor* ,
    XColor* ,
    unsigned int ,
    unsigned int

);
extern Cursor XCreateGlyphCursor(

    Display* ,
    Font ,
    Font ,
    unsigned int ,
    unsigned int ,
    XColor const * ,
    XColor const *

);
extern Cursor XCreateFontCursor(

    Display* ,
    unsigned int

);
extern Font XLoadFont(

    Display* ,
    const char*

);
extern GC XCreateGC(

    Display* ,
    Drawable ,
    unsigned long ,
    XGCValues*

);
extern GContext XGContextFromGC(

    GC

);
extern void XFlushGC(

    Display* ,
    GC

);
extern Pixmap XCreatePixmap(

    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int

);
extern Pixmap XCreateBitmapFromData(

    Display* ,
    Drawable ,
    const char* ,
    unsigned int ,
    unsigned int

);
extern Pixmap XCreatePixmapFromBitmapData(

    Display* ,
    Drawable ,
    char* ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    unsigned long ,
    unsigned int

);
extern Window XCreateSimpleWindow(

    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    unsigned long

);
extern Window XGetSelectionOwner(

    Display* ,
    Atom

);
extern Window XCreateWindow(

    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    int ,
    unsigned int ,
    Visual* ,
    unsigned long ,
    XSetWindowAttributes*

);
extern Colormap *XListInstalledColormaps(

    Display* ,
    Window ,
    int*

);
extern char **XListFonts(

    Display* ,
    const char* ,
    int ,
    int*

);
extern char **XListFontsWithInfo(

    Display* ,
    const char* ,
    int ,
    int* ,
    XFontStruct**

);
extern char **XGetFontPath(

    Display* ,
    int*

);
extern char **XListExtensions(

    Display* ,
    int*

);
extern Atom *XListProperties(

    Display* ,
    Window ,
    int*

);
extern XHostAddress *XListHosts(

    Display* ,
    int* ,
    int*

);
extern KeySym XKeycodeToKeysym(

    Display* ,

    unsigned int ,



    int

);
extern KeySym XLookupKeysym(

    XKeyEvent* ,
    int

);
extern KeySym *XGetKeyboardMapping(

    Display* ,

    unsigned int ,



    int ,
    int*

);
extern KeySym XStringToKeysym(

    const char*

);
extern long XMaxRequestSize(

    Display*

);
extern long XExtendedMaxRequestSize(

    Display*

);
extern char *XResourceManagerString(

    Display*

);
extern char *XScreenResourceString(

        Screen*

);
extern unsigned long XDisplayMotionBufferSize(

    Display*

);
extern VisualID XVisualIDFromVisual(

    Visual*

);



extern int XInitThreads(

    void

);

extern void XLockDisplay(

    Display*

);

extern void XUnlockDisplay(

    Display*

);



extern XExtCodes *XInitExtension(

    Display* ,
    const char*

);

extern XExtCodes *XAddExtension(

    Display*

);
extern XExtData *XFindOnExtensionList(

    XExtData** ,
    int

);
extern XExtData **XEHeadOfExtensionList(

    XEDataObject

);


extern Window XRootWindow(

    Display* ,
    int

);
extern Window XDefaultRootWindow(

    Display*

);
extern Window XRootWindowOfScreen(

    Screen*

);
extern Visual *XDefaultVisual(

    Display* ,
    int

);
extern Visual *XDefaultVisualOfScreen(

    Screen*

);
extern GC XDefaultGC(

    Display* ,
    int

);
extern GC XDefaultGCOfScreen(

    Screen*

);
extern unsigned long XBlackPixel(

    Display* ,
    int

);
extern unsigned long XWhitePixel(

    Display* ,
    int

);
extern unsigned long XAllPlanes(

    void

);
extern unsigned long XBlackPixelOfScreen(

    Screen*

);
extern unsigned long XWhitePixelOfScreen(

    Screen*

);
extern unsigned long XNextRequest(

    Display*

);
extern unsigned long XLastKnownRequestProcessed(

    Display*

);
extern char *XServerVendor(

    Display*

);
extern char *XDisplayString(

    Display*

);
extern Colormap XDefaultColormap(

    Display* ,
    int

);
extern Colormap XDefaultColormapOfScreen(

    Screen*

);
extern Display *XDisplayOfScreen(

    Screen*

);
extern Screen *XScreenOfDisplay(

    Display* ,
    int

);
extern Screen *XDefaultScreenOfDisplay(

    Display*

);
extern long XEventMaskOfScreen(

    Screen*

);

extern int XScreenNumberOfScreen(

    Screen*

);

typedef int (*XErrorHandler) (

    Display* ,
    XErrorEvent*

);

extern XErrorHandler XSetErrorHandler (

    XErrorHandler

);


typedef int (*XIOErrorHandler) (

    Display*

);

extern XIOErrorHandler XSetIOErrorHandler (

    XIOErrorHandler

);


extern XPixmapFormatValues *XListPixmapFormats(

    Display* ,
    int*

);
extern int *XListDepths(

    Display* ,
    int ,
    int*

);



extern int XReconfigureWMWindow(

    Display* ,
    Window ,
    int ,
    unsigned int ,
    XWindowChanges*

);

extern int XGetWMProtocols(

    Display* ,
    Window ,
    Atom** ,
    int*

);
extern int XSetWMProtocols(

    Display* ,
    Window ,
    Atom* ,
    int

);
extern int XIconifyWindow(

    Display* ,
    Window ,
    int

);
extern int XWithdrawWindow(

    Display* ,
    Window ,
    int

);
extern int XGetCommand(

    Display* ,
    Window ,
    char*** ,
    int*

);
extern int XGetWMColormapWindows(

    Display* ,
    Window ,
    Window** ,
    int*

);
extern int XSetWMColormapWindows(

    Display* ,
    Window ,
    Window* ,
    int

);
extern void XFreeStringList(

    char**

);
extern int XSetTransientForHint(

    Display* ,
    Window ,
    Window

);



extern int XActivateScreenSaver(

    Display*

);

extern int XAddHost(

    Display* ,
    XHostAddress*

);

extern int XAddHosts(

    Display* ,
    XHostAddress* ,
    int

);

extern int XAddToExtensionList(

    struct _XExtData** ,
    XExtData*

);

extern int XAddToSaveSet(

    Display* ,
    Window

);

extern int XAllocColor(

    Display* ,
    Colormap ,
    XColor*

);

extern int XAllocColorCells(

    Display* ,
    Colormap ,
    int ,
    unsigned long* ,
    unsigned int ,
    unsigned long* ,
    unsigned int

);

extern int XAllocColorPlanes(

    Display* ,
    Colormap ,
    int ,
    unsigned long* ,
    int ,
    int ,
    int ,
    int ,
    unsigned long* ,
    unsigned long* ,
    unsigned long*

);

extern int XAllocNamedColor(

    Display* ,
    Colormap ,
    const char* ,
    XColor* ,
    XColor*

);

extern int XAllowEvents(

    Display* ,
    int ,
    Time

);

extern int XAutoRepeatOff(

    Display*

);

extern int XAutoRepeatOn(

    Display*

);

extern int XBell(

    Display* ,
    int

);

extern int XBitmapBitOrder(

    Display*

);

extern int XBitmapPad(

    Display*

);

extern int XBitmapUnit(

    Display*

);

extern int XCellsOfScreen(

    Screen*

);

extern int XChangeActivePointerGrab(

    Display* ,
    unsigned int ,
    Cursor ,
    Time

);

extern int XChangeGC(

    Display* ,
    GC ,
    unsigned long ,
    XGCValues*

);

extern int XChangeKeyboardControl(

    Display* ,
    unsigned long ,
    XKeyboardControl*

);

extern int XChangeKeyboardMapping(

    Display* ,
    int ,
    int ,
    KeySym* ,
    int

);

extern int XChangePointerControl(

    Display* ,
    int ,
    int ,
    int ,
    int ,
    int

);

extern int XChangeProperty(

    Display* ,
    Window ,
    Atom ,
    Atom ,
    int ,
    int ,
    const unsigned char* ,
    int

);

extern int XChangeSaveSet(

    Display* ,
    Window ,
    int

);

extern int XChangeWindowAttributes(

    Display* ,
    Window ,
    unsigned long ,
    XSetWindowAttributes*

);

extern int XCheckIfEvent(

    Display* ,
    XEvent* ,
    int (*) (

               Display* ,
               XEvent* ,
               XPointer

             ) ,
    XPointer

);

extern int XCheckMaskEvent(

    Display* ,
    long ,
    XEvent*

);

extern int XCheckTypedEvent(

    Display* ,
    int ,
    XEvent*

);

extern int XCheckTypedWindowEvent(

    Display* ,
    Window ,
    int ,
    XEvent*

);

extern int XCheckWindowEvent(

    Display* ,
    Window ,
    long ,
    XEvent*

);

extern int XCirculateSubwindows(

    Display* ,
    Window ,
    int

);

extern int XCirculateSubwindowsDown(

    Display* ,
    Window

);

extern int XCirculateSubwindowsUp(

    Display* ,
    Window

);

extern int XClearArea(

    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int

);

extern int XClearWindow(

    Display* ,
    Window

);

extern int XCloseDisplay(

    Display*

);

extern int XConfigureWindow(

    Display* ,
    Window ,
    unsigned int ,
    XWindowChanges*

);

extern int XConnectionNumber(

    Display*

);

extern int XConvertSelection(

    Display* ,
    Atom ,
    Atom ,
    Atom ,
    Window ,
    Time

);

extern int XCopyArea(

    Display* ,
    Drawable ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int

);

extern int XCopyGC(

    Display* ,
    GC ,
    unsigned long ,
    GC

);

extern int XCopyPlane(

    Display* ,
    Drawable ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int ,
    unsigned long

);

extern int XDefaultDepth(

    Display* ,
    int

);

extern int XDefaultDepthOfScreen(

    Screen*

);

extern int XDefaultScreen(

    Display*

);

extern int XDefineCursor(

    Display* ,
    Window ,
    Cursor

);

extern int XDeleteProperty(

    Display* ,
    Window ,
    Atom

);

extern int XDestroyWindow(

    Display* ,
    Window

);

extern int XDestroySubwindows(

    Display* ,
    Window

);

extern int XDoesBackingStore(

    Screen*

);

extern int XDoesSaveUnders(

    Screen*

);

extern int XDisableAccessControl(

    Display*

);


extern int XDisplayCells(

    Display* ,
    int

);

extern int XDisplayHeight(

    Display* ,
    int

);

extern int XDisplayHeightMM(

    Display* ,
    int

);

extern int XDisplayKeycodes(

    Display* ,
    int* ,
    int*

);

extern int XDisplayPlanes(

    Display* ,
    int

);

extern int XDisplayWidth(

    Display* ,
    int

);

extern int XDisplayWidthMM(

    Display* ,
    int

);

extern int XDrawArc(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int

);

extern int XDrawArcs(

    Display* ,
    Drawable ,
    GC ,
    XArc* ,
    int

);

extern int XDrawImageString(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const char* ,
    int

);

extern int XDrawImageString16(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const XChar2b* ,
    int

);

extern int XDrawLine(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    int ,
    int

);

extern int XDrawLines(

    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int

);

extern int XDrawPoint(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int

);

extern int XDrawPoints(

    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int

);

extern int XDrawRectangle(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int

);

extern int XDrawRectangles(

    Display* ,
    Drawable ,
    GC ,
    XRectangle* ,
    int

);

extern int XDrawSegments(

    Display* ,
    Drawable ,
    GC ,
    XSegment* ,
    int

);

extern int XDrawString(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const char* ,
    int

);

extern int XDrawString16(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const XChar2b* ,
    int

);

extern int XDrawText(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XTextItem* ,
    int

);

extern int XDrawText16(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XTextItem16* ,
    int

);

extern int XEnableAccessControl(

    Display*

);

extern int XEventsQueued(

    Display* ,
    int

);

extern int XFetchName(

    Display* ,
    Window ,
    char**

);

extern int XFillArc(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int

);

extern int XFillArcs(

    Display* ,
    Drawable ,
    GC ,
    XArc* ,
    int

);

extern int XFillPolygon(

    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int ,
    int

);

extern int XFillRectangle(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int

);

extern int XFillRectangles(

    Display* ,
    Drawable ,
    GC ,
    XRectangle* ,
    int

);

extern int XFlush(

    Display*

);

extern int XForceScreenSaver(

    Display* ,
    int

);

extern int XFree(

    void*

);

extern int XFreeColormap(

    Display* ,
    Colormap

);

extern int XFreeColors(

    Display* ,
    Colormap ,
    unsigned long* ,
    int ,
    unsigned long

);

extern int XFreeCursor(

    Display* ,
    Cursor

);

extern int XFreeExtensionList(

    char**

);

extern int XFreeFont(

    Display* ,
    XFontStruct*

);

extern int XFreeFontInfo(

    char** ,
    XFontStruct* ,
    int

);

extern int XFreeFontNames(

    char**

);

extern int XFreeFontPath(

    char**

);

extern int XFreeGC(

    Display* ,
    GC

);

extern int XFreeModifiermap(

    XModifierKeymap*

);

extern int XFreePixmap(

    Display* ,
    Pixmap

);

extern int XGeometry(

    Display* ,
    int ,
    const char* ,
    const char* ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    int ,
    int ,
    int* ,
    int* ,
    int* ,
    int*

);

extern int XGetErrorDatabaseText(

    Display* ,
    const char* ,
    const char* ,
    const char* ,
    char* ,
    int

);

extern int XGetErrorText(

    Display* ,
    int ,
    char* ,
    int

);

extern int XGetFontProperty(

    XFontStruct* ,
    Atom ,
    unsigned long*

);

extern int XGetGCValues(

    Display* ,
    GC ,
    unsigned long ,
    XGCValues*

);

extern int XGetGeometry(

    Display* ,
    Drawable ,
    Window* ,
    int* ,
    int* ,
    unsigned int* ,
    unsigned int* ,
    unsigned int* ,
    unsigned int*

);

extern int XGetIconName(

    Display* ,
    Window ,
    char**

);

extern int XGetInputFocus(

    Display* ,
    Window* ,
    int*

);

extern int XGetKeyboardControl(

    Display* ,
    XKeyboardState*

);

extern int XGetPointerControl(

    Display* ,
    int* ,
    int* ,
    int*

);

extern int XGetPointerMapping(

    Display* ,
    unsigned char* ,
    int

);

extern int XGetScreenSaver(

    Display* ,
    int* ,
    int* ,
    int* ,
    int*

);

extern int XGetTransientForHint(

    Display* ,
    Window ,
    Window*

);

extern int XGetWindowProperty(

    Display* ,
    Window ,
    Atom ,
    long ,
    long ,
    int ,
    Atom ,
    Atom* ,
    int* ,
    unsigned long* ,
    unsigned long* ,
    unsigned char**

);

extern int XGetWindowAttributes(

    Display* ,
    Window ,
    XWindowAttributes*

);

extern int XGrabButton(

    Display* ,
    unsigned int ,
    unsigned int ,
    Window ,
    int ,
    unsigned int ,
    int ,
    int ,
    Window ,
    Cursor

);

extern int XGrabKey(

    Display* ,
    int ,
    unsigned int ,
    Window ,
    int ,
    int ,
    int

);

extern int XGrabKeyboard(

    Display* ,
    Window ,
    int ,
    int ,
    int ,
    Time

);

extern int XGrabPointer(

    Display* ,
    Window ,
    int ,
    unsigned int ,
    int ,
    int ,
    Window ,
    Cursor ,
    Time

);

extern int XGrabServer(

    Display*

);

extern int XHeightMMOfScreen(

    Screen*

);

extern int XHeightOfScreen(

    Screen*

);

extern int XIfEvent(

    Display* ,
    XEvent* ,
    int (*) (

               Display* ,
               XEvent* ,
               XPointer

             ) ,
    XPointer

);

extern int XImageByteOrder(

    Display*

);

extern int XInstallColormap(

    Display* ,
    Colormap

);

extern KeyCode XKeysymToKeycode(

    Display* ,
    KeySym

);

extern int XKillClient(

    Display* ,
    XID

);

extern int XLookupColor(

    Display* ,
    Colormap ,
    const char* ,
    XColor* ,
    XColor*

);

extern int XLowerWindow(

    Display* ,
    Window

);

extern int XMapRaised(

    Display* ,
    Window

);

extern int XMapSubwindows(

    Display* ,
    Window

);

extern int XMapWindow(

    Display* ,
    Window

);

extern int XMaskEvent(

    Display* ,
    long ,
    XEvent*

);

extern int XMaxCmapsOfScreen(

    Screen*

);

extern int XMinCmapsOfScreen(

    Screen*

);

extern int XMoveResizeWindow(

    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int

);

extern int XMoveWindow(

    Display* ,
    Window ,
    int ,
    int

);

extern int XNextEvent(

    Display* ,
    XEvent*

);

extern int XNoOp(

    Display*

);

extern int XParseColor(

    Display* ,
    Colormap ,
    const char* ,
    XColor*

);

extern int XParseGeometry(

    const char* ,
    int* ,
    int* ,
    unsigned int* ,
    unsigned int*

);

extern int XPeekEvent(

    Display* ,
    XEvent*

);

extern int XPeekIfEvent(

    Display* ,
    XEvent* ,
    int (*) (

               Display* ,
               XEvent* ,
               XPointer

             ) ,
    XPointer

);

extern int XPending(

    Display*

);

extern int XPlanesOfScreen(

    Screen*


);

extern int XProtocolRevision(

    Display*

);

extern int XProtocolVersion(

    Display*

);


extern int XPutBackEvent(

    Display* ,
    XEvent*

);

extern int XPutImage(

    Display* ,
    Drawable ,
    GC ,
    XImage* ,
    int ,
    int ,
    int ,
    int ,
    unsigned int ,
    unsigned int

);

extern int XQLength(

    Display*

);

extern int XQueryBestCursor(

    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*

);

extern int XQueryBestSize(

    Display* ,
    int ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*

);

extern int XQueryBestStipple(

    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*

);

extern int XQueryBestTile(

    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*

);

extern int XQueryColor(

    Display* ,
    Colormap ,
    XColor*

);

extern int XQueryColors(

    Display* ,
    Colormap ,
    XColor* ,
    int

);

extern int XQueryExtension(

    Display* ,
    const char* ,
    int* ,
    int* ,
    int*

);

extern int XQueryKeymap(

    Display* ,
    char [32]

);

extern int XQueryPointer(

    Display* ,
    Window ,
    Window* ,
    Window* ,
    int* ,
    int* ,
    int* ,
    int* ,
    unsigned int*

);

extern int XQueryTextExtents(

    Display* ,
    XID ,
    const char* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*

);

extern int XQueryTextExtents16(

    Display* ,
    XID ,
    const XChar2b* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*

);

extern int XQueryTree(

    Display* ,
    Window ,
    Window* ,
    Window* ,
    Window** ,
    unsigned int*

);

extern int XRaiseWindow(

    Display* ,
    Window

);

extern int XReadBitmapFile(

    Display* ,
    Drawable ,
    const char* ,
    unsigned int* ,
    unsigned int* ,
    Pixmap* ,
    int* ,
    int*

);

extern int XReadBitmapFileData(

    const char* ,
    unsigned int* ,
    unsigned int* ,
    unsigned char** ,
    int* ,
    int*

);

extern int XRebindKeysym(

    Display* ,
    KeySym ,
    KeySym* ,
    int ,
    const unsigned char* ,
    int

);

extern int XRecolorCursor(

    Display* ,
    Cursor ,
    XColor* ,
    XColor*

);

extern int XRefreshKeyboardMapping(

    XMappingEvent*

);

extern int XRemoveFromSaveSet(

    Display* ,
    Window

);

extern int XRemoveHost(

    Display* ,
    XHostAddress*

);

extern int XRemoveHosts(

    Display* ,
    XHostAddress* ,
    int

);

extern int XReparentWindow(

    Display* ,
    Window ,
    Window ,
    int ,
    int

);

extern int XResetScreenSaver(

    Display*

);

extern int XResizeWindow(

    Display* ,
    Window ,
    unsigned int ,
    unsigned int

);

extern int XRestackWindows(

    Display* ,
    Window* ,
    int

);

extern int XRotateBuffers(

    Display* ,
    int

);

extern int XRotateWindowProperties(

    Display* ,
    Window ,
    Atom* ,
    int ,
    int

);

extern int XScreenCount(

    Display*

);

extern int XSelectInput(

    Display* ,
    Window ,
    long

);

extern int XSendEvent(

    Display* ,
    Window ,
    int ,
    long ,
    XEvent*

);

extern int XSetAccessControl(

    Display* ,
    int

);

extern int XSetArcMode(

    Display* ,
    GC ,
    int

);

extern int XSetBackground(

    Display* ,
    GC ,
    unsigned long

);

extern int XSetClipMask(

    Display* ,
    GC ,
    Pixmap

);

extern int XSetClipOrigin(

    Display* ,
    GC ,
    int ,
    int

);

extern int XSetClipRectangles(

    Display* ,
    GC ,
    int ,
    int ,
    XRectangle* ,
    int ,
    int

);

extern int XSetCloseDownMode(

    Display* ,
    int

);

extern int XSetCommand(

    Display* ,
    Window ,
    char** ,
    int

);

extern int XSetDashes(

    Display* ,
    GC ,
    int ,
    const char* ,
    int

);

extern int XSetFillRule(

    Display* ,
    GC ,
    int

);

extern int XSetFillStyle(

    Display* ,
    GC ,
    int

);

extern int XSetFont(

    Display* ,
    GC ,
    Font

);

extern int XSetFontPath(

    Display* ,
    char** ,
    int

);

extern int XSetForeground(

    Display* ,
    GC ,
    unsigned long

);

extern int XSetFunction(

    Display* ,
    GC ,
    int

);

extern int XSetGraphicsExposures(

    Display* ,
    GC ,
    int

);

extern int XSetIconName(

    Display* ,
    Window ,
    const char*

);

extern int XSetInputFocus(

    Display* ,
    Window ,
    int ,
    Time

);

extern int XSetLineAttributes(

    Display* ,
    GC ,
    unsigned int ,
    int ,
    int ,
    int

);

extern int XSetModifierMapping(

    Display* ,
    XModifierKeymap*

);

extern int XSetPlaneMask(

    Display* ,
    GC ,
    unsigned long

);

extern int XSetPointerMapping(

    Display* ,
    const unsigned char* ,
    int

);

extern int XSetScreenSaver(

    Display* ,
    int ,
    int ,
    int ,
    int

);

extern int XSetSelectionOwner(

    Display* ,
    Atom ,
    Window ,
    Time

);

extern int XSetState(

    Display* ,
    GC ,
    unsigned long ,
    unsigned long ,
    int ,
    unsigned long

);

extern int XSetStipple(

    Display* ,
    GC ,
    Pixmap

);

extern int XSetSubwindowMode(

    Display* ,
    GC ,
    int

);

extern int XSetTSOrigin(

    Display* ,
    GC ,
    int ,
    int

);

extern int XSetTile(

    Display* ,
    GC ,
    Pixmap

);

extern int XSetWindowBackground(

    Display* ,
    Window ,
    unsigned long

);

extern int XSetWindowBackgroundPixmap(

    Display* ,
    Window ,
    Pixmap

);

extern int XSetWindowBorder(

    Display* ,
    Window ,
    unsigned long

);

extern int XSetWindowBorderPixmap(

    Display* ,
    Window ,
    Pixmap

);

extern int XSetWindowBorderWidth(

    Display* ,
    Window ,
    unsigned int

);

extern int XSetWindowColormap(

    Display* ,
    Window ,
    Colormap

);

extern int XStoreBuffer(

    Display* ,
    const char* ,
    int ,
    int

);

extern int XStoreBytes(

    Display* ,
    const char* ,
    int

);

extern int XStoreColor(

    Display* ,
    Colormap ,
    XColor*

);

extern int XStoreColors(

    Display* ,
    Colormap ,
    XColor* ,
    int

);

extern int XStoreName(

    Display* ,
    Window ,
    const char*

);

extern int XStoreNamedColor(

    Display* ,
    Colormap ,
    const char* ,
    unsigned long ,
    int

);

extern int XSync(

    Display* ,
    int

);

extern int XTextExtents(

    XFontStruct* ,
    const char* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*

);

extern int XTextExtents16(

    XFontStruct* ,
    const XChar2b* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*

);

extern int XTextWidth(

    XFontStruct* ,
    const char* ,
    int

);

extern int XTextWidth16(

    XFontStruct* ,
    const XChar2b* ,
    int

);

extern int XTranslateCoordinates(

    Display* ,
    Window ,
    Window ,
    int ,
    int ,
    int* ,
    int* ,
    Window*

);

extern int XUndefineCursor(

    Display* ,
    Window

);

extern int XUngrabButton(

    Display* ,
    unsigned int ,
    unsigned int ,
    Window

);

extern int XUngrabKey(

    Display* ,
    int ,
    unsigned int ,
    Window

);

extern int XUngrabKeyboard(

    Display* ,
    Time

);

extern int XUngrabPointer(

    Display* ,
    Time

);

extern int XUngrabServer(

    Display*

);

extern int XUninstallColormap(

    Display* ,
    Colormap

);

extern int XUnloadFont(

    Display* ,
    Font

);

extern int XUnmapSubwindows(

    Display* ,
    Window

);

extern int XUnmapWindow(

    Display* ,
    Window

);

extern int XVendorRelease(

    Display*

);

extern int XWarpPointer(

    Display* ,
    Window ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int

);

extern int XWidthMMOfScreen(

    Screen*

);

extern int XWidthOfScreen(

    Screen*

);

extern int XWindowEvent(

    Display* ,
    Window ,
    long ,
    XEvent*

);

extern int XWriteBitmapFile(

    Display* ,
    const char* ,
    Pixmap ,
    unsigned int ,
    unsigned int ,
    int ,
    int

);

extern int XSupportsLocale (void);

extern char *XSetLocaleModifiers(
    const char*
);

extern XOM XOpenOM(

    Display* ,
    struct _XrmHashBucketRec* ,
    const char* ,
    const char*

);

extern int XCloseOM(

    XOM

);

extern char *XSetOMValues(

    XOM ,
    ...

);

extern char *XGetOMValues(

    XOM ,
    ...

);

extern Display *XDisplayOfOM(

    XOM

);

extern char *XLocaleOfOM(

    XOM

);

extern XOC XCreateOC(

    XOM ,
    ...

);

extern void XDestroyOC(

    XOC

);

extern XOM XOMOfOC(

    XOC

);

extern char *XSetOCValues(

    XOC ,
    ...

);

extern char *XGetOCValues(

    XOC ,
    ...

);

extern XFontSet XCreateFontSet(

    Display* ,
    const char* ,
    char*** ,
    int* ,
    char**

);

extern void XFreeFontSet(

    Display* ,
    XFontSet

);

extern int XFontsOfFontSet(

    XFontSet ,
    XFontStruct*** ,
    char***

);

extern char *XBaseFontNameListOfFontSet(

    XFontSet

);

extern char *XLocaleOfFontSet(

    XFontSet

);

extern int XContextDependentDrawing(

    XFontSet

);

extern int XDirectionalDependentDrawing(

    XFontSet

);

extern int XContextualDrawing(

    XFontSet

);

extern XFontSetExtents *XExtentsOfFontSet(

    XFontSet

);

extern int XmbTextEscapement(

    XFontSet ,
    const char* ,
    int

);

extern int XwcTextEscapement(

    XFontSet ,
    const wchar_t* ,
    int

);

extern int Xutf8TextEscapement(

    XFontSet ,
    const char* ,
    int

);

extern int XmbTextExtents(

    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle*

);

extern int XwcTextExtents(

    XFontSet ,
    const wchar_t* ,
    int ,
    XRectangle* ,
    XRectangle*

);

extern int Xutf8TextExtents(

    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle*

);

extern int XmbTextPerCharExtents(

    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*

);

extern int XwcTextPerCharExtents(

    XFontSet ,
    const wchar_t* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*

);

extern int Xutf8TextPerCharExtents(

    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*

);

extern void XmbDrawText(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XmbTextItem* ,
    int

);

extern void XwcDrawText(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XwcTextItem* ,
    int

);

extern void Xutf8DrawText(

    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XmbTextItem* ,
    int

);

extern void XmbDrawString(

    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int

);

extern void XwcDrawString(

    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const wchar_t* ,
    int

);

extern void Xutf8DrawString(

    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int

);

extern void XmbDrawImageString(

    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int

);

extern void XwcDrawImageString(

    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const wchar_t* ,
    int

);

extern void Xutf8DrawImageString(

    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int

);

extern XIM XOpenIM(

    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char*

);

extern int XCloseIM(

    XIM

);

extern char *XGetIMValues(

    XIM , ...

);

extern char *XSetIMValues(

    XIM , ...

);

extern Display *XDisplayOfIM(

    XIM

);

extern char *XLocaleOfIM(

    XIM

);

extern XIC XCreateIC(

    XIM , ...

);

extern void XDestroyIC(

    XIC

);

extern void XSetICFocus(

    XIC

);

extern void XUnsetICFocus(

    XIC

);

extern wchar_t *XwcResetIC(

    XIC

);

extern char *XmbResetIC(

    XIC

);

extern char *Xutf8ResetIC(

    XIC

);

extern char *XSetICValues(

    XIC , ...

);

extern char *XGetICValues(

    XIC , ...

);

extern XIM XIMOfIC(

    XIC

);

extern int XFilterEvent(

    XEvent* ,
    Window

);

extern int XmbLookupString(

    XIC ,
    XKeyPressedEvent* ,
    char* ,
    int ,
    KeySym* ,
    int*

);

extern int XwcLookupString(

    XIC ,
    XKeyPressedEvent* ,
    wchar_t* ,
    int ,
    KeySym* ,
    int*

);

extern int Xutf8LookupString(

    XIC ,
    XKeyPressedEvent* ,
    char* ,
    int ,
    KeySym* ,
    int*

);

extern XVaNestedList XVaCreateNestedList(

    int , ...

);



extern int XRegisterIMInstantiateCallback(

    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char* ,
    XIDProc ,
    XPointer

);

extern int XUnregisterIMInstantiateCallback(

    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char* ,
    XIDProc ,
    XPointer

);

typedef void (*XConnectionWatchProc)(

    Display* ,
    XPointer ,
    int ,
    int ,
    XPointer*

);


extern int XInternalConnectionNumbers(

    Display* ,
    int** ,
    int*

);

extern void XProcessInternalConnection(

    Display* ,
    int

);

extern int XAddConnectionWatch(

    Display* ,
    XConnectionWatchProc ,
    XPointer

);

extern void XRemoveConnectionWatch(

    Display* ,
    XConnectionWatchProc ,
    XPointer

);

extern void XSetAuthorization(

    char * ,
    int ,
    char * ,
    int

);

extern int _Xmbtowc(

    wchar_t * ,




    char * ,
    int


);

extern int _Xwctomb(

    char * ,
    wchar_t

);

}
# 34 "/coolo/prod/kdelibs/kdecore/netwm.h" 2
# 1 "/usr/X11R6/include/X11/Xutil.h" 1
# 52 "/usr/X11R6/include/X11/Xutil.h"
# 61 "/usr/X11R6/include/X11/Xutil.h"





typedef struct {
        long flags;
        int x, y;
        int width, height;
        int min_width, min_height;
        int max_width, max_height;
        int width_inc, height_inc;
        struct {
                int x;
                int y;
        } min_aspect, max_aspect;
        int base_width, base_height;
        int win_gravity;
} XSizeHints;













typedef struct {
        long flags;
        int input;

        int initial_state;
        Pixmap icon_pixmap;
        Window icon_window;
        int icon_x, icon_y;
        Pixmap icon_mask;
        XID window_group;

} XWMHints;

















typedef struct {
    unsigned char *value;
    Atom encoding;
    int format;
    unsigned long nitems;
} XTextProperty;


typedef enum {
    XStringStyle,
    XCompoundTextStyle,
    XTextStyle,
    XStdICCTextStyle,

    XUTF8StringStyle
} XICCEncodingStyle;

typedef struct {
        int min_width, min_height;
        int max_width, max_height;
        int width_inc, height_inc;
} XIconSize;

typedef struct {
        char *res_name;
        char *res_class;
} XClassHint;














typedef struct _XComposeStatus {
    XPointer compose_ptr;
    int chars_matched;
} XComposeStatus;
















# 240 "/usr/X11R6/include/X11/Xutil.h"
typedef struct _XRegion *Region;










typedef struct {
  Visual *visual;
  VisualID visualid;
  int screen;
  int depth;

  int c_class;



  unsigned long red_mask;
  unsigned long green_mask;
  unsigned long blue_mask;
  int colormap_size;
  int bits_per_rgb;
} XVisualInfo;






typedef struct {
        Colormap colormap;
        unsigned long red_max;
        unsigned long red_mult;
        unsigned long green_max;
        unsigned long green_mult;
        unsigned long blue_max;
        unsigned long blue_mult;
        unsigned long base_pixel;
        VisualID visualid;
        XID killid;
} XStandardColormap;






# 320 "/usr/X11R6/include/X11/Xutil.h"

typedef int XContext;


extern "C" {



extern XClassHint *XAllocClassHint (

    void

);

extern XIconSize *XAllocIconSize (

    void

);

extern XSizeHints *XAllocSizeHints (

    void

);

extern XStandardColormap *XAllocStandardColormap (

    void

);

extern XWMHints *XAllocWMHints (

    void

);

extern int XClipBox(

    Region ,
    XRectangle*

);

extern Region XCreateRegion(

    void

);

extern const char *XDefaultString (void);

extern int XDeleteContext(

    Display* ,
    XID ,
    XContext

);

extern int XDestroyRegion(

    Region

);

extern int XEmptyRegion(

    Region

);

extern int XEqualRegion(

    Region ,
    Region

);

extern int XFindContext(

    Display* ,
    XID ,
    XContext ,
    XPointer*

);

extern int XGetClassHint(

    Display* ,
    Window ,
    XClassHint*

);

extern int XGetIconSizes(

    Display* ,
    Window ,
    XIconSize** ,
    int*

);

extern int XGetNormalHints(

    Display* ,
    Window ,
    XSizeHints*

);

extern int XGetRGBColormaps(

    Display* ,
    Window ,
    XStandardColormap** ,
    int* ,
    Atom

);

extern int XGetSizeHints(

    Display* ,
    Window ,
    XSizeHints* ,
    Atom

);

extern int XGetStandardColormap(

    Display* ,
    Window ,
    XStandardColormap* ,
    Atom

);

extern int XGetTextProperty(

    Display* ,
    Window ,
    XTextProperty* ,
    Atom

);

extern XVisualInfo *XGetVisualInfo(

    Display* ,
    long ,
    XVisualInfo* ,
    int*

);

extern int XGetWMClientMachine(

    Display* ,
    Window ,
    XTextProperty*

);

extern XWMHints *XGetWMHints(

    Display* ,
    Window

);

extern int XGetWMIconName(

    Display* ,
    Window ,
    XTextProperty*

);

extern int XGetWMName(

    Display* ,
    Window ,
    XTextProperty*

);

extern int XGetWMNormalHints(

    Display* ,
    Window ,
    XSizeHints* ,
    long*

);

extern int XGetWMSizeHints(

    Display* ,
    Window ,
    XSizeHints* ,
    long* ,
    Atom

);

extern int XGetZoomHints(

    Display* ,
    Window ,
    XSizeHints*

);

extern int XIntersectRegion(

    Region ,
    Region ,
    Region

);

extern void XConvertCase(

    KeySym ,
    KeySym* ,
    KeySym*

);

extern int XLookupString(

    XKeyEvent* ,
    char* ,
    int ,
    KeySym* ,
    XComposeStatus*

);

extern int XMatchVisualInfo(

    Display* ,
    int ,
    int ,
    int ,
    XVisualInfo*

);

extern int XOffsetRegion(

    Region ,
    int ,
    int

);

extern int XPointInRegion(

    Region ,
    int ,
    int

);

extern Region XPolygonRegion(

    XPoint* ,
    int ,
    int

);

extern int XRectInRegion(

    Region ,
    int ,
    int ,
    unsigned int ,
    unsigned int

);

extern int XSaveContext(

    Display* ,
    XID ,
    XContext ,
    const char*

);

extern int XSetClassHint(

    Display* ,
    Window ,
    XClassHint*

);

extern int XSetIconSizes(

    Display* ,
    Window ,
    XIconSize* ,
    int

);

extern int XSetNormalHints(

    Display* ,
    Window ,
    XSizeHints*

);

extern void XSetRGBColormaps(

    Display* ,
    Window ,
    XStandardColormap* ,
    int ,
    Atom

);

extern int XSetSizeHints(

    Display* ,
    Window ,
    XSizeHints* ,
    Atom

);

extern int XSetStandardProperties(

    Display* ,
    Window ,
    const char* ,
    const char* ,
    Pixmap ,
    char** ,
    int ,
    XSizeHints*

);

extern void XSetTextProperty(

    Display* ,
    Window ,
    XTextProperty* ,
    Atom

);

extern void XSetWMClientMachine(

    Display* ,
    Window ,
    XTextProperty*

);

extern int XSetWMHints(

    Display* ,
    Window ,
    XWMHints*

);

extern void XSetWMIconName(

    Display* ,
    Window ,
    XTextProperty*

);

extern void XSetWMName(

    Display* ,
    Window ,
    XTextProperty*

);

extern void XSetWMNormalHints(

    Display* ,
    Window ,
    XSizeHints*

);

extern void XSetWMProperties(

    Display* ,
    Window ,
    XTextProperty* ,
    XTextProperty* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*

);

extern void XmbSetWMProperties(

    Display* ,
    Window ,
    const char* ,
    const char* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*

);

extern void Xutf8SetWMProperties(

    Display* ,
    Window ,
    const char* ,
    const char* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*

);

extern void XSetWMSizeHints(

    Display* ,
    Window ,
    XSizeHints* ,
    Atom

);

extern int XSetRegion(

    Display* ,
    GC ,
    Region

);

extern void XSetStandardColormap(

    Display* ,
    Window ,
    XStandardColormap* ,
    Atom

);

extern int XSetZoomHints(

    Display* ,
    Window ,
    XSizeHints*

);

extern int XShrinkRegion(

    Region ,
    int ,
    int

);

extern int XStringListToTextProperty(

    char** ,
    int ,
    XTextProperty*

);

extern int XSubtractRegion(

    Region ,
    Region ,
    Region

);

extern int XmbTextListToTextProperty(
    Display* display,
    char** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern int XwcTextListToTextProperty(
    Display* display,
    wchar_t** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern int Xutf8TextListToTextProperty(
    Display* display,
    char** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern void XwcFreeStringList(
    wchar_t** list
);

extern int XTextPropertyToStringList(

    XTextProperty* ,
    char*** ,
    int*

);

extern int XmbTextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    char*** list_return,
    int* count_return
);

extern int XwcTextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    wchar_t*** list_return,
    int* count_return
);

extern int Xutf8TextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    char*** list_return,
    int* count_return
);

extern int XUnionRectWithRegion(

    XRectangle* ,
    Region ,
    Region

);

extern int XUnionRegion(

    Region ,
    Region ,
    Region

);

extern int XWMGeometry(

    Display* ,
    int ,
    const char* ,
    const char* ,
    unsigned int ,
    XSizeHints* ,
    int* ,
    int* ,
    int* ,
    int* ,
    int*

);

extern int XXorRegion(

    Region ,
    Region ,
    Region

);

}
# 35 "/coolo/prod/kdelibs/kdecore/netwm.h" 2
# 1 "/usr/X11R6/include/X11/Xatom.h" 1








# 36 "/coolo/prod/kdelibs/kdecore/netwm.h" 2




struct NETRootInfoPrivate;
struct NETWinInfoPrivate;
# 57 "/coolo/prod/kdelibs/kdecore/netwm.h"
class NETRootInfo : public NET {
public:




    enum { PROTOCOLS, WINDOW_TYPES, STATES, PROTOCOLS2, ACTIONS,
        PROPERTIES_SIZE };
# 99 "/coolo/prod/kdelibs/kdecore/netwm.h"
    NETRootInfo(Display *display, Window supportWindow, const char *wmName,
                const unsigned long properties[], int properties_size,
                int screen = -1, bool doActivate = true);







    NETRootInfo(Display *display, Window supportWindow, const char *wmName,
                unsigned long properties, int screen = -1, bool doActivate = true) ;
# 134 "/coolo/prod/kdelibs/kdecore/netwm.h"
    NETRootInfo(Display *display, const unsigned long properties[], int properties_size,
                int screen = -1, bool doActivate = true);







    NETRootInfo(Display *display, unsigned long properties, int screen = -1,
                bool doActivate = true) ;






    NETRootInfo(const NETRootInfo &rootinfo);




    virtual ~NETRootInfo();






    Display *x11Display() const;






    Window rootWindow() const;






    Window supportWindow() const;






    const char *wmName() const;






    int screenNumber() const;







    bool isSupported( NET::Property property ) const;




    bool isSupported( NET::Property2 property ) const;




    bool isSupported( NET::WindowType type ) const;




    bool isSupported( NET::State state ) const;





    bool isSupported( NET::Action action ) const;
# 233 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const unsigned long* supportedProperties() const;
# 242 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const unsigned long* passedProperties() const;
# 259 "/coolo/prod/kdelibs/kdecore/netwm.h"
    unsigned long supported() const ;
# 268 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const Window *clientList() const;
# 277 "/coolo/prod/kdelibs/kdecore/netwm.h"
    int clientListCount() const;
# 287 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const Window *clientListStacking() const;
# 296 "/coolo/prod/kdelibs/kdecore/netwm.h"
    int clientListStackingCount() const;
# 305 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const Window *kdeSystemTrayWindows() const;
# 314 "/coolo/prod/kdelibs/kdecore/netwm.h"
    int kdeSystemTrayWindowsCount() const;
# 326 "/coolo/prod/kdelibs/kdecore/netwm.h"
    NETSize desktopGeometry(int desktop) const;
# 335 "/coolo/prod/kdelibs/kdecore/netwm.h"
    NETPoint desktopViewport(int desktop) const;
# 344 "/coolo/prod/kdelibs/kdecore/netwm.h"
    NETRect workArea(int desktop) const;
# 353 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const char *desktopName(int desktop) const;
# 362 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const Window *virtualRoots( ) const;
# 371 "/coolo/prod/kdelibs/kdecore/netwm.h"
    int virtualRootsCount() const;






    int numberOfDesktops() const;






    int currentDesktop() const;






    Window activeWindow() const;
# 402 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void activate();
# 412 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setClientList(Window *windows, unsigned int count);
# 422 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setClientListStacking(Window *windows, unsigned int count);
# 431 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setKDESystemTrayWindows(Window *windows, unsigned int count);






    void setCurrentDesktop(int desktop);
# 450 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setDesktopGeometry(int desktop, const NETSize &geometry);
# 459 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setDesktopViewport(int desktop, const NETPoint &viewport);






    void setNumberOfDesktops(int numberOfDesktops);
# 475 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setDesktopName(int desktop, const char *desktopName);
# 488 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setActiveWindow(Window window, NET::RequestSource src,
        Time timestamp );







    void setActiveWindow(Window window);
# 506 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setWorkArea(int desktop, const NETRect &workArea);
# 515 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setVirtualRoots(Window *windows, unsigned int count);





    const NETRootInfo &operator=(const NETRootInfo &rootinfo);
# 530 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void closeWindowRequest(Window window);
# 546 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void moveResizeRequest(Window window, int x_root, int y_root,
                           Direction direction);
# 563 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void event( XEvent* event, unsigned long* properties, int properties_size );
# 575 "/coolo/prod/kdelibs/kdecore/netwm.h"
    unsigned long event(XEvent *event) ;


protected:







    virtual void addClient(Window) { }
# 595 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void removeClient(Window) { }
# 605 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void addSystemTrayWin(Window) { }
# 615 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void removeSystemTrayWin(Window) { }
# 625 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void changeNumberOfDesktops(int) { }
# 637 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void changeDesktopGeometry(int, const NETSize &) { }
# 649 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void changeDesktopViewport(int, const NETPoint &) { }
# 659 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void changeCurrentDesktop(int) { }
# 671 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual  void changeActiveWindow(Window) { }
# 680 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void closeWindow(Window) { }
# 697 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void moveResize(Window, int, int, unsigned long) { }


private:
    void update( const unsigned long[] );
    void setSupported();
    void setDefaultProperties();
    void updateSupportedProperties( Atom atom );
    Role role;

protected:
    virtual void virtual_hook( int id, void* data );
private:
    NETRootInfoPrivate *p;
    friend class NETRootInfo2;
};

class NETRootInfo2
    : public NETRootInfo
{
public:
    NETRootInfo2(Display *display, Window supportWindow, const char *wmName,
                unsigned long properties[], int properties_size,
                int screen = -1, bool doActivate = true);
    void sendPing( Window window, Time timestamp );
protected:
    friend class NETRootInfo;
    virtual void gotPing( Window, Time ) {};
# 735 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void changeActiveWindow(Window,NET::RequestSource,Time) { }


};
# 754 "/coolo/prod/kdelibs/kdecore/netwm.h"
class NETWinInfo : public NET {
public:




    enum { PROTOCOLS, PROTOCOLS2,
        PROPERTIES_SIZE };
# 784 "/coolo/prod/kdelibs/kdecore/netwm.h"
    NETWinInfo(Display *display, Window window, Window rootWindow,
               const unsigned long properties[], int properties_size,
               Role role = Client);







    NETWinInfo(Display *display, Window window,
               Window rootWindow, unsigned long properties,
               Role role = Client);






    NETWinInfo(const NETWinInfo & wininfo);




    virtual ~NETWinInfo();





    const NETWinInfo &operator=(const NETWinInfo &wintinfo);
# 823 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const unsigned long* passedProperties() const;
# 834 "/coolo/prod/kdelibs/kdecore/netwm.h"
    unsigned long properties() const ;






    NETRect iconGeometry() const;







    unsigned long state() const;






    NETStrut strut() const;
# 871 "/coolo/prod/kdelibs/kdecore/netwm.h"
    WindowType windowType( unsigned long supported_types ) const;
# 880 "/coolo/prod/kdelibs/kdecore/netwm.h"
    WindowType windowType() const ;






    const char *name() const;






    const char *visibleName() const;
# 905 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const char *iconName() const;
# 916 "/coolo/prod/kdelibs/kdecore/netwm.h"
    const char *visibleIconName() const;
# 925 "/coolo/prod/kdelibs/kdecore/netwm.h"
    int desktop() const;






    int pid() const;






    int handledIcons() const;







    Window kdeSystemTrayWinFor() const;







    MappingState mappingState() const;
# 966 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setIcon(NETIcon icon, int replace = 1);






    void setIconGeometry(NETRect geometry);






    void setStrut(NETStrut strut);
# 992 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setState(unsigned long state, unsigned long mask);







    void setWindowType(WindowType type);






    void setName(const char *name);







    void setVisibleName(const char *visibleName);






    void setIconName(const char *name);







    void setVisibleIconName(const char *name);
# 1039 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setDesktop(int desktop);






    void setPid(int pid);






    void setHandledIcons(int handled);






    void setKDESystemTrayWinFor(Window window);







    void setKDEFrameStrut(NETStrut strut);
# 1081 "/coolo/prod/kdelibs/kdecore/netwm.h"
    NETIcon icon(int width = -1, int height = -1) const;
# 1090 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void setUserTime( Time time );




    Time userTime() const;




    void setStartupId( const char* startup_id );




    const char* startupId() const;




    void setAllowedActions( unsigned long actions );




    unsigned long allowedActions() const;





    Window transientFor() const;




    Window groupLeader() const;
# 1136 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void kdeGeometry(NETRect &frame, NETRect &window);
# 1152 "/coolo/prod/kdelibs/kdecore/netwm.h"
    void event( XEvent* event, unsigned long* properties, int properties_size );
# 1164 "/coolo/prod/kdelibs/kdecore/netwm.h"
    unsigned long event(XEvent *event) ;







    static const int OnAllDesktops;


protected:
# 1184 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void changeDesktop(int) { }
# 1195 "/coolo/prod/kdelibs/kdecore/netwm.h"
    virtual void changeState(unsigned long , unsigned long ) { }

private:
    void update( const unsigned long[] );
    void updateWMState();
    Role role;

protected:
    virtual void virtual_hook( int id, void* data );
private:
    NETWinInfoPrivate *p;
};
# 104 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/kprocctrl.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kprocctrl.h"



# 1 "/coolo/prod/kdelibs/kdecore/kprocess.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kprocess.h"
# 32 "/coolo/prod/kdelibs/kdecore/kprocess.h"
class QSocketNotifier;
class KProcessPrivate;
class KPty;
# 124 "/coolo/prod/kdelibs/kdecore/kprocess.h"
class KProcess : public QObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
# 142 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  enum Communication {
       NoCommunication = 0,
       Stdin = 1, Stdout = 2, Stderr = 4,
       AllOutput = 6, All = 7,
       NoRead
  };




  enum RunMode {




       DontCare,



       NotifyOnExit,



       Block,




       OwnGroup
  };





  KProcess( QObject* parent, const char *name = 0 );




  KProcess();
# 192 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  virtual ~KProcess();
# 205 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  bool setExecutable(const QString& proc) ;
# 221 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  KProcess &operator<<(const QString& arg);



  KProcess &operator<<(const char * arg);





  KProcess &operator<<(const QCString & arg);







  KProcess &operator<<(const QStringList& args);





  void clearArguments();
# 273 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  virtual bool start(RunMode runmode = NotifyOnExit,
        Communication comm = NoCommunication);







  virtual bool kill(int signo = 15);





  bool isRunning() const;
# 300 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  pid_t pid() const;





  __attribute__ ((deprecated)) pid_t getPid() const { return pid(); }




  void suspend();




  void resume();
# 326 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  bool wait(int timeout = -1);







  bool normalExit() const;







  int exitStatus() const;
# 372 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  bool writeStdin(const char *buffer, int buflen);







  bool closeStdin();
# 389 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  bool closeStdout();
# 398 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  bool closeStderr();
# 408 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  bool closePty();




  void closeAll();





  const QValueList<QCString> &args() { return arguments; }
# 430 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  void setRunPrivileged(bool keepPrivileges);






  bool runPrivileged() const;







  void setEnvironment(const QString &name, const QString &value);







  void setWorkingDirectory(const QString &dir);
# 471 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  void setUseShell(bool useShell, const char *shell = 0);
# 482 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  static QString quote(const QString &arg);
# 491 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  void detach();
# 504 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  void setUsePty(Communication comm, bool addUtmp);
# 514 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  KPty *pty() const;




  enum { PrioLowest = 20, PrioLow = 10, PrioLower = 5, PrioNormal = 0,
    PrioHigher = -5, PrioHigh = -10, PrioHighest = -19 };







  bool setPriority(int prio);

protected:






  void processExited(KProcess *proc);
# 558 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  void receivedStdout(KProcess *proc, char *buffer, int buflen);
# 578 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  void receivedStdout(int fd, int &len);
# 595 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  void receivedStderr(KProcess *proc, char *buffer, int buflen);







  void wroteStdin(KProcess *proc);


protected :






  void slotChildOutput(int fdno);






  void slotChildError(int fdno);







  void slotSendData(int dummy);

protected:





  void setupEnvironment();





  QValueList<QCString> arguments;




  RunMode run_mode;






  bool runs;
# 663 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  pid_t pid_;
# 672 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  int status;







  bool keepPrivs;
# 694 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  virtual int setupCommunication(Communication comm);
# 708 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  virtual int commSetupDoneP();






  virtual int commSetupDoneC();
# 724 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  virtual void processHasExited(int state);
# 751 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  virtual void commClose();
# 766 "/coolo/prod/kdelibs/kdecore/kprocess.h"
  void setBinaryExecutable(const char *filename);




  int out[2];



  int in[2];



  int err[2];




  QSocketNotifier *innot;



  QSocketNotifier *outnot;



  QSocketNotifier *errnot;





  Communication communication;






  int childOutput(int fdno);






  int childError(int fdno);




  const char *input_data;



  int input_sent;



  int input_total;





  friend class KProcessController;

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KProcessPrivate *d;
};

class KShellProcessPrivate;
# 851 "/coolo/prod/kdelibs/kdecore/kprocess.h"
class KShellProcess: public KProcess
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:






  KShellProcess(const char *shellname=0);




  ~KShellProcess();

  virtual bool start(RunMode runmode = NotifyOnExit,
                  Communication comm = NoCommunication);

  static QString quote(const QString &arg);

private:
  QCString shell;

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KShellProcessPrivate *d;
};
# 26 "/coolo/prod/kdelibs/kdecore/kprocctrl.h" 2

class QSocketNotifier;
# 39 "/coolo/prod/kdelibs/kdecore/kprocctrl.h"
class KProcessController : public QObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:




  static void ref();





  static void deref();





  static KProcessController *theKProcessController;
# 69 "/coolo/prod/kdelibs/kdecore/kprocctrl.h"
  static void theSigCHLDHandler(int signal);
# 81 "/coolo/prod/kdelibs/kdecore/kprocctrl.h"
  bool waitForProcessExit(int timeout);






  void unscheduleCheck();






  void rescheduleCheck();
# 104 "/coolo/prod/kdelibs/kdecore/kprocctrl.h"
  int notifierFd() const;




  void addKProcess( KProcess* );



  void removeKProcess( KProcess* );



  void addProcess( int pid );

private :
  void slotDoHousekeeping();

private:
  friend class I_just_love_gcc;

  int fd[2];
  bool needcheck;
  QSocketNotifier *notifier;
  QValueList<KProcess*> kProcessList;
  QValueList<int> unixProcessList;

  static void setupHandlers();
  static void resetHandlers();
  static struct sigaction oldChildHandlerData;
  static bool handlerSet;

  static int refCount;


  KProcessController();
  ~KProcessController();


  KProcessController( const KProcessController& );
  KProcessController& operator= ( const KProcessController& );
};
# 107 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2


# 1 "/usr/include/paths.h" 1 3 4
# 33 "/usr/include/paths.h" 3 4







# 110 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2







# 1 "/usr/X11R6/include/X11/SM/SMlib.h" 1
# 34 "/usr/X11R6/include/X11/SM/SMlib.h"

# 1 "/usr/X11R6/include/X11/SM/SM.h" 1
# 34 "/usr/X11R6/include/X11/SM/SM.h"















































# 37 "/usr/X11R6/include/X11/SM/SMlib.h" 2
# 1 "/usr/X11R6/include/X11/ICE/ICElib.h" 1
# 32 "/usr/X11R6/include/X11/ICE/ICElib.h"

# 1 "/usr/X11R6/include/X11/ICE/ICE.h" 1
# 32 "/usr/X11R6/include/X11/ICE/ICE.h"



































# 35 "/usr/X11R6/include/X11/ICE/ICElib.h" 2




typedef void *IcePointer;




typedef enum {
    IcePoAuthHaveReply,
    IcePoAuthRejected,
    IcePoAuthFailed,
    IcePoAuthDoneCleanup
} IcePoAuthStatus;

typedef enum {
    IcePaAuthContinue,
    IcePaAuthAccepted,
    IcePaAuthRejected,
    IcePaAuthFailed
} IcePaAuthStatus;

typedef enum {
    IceConnectPending,
    IceConnectAccepted,
    IceConnectRejected,
    IceConnectIOError
} IceConnectStatus;

typedef enum {
    IceProtocolSetupSuccess,
    IceProtocolSetupFailure,
    IceProtocolSetupIOError,
    IceProtocolAlreadyActive
} IceProtocolSetupStatus;

typedef enum {
    IceAcceptSuccess,
    IceAcceptFailure,
    IceAcceptBadMalloc
} IceAcceptStatus;

typedef enum {
    IceClosedNow,
    IceClosedASAP,
    IceConnectionInUse,
    IceStartedShutdownNegotiation
} IceCloseStatus;

typedef enum {
    IceProcessMessagesSuccess,
    IceProcessMessagesIOError,
    IceProcessMessagesConnectionClosed
} IceProcessMessagesStatus;

typedef struct {
    unsigned long sequence_of_request;
    int major_opcode_of_request;
    int minor_opcode_of_request;
    IcePointer reply;
} IceReplyWaitInfo;

typedef struct _IceConn *IceConn;
typedef struct _IceListenObj *IceListenObj;

typedef void (*IceWatchProc) (

    IceConn ,
    IcePointer ,
    int ,
    IcePointer *

);

typedef void (*IcePoProcessMsgProc) (

    IceConn ,
    IcePointer ,
    int ,
    unsigned long ,
    int ,
    IceReplyWaitInfo * ,
    int *

);

typedef void (*IcePaProcessMsgProc) (

    IceConn ,
    IcePointer ,
    int ,
    unsigned long ,
    int

);

typedef struct {
    int major_version;
    int minor_version;
    IcePoProcessMsgProc process_msg_proc;
} IcePoVersionRec;

typedef struct {
    int major_version;
    int minor_version;
    IcePaProcessMsgProc process_msg_proc;
} IcePaVersionRec;

typedef IcePoAuthStatus (*IcePoAuthProc) (

    IceConn ,
    IcePointer * ,
    int ,
    int ,
    int ,
    IcePointer ,
    int * ,
    IcePointer * ,
    char **

);

typedef IcePaAuthStatus (*IcePaAuthProc) (

    IceConn ,
    IcePointer * ,
    int ,
    int ,
    IcePointer ,
    int * ,
    IcePointer * ,
    char **

);

typedef int (*IceHostBasedAuthProc) (

    char *

);

typedef int (*IceProtocolSetupProc) (

    IceConn ,
    int ,
    int ,
    char * ,
    char * ,
    IcePointer * ,
    char **

);

typedef void (*IceProtocolActivateProc) (

    IceConn ,
    IcePointer

);

typedef void (*IceIOErrorProc) (

    IceConn

);

typedef void (*IcePingReplyProc) (

    IceConn ,
    IcePointer

);

typedef void (*IceErrorHandler) (

    IceConn ,
    int ,
    int ,
    unsigned long ,
    int ,
    int ,
    IcePointer

);

typedef void (*IceIOErrorHandler) (

    IceConn

);






extern "C" {

extern int IceRegisterForProtocolSetup (

    char * ,
    char * ,
    char * ,
    int ,
    IcePoVersionRec * ,
    int ,
    char ** ,
    IcePoAuthProc * ,
    IceIOErrorProc

);

extern int IceRegisterForProtocolReply (

    char * ,
    char * ,
    char * ,
    int ,
    IcePaVersionRec * ,
    int ,
    char ** ,
    IcePaAuthProc * ,
    IceHostBasedAuthProc ,
    IceProtocolSetupProc ,
    IceProtocolActivateProc ,
    IceIOErrorProc

);

extern IceConn IceOpenConnection (

    char * ,
    IcePointer ,
    int ,
    int ,
    int ,
    char *

);

extern IcePointer IceGetConnectionContext (

    IceConn

);

extern int IceListenForConnections (

    int * ,
    IceListenObj ** ,
    int ,
    char *

);

extern int IceListenForWellKnownConnections (

    char * ,
    int * ,
    IceListenObj ** ,
    int ,
    char *

);

extern int IceGetListenConnectionNumber (

    IceListenObj

);

extern char *IceGetListenConnectionString (

    IceListenObj

);

extern char *IceComposeNetworkIdList (

    int ,
    IceListenObj *

);

extern void IceFreeListenObjs (

    int ,
    IceListenObj *

);

extern void IceSetHostBasedAuthProc (

    IceListenObj ,
    IceHostBasedAuthProc

);

extern IceConn IceAcceptConnection (

    IceListenObj ,
    IceAcceptStatus *

);

extern void IceSetShutdownNegotiation (

    IceConn ,
    int

);

extern int IceCheckShutdownNegotiation (

    IceConn

);

extern IceCloseStatus IceCloseConnection (

    IceConn

);

extern int IceAddConnectionWatch (

    IceWatchProc ,
    IcePointer

);

extern void IceRemoveConnectionWatch (

    IceWatchProc ,
    IcePointer

);

extern IceProtocolSetupStatus IceProtocolSetup (

    IceConn ,
    int ,
    IcePointer ,
    int ,
    int * ,
    int * ,
    char ** ,
    char ** ,
    int ,
    char *

);

extern int IceProtocolShutdown (

    IceConn ,
    int

);

extern IceProcessMessagesStatus IceProcessMessages (

    IceConn ,
    IceReplyWaitInfo * ,
    int *

);

extern int IcePing (

   IceConn ,
   IcePingReplyProc ,
   IcePointer

);

extern char *IceAllocScratch (

   IceConn ,
   unsigned long

);

extern int IceFlush (

   IceConn

);

extern int IceGetOutBufSize (

   IceConn

);

extern int IceGetInBufSize (

   IceConn

);

extern IceConnectStatus IceConnectionStatus (

    IceConn

);

extern char *IceVendor (

    IceConn

);

extern char *IceRelease (

    IceConn

);

extern int IceProtocolVersion (

    IceConn

);

extern int IceProtocolRevision (

    IceConn

);

extern int IceConnectionNumber (

    IceConn

);

extern char *IceConnectionString (

    IceConn

);

extern unsigned long IceLastSentSequenceNumber (

    IceConn

);

extern unsigned long IceLastReceivedSequenceNumber (

    IceConn

);

extern int IceSwapping (

    IceConn

);

extern IceErrorHandler IceSetErrorHandler (

    IceErrorHandler

);

extern IceIOErrorHandler IceSetIOErrorHandler (

    IceIOErrorHandler

);






extern int IceInitThreads (

    void

);

extern void IceAppLockConn (

    IceConn

);

extern void IceAppUnlockConn (

    IceConn

);

}
# 38 "/usr/X11R6/include/X11/SM/SMlib.h" 2






typedef IcePointer SmPointer;






typedef struct _SmcConn *SmcConn;
typedef struct _SmsConn *SmsConn;






typedef struct {
    int length;
    SmPointer value;
} SmPropValue;

typedef struct {
    char *name;
    char *type;
    int num_vals;
    SmPropValue *vals;
} SmProp;







typedef enum {
    SmcClosedNow,
    SmcClosedASAP,
    SmcConnectionInUse
} SmcCloseStatus;







typedef void (*SmcSaveYourselfProc) (

    SmcConn ,
    SmPointer ,
    int ,
    int ,
    int ,
    int

);

typedef void (*SmcSaveYourselfPhase2Proc) (

    SmcConn ,
    SmPointer

);

typedef void (*SmcInteractProc) (

    SmcConn ,
    SmPointer

);

typedef void (*SmcDieProc) (

    SmcConn ,
    SmPointer

);

typedef void (*SmcShutdownCancelledProc) (

    SmcConn ,
    SmPointer

);

typedef void (*SmcSaveCompleteProc) (

    SmcConn ,
    SmPointer

);

typedef void (*SmcPropReplyProc) (

    SmcConn ,
    SmPointer ,
    int ,
    SmProp **

);






typedef struct {

    struct {
        SmcSaveYourselfProc callback;
        SmPointer client_data;
    } save_yourself;

    struct {
        SmcDieProc callback;
        SmPointer client_data;
    } die;

    struct {
        SmcSaveCompleteProc callback;
        SmPointer client_data;
    } save_complete;

    struct {
        SmcShutdownCancelledProc callback;
        SmPointer client_data;
    } shutdown_cancelled;

} SmcCallbacks;








typedef int (*SmsRegisterClientProc) (

    SmsConn ,
    SmPointer ,
    char *

);

typedef void (*SmsInteractRequestProc) (

    SmsConn ,
    SmPointer ,
    int

);

typedef void (*SmsInteractDoneProc) (

    SmsConn ,
    SmPointer ,
    int

);

typedef void (*SmsSaveYourselfRequestProc) (

    SmsConn ,
    SmPointer ,
    int ,
    int ,
    int ,
    int ,
    int

);

typedef void (*SmsSaveYourselfPhase2RequestProc) (

    SmsConn ,
    SmPointer

);

typedef void (*SmsSaveYourselfDoneProc) (

    SmsConn ,
    SmPointer ,
    int

);

typedef void (*SmsCloseConnectionProc) (

    SmsConn ,
    SmPointer ,
    int ,
    char **

);

typedef void (*SmsSetPropertiesProc) (

    SmsConn ,
    SmPointer ,
    int ,
    SmProp **

);

typedef void (*SmsDeletePropertiesProc) (

    SmsConn ,
    SmPointer ,
    int ,
    char **

);

typedef void (*SmsGetPropertiesProc) (

    SmsConn ,
    SmPointer

);






typedef struct {

    struct {
        SmsRegisterClientProc callback;
        SmPointer manager_data;
    } register_client;

    struct {
        SmsInteractRequestProc callback;
        SmPointer manager_data;
    } interact_request;

    struct {
        SmsInteractDoneProc callback;
        SmPointer manager_data;
    } interact_done;

    struct {
        SmsSaveYourselfRequestProc callback;
        SmPointer manager_data;
    } save_yourself_request;

    struct {
        SmsSaveYourselfPhase2RequestProc callback;
        SmPointer manager_data;
    } save_yourself_phase2_request;

    struct {
        SmsSaveYourselfDoneProc callback;
        SmPointer manager_data;
    } save_yourself_done;

    struct {
        SmsCloseConnectionProc callback;
        SmPointer manager_data;
    } close_connection;

    struct {
        SmsSetPropertiesProc callback;
        SmPointer manager_data;
    } set_properties;

    struct {
        SmsDeletePropertiesProc callback;
        SmPointer manager_data;
    } delete_properties;

    struct {
        SmsGetPropertiesProc callback;
        SmPointer manager_data;
    } get_properties;

} SmsCallbacks;





typedef int (*SmsNewClientProc) (

    SmsConn ,
    SmPointer ,
    unsigned long * ,
    SmsCallbacks * ,
    char **

);







typedef void (*SmcErrorHandler) (

    SmcConn ,
    int ,
    int ,
    unsigned long ,
    int ,
    int ,
    SmPointer

);

typedef void (*SmsErrorHandler) (

    SmsConn ,
    int ,
    int ,
    unsigned long ,
    int ,
    int ,
    SmPointer

);







extern "C" {

extern SmcConn SmcOpenConnection (

    char * ,
    SmPointer ,
    int ,
    int ,
    unsigned long ,
    SmcCallbacks * ,
    char * ,
    char ** ,
    int ,
    char *

);

extern SmcCloseStatus SmcCloseConnection (

    SmcConn ,
    int ,
    char **

);

extern void SmcModifyCallbacks (

    SmcConn ,
    unsigned long ,
    SmcCallbacks *

);

extern void SmcSetProperties (

    SmcConn ,
    int ,
    SmProp **

);

extern void SmcDeleteProperties (

    SmcConn ,
    int ,
    char **

);

extern int SmcGetProperties (

    SmcConn ,
    SmcPropReplyProc ,
    SmPointer

);

extern int SmcInteractRequest (

    SmcConn ,
    int ,
    SmcInteractProc ,
    SmPointer

);

extern void SmcInteractDone (

    SmcConn ,
    int

);

extern void SmcRequestSaveYourself (

    SmcConn ,
    int ,
    int ,
    int ,
    int ,
    int

);

extern int SmcRequestSaveYourselfPhase2 (

    SmcConn ,
    SmcSaveYourselfPhase2Proc ,
    SmPointer

);

extern void SmcSaveYourselfDone (

    SmcConn ,
    int

);

extern int SmcProtocolVersion (

    SmcConn

);

extern int SmcProtocolRevision (

    SmcConn

);

extern char *SmcVendor (

    SmcConn

);

extern char *SmcRelease (

    SmcConn

);

extern char *SmcClientID (

    SmcConn

);

extern IceConn SmcGetIceConnection (

    SmcConn

);

extern int SmsInitialize (

    char * ,
    char * ,
    SmsNewClientProc ,
    SmPointer ,
    IceHostBasedAuthProc ,
    int ,
    char *

);

extern char *SmsClientHostName (

    SmsConn

);

extern char *SmsGenerateClientID (

    SmsConn

);

extern int SmsRegisterClientReply (

    SmsConn ,
    char *

);

extern void SmsSaveYourself (

    SmsConn ,
    int ,
    int ,
    int ,
    int

);

extern void SmsSaveYourselfPhase2 (

    SmsConn

);

extern void SmsInteract (

    SmsConn

);

extern void SmsDie (

    SmsConn

);

extern void SmsSaveComplete (

    SmsConn

);

extern void SmsShutdownCancelled (

    SmsConn

);

extern void SmsReturnProperties (

    SmsConn ,
    int ,
    SmProp **

);

extern void SmsCleanUp (

    SmsConn

);

extern int SmsProtocolVersion (

    SmsConn

);

extern int SmsProtocolRevision (

    SmsConn

);

extern char *SmsClientID (

    SmsConn

);

extern IceConn SmsGetIceConnection (

    SmsConn

);

extern SmcErrorHandler SmcSetErrorHandler (

    SmcErrorHandler

);

extern SmsErrorHandler SmsSetErrorHandler (

    SmsErrorHandler

);

extern void SmFreeProperty (

    SmProp *

);

extern void SmFreeReasons (

    int ,
    char **

);

}
# 118 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/fixx11h.h" 1
# 31 "/coolo/prod/kdelibs/kdecore/fixx11h.h"
namespace X
{





const int XUnsorted = 0;
#undef Unsorted
const int Unsorted = XUnsorted;
# 50 "/coolo/prod/kdelibs/kdecore/fixx11h.h"
const XID XNone = 0L;
#undef None
const XID None = XNone;
# 62 "/coolo/prod/kdelibs/kdecore/fixx11h.h"
typedef int XBool;
#undef Bool
typedef XBool Bool;
# 74 "/coolo/prod/kdelibs/kdecore/fixx11h.h"
const int XKeyPress = 2;
#undef KeyPress
const int KeyPress = XKeyPress;







const int XKeyRelease = 3;
#undef KeyRelease
const int KeyRelease = XKeyRelease;







const int XAbove = 0;
#undef Above
const int Above = XAbove;







const int XBelow = 1;
#undef Below
const int Below = XBelow;







const int XFocusIn = 9;
#undef FocusIn
const int FocusIn = XFocusIn;







const int XFocusOut = 10;
#undef FocusOut
const int FocusOut = XFocusOut;







const int XAlways = 2;
#undef Always
const int Always = XAlways;







const int XSuccess = 0;
#undef Success
const int Success = XSuccess;







const int XGrayScale = 1;
#undef GrayScale
const int GrayScale = XGrayScale;







typedef int XStatus;
#undef Status
typedef XStatus Status;
# 220 "/coolo/prod/kdelibs/kdecore/fixx11h.h"
}

using namespace X;
# 119 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

# 1 "/coolo/prod/kdelibs/dcop/KDE-ICE/ICElib.h" 1
# 121 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2







# 1 "/coolo/prod/kdelibs/kdecore/kipc.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kipc.h"
# 49 "/coolo/prod/kdelibs/kdecore/kipc.h"
class KIPC
{
public:




    enum Message { PaletteChanged=0, FontChanged, StyleChanged,
                   BackgroundChanged, SettingsChanged, IconChanged, ToolbarStyleChanged,
                   ClipboardConfigChanged,
                   UserMessage=32 };
# 68 "/coolo/prod/kdelibs/kdecore/kipc.h"
    static void sendMessage(Message msg, WId w, int data=0);







    static void sendMessageAll(Message msg, int data=0);
};
# 130 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/kappdcopiface.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kappdcopiface.h"

# 1 "/coolo/prod/kdelibs/dcop/dcopobject.h" 1
# 24 "/coolo/prod/kdelibs/dcop/dcopobject.h"
# 33 "/coolo/prod/kdelibs/dcop/dcopobject.h"
class DCOPClient;
typedef QValueList<QCString> QCStringList;









# 66 "/coolo/prod/kdelibs/dcop/dcopobject.h"
class DCOPObject
{
public:




  DCOPObject();





  DCOPObject(QObject *obj);




  DCOPObject(const QCString &objId);




  virtual ~DCOPObject();





  QCString objId() const;







  bool setObjId(const QCString &objId);
# 136 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  virtual bool process(const QCString &fun, const QByteArray &data,
                       QCString& replyType, QByteArray &replyData);
# 162 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  virtual bool processDynamic(const QCString &fun, const QByteArray &data,
                              QCString& replyType, QByteArray &replyData);
# 176 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  virtual QCStringList functionsDynamic();
# 189 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  virtual QCStringList interfacesDynamic();
# 200 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  virtual QCStringList interfaces();
# 220 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  virtual QCStringList functions();







  void emitDCOPSignal( const QCString &signal, const QByteArray &data);
# 249 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  bool connectDCOPSignal( const QCString &sender, const QCString &senderObj,
                          const QCString &signal,
                          const QCString &slot,
                          bool Volatile);
# 271 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  bool disconnectDCOPSignal( const QCString &sender, const QCString &senderObj,
                             const QCString &signal,
                             const QCString &slot);
# 283 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  DCOPClient *callingDcopClient();





  void setCallingDcopClient(DCOPClient *);
# 298 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  static bool hasObject(const QCString &objId);







  static DCOPObject *find(const QCString &objId);
# 318 "/coolo/prod/kdelibs/dcop/dcopobject.h"
  static QPtrList<DCOPObject> match(const QCString &partialId);







  static QCString objectName( QObject* obj );

private:



  QCString ident;

protected:
  virtual void virtual_hook( int id, void* data );
private:
  class DCOPObjectPrivate;
  DCOPObjectPrivate *d;
};

class DCOPObjectProxyPrivate;
# 351 "/coolo/prod/kdelibs/dcop/dcopobject.h"
class DCOPObjectProxy
{
public:



    DCOPObjectProxy();







    DCOPObjectProxy( DCOPClient*);




    virtual ~DCOPObjectProxy();
# 393 "/coolo/prod/kdelibs/dcop/dcopobject.h"
    virtual bool process( const QCString& obj, const QCString& fun,
                          const QByteArray& data,
                          QCString& replyType, QByteArray &replyData );
private:
    void* unused;
    void* unused_too;
    friend class DCOPClient;
    static QPtrList<DCOPObjectProxy>* proxies;
protected:
    virtual void virtual_hook( int id, void* data );
private:
    DCOPObjectProxyPrivate* d;
};
# 24 "/coolo/prod/kdelibs/kdecore/kappdcopiface.h" 2




class KApplication;







class KAppDCOPInterface : virtual public DCOPObject
{
public: virtual bool process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData); QCStringList functions(); QCStringList interfaces(); private:

public:





        KAppDCOPInterface( KApplication * theKapp );




        ~KAppDCOPInterface();
public:



        void disableSessionManagement();

        QCString startupId();
        QCString caption();

        void quit();




private:
        KApplication *m_KApplication;
};
# 133 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2

bool kde_have_kipc = true;

KApplication* KApplication::KApp = 0L;
bool KApplication::loadedByKdeinit = false;
DCOPClient *KApplication::s_DCOPClient = 0L;
bool KApplication::s_dcopClientNeedsPostInit = false;

static Atom atom_DesktopWindow;
static Atom atom_NetSupported;




static Atom atom_KdeNetUserTime;
static Atom kde_net_wm_user_time = 0;




Time qt_x_last_input_time = 0L;
extern Time qt_x_time;

template class QPtrList<KSessionManaged>;


extern "C" {
static int kde_xio_errhandler( Display * dpy )
{
  return KApplication::kApplication()->xioErrhandler( dpy );
}

static int kde_x_errhandler( Display *dpy, XErrorEvent *err )
{
  return KApplication::kApplication()->xErrhandler( dpy, err );
}

}


extern "C" {
static void kde_ice_ioerrorhandler( IceConn conn )
{
    if(KApplication::kApplication())
        KApplication::kApplication()->iceIOErrorHandler( conn );

}
}




class KApplicationPrivate
{
public:
  KApplicationPrivate()
    : actionRestrictions( false ),
        refCount( 1 ),
        oldIceIOErrorHandler( 0 ),
        checkAccelerators( 0 ),
        overrideStyle( QString::null ),
        startup_id( "0" ),
        m_KAppDCOPInterface( 0L ),
        session_save( false ),
        oldXErrorHandler( __null ),
        oldXIOErrorHandler( __null )
  {
  }

  ~KApplicationPrivate()
  {}


  bool actionRestrictions : 1;






  int refCount;
  IceIOErrorHandler oldIceIOErrorHandler;
  KCheckAccelerators* checkAccelerators;
  QString overrideStyle;
  QString geometry_arg;
  QCString startup_id;
  KAppDCOPInterface *m_KAppDCOPInterface;
  bool session_save;
  int (*oldXErrorHandler)(Display*,XErrorEvent*);
  int (*oldXIOErrorHandler)(Display*);

  class URLActionRule
  {
  public:










     URLActionRule(const QString &act,
                   const QString &bProt, const QString &bHost, const QString &bPath,
                   const QString &dProt, const QString &dHost, const QString &dPath,
                   bool perm)
                   : action(act),
                     baseProt(bProt), baseHost(bHost), basePath(bPath),
                     destProt(dProt), destHost(dHost), destPath(dPath),
                     permission(perm)
                   {
                      if (baseProt.isEmpty()) baseProtWildCard = true; else if (baseProt[baseProt.length()-1] == '!') { baseProtWildCard = false; baseProt.truncate(baseProt.length()-1); } else baseProtWildCard = true;;
                      if (baseHost.isEmpty()) baseHostWildCard = true; else if (baseHost[0] == '*') { baseHostWildCard = true; baseHost = baseHost.mid(1); } else baseHostWildCard = false;;
                      if (basePath.isEmpty()) basePathWildCard = true; else if (basePath[basePath.length()-1] == '!') { basePathWildCard = false; basePath.truncate(basePath.length()-1); } else basePathWildCard = true;;
                      if (destProt.isEmpty()) destProtWildCard = true; else if (destProt[destProt.length()-1] == '!') { destProtWildCard = false; destProt.truncate(destProt.length()-1); } else destProtWildCard = true;;
                      if (destHost.isEmpty()) destHostWildCard = true; else if (destHost[0] == '*') { destHostWildCard = true; destHost = destHost.mid(1); } else destHostWildCard = false;;
                      if (destPath.isEmpty()) destPathWildCard = true; else if (destPath[destPath.length()-1] == '!') { destPathWildCard = false; destPath.truncate(destPath.length()-1); } else destPathWildCard = true;;
                      destProtEqual = (destProt == "=");;
                      destHostEqual = (destHost == "=");;
                   }

     bool baseMatch(const KURL &url, const QString &protClass)
     {
        if (baseProtWildCard)
        {
           if ( !baseProt.isEmpty() && !url.protocol().startsWith(baseProt) &&
                (protClass.isEmpty() || (protClass != baseProt)) )
              return false;
        }
        else
        {
           if ( (url.protocol() != baseProt) &&
                (protClass.isEmpty() || (protClass != baseProt)) )
              return false;
        }
        if (baseHostWildCard)
        {
           if (!baseHost.isEmpty() && !url.host().endsWith(baseHost))
              return false;
        }
        else
        {
           if (url.host() != baseHost)
              return false;
        }
        if (basePathWildCard)
        {
           if (!basePath.isEmpty() && !url.path().startsWith(basePath))
              return false;
        }
        else
        {
           if (url.path() != basePath)
              return false;
        }
        return true;
     }

     bool destMatch(const KURL &url, const QString &protClass, const KURL &base, const QString &baseClass)
     {
        if (destProtEqual)
        {
           if ( (url.protocol() != base.protocol()) &&
                (protClass.isEmpty() || baseClass.isEmpty() || protClass != baseClass) )
              return false;
        }
        else if (destProtWildCard)
        {
           if ( !destProt.isEmpty() && !url.protocol().startsWith(destProt) &&
                (protClass.isEmpty() || (protClass != destProt)) )
              return false;
        }
        else
        {
           if ( (url.protocol() != destProt) &&
                (protClass.isEmpty() || (protClass != destProt)) )
              return false;
        }
        if (destHostWildCard)
        {
           if (!destHost.isEmpty() && !url.host().endsWith(destHost))
              return false;
        }
        else if (destHostEqual)
        {
           if (url.host() != base.host())
              return false;
        }
        else
        {
           if (url.host() != destHost)
              return false;
        }
        if (destPathWildCard)
        {
           if (!destPath.isEmpty() && !url.path().startsWith(destPath))
              return false;
        }
        else
        {
           if (url.path() != destPath)
              return false;
        }
        return true;
     }

     QString action;
     QString baseProt;
     QString baseHost;
     QString basePath;
     QString destProt;
     QString destHost;
     QString destPath;
     bool baseProtWildCard : 1;
     bool baseHostWildCard : 1;
     bool basePathWildCard : 1;
     bool destProtWildCard : 1;
     bool destHostWildCard : 1;
     bool destPathWildCard : 1;
     bool destProtEqual : 1;
     bool destHostEqual : 1;
     bool permission;
  };
  QPtrList<URLActionRule> urlActionRestrictions;

    QString sessionKey;
    QString pSessionConfigFile;
};


static QPtrList<QWidget>*x11Filter = 0;
static bool autoDcopRegistration = true;

void KApplication::installX11EventFilter( QWidget* filter )
{
    if ( !filter )
        return;
    if (!x11Filter)
        x11Filter = new QPtrList<QWidget>;
    connect ( filter, "2""destroyed()", this, "1""x11FilterDestroyed()" );
    x11Filter->append( filter );
}

void KApplication::x11FilterDestroyed()
{
    removeX11EventFilter( static_cast< const QWidget* >( sender()));
}

void KApplication::removeX11EventFilter( const QWidget* filter )
{
    if ( !x11Filter || !filter )
        return;
    x11Filter->removeRef( filter );
    if ( x11Filter->isEmpty() ) {
        delete x11Filter;
        x11Filter = 0;
    }
}





extern bool kde_g_bKillAccelOverride;

bool KApplication::notify(QObject *receiver, QEvent *event)
{
    QEvent::Type t = event->type();
    if (kde_g_bKillAccelOverride)
    {
       kde_g_bKillAccelOverride = false;

       if (t == QEvent::AccelOverride)
       {
          static_cast<QKeyEvent *>(event)->accept();
          return true;
       }
       else
          kdWarning(125) << "kde_g_bKillAccelOverride set, but received an event other than AccelOverride." << endl;
    }

    if ((t == QEvent::AccelOverride) || (t == QEvent::KeyPress))
    {
       static const KShortcut& _selectAll = KStdAccel::selectAll();
       if (receiver && receiver->inherits("QLineEdit"))
       {
          QLineEdit *edit = static_cast<QLineEdit *>(receiver);

          QKeyEvent *kevent = static_cast<QKeyEvent *>(event);
          KKey key(kevent);
          if (_selectAll.contains(key))
          {
             if (t == QEvent::KeyPress)
             {
                edit->selectAll();
                return true;
             }
             else
             {
                kevent->accept();
             }
          }

          if (key == KKey(Qt::CTRL + Qt::Key_U))
          {
             if (t == QEvent::KeyPress)
             {
                if (!edit->isReadOnly())
                {
                   QString t(edit->text());
                   t = t.mid(edit->cursorPosition());
                   edit->validateAndSet(t, 0, 0, 0);
                }
                return true;
             }
             else
             {
                kevent->accept();
             }

          }
       }
       if (receiver && receiver->inherits("QTextEdit"))
       {
          QTextEdit *medit = static_cast<QTextEdit *>(receiver);

          QKeyEvent *kevent = static_cast<QKeyEvent *>(event);
          if (_selectAll.contains(KKey(kevent)))
          {
             if (t == QEvent::KeyPress)
             {
                medit->selectAll();
                return true;
             }
             else
             {
                kevent->accept();
             }
          }
       }
    }
    if( event->type() == QEvent::Show && receiver->isWidgetType())
    {
        QWidget* w = static_cast< QWidget* >( receiver );
        if( w->isTopLevel() && qt_x_last_input_time != 0L )
            XChangeProperty( qt_xdisplay(), w->winId(), kde_net_wm_user_time, ((Atom) 6),
                32, 0, (unsigned char*)&qt_x_last_input_time, 1 );
    }
    if( event->type() == QEvent::Hide && receiver->isWidgetType())
    {
        QWidget* w = static_cast< QWidget* >( receiver );
        if( w->isTopLevel() && w->winId() != 0 )
            XDeleteProperty( qt_xdisplay(), w->winId(), kde_net_wm_user_time );
    }
    return QApplication::notify(receiver, event);
}



static QPtrList<KSessionManaged>* sessionClients()
{
    static QPtrList<KSessionManaged>* session_clients = 0L;
    if ( !session_clients )
        session_clients = new QPtrList<KSessionManaged>;
    return session_clients;
}






QString KApplication::sessionConfigName() const
{



    QString sessKey = sessionKey();
    if ( sessKey.isEmpty() && !d->sessionKey.isEmpty() )
        sessKey = d->sessionKey;
    return QString("session/%1_%2_%3").arg(name()).arg(sessionId()).arg(sessKey);

}


static SmcConn mySmcConnection = 0;
static SmcConn tmpSmcConnection = 0;




static QTime* smModificationTime = 0;

KApplication::KApplication( int& argc, char** argv, const QCString& rAppName,
                            bool allowStyles, bool GUIenabled ) :
  QApplication( argc, argv, GUIenabled ), KInstance(rAppName),

  display(0L),

  d (new KApplicationPrivate())
{
    read_app_startup_id();
    if (!GUIenabled)
       allowStyles = false;
    useStyles = allowStyles;
    ((!rAppName.isEmpty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!rAppName.isEmpty()","/coolo/prod/kdelibs/kdecore/kapplication.cpp",543));
    setName(rAppName);

    installSigpipeHandler();
    KCmdLineArgs::initIgnore(argc, argv, rAppName.data());
    parseCommandLine( );
    init(GUIenabled);
    d->m_KAppDCOPInterface = new KAppDCOPInterface(this);
}

KApplication::KApplication( bool allowStyles, bool GUIenabled ) :
  QApplication( *KCmdLineArgs::qt_argc(), *KCmdLineArgs::qt_argv(),
                GUIenabled ),
  KInstance( KCmdLineArgs::about),

  display(0L),

  d (new KApplicationPrivate)
{
    read_app_startup_id();
    if (!GUIenabled)
       allowStyles = false;
    useStyles = allowStyles;
    setName( instanceName() );

    installSigpipeHandler();
    parseCommandLine( );
    init(GUIenabled);
    d->m_KAppDCOPInterface = new KAppDCOPInterface(this);
}

KApplication::KApplication( bool allowStyles, bool GUIenabled, KInstance* _instance ) :
  QApplication( *KCmdLineArgs::qt_argc(), *KCmdLineArgs::qt_argv(),
                GUIenabled ),
  KInstance( _instance ),

  display(0L),

  d (new KApplicationPrivate)
{
    read_app_startup_id();
    if (!GUIenabled)
       allowStyles = false;
    useStyles = allowStyles;
    setName( instanceName() );

    installSigpipeHandler();
    parseCommandLine( );
    init(GUIenabled);
}


KApplication::KApplication(Display *display, int& argc, char** argv, const QCString& rAppName,
                           bool allowStyles, bool GUIenabled ) :
  QApplication( display ), KInstance(rAppName),
  display(0L),
  d (new KApplicationPrivate())
{
    read_app_startup_id();
    if (!GUIenabled)
       allowStyles = false;
    useStyles = allowStyles;

    ((!rAppName.isEmpty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!rAppName.isEmpty()","/coolo/prod/kdelibs/kdecore/kapplication.cpp",606));
    setName(rAppName);

    installSigpipeHandler();
    KCmdLineArgs::initIgnore(argc, argv, rAppName.data());
    parseCommandLine( );
    init(GUIenabled);
    d->m_KAppDCOPInterface = new KAppDCOPInterface(this);
}


int KApplication::xioErrhandler( Display* dpy )
{
    if(KApplication::kApplication())
    {
        shutDown();
        d->oldXIOErrorHandler( dpy );
    }
    exit( 1 );
    return 0;
}

int KApplication::xErrhandler( Display* dpy, void* err_ )
{
    XErrorEvent* err = static_cast< XErrorEvent* >( err_ );
    if(KApplication::kApplication())
    {

        d->oldXErrorHandler( dpy, err );
    }
    return 0;
}

void KApplication::iceIOErrorHandler( _IceConn *conn )
{
    shutDown();

    if ( d->oldIceIOErrorHandler != __null )
      (*d->oldIceIOErrorHandler)( conn );

    exit( 1 );
}

class KDETranslator : public QTranslator
{
public:
  KDETranslator(QObject *parent) : QTranslator(parent, "kdetranslator") {}
  virtual QTranslatorMessage findMessage(const char* context,
                                         const char *sourceText,
                                         const char* message) const
  {
    QTranslatorMessage res;
    res.setTranslation(KGlobal::locale()->translateQt(context, sourceText, message));
    return res;
  }
};

void KApplication::init(bool GUIenabled)
{
  if ((getuid() != geteuid()) ||
      (getgid() != getegid()))
  {
     fprintf(stderr, "The KDE libraries are not designed to run with suid privileges.\n");
     ::exit(127);
  }

  KProcessController::ref();

  (void) KClipboardSynchronizer::self();

  QApplication::setDesktopSettingsAware( false );

  KApp = this;




  if ( GUIenabled ) {
      const int max = 20;
      Atom* atoms[max];
      char* names[max];
      Atom atoms_return[max];
      int n = 0;

      atoms[n] = &kipcCommAtom;
      names[n++] = (char *) "KIPC_COMM_ATOM";

      atoms[n] = &atom_DesktopWindow;
      names[n++] = (char *) "KDE_DESKTOP_WINDOW";

      atoms[n] = &atom_NetSupported;
      names[n++] = (char *) "_NET_SUPPORTED";

      atoms[n] = &atom_KdeNetUserTime;
      names[n++] = (char *) "_KDE_NET_USER_TIME";

      atoms[n] = &kde_net_wm_user_time;
      names[n++] = (char *) "_NET_WM_USER_TIME";

      XInternAtoms( qt_xdisplay(), names, n, FALSE, atoms_return );
      for (int i = 0; i < n; i++ )
          *atoms[i] = atoms_return[i];
  }


  dcopAutoRegistration();
  dcopClientPostInit();

  smw = 0;



  kipcEventMask = (1 << KIPC::StyleChanged) | (1 << KIPC::PaletteChanged) |
                  (1 << KIPC::FontChanged) | (1 << KIPC::BackgroundChanged) |
                  (1 << KIPC::ToolbarStyleChanged) | (1 << KIPC::SettingsChanged) |
                  (1 << KIPC::ClipboardConfigChanged);



  (void) KGlobal::locale();

  KConfig* config = KGlobal::config();
  d->actionRestrictions = config->hasGroup("KDE Action Restrictions" );




  QCString readOnly = getenv("KDE_HOME_READONLY");
  if (readOnly.isEmpty() && (qstrcmp(name(), "kdialog") != 0))
  {
    KConfigGroupSaver saver(config, "KDE Action Restrictions");
    if (config->readBoolEntry("warn_unwritable_config",TRUE))
       config->checkConfigFilesWritable(TRUE);
  }

  if (GUIenabled)
  {


    fcntl((((_XPrivDisplay)qt_xdisplay())->fd), 2, 1);

    d->oldXErrorHandler = XSetErrorHandler( kde_x_errhandler );
    d->oldXIOErrorHandler = XSetIOErrorHandler( kde_xio_errhandler );


    connect( this, "2""aboutToQuit()", this, "2""shutDown()" );


    display = desktop()->x11Display();


    {
        QStringList plugins = KGlobal::dirs()->resourceDirs( "qtplugins" );
        QStringList::Iterator it = plugins.begin();
        while (it != plugins.end()) {
            addLibraryPath( *it );
            ++it;
        }

    }
    kdisplaySetStyle();
    kdisplaySetFont();

    propagateSettings(SETTINGS_QT);


    QMimeSourceFactory::defaultFactory()->addFactory( mimeSourceFactory() );

    KConfigGroupSaver saver( config, "Development" );
    if( config->hasKey( "CheckAccelerators" ) || config->hasKey( "AutoCheckAccelerators" ))
        d->checkAccelerators = new KCheckAccelerators( this );
  }



  bool rtl = reverseLayout();
  installTranslator(new KDETranslator(this));
  setReverseLayout( rtl );
  if (i18n( "_: Dear Translator! Translate this string to the string 'LTR' in "
         "left-to-right languages (as english) or to 'RTL' in right-to-left "
         "languages (such as Hebrew and Arabic) to get proper widget layout." ) == "RTL")

        setReverseLayout( !rtl );


  KGlobal::dirs()->addResourceType("appdata", KStandardDirs::kde_default("data")
                                   + QString::fromLatin1(name()) + '/');
  pSessionConfig = 0L;
  bSessionManagement = true;



  if (GUIenabled && kde_have_kipc )
  {
    smw = new QWidget(0,0);
    long data = 1;
    XChangeProperty(qt_xdisplay(), smw->winId(),
                    atom_DesktopWindow, atom_DesktopWindow,
                    32, 0, (unsigned char *)&data, 1);
  }




  d->oldIceIOErrorHandler = IceSetIOErrorHandler( kde_ice_ioerrorhandler );
}

static int my_system (const char *command) {
   int pid, status;

   QApplication::flushX();
   pid = fork();
   if (pid == -1)
      return -1;
   if (pid == 0) {
      const char* shell = "/bin/sh";
      execl(shell, shell, "-c", command, (void *)0);
      ::exit(127);
   }
   do {
      if (waitpid(pid, &status, 0) == -1) {
         if ((*__errno_location ()) != 4)
            return -1;
       } else
            return status;
   } while(1);
}


DCOPClient *KApplication::dcopClient()
{
  if (s_DCOPClient)
    return s_DCOPClient;

  s_DCOPClient = new DCOPClient();
  KCmdLineArgs *args = KCmdLineArgs::parsedArgs("kde");
  if (args->isSet("dcopserver"))
  {
    s_DCOPClient->setServerAddress( args->getOption("dcopserver"));
  }
  if( KApplication::kApplication() ) {
    connect(s_DCOPClient, "2""attachFailed(const QString &)",
            KApplication::kApplication(), "1""dcopFailure(const QString &)");
    connect(s_DCOPClient, "2""blockUserInput(bool)",
            KApplication::kApplication(), "1""dcopBlockUserInput(bool)" );
  }
  else
    s_dcopClientNeedsPostInit = true;

  DCOPClient::setMainClient( s_DCOPClient );
  return s_DCOPClient;
}

void KApplication::dcopClientPostInit()
{
  if( s_dcopClientNeedsPostInit )
    {
    s_dcopClientNeedsPostInit = false;
    connect(s_DCOPClient, "2""blockUserInput(bool)",
            "1""dcopBlockUserInput(bool)" );
    s_DCOPClient->bindToApp();
    }
}

void KApplication::dcopAutoRegistration()
{
  if (autoDcopRegistration)
     {
     ( void ) dcopClient();
     if( dcopClient()->appId().isEmpty())
         dcopClient()->registerAs(name());
     }
}

void KApplication::disableAutoDcopRegistration()
{
  autoDcopRegistration = false;
}

KConfig* KApplication::sessionConfig()
{
    if (pSessionConfig)
        return pSessionConfig;


    pSessionConfig = new KConfig( sessionConfigName(), false, false);
    return pSessionConfig;
}

void KApplication::ref()
{
    d->refCount++;

}

void KApplication::deref()
{
    d->refCount--;

    if ( d->refCount <= 0 )
        quit();
}

KSessionManaged::KSessionManaged()
{
    sessionClients()->remove( this );
    sessionClients()->append( this );
}

KSessionManaged::~KSessionManaged()
{
    sessionClients()->remove( this );
}

bool KSessionManaged::saveState(QSessionManager&)
{
    return true;
}

bool KSessionManaged::commitData(QSessionManager&)
{
    return true;
}


void KApplication::disableSessionManagement() {
  bSessionManagement = false;
}

void KApplication::enableSessionManagement() {
  bSessionManagement = true;
# 946 "/coolo/prod/kdelibs/kdecore/kapplication.cpp"
  if( mySmcConnection ) {
        SmcRequestSaveYourself( mySmcConnection, 1, 0,
                                2,
                                0, 0 );


        IceFlush(SmcGetIceConnection(mySmcConnection));
  }
}


bool KApplication::requestShutDown(
    ShutdownConfirm confirm, ShutdownType sdtype, ShutdownMode sdmode )
{

    QApplication::syncX();

    if ( confirm == ShutdownConfirmYes ||
         sdtype != ShutdownTypeDefault ||
         sdmode != ShutdownModeDefault )
    {
        QByteArray data;
        QDataStream arg(data, 0x0002);
        arg << (int)confirm << (int)sdtype << (int)sdmode;
        return dcopClient()->send( "ksmserver", "ksmserver",
                                   "logout(int,int,int)", data );
    }

    if ( mySmcConnection ) {

        SmcRequestSaveYourself( mySmcConnection, 2, 1,
                                2,
                                confirm == ShutdownConfirmNo, 1 );


        IceFlush(SmcGetIceConnection(mySmcConnection));
        return TRUE;
    }



    propagateSessionManager();
    QCString smEnv = ::getenv("SESSION_MANAGER");
    if (smEnv.isEmpty())
        return FALSE;

    if (! tmpSmcConnection) {
        char cerror[256];
        char* myId = 0;
        char* prevId = 0;
        SmcCallbacks cb;
        tmpSmcConnection = SmcOpenConnection( 0, 0, 1, 0,
                                              0, &cb,
                                              prevId,
                                              &myId,
                                              255,
                                              cerror );
        ::free( myId );
        if (!tmpSmcConnection )
            return FALSE;
    }

    SmcRequestSaveYourself( tmpSmcConnection, 2, 1,
                            2, 0, 1 );


    IceFlush(SmcGetIceConnection(tmpSmcConnection));
    return TRUE;




}

void KApplication::propagateSessionManager()
{
    QCString fName = QFile::encodeName(locateLocal("socket", "KSMserver"));
    QCString display = ::getenv("DISPLAY");

    display.replace(QRegExp("\\.[0-9]+$"), "");
    int i;
    while( (i = display.find(':')) >= 0)
       display[i] = '_';

    fName += "_"+display;
    QCString smEnv = ::getenv("SESSION_MANAGER");
    bool check = smEnv.isEmpty();
    if ( !check && smModificationTime ) {
         QFileInfo info( fName );
         QTime current = info.lastModified().time();
         check = current > *smModificationTime;
    }
    if ( check ) {
        delete smModificationTime;
        QFile f( fName );
        if ( !f.open( 0x0001 ) )
            return;
        QFileInfo info ( f );
        smModificationTime = new QTime( info.lastModified().time() );
        QTextStream t(&f);
        t.setEncoding( QTextStream::Latin1 );
        QString s = t.readLine();
        f.close();
        ::setenv( "SESSION_MANAGER", s.latin1(), TRUE );
    }
}

void KApplication::commitData( QSessionManager& sm )
{
    d->session_save = true;
    bool canceled = false;
    for (KSessionManaged* it = sessionClients()->first();
         it && !canceled;
         it = sessionClients()->next() ) {
        canceled = !it->commitData( sm );
    }
    if ( canceled )
        sm.cancel();

    if ( sm.allowsInteraction() ) {
        QWidgetList done;
        QWidgetList *list = QApplication::topLevelWidgets();
        bool canceled = FALSE;
        QWidget* w = list->first();
        while ( !canceled && w ) {
            if ( !w->testWState( WState_ForceHide ) && !w->inherits("KMainWindow") ) {
                QCloseEvent e;
                sendEvent( w, &e );
                canceled = !e.isAccepted();
                if ( !canceled )
                    done.append( w );
                delete list;
                list = QApplication::topLevelWidgets();
                w = list->first();
            } else {
                w = list->next();
            }
            while ( w && done.containsRef( w ) )
                w = list->next();
        }
        delete list;
    }


    if ( !bSessionManagement )
        sm.setRestartHint( QSessionManager::RestartNever );
    else
        sm.setRestartHint( QSessionManager::RestartIfRunning );
    d->session_save = false;
}

void KApplication::saveState( QSessionManager& sm )
{
    d->session_save = true;

    static bool firstTime = true;
    mySmcConnection = (SmcConn) sm.handle();

    if ( !bSessionManagement ) {
        sm.setRestartHint( QSessionManager::RestartNever );
        d->session_save = false;
        return;
    }
    else
        sm.setRestartHint( QSessionManager::RestartIfRunning );
# 1121 "/coolo/prod/kdelibs/kdecore/kapplication.cpp"
    if ( firstTime ) {
        firstTime = false;
        d->session_save = false;
        return;
    }







    if ( pSessionConfig ) {
        delete pSessionConfig;
        pSessionConfig = 0;
    }


    QStringList restartCommand = sm.restartCommand();







    QCString multiHead = getenv("KDE_MULTIHEAD");
    if (multiHead.lower() == "true") {






        QCString displayname = getenv("DISPLAY");
        if (! displayname.isNull()) {


            restartCommand.append("-display");
            restartCommand.append(displayname);
        }
        sm.setRestartCommand( restartCommand );
    }



    saveYourself();
    bool canceled = false;
    for (KSessionManaged* it = sessionClients()->first();
         it && !canceled;
         it = sessionClients()->next() ) {
        canceled = !it->saveState( sm );
    }


    if ( pSessionConfig ) {
        pSessionConfig->sync();
        QStringList discard;
        discard << "rm" << locateLocal("config", sessionConfigName());
        sm.setDiscardCommand( discard );
    } else {
        sm.setDiscardCommand( "" );
    }

    if ( canceled )
        sm.cancel();



    d->session_save = false;
}

bool KApplication::sessionSaving() const
{
    return d->session_save;
}

void KApplication::startKdeinit()
{

  QString srv = KStandardDirs::findExe(QString::fromLatin1("kdeinit"));
  if (srv.isEmpty())
     srv = KStandardDirs::findExe(QString::fromLatin1("kdeinit"), "/coolo/KDE"+QString::fromLatin1("/bin"));
  if (srv.isEmpty())
     return;
  if (KApplication::kApplication() && (Tty != KApplication::kApplication()->type()))
    setOverrideCursor( Qt::waitCursor );
  my_system(QFile::encodeName(srv)+" --suicide");
  if (KApplication::kApplication() && (Tty != KApplication::kApplication()->type()))
    restoreOverrideCursor();
}

void KApplication::dcopFailure(const QString &msg)
{
  static int failureCount = 0;
  failureCount++;
  if (failureCount == 1)
  {
     startKdeinit();
     return;
  }
  if (failureCount == 2)
  {
     QString msgStr(i18n("There was an error setting up inter-process\n"
                      "communications for KDE. The message returned\n"
                      "by the system was:\n\n"));
     msgStr += msg;
     msgStr += i18n("\n\nPlease check that the \"dcopserver\" program is running!");

     if (Tty != KApplication::kApplication()->type())
     {
       QMessageBox::critical
         (
           KApplication::kApplication()->mainWidget(),
           i18n("DCOP communications error (%1)").arg(KApplication::kApplication()->caption()),
           msgStr,
           i18n("OK")
         );
     }
     else
     {
       fprintf(stderr, "%s\n", msgStr.local8Bit().data());
     }

     return;
  }
}

static const KCmdLineOptions qt_options[] =
{


   { "display <displayname>", ("Use the X-server display 'displayname'."), 0},



   { "session <sessionId>", ("Restore the application for the given 'sessionId'."), 0},
   { "cmap", ("Causes the application to install a private color\nmap on an 8-bit display."), 0},
   { "ncols <count>", ("Limits the number of colors allocated in the color\ncube on an 8-bit display, if the application is\nusing the QApplication::ManyColor color\nspecification."), 0},
   { "nograb", ("tells Qt to never grab the mouse or the keyboard."), 0},
   { "dograb", ("running under a debugger can cause an implicit\n-nograb, use -dograb to override."), 0},
   { "sync", ("switches to synchronous mode for debugging."), 0},
   { "fn", 0, 0},
   { "font <fontname>", ("defines the application font."), 0},
   { "bg", 0, 0},
   { "background <color>", ("sets the default background color and an\napplication palette (light and dark shades are\ncalculated)."), 0},
   { "fg", 0, 0},
   { "foreground <color>", ("sets the default foreground color."), 0},
   { "btn", 0, 0},
   { "button <color>", ("sets the default button color."), 0},
   { "name <name>", ("sets the application name."), 0},
   { "title <title>", ("sets the application title (caption)."), 0},

   { "visual TrueColor", ("forces the application to use a TrueColor visual on\nan 8-bit display."), 0},
   { "inputstyle <inputstyle>", ("sets XIM (X Input Method) input style. Possible\nvalues are onthespot, overthespot, offthespot and\nroot."), 0 },
   { "im <XIM server>", ("set XIM server."),0},
   { "noxim", ("disable XIM."), 0 },




   { "reverse", ("mirrors the whole layout of widgets."), 0},
   { 0, 0, 0 }
};

static const KCmdLineOptions kde_options[] =
{
   { "caption <caption>", ("Use 'caption' as name in the titlebar."), 0},
   { "icon <icon>", ("Use 'icon' as the application icon."), 0},
   { "miniicon <icon>", ("Use 'icon' as the icon in the titlebar."), 0},
   { "config <filename>", ("Use alternative configuration file."), 0},
   { "dcopserver <server>", ("Use the DCOP Server specified by 'server'."), 0},
   { "nocrashhandler", ("Disable crash handler, to get core dumps."), 0},
   { "waitforwm", ("Waits for a WM_NET compatible windowmanager."), 0},
   { "style <style>", ("sets the application GUI style."), 0},
   { "geometry <geometry>", ("sets the client geometry of the main widget."), 0},



   { "smkey <sessionKey>", 0, 0},



   { 0, 0, 0 }
};

void
KApplication::addCmdLineOptions()
{
   KCmdLineArgs::addCmdLineOptions(qt_options, "Qt", "qt");
   KCmdLineArgs::addCmdLineOptions(kde_options, "KDE", "kde");
}

void KApplication::parseCommandLine( )
{
    KCmdLineArgs *args = KCmdLineArgs::parsedArgs("kde");

    if (args->isSet("config"))
    {
        QString config = QString::fromLocal8Bit(args->getOption("config"));
        setConfigName(config);
    }

    if (args->isSet("style"))
    {

       QStringList styles = QStyleFactory::keys();
       QString reqStyle(args->getOption("style").lower());

           for (QStringList::ConstIterator it = styles.begin(); it != styles.end(); ++it)
                   if ((*it).lower() == reqStyle)
                   {
                           d->overrideStyle = *it;
                           break;
                   }

       if (d->overrideStyle.isEmpty())
          fprintf(stderr, "%s", i18n("The style %1 was not found\n").arg(reqStyle).local8Bit().data());
    }

    if (args->isSet("caption"))
    {
       aCaption = QString::fromLocal8Bit(args->getOption("caption"));
    }

    if (args->isSet("miniicon"))
    {
       const char *tmp = args->getOption("miniicon");
       aMiniIconPixmap = SmallIcon(tmp);
       aMiniIconName = tmp;
    }

    if (args->isSet("icon"))
    {
       const char *tmp = args->getOption("icon");
       aIconPixmap = DesktopIcon( tmp );
       aIconName = tmp;
       if (aMiniIconPixmap.isNull())
       {
          aMiniIconPixmap = SmallIcon( tmp );
          aMiniIconName = tmp;
       }
    }

    bool nocrashhandler = (getenv("KDE_DEBUG") != __null);
    if (!nocrashhandler && args->isSet("crashhandler"))
    {

        KCrash::setCrashHandler(KCrash::defaultCrashHandler);
        KCrash::setEmergencySaveFunction(__null);

        KCrash::setApplicationName(QString(args->appName()));
    }


    if ( args->isSet( "waitforwm" ) ) {
        Atom type;
        (void) desktop();
        int format;
        unsigned long length, after;
        unsigned char *data;
        while ( XGetWindowProperty( qt_xdisplay(), qt_xrootwin(), atom_NetSupported,
                                    0, 1, FALSE, 0L, &type, &format,
                                    &length, &after, &data ) != Success || !length ) {
            if ( data )
                XFree( data );
            XEvent event;
            XWindowEvent( qt_xdisplay(), qt_xrootwin(), (1L<<22), &event );
        }
        if ( data )
            XFree( data );
    }




    if (args->isSet("geometry"))
    {
        d->geometry_arg = args->getOption("geometry");
    }

    if (args->isSet("smkey"))
    {
        d->sessionKey = args->getOption("smkey");
    }

}

QString KApplication::geometryArgument() const
{
    return d->geometry_arg;
}

QPixmap KApplication::icon() const
{
  if( aIconPixmap.isNull()) {
      KApplication *that = const_cast<KApplication *>(this);
      that->aIconPixmap = DesktopIcon( instanceName() );
  }
  return aIconPixmap;
}

QString KApplication::iconName() const
{
  return aIconName.isNull() ? (QString)instanceName() : aIconName;
}

QPixmap KApplication::miniIcon() const
{
  if (aMiniIconPixmap.isNull()) {
      KApplication *that = const_cast<KApplication *>(this);
      that->aMiniIconPixmap = SmallIcon( instanceName() );
  }
  return aMiniIconPixmap;
}

QString KApplication::miniIconName() const
{
  return aMiniIconName.isNull() ? (QString)instanceName() : aMiniIconName;
}

extern void kDebugCleanup();

KApplication::~KApplication()
{
  delete d->m_KAppDCOPInterface;




  KGlobal::deleteStaticDeleters();
  KLibLoader::cleanUp();

  delete smw;


  delete s_DCOPClient;
  s_DCOPClient = 0L;

  KProcessController::deref();

  if ( d->oldXErrorHandler != __null )
      XSetErrorHandler( d->oldXErrorHandler );
  if ( d->oldXIOErrorHandler != __null )
      XSetIOErrorHandler( d->oldXIOErrorHandler );
  if ( d->oldIceIOErrorHandler != __null )
      IceSetIOErrorHandler( d->oldIceIOErrorHandler );

  delete d;
  KApp = 0;


  mySmcConnection = 0;
  delete smModificationTime;
  smModificationTime = 0;


  if (tmpSmcConnection) {
      SmcCloseConnection( tmpSmcConnection, 0, 0 );
      tmpSmcConnection = 0;
  }



}



class KAppX11HackWidget: public QWidget
{
public:
    bool publicx11Event( XEvent * e) { return x11Event( e ); }
};




static bool kapp_block_user_input = false;

void KApplication::dcopBlockUserInput( bool b )
{
    kapp_block_user_input = b;
}


bool KApplication::x11EventFilter( XEvent *_event )
{
    switch ( _event->type ) {
        case 4:
        case XKeyPress:
        {
            if( _event->type == 4 )
                qt_x_last_input_time = _event->xbutton.time;
            else
                qt_x_last_input_time = _event->xkey.time;
            QWidget* w = activeWindow();
            if( w ) {
                XChangeProperty( qt_xdisplay(), w->winId(), kde_net_wm_user_time, ((Atom) 6),
                    32, 0, (unsigned char*)&qt_x_time, 1 );
                timeval tv;
                gettimeofday( &tv, __null );
                unsigned long now = tv.tv_sec * 10 + tv.tv_usec / 100000;
                XChangeProperty(qt_xdisplay(), w->winId(),
                            atom_KdeNetUserTime, ((Atom) 6),
                            32, 0, (unsigned char *)&now, 1);
            }
        }
        break;
        default: break;
    }

    if ( kapp_block_user_input ) {
        switch ( _event->type ) {
        case 4:
        case 5:
        case XKeyPress:
        case XKeyRelease:
        case 6:
            return TRUE;
        default:
            break;
        }
    }

    if (x11Filter) {
        for (QWidget *w=x11Filter->first(); w; w=x11Filter->next()) {
            if (((KAppX11HackWidget*) w)->publicx11Event(_event))
                return true;
        }
    }


    if ((_event->type == 33) &&
            (_event->xclient.message_type == kipcCommAtom))
    {
        XClientMessageEvent *cme = (XClientMessageEvent *) _event;

        int id = cme->data.l[0];
        int arg = cme->data.l[1];
        if ((id < 32) && (kipcEventMask & (1 << id)))
        {
            switch (id)
            {
            case KIPC::StyleChanged:
                KGlobal::config()->reparseConfiguration();
                kdisplaySetStyle();
                break;

            case KIPC::ToolbarStyleChanged:
                KGlobal::config()->reparseConfiguration();
                if (useStyles)
                    toolbarAppearanceChanged(arg);
                break;

            case KIPC::PaletteChanged:
                KGlobal::config()->reparseConfiguration();
                kdisplaySetPalette();
                break;

            case KIPC::FontChanged:
                KGlobal::config()->reparseConfiguration();
                KGlobalSettings::rereadFontSettings();
                kdisplaySetFont();
                break;

            case KIPC::BackgroundChanged:
                backgroundChanged(arg);
                break;

            case KIPC::SettingsChanged:
                KGlobal::config()->reparseConfiguration();
                if (arg == SETTINGS_PATHS)
                    KGlobalSettings::rereadPathSettings();
                else if (arg == SETTINGS_MOUSE)
                    KGlobalSettings::rereadMouseSettings();
                propagateSettings((SettingsCategory)arg);
                break;

            case KIPC::IconChanged:
                QPixmapCache::clear();
                KGlobal::config()->reparseConfiguration();
                KGlobal::instance()->newIconLoader();
                iconChanged(arg);
                break;

            case KIPC::ClipboardConfigChanged:
                KClipboardSynchronizer::newConfiguration(arg);
                break;
            }
        }
        else if (id >= 32)
        {
            kipcMessage(id, arg);
        }
        return true;
    }

    return false;
}


void KApplication::invokeEditSlot( const char *slot )
{
  QObject *object = focusWidget();
  if( !object )
    return;

  QMetaObject *meta = object->metaObject();

  int idx = meta->findSlot( slot + 1, true );
  if( idx < 0 )
    return;

  object->qt_invoke( idx, 0 );
}

void KApplication::addKipcEventMask(int id)
{
    if (id >= 32)
    {
        kdDebug(101) << "Cannot use KIPC event mask for message IDs >= 32\n";
        return;
    }
    kipcEventMask |= (1 << id);
}

void KApplication::removeKipcEventMask(int id)
{
    if (id >= 32)
    {
        kdDebug(101) << "Cannot use KIPC event mask for message IDs >= 32\n";
        return;
    }
    kipcEventMask &= ~(1 << id);
}

void KApplication::enableStyles()
{
    if (!useStyles)
    {
        useStyles = true;
        applyGUIStyle();
    }
}

void KApplication::disableStyles()
{
    useStyles = false;
}

void KApplication::applyGUIStyle()
{
    if ( !useStyles ) return;

    KConfigGroup pConfig (KGlobal::config(), "General");
    QString defaultStyle = KStyle::defaultStyle();
    QString styleStr = pConfig.readEntry("widgetStyle", defaultStyle);

    if (d->overrideStyle.isEmpty()) {



      QStyle* sp = QStyleFactory::create( styleStr );


      if ( !sp && styleStr != defaultStyle)
          sp = QStyleFactory::create( defaultStyle );
      if ( !sp )
          sp = QStyleFactory::create( *(QStyleFactory::keys().begin()) );
      setStyle(sp);
    }
    else
        setStyle(d->overrideStyle);

    kdisplaySetPalette();
}

QString KApplication::caption() const
{

  if( !aCaption.isNull() )
        return aCaption;
  else

      if ( KGlobal::instance()->aboutData() )
        return KGlobal::instance()->aboutData()->programName();
      else

        return name();
}






QString KApplication::makeStdCaption( const QString &userCaption,
                                      bool withAppName, bool modified ) const
{
  QString s = userCaption.isEmpty() ? caption() : userCaption;


  if (modified)
      s += QString::fromUtf8(" [") + i18n("modified") + QString::fromUtf8("]");

  if ( !userCaption.isEmpty() ) {


      if ( withAppName && !caption().isNull() && !userCaption.endsWith(caption()) )
          s += QString::fromUtf8(" - ") + caption();
  }

  return s;
}

QPalette KApplication::createApplicationPalette()
{
    KConfig *config = KGlobal::config();
    KConfigGroupSaver saver( config, "General" );
    return createApplicationPalette( config, KGlobalSettings::contrast() );
}

QPalette KApplication::createApplicationPalette( KConfig *config, int contrast_ )
{
    QColor kde31Background( 238, 238, 230 );
    QColor kde31Beige( 255,221,118 );

    QColor kde31Button;
    if ( QPixmap::defaultDepth() > 8 )
      kde31Button.setRgb( 238, 234, 222 );
    else
      kde31Button.setRgb( 220, 220, 220 );

    QColor kde31Link( 0, 0, 192 );
    QColor kde31VisitedLink( 128, 0,128 );

    QColor background = config->readColorEntry( "background", &kde31Background );
    QColor foreground = config->readColorEntry( "foreground", &black );
    QColor button = config->readColorEntry( "buttonBackground", &kde31Button );
    QColor buttonText = config->readColorEntry( "buttonForeground", &foreground );
    QColor highlight = config->readColorEntry( "selectBackground", &kde31Beige );
    QColor highlightedText = config->readColorEntry( "selectForeground", &black );
    QColor base = config->readColorEntry( "windowBackground", &white );
    QColor baseText = config->readColorEntry( "windowForeground", &black );
    QColor link = config->readColorEntry( "linkColor", &kde31Link );
    QColor visitedLink = config->readColorEntry( "visitedLinkColor", &kde31VisitedLink );

    int highlightVal, lowlightVal;
    highlightVal = 100 + (2*contrast_+4)*16/10;
    lowlightVal = 100 + (2*contrast_+4)*10;

    QColor disfg = foreground;

    int h, s, v;
    disfg.hsv( &h, &s, &v );
    if (v > 128)

        disfg = disfg.dark(lowlightVal);
    else if (disfg != black)

        disfg = disfg.light(highlightVal);
    else

        disfg = Qt::darkGray;


    QColorGroup disabledgrp(disfg, background,
                            background.light(highlightVal),
                            background.dark(lowlightVal),
                            background.dark(120),
                            background.dark(120), base);

    QColorGroup colgrp(foreground, background, background.light(highlightVal),
                       background.dark(lowlightVal),
                       background.dark(120),
                       baseText, base);

    int inlowlightVal = lowlightVal-25;
    if(inlowlightVal < 120)
        inlowlightVal = 120;

    colgrp.setColor(QColorGroup::Highlight, highlight);
    colgrp.setColor(QColorGroup::HighlightedText, highlightedText);
    colgrp.setColor(QColorGroup::Button, button);
    colgrp.setColor(QColorGroup::ButtonText, buttonText);
    colgrp.setColor(QColorGroup::Midlight, background.light(110));
    colgrp.setColor(QColorGroup::Link, link);
    colgrp.setColor(QColorGroup::LinkVisited, visitedLink);

    disabledgrp.setColor(QColorGroup::Button, button);

    QColor disbtntext = buttonText;
    disbtntext.hsv( &h, &s, &v );
    if (v > 128)

        disbtntext = disbtntext.dark(lowlightVal);
    else if (disbtntext != black)

        disbtntext = disbtntext.light(highlightVal);
    else

        disbtntext = Qt::darkGray;

    disabledgrp.setColor(QColorGroup::ButtonText, disbtntext);
    disabledgrp.setColor(QColorGroup::Midlight, background.light(110));
    disabledgrp.setColor(QColorGroup::Highlight, highlight.dark(120));
    disabledgrp.setColor(QColorGroup::Link, link);
    disabledgrp.setColor(QColorGroup::LinkVisited, visitedLink);

    return QPalette(colgrp, disabledgrp, colgrp);
}


void KApplication::kdisplaySetPalette()
{
    QApplication::setPalette( createApplicationPalette(), true);
    kdisplayPaletteChanged();
    appearanceChanged();
}


void KApplication::kdisplaySetFont()
{
    QApplication::setFont(KGlobalSettings::generalFont(), true);
    QApplication::setFont(KGlobalSettings::menuFont(), true, "QMenuBar");
    QApplication::setFont(KGlobalSettings::menuFont(), true, "QPopupMenu");
    QApplication::setFont(KGlobalSettings::menuFont(), true, "KPopupTitle");


    QStyleSheet* sheet = QStyleSheet::defaultSheet();
    sheet->item ("pre")->setFontFamily (KGlobalSettings::fixedFont().family());
    sheet->item ("code")->setFontFamily (KGlobalSettings::fixedFont().family());
    sheet->item ("tt")->setFontFamily (KGlobalSettings::fixedFont().family());

    kdisplayFontChanged();
    appearanceChanged();
}


void KApplication::kdisplaySetStyle()
{
    if (useStyles)
    {
        applyGUIStyle();
        kdisplayStyleChanged();
        appearanceChanged();
    }
}


void KApplication::propagateSettings(SettingsCategory arg)
{
    KConfigBase* config = KGlobal::config();
    KConfigGroupSaver saver( config, "KDE" );

    int num = config->readNumEntry("CursorBlinkRate", QApplication::cursorFlashTime());
    if (num < 200)
        num = 200;
    if (num > 2000)
        num = 2000;
    QApplication::setCursorFlashTime(num);
    num = config->readNumEntry("DoubleClickInterval", QApplication::doubleClickInterval());
    QApplication::setDoubleClickInterval(num);
    num = config->readNumEntry("StartDragTime", QApplication::startDragTime());
    QApplication::setStartDragTime(num);
    num = config->readNumEntry("StartDragDist", QApplication::startDragDistance());
    QApplication::setStartDragDistance(num);
    num = config->readNumEntry("WheelScrollLines", QApplication::wheelScrollLines());
    QApplication::setWheelScrollLines(num);

    bool b = config->readBoolEntry("EffectAnimateMenu", false);
    QApplication::setEffectEnabled( Qt::UI_AnimateMenu, b);
    b = config->readBoolEntry("EffectFadeMenu", false);
    QApplication::setEffectEnabled( Qt::UI_FadeMenu, b);
    b = config->readBoolEntry("EffectAnimateCombo", false);
    QApplication::setEffectEnabled( Qt::UI_AnimateCombo, b);
    b = config->readBoolEntry("EffectAnimateTooltip", false);
    QApplication::setEffectEnabled( Qt::UI_AnimateTooltip, b);
    b = config->readBoolEntry("EffectFadeTooltip", false);
    QApplication::setEffectEnabled( Qt::UI_FadeTooltip, b);
    b = !config->readBoolEntry("EffectNoTooltip", false);
    QToolTip::setGloballyEnabled( b );

    settingsChanged(arg);
}

void KApplication::installKDEPropertyMap()
{







    QSqlPropertyMap *kdeMap = new QSqlPropertyMap;
    kdeMap->insert( "KColorButton", "color" );
    kdeMap->insert( "KComboBox", "currentItem" );
    kdeMap->insert( "KDatePicker", "date" );
    kdeMap->insert( "KEditListBox", "currentItem" );
    kdeMap->insert( "KFontCombo", "family" );
    kdeMap->insert( "KFontRequester", "font" );
    kdeMap->insert( "KFontChooser", "font" );
    kdeMap->insert( "KHistoryCombo", "currentItem" );
    kdeMap->insert( "KListBox", "currentItem" );
    kdeMap->insert( "KLineEdit", "text" );
    kdeMap->insert( "KRestrictedLine", "text" );
    kdeMap->insert( "KSqueezedTextLabel", "text" );
    kdeMap->insert( "KTextBrowser", "source" );
    kdeMap->insert( "KTextEdit", "text" );
    kdeMap->insert( "KURLRequester", "url" );
    kdeMap->insert( "KPasswordEdit", "password" );
    kdeMap->insert( "KIntNumInput", "value" );
    kdeMap->insert( "KIntSpinBox", "value" );
    kdeMap->insert( "KDoubleNumInput", "value" );





      kdeMap->insert( "QTabWidget", "currentPage" );

    QSqlPropertyMap::installDefaultMap( kdeMap );

}

void KApplication::invokeHelp( const QString& anchor,
                               const QString& _appname) const
{
   QString url;
   QString appname;
   if (_appname.isEmpty())
     appname = name();
   else
     appname = _appname;

   if (!anchor.isEmpty())
     url = QString("help:/%1?anchor=%2").arg(appname).arg(anchor);
   else
     url = QString("help:/%1/index.html").arg(appname);

   QString error;
   if ( !dcopClient()->isApplicationRegistered("khelpcenter") )
   {
       if (startServiceByDesktopName("khelpcenter", url, &error, 0, 0, "", true))
       {
           kdWarning() << "Could not launch help:\n" << error << endl;
           return;
       }
   }
   else
       DCOPRef( "khelpcenter", "KHelpCenterIface" ).send( "openURL", url );
}

void KApplication::invokeHTMLHelp( const QString& _filename, const QString& topic ) const
{
   kdWarning() << "invoking HTML help is deprecated! use docbook and invokeHelp!\n";

   QString filename;

   if( _filename.isEmpty() )
     filename = QString(name()) + "/index.html";
   else
     filename = _filename;

   QString url;
   if (!topic.isEmpty())
     url = QString("help:/%1#%2").arg(filename).arg(topic);
   else
     url = QString("help:/%1").arg(filename);

   QString error;
   if ( !dcopClient()->isApplicationRegistered("khelpcenter") )
   {
       if (startServiceByDesktopName("khelpcenter", url, &error, 0, 0, "", true))
       {
           kdWarning() << "Could not launch help:\n" << error << endl;
           return;
       }
   }
   else
       DCOPRef( "khelpcenter", "KHelpCenterIface" ).send( "openURL", url );
}


void KApplication::invokeMailer(const QString &address, const QString &subject)
{
   invokeMailer(address, QString::null, QString::null, subject, QString::null, QString::null, QStringList());
}

void KApplication::invokeMailer(const KURL &mailtoURL)
{
   QString address = KURL::decode_string(mailtoURL.path()), subject, cc, bcc, body, attach;
   QStringList queries = QStringList::split('&', mailtoURL.query().mid(1));
   for (QStringList::Iterator it = queries.begin(); it != queries.end(); ++it)
   {
     QString q = (*it).lower();
     if (q.startsWith("subject="))
       subject = KURL::decode_string((*it).mid(8));
     else
     if (q.startsWith("cc="))
       cc = KURL::decode_string((*it).mid(3));
     else
     if (q.startsWith("bcc="))
       bcc = KURL::decode_string((*it).mid(4));
     else
     if (q.startsWith("body="))
       body = KURL::decode_string((*it).mid(5));



   }

   invokeMailer( address, cc, bcc, subject, body, QString::null, QStringList() );
}

void KApplication::invokeMailer(const QString &to, const QString &cc, const QString &bcc,
                                const QString &subject, const QString &body,
                                const QString & , const QStringList &attachURLs)
{
   KConfig config("emaildefaults");
   config.setGroup( QString::fromLatin1("PROFILE_Default") );
   QString command = config.readPathEntry("EmailClient");

   if (command.isEmpty() || command == QString::fromLatin1("kmail")
       || command.endsWith("/kmail"))
     command = QString::fromLatin1("kmail --composer -s %s -c %c -b %b --body %B --attach %A %t");






   if (config.readBoolEntry("TerminalClient", false))
      command = "konsole -e " + command;

   QStringList cmdTokens = KShell::splitArgs(command);
   QString cmd = cmdTokens[0];
   cmdTokens.remove(cmdTokens.begin());

   QMap<QChar, QString> keyMap;
   keyMap.insert('t', to);
   keyMap.insert('s', subject);
   keyMap.insert('c', cc);
   keyMap.insert('b', bcc);
   keyMap.insert('B', body);

   for (QStringList::Iterator it = cmdTokens.begin(); it != cmdTokens.end(); )
   {
     if (*it == "%A")
     {
         if (it == cmdTokens.begin())
             continue;
         QStringList::ConstIterator urlit = attachURLs.begin();
         QStringList::ConstIterator urlend = attachURLs.end();
         if ( urlit != urlend )
         {
             QStringList::Iterator previt = it;
             --previt;
             *it = *urlit;
             ++it;
             while ( ++urlit != urlend )
             {
                 cmdTokens.insert( it, *previt );
                 cmdTokens.insert( it, *urlit );
             }
         } else {
             --it;
             it = cmdTokens.remove( cmdTokens.remove( it ) );
         }
     } else {
         *it = KMacroExpander::expandMacros(*it, keyMap);
         ++it;
     }
   }

   QString error;
   if (kdeinitExec(cmd, cmdTokens, &error))
      kdWarning() << "Could not launch mail client:\n" << error << endl;
}


void KApplication::invokeBrowser( const QString &url )
{
   QString error;

   if (startServiceByDesktopName("kfmclient", url, &error, 0, 0, "", true))
   {
      kdWarning() << "Could not launch browser:\n" << error << endl;
      return;
   }
}

void KApplication::cut()
{
  invokeEditSlot( "1""cut()" );
}

void KApplication::copy()
{
  invokeEditSlot( "1""copy()" );
}

void KApplication::paste()
{
  invokeEditSlot( "1""paste()" );
}

void KApplication::clear()
{
  invokeEditSlot( "1""clear()" );
}

void KApplication::selectAll()
{
  invokeEditSlot( "1""selectAll()" );
}

QCString
KApplication::launcher()
{
   return "klauncher";
}

static int
startServiceInternal( const QCString &function,
              const QString& _name, const QStringList &URLs,
              QString *error, QCString *dcopService, int *pid, const QCString& startup_id, bool noWait )
{
   struct serviceResult
   {
      int result;
      QCString dcopName;
      QString error;
      pid_t pid;
   };


   DCOPClient *dcopClient;
   if (KApplication::kApplication())
      dcopClient = KApplication::kApplication()->dcopClient();
   else
      dcopClient = new DCOPClient;

   if (!dcopClient->isAttached())
   {
      if (!dcopClient->attach())
      {
         if (error)
            *error = i18n("Could not register with DCOP.\n");
         return -1;
      }
   }
   QByteArray params;
   QDataStream stream(params, 0x0002);
   stream << _name << URLs;
   QCString replyType;
   QByteArray replyData;
   QCString _launcher = KApplication::launcher();
   QValueList<QCString> envs;

   if (qt_xdisplay()) {
       QCString dpystring(XDisplayString(qt_xdisplay()));
       envs.append( QCString("DISPLAY=") + dpystring );
   } else if( getenv( "DISPLAY" )) {
       QCString dpystring( getenv( "DISPLAY" ));
       envs.append( QCString("DISPLAY=") + dpystring );
   }

   stream << envs;
   if( !startup_id.isNull())
       stream << startup_id << noWait;

   if (!dcopClient->call(_launcher, _launcher,
        function, params, replyType, replyData))
   {
        if (error)
           *error = i18n("KLauncher could not be reached via DCOP.\n");
        if (!KApplication::kApplication())
           delete dcopClient;
        return -1;
   }
   if (!KApplication::kApplication())
      delete dcopClient;

   if (noWait)
      return 0;

   QDataStream stream2(replyData, 0x0001);
   serviceResult result;
   stream2 >> result.result >> result.dcopName >> result.error >> result.pid;
   if (dcopService)
      *dcopService = result.dcopName;
   if (error)
      *error = result.error;
   if (pid)
      *pid = result.pid;
   return result.result;
}

int
KApplication::startServiceByName( const QString& _name, const QString &URL,
                  QString *error, QCString *dcopService, int *pid, const QCString& startup_id, bool noWait )
{
   QStringList URLs;
   if (!URL.isEmpty())
      URLs.append(URL);
   return startServiceInternal(
                      "start_service_by_name(QString,QStringList,QValueList<QCString>,QCString,bool)",
                      _name, URLs, error, dcopService, pid, startup_id, noWait);
}

int
KApplication::startServiceByName( const QString& _name, const QStringList &URLs,
                  QString *error, QCString *dcopService, int *pid, const QCString& startup_id, bool noWait )
{
   return startServiceInternal(
                      "start_service_by_name(QString,QStringList,QValueList<QCString>,QCString,bool)",
                      _name, URLs, error, dcopService, pid, startup_id, noWait);
}

int
KApplication::startServiceByDesktopPath( const QString& _name, const QString &URL,
                  QString *error, QCString *dcopService, int *pid, const QCString& startup_id, bool noWait )
{
   QStringList URLs;
   if (!URL.isEmpty())
      URLs.append(URL);
   return startServiceInternal(
                      "start_service_by_desktop_path(QString,QStringList,QValueList<QCString>,QCString,bool)",
                      _name, URLs, error, dcopService, pid, startup_id, noWait);
}

int
KApplication::startServiceByDesktopPath( const QString& _name, const QStringList &URLs,
                  QString *error, QCString *dcopService, int *pid, const QCString& startup_id, bool noWait )
{
   return startServiceInternal(
                      "start_service_by_desktop_path(QString,QStringList,QValueList<QCString>,QCString,bool)",
                      _name, URLs, error, dcopService, pid, startup_id, noWait);
}

int
KApplication::startServiceByDesktopName( const QString& _name, const QString &URL,
                  QString *error, QCString *dcopService, int *pid, const QCString& startup_id, bool noWait )
{
   QStringList URLs;
   if (!URL.isEmpty())
      URLs.append(URL);
   return startServiceInternal(
                      "start_service_by_desktop_name(QString,QStringList,QValueList<QCString>,QCString,bool)",
                      _name, URLs, error, dcopService, pid, startup_id, noWait);
}

int
KApplication::startServiceByDesktopName( const QString& _name, const QStringList &URLs,
                  QString *error, QCString *dcopService, int *pid, const QCString& startup_id, bool noWait )
{
   return startServiceInternal(
                      "start_service_by_desktop_name(QString,QStringList,QValueList<QCString>,QCString,bool)",
                      _name, URLs, error, dcopService, pid, startup_id, noWait);
}

int
KApplication::kdeinitExec( const QString& name, const QStringList &args,
                           QString *error, int *pid )
{
   return startServiceInternal("kdeinit_exec(QString,QStringList,QValueList<QCString>)",
        name, args, error, 0, pid, QCString(), false);
}

int
KApplication::kdeinitExecWait( const QString& name, const QStringList &args,
                           QString *error, int *pid )
{
   return startServiceInternal("kdeinit_exec_wait(QString,QStringList,QValueList<QCString>)",
        name, args, error, 0, pid, QCString(), false);
}

QString KApplication::tempSaveName( const QString& pFilename ) const
{
  QString aFilename;

  if( pFilename[0] != '/' )
    {
      kdWarning(101) << "Relative filename passed to KApplication::tempSaveName" << endl;
      aFilename = QFileInfo( QDir( "." ), pFilename ).absFilePath();
    }
  else
    aFilename = pFilename;

  QDir aAutosaveDir( QDir::homeDirPath() + "/autosave/" );
  if( !aAutosaveDir.exists() )
    {
      if( !aAutosaveDir.mkdir( aAutosaveDir.absPath() ) )
        {

          aAutosaveDir.setPath( KGlobal::dirs()->saveLocation("tmp") );
        }
    }

  aFilename.replace( "/", "\\!" ).prepend( "#" ).append( "#" ).prepend( "/" ).prepend( aAutosaveDir.absPath() );

  return aFilename;
}


QString KApplication::checkRecoverFile( const QString& pFilename,
        bool& bRecover ) const
{
  QString aFilename;

  if( pFilename[0] != '/' )
    {
      kdWarning(101) << "Relative filename passed to KApplication::tempSaveName" << endl;
      aFilename = QFileInfo( QDir( "." ), pFilename ).absFilePath();
    }
  else
    aFilename = pFilename;

  QDir aAutosaveDir( QDir::homeDirPath() + "/autosave/" );
  if( !aAutosaveDir.exists() )
    {
      if( !aAutosaveDir.mkdir( aAutosaveDir.absPath() ) )
        {

          aAutosaveDir.setPath( KGlobal::dirs()->saveLocation("tmp") );
        }
    }

  aFilename.replace( "/", "\\!" ).prepend( "#" ).append( "#" ).prepend( "/" ).prepend( aAutosaveDir.absPath() );

  if( QFile( aFilename ).exists() )
    {
      bRecover = true;
      return aFilename;
    }
  else
    {
      bRecover = false;
      return pFilename;
    }
}


bool checkAccess(const QString& pathname, int mode)
{
  int accessOK = access( QFile::encodeName(pathname), mode );
  if ( accessOK == 0 )
    return true;




  if ( (mode & 2) == 0 )
    return false;


  if (!access( QFile::encodeName(pathname), 0))
      return false;


  QString dirName(pathname);
  int pos = dirName.findRev('/');
  if ( pos == -1 )
    return false;
  else if ( pos == 0 )
      pos = 1;

  dirName.truncate(pos);

  accessOK = access( QFile::encodeName(dirName), 2 );

  if ( accessOK == 0 )
    return true;
  else
    return false;
}

void KApplication::setTopWidget( QWidget *topWidget )
{
  if( topWidget != 0 )
  {

    Window leader = topWidget->winId();
    char* argv = const_cast< char* >( KCmdLineArgs::appName());
    XSetCommand(display, leader, &argv, 1);

    XWMHints *hints = XGetWMHints(display, topWidget->winId());
    if (hints)
    {
        if (!(hints->flags & (1L << 6)))
        {
            hints->window_group = leader;
            hints->flags |= (1L << 6);
        }
        if (!(hints->flags & (1L << 0)))
        {
            hints->input = 1;
            hints->flags |= (1L << 0);
        }
        XSetWMHints(display, topWidget->winId(), hints);
        XFree(reinterpret_cast<char *>(hints));
    }



    if ( !topWidget->inherits("KMainWindow") ) {
        topWidget->setCaption( caption() );


        NETWinInfo info(qt_xdisplay(), topWidget->winId(), qt_xrootwin(), NET::WMName );
        info.setName( caption().utf8().data() );

    }


    topWidget->setIcon( icon() );


    KWin::setIcons(topWidget->winId(), icon(), miniIcon() );


    KStartupInfo::setWindowStartupId( topWidget->winId(), startupId());

  }
}

QCString KApplication::startupId() const
{
    return d->startup_id;
}

void KApplication::setStartupId( const QCString& startup_id )
{
    if( startup_id.isEmpty())
        d->startup_id = "0";
    else
        d->startup_id = startup_id;
}



void KApplication::read_app_startup_id()
{

    KStartupInfoId id = KStartupInfo::currentStartupIdEnv();
    KStartupInfo::resetStartupEnv();
    d->startup_id = id.id();

}

int KApplication::random()
{
   static int init = false;
   if (!init)
   {
      unsigned int seed;
      init = true;
      int fd = open("/dev/urandom", 00);
      if (fd <= 0 || ::read(fd, &seed, sizeof(seed)) != sizeof(seed))
      {

            srand(getpid());
            seed = rand()+time(0);
      }
      if (fd >= 0) close(fd);
      srand(seed);
   }
   return rand();
}

QString KApplication::randomString(int length)
{
   if (length <=0 ) return QString::null;

   QString str;
   while (length--)
   {
      int r=random() % 62;
      r+=48;
      if (r>57) r+=7;
      if (r>90) r+=6;
      str += char(r);

   }
   return str;
}

bool KApplication::authorize(const QString &genericAction)
{
   if (!d->actionRestrictions)
      return true;

   KConfig *config = KGlobal::config();
   KConfigGroupSaver saver( config, "KDE Action Restrictions" );
   return config->readBoolEntry(genericAction, true);
}

bool KApplication::authorizeKAction(const char *action)
{
   if (!d->actionRestrictions || !action)
      return true;

   static const QString &action_prefix = KGlobal::staticQString( "action/" );

   return authorize(action_prefix + action);
}

void KApplication::initUrlActionRestrictions()
{
  d->urlActionRestrictions.setAutoDelete(true);
  d->urlActionRestrictions.clear();
  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("open", QString::null, QString::null, QString::null, QString::null, QString::null, QString::null, true));
  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("list", QString::null, QString::null, QString::null, QString::null, QString::null, QString::null, true));





  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("link", QString::null, QString::null, QString::null, ":internet", QString::null, QString::null, true));
  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("redirect", QString::null, QString::null, QString::null, ":internet", QString::null, QString::null, true));



  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("redirect", QString::null, QString::null, QString::null, "file", QString::null, QString::null, true));
  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("redirect", ":internet", QString::null, QString::null, "file", QString::null, QString::null, false));


  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("redirect", ":local", QString::null, QString::null, QString::null, QString::null, QString::null, true));


  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("redirect", QString::null, QString::null, QString::null, "about", QString::null, QString::null, true));


  d->urlActionRestrictions.append( new KApplicationPrivate::URLActionRule
  ("redirect", QString::null, QString::null, QString::null, "=", QString::null, QString::null, true));

  KConfig *config = KGlobal::config();
  KConfigGroupSaver saver( config, "KDE URL Restrictions" );
  int count = config->readNumEntry("rule_count");
  QString keyFormat = QString("rule_%1");
  for(int i = 1; i <= count; i++)
  {
    QString key = keyFormat.arg(i);
    QStringList rule = config->readListEntry(key);
    if (rule.count() != 8)
      continue;
    QString action = rule[0];
    QString refProt = rule[1];
    QString refHost = rule[2];
    QString refPath = rule[3];
    QString urlProt = rule[4];
    QString urlHost = rule[5];
    QString urlPath = rule[6];
    QString strEnabled = rule[7].lower();

    bool bEnabled = (strEnabled == "true");

    if (refPath.startsWith("$HOME"))
       refPath.replace(0, 5, QDir::homeDirPath());
    else if (refPath.startsWith("~"))
       refPath.replace(0, 1, QDir::homeDirPath());
    if (urlPath.startsWith("$HOME"))
       urlPath.replace(0, 5, QDir::homeDirPath());
    else if (urlPath.startsWith("~"))
       urlPath.replace(0, 1, QDir::homeDirPath());

    if (refPath.startsWith("$TMP"))
       refPath.replace(0, 4, KGlobal::dirs()->saveLocation("tmp"));
    if (urlPath.startsWith("$TMP"))
       urlPath.replace(0, 4, KGlobal::dirs()->saveLocation("tmp"));

    d->urlActionRestrictions.append(new KApplicationPrivate::URLActionRule
        ( action, refProt, refHost, refPath, urlProt, urlHost, urlPath, bEnabled));
  }
}

bool KApplication::authorizeURLAction(const QString &action, const KURL &_baseURL, const KURL &_destURL)
{
  bool result = false;
  if (d->urlActionRestrictions.isEmpty())
     initUrlActionRestrictions();

  KURL baseURL(_baseURL);
  baseURL.setPath(QDir::cleanDirPath(baseURL.path()));
  QString baseClass = KProtocolInfo::protocolClass(baseURL.protocol());
  KURL destURL(_destURL);
  destURL.setPath(QDir::cleanDirPath(destURL.path()));
  QString destClass = KProtocolInfo::protocolClass(destURL.protocol());

  for(KApplicationPrivate::URLActionRule *rule = d->urlActionRestrictions.first();
      rule; rule = d->urlActionRestrictions.next())
  {
     if ((result != rule->permission) &&
         (action == rule->action) &&
         rule->baseMatch(baseURL, baseClass) &&
         rule->destMatch(destURL, destClass, baseURL, baseClass))
     {
        result = rule->permission;
     }
  }
  return result;
}


uint KApplication::keyboardModifiers()
{
    Window root;
    Window child;
    int root_x, root_y, win_x, win_y;
    uint keybstate;
    XQueryPointer( qt_xdisplay(), qt_xrootwin(), &root, &child,
                   &root_x, &root_y, &win_x, &win_y, &keybstate );
    return keybstate & 0x00ff;
}

uint KApplication::mouseState()
{
    Window root;
    Window child;
    int root_x, root_y, win_x, win_y;
    uint keybstate;
    XQueryPointer( qt_xdisplay(), qt_xrootwin(), &root, &child,
                   &root_x, &root_y, &win_x, &win_y, &keybstate );
    return keybstate & 0xff00;
}

void KApplication::installSigpipeHandler()
{
    struct sigaction act;
    act.__sigaction_handler.sa_handler = sigpipeHandler;
    sigemptyset( &act.sa_mask );
    act.sa_flags = 0;
    sigaction( 13, &act, 0 );
}

void KApplication::sigpipeHandler(int)
{
    int saved_errno = (*__errno_location ());


    char msg[1000];
    sprintf(msg, "*** SIGPIPE *** (ignored, pid = %ld)\n", (long) getpid());
    write(2, msg, strlen(msg));



    (*__errno_location ()) = saved_errno;
}

void KApplication::virtual_hook( int id, void* data )
{ KInstance::virtual_hook( id, data ); }

void KSessionManaged::virtual_hook( int, void* )
{ }

# 1 "../kdecore/kapplication.moc" 1
# 10 "../kdecore/kapplication.moc"
#undef QT_NO_COMPAT
# 1 "../../../prod/kdelibs/kdecore/kapplication.h" 1
# 12 "../kdecore/kapplication.moc" 2



# 1 "/coolo/prod/qt-copy/include/private/qucomextra_p.h" 1
# 39 "/coolo/prod/qt-copy/include/private/qucomextra_p.h"
# 54 "/coolo/prod/qt-copy/include/private/qucomextra_p.h"
# 1 "/coolo/prod/qt-copy/include/private/qucom_p.h" 1
# 39 "/coolo/prod/qt-copy/include/private/qucom_p.h"
# 55 "/coolo/prod/qt-copy/include/private/qucom_p.h"
# 1 "/coolo/prod/qt-copy/include/quuid.h" 1
# 39 "/coolo/prod/qt-copy/include/quuid.h"
# 60 "/coolo/prod/qt-copy/include/quuid.h"
struct QUuid
{
    QUuid()
    {
        memset( this, 0, sizeof(QUuid) );
    }
    QUuid( uint l, ushort w1, ushort w2, uchar b1, uchar b2, uchar b3, uchar b4, uchar b5, uchar b6, uchar b7, uchar b8 )
    {
        data1 = l;
        data2 = w1;
        data3 = w2;
        data4[0] = b1;
        data4[1] = b2;
        data4[2] = b3;
        data4[3] = b4;
        data4[4] = b5;
        data4[5] = b6;
        data4[6] = b7;
        data4[7] = b8;
    }
    QUuid( const QUuid &uuid )
    {
        memcpy( this, &uuid, sizeof(QUuid) );
    }

    QUuid( const QString & );
    QUuid( const char * );
    QString toString() const;
    operator QString() const { return toString(); }

    bool isNull() const;

    QUuid &operator=(const QUuid &orig )
    {
        memcpy( this, &orig, sizeof(QUuid) );
        return *this;
    }

    bool operator==(const QUuid &orig ) const
    {
        uint i;
        if ( data1 != orig.data1 || data2 != orig.data2 ||
             data3 != orig.data3 )
            return FALSE;

        for( i = 0; i < 8; i++ )
            if ( data4[i] != orig.data4[i] )
                return FALSE;

        return TRUE;
    }

    bool operator!=(const QUuid &orig ) const
    {
        return !( *this == orig );
    }
# 157 "/coolo/prod/qt-copy/include/quuid.h"
    uint data1;
    ushort data2;
    ushort data3;
    uchar data4[ 8 ];
};


 QDataStream &operator<<( QDataStream &, const QUuid & );
 QDataStream &operator>>( QDataStream &, QUuid & );
# 56 "/coolo/prod/qt-copy/include/private/qucom_p.h" 2






struct QUObject;
struct QUInterfaceDescription;
struct QUnknownInterface;
struct QDispatchInterface;


struct QUBuffer
{
    virtual long read( char *data, ulong maxlen ) = 0;
    virtual long write( const char *data, ulong len ) = 0;
};



struct QUType
{
    virtual const QUuid *uuid() const = 0;
    virtual const char *desc() const = 0;


    virtual bool canConvertFrom( QUObject *, QUType * ) = 0;

    virtual bool canConvertTo( QUObject *, QUType * ) = 0;


    virtual bool convertFrom( QUObject *, QUType * ) = 0;

    virtual bool convertTo( QUObject *, QUType * ) = 0;

    virtual void clear( QUObject * ) = 0;

    virtual int serializeTo( QUObject *, QUBuffer * ) = 0;
    virtual int serializeFrom( QUObject *, QUBuffer * ) = 0;

    static bool isEqual( const QUType *t1, const QUType *t2 );
    static bool check( QUObject* o, QUType* t );
};



extern const QUuid TID_QUType_Null;
struct QUType_Null : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * );
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_Null static_QUType_Null;



struct QUObject
{
public:
    QUObject() : type( &static_QUType_Null ) {}
    ~QUObject() { type->clear( this ); }

    QUType *type;


    union
    {
        bool b;

        char c;
        short s;
        int i;
        long l;

        unsigned char uc;
        unsigned short us;
        unsigned int ui;
        unsigned long ul;

        float f;
        double d;

        char byte[16];

        struct {
           char* data;
           unsigned long size;
        } bytearray;

        void* ptr;

        struct {
            void *ptr;
            bool owner;
        } voidstar;

        struct {
            char *ptr;
            bool owner;
        } charstar;

        struct {
            char *ptr;
            bool owner;
        } utf8;

        struct {
            char *ptr;
            bool owner;
        } local8bit;

        QUnknownInterface* iface;
        QDispatchInterface* idisp;

    } payload;

};





struct QUParameter
{
    const char* name;
    QUType *type;
    const void* typeExtra;
    enum { In = 1, Out = 2, InOut = In | Out };
    int inOut;
};



struct QUMethod
{
    const char* name;
    int count;
    const QUParameter* parameters;
};


struct QUProperty
{
    const char* name;
    QUType* type;
    const void* typeExtra;

    int set;
    int get;

    int designable;
    int stored;
};



struct QUInterfaceDescription
{
    int methodCount;
    const QUMethod* methods;
    int propertyCount;
    const QUProperty* properties;
};





struct QUComponentDescription
{
    const char* name;
    const char* vendor;
    const char* release;
    const char* info;
    QUuid cid;
    int count;
    const QUuid* interfaces;
};





struct QUComponentServerDescription
{
    const char* name;
    const char* vendor;
    const char* release;
    const char* info;
    int count;
    const QUComponentDescription* components;
};



struct QUEnumItem
{
    const char *key;
    int value;
};

struct QUEnum
{
    const char *name;
    unsigned int count;
    const QUEnumItem *items;
    bool set;
};

inline bool QUType::isEqual( const QUType *t1, const QUType *t2 ) {
    return t1 == t2 || t1->uuid() == t2->uuid() ||
        *(t1->uuid()) == *(t2->uuid());
}

inline bool QUType::check( QUObject* o, QUType* t ) {
    return isEqual( o->type, t ) || t->convertFrom( o, o->type );
}




extern const QUuid TID_QUType_enum;
struct QUType_enum : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, int );
    int &get( QUObject * o ) { return o->payload.i; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_enum static_QUType_enum;



extern const QUuid TID_QUType_ptr;
struct QUType_ptr : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const void* );
    void* &get( QUObject * o ) { return o->payload.ptr; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_ptr static_QUType_ptr;


extern const QUuid TID_QUType_iface;
struct QUType_iface : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, QUnknownInterface* );
    QUnknownInterface* &get( QUObject *o ){ return o->payload.iface; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_iface static_QUType_iface;


extern const QUuid TID_QUType_idisp;
struct QUType_idisp : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, QDispatchInterface* );
    QDispatchInterface* &get( QUObject *o ){ return o->payload.idisp; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_idisp static_QUType_idisp;


extern const QUuid TID_QUType_bool;
struct QUType_bool : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, bool );
    bool &get( QUObject *o ) { return o->payload.b; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_bool static_QUType_bool;


extern const QUuid TID_QUType_int;
struct QUType_int : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, int );
    int &get( QUObject *o ) { return o->payload.i; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_int static_QUType_int;



extern const QUuid TID_QUType_double;
struct QUType_double : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, double );
    double &get( QUObject *o ) { return o->payload.d; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_double static_QUType_double;



extern const QUuid TID_QUType_charstar;
struct QUType_charstar : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const char*, bool take = FALSE );
    char* get( QUObject *o ){ return o->payload.charstar.ptr; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * );
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );

};
extern QUType_charstar static_QUType_charstar;


extern const QUuid TID_QUType_QString;

struct QUType_QString : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const QString & );
    QString &get( QUObject * o ) { return *(QString*)o->payload.ptr; }

    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * );
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );

};
extern QUType_QString static_QUType_QString;
# 55 "/coolo/prod/qt-copy/include/private/qucomextra_p.h" 2



class QVariant;



extern const QUuid TID_QUType_QVariant;

struct QUType_QVariant : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const QVariant & );
    QVariant &get( QUObject * o );

    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * );
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_QVariant static_QUType_QVariant;




extern const QUuid TID_QUType_varptr;
struct QUType_varptr : public QUType
{
    const QUuid *uuid() const;
    const char *desc() const;

    void set( QUObject *, const void* );
    void* &get( QUObject * o ) { return o->payload.ptr; }
    bool canConvertFrom( QUObject *, QUType * );
    bool canConvertTo( QUObject *, QUType * );
    bool convertFrom( QUObject *, QUType * );
    bool convertTo( QUObject *, QUType * );
    void clear( QUObject * ) {}
    int serializeTo( QUObject *, QUBuffer * );
    int serializeFrom( QUObject *, QUBuffer * );
};
extern QUType_varptr static_QUType_varptr;
# 16 "../kdecore/kapplication.moc" 2






const char *KApplication::className() const
{
    return "KApplication";
}

QMetaObject *KApplication::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KApplication( "KApplication", &KApplication::staticMetaObject );
# 50 "../kdecore/kapplication.moc"
QMetaObject* KApplication::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QApplication::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { "url", &static_QUType_QString, 0, QUParameter::In }
    };
    static const QUMethod slot_0 = {"invokeBrowser", 1, param_slot_0 };
    static const QUMethod slot_1 = {"cut", 0, 0 };
    static const QUMethod slot_2 = {"copy", 0, 0 };
    static const QUMethod slot_3 = {"paste", 0, 0 };
    static const QUMethod slot_4 = {"clear", 0, 0 };
    static const QUMethod slot_5 = {"selectAll", 0, 0 };
    static const QUMethod slot_6 = {"ref", 0, 0 };
    static const QUMethod slot_7 = {"deref", 0, 0 };
    static const QUParameter param_slot_8[] = {
        { 0, &static_QUType_QString, 0, QUParameter::In }
    };
    static const QUMethod slot_8 = {"dcopFailure", 1, param_slot_8 };
    static const QUParameter param_slot_9[] = {
        { 0, &static_QUType_bool, 0, QUParameter::In }
    };
    static const QUMethod slot_9 = {"dcopBlockUserInput", 1, param_slot_9 };
    static const QUMethod slot_10 = {"x11FilterDestroyed", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "invokeBrowser(const QString&)", &slot_0, QMetaData::Public },
        { "cut()", &slot_1, QMetaData::Public },
        { "copy()", &slot_2, QMetaData::Public },
        { "paste()", &slot_3, QMetaData::Public },
        { "clear()", &slot_4, QMetaData::Public },
        { "selectAll()", &slot_5, QMetaData::Public },
        { "ref()", &slot_6, QMetaData::Public },
        { "deref()", &slot_7, QMetaData::Public },
        { "dcopFailure(const QString&)", &slot_8, QMetaData::Private },
        { "dcopBlockUserInput(bool)", &slot_9, QMetaData::Private },
        { "x11FilterDestroyed()", &slot_10, QMetaData::Private }
    };
    static const QUMethod signal_0 = {"kdisplayPaletteChanged", 0, 0 };
    static const QUMethod signal_1 = {"kdisplayStyleChanged", 0, 0 };
    static const QUMethod signal_2 = {"kdisplayFontChanged", 0, 0 };
    static const QUMethod signal_3 = {"appearanceChanged", 0, 0 };
    static const QUParameter param_signal_4[] = {
        { 0, &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_4 = {"toolbarAppearanceChanged", 1, param_signal_4 };
    static const QUParameter param_signal_5[] = {
        { "desk", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_5 = {"backgroundChanged", 1, param_signal_5 };
    static const QUParameter param_signal_6[] = {
        { "category", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_6 = {"settingsChanged", 1, param_signal_6 };
    static const QUParameter param_signal_7[] = {
        { "group", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_7 = {"iconChanged", 1, param_signal_7 };
    static const QUParameter param_signal_8[] = {
        { "id", &static_QUType_int, 0, QUParameter::In },
        { "data", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_8 = {"kipcMessage", 2, param_signal_8 };
    static const QUMethod signal_9 = {"saveYourself", 0, 0 };
    static const QUMethod signal_10 = {"shutDown", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "kdisplayPaletteChanged()", &signal_0, QMetaData::Public },
        { "kdisplayStyleChanged()", &signal_1, QMetaData::Public },
        { "kdisplayFontChanged()", &signal_2, QMetaData::Public },
        { "appearanceChanged()", &signal_3, QMetaData::Public },
        { "toolbarAppearanceChanged(int)", &signal_4, QMetaData::Public },
        { "backgroundChanged(int)", &signal_5, QMetaData::Public },
        { "settingsChanged(int)", &signal_6, QMetaData::Public },
        { "iconChanged(int)", &signal_7, QMetaData::Public },
        { "kipcMessage(int,int)", &signal_8, QMetaData::Public },
        { "saveYourself()", &signal_9, QMetaData::Public },
        { "shutDown()", &signal_10, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KApplication", parentObject,
        slot_tbl, 11,
        signal_tbl, 11,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KApplication.setMetaObject( metaObj );
    return metaObj;
}

void* KApplication::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KApplication" ) )
        return this;
    if ( !qstrcmp( clname, "KInstance" ) )
        return (KInstance*)this;
    return QApplication::qt_cast( clname );
}


void KApplication::kdisplayPaletteChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 0 );
}


void KApplication::kdisplayStyleChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 1 );
}


void KApplication::kdisplayFontChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 2 );
}


void KApplication::appearanceChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 3 );
}


void KApplication::toolbarAppearanceChanged( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 4, t0 );
}


void KApplication::backgroundChanged( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 5, t0 );
}


void KApplication::settingsChanged( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 6, t0 );
}


void KApplication::iconChanged( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 7, t0 );
}


# 1 "/coolo/prod/qt-copy/include/qsignalslotimp.h" 1
# 39 "/coolo/prod/qt-copy/include/qsignalslotimp.h"







class QConnectionList : public QPtrList<QConnection>
{
public:
    QConnectionList() : QPtrList<QConnection>() {}
    QConnectionList( const QConnectionList &list ) : QPtrList<QConnection>(list) {}
   ~QConnectionList() { clear(); }
    QConnectionList &operator=(const QConnectionList &list)
        { return (QConnectionList&)QPtrList<QConnection>::operator=(list); }
};

class QConnectionListIt : public QPtrListIterator<QConnection>
{
public:
    QConnectionListIt( const QConnectionList &l ) : QPtrListIterator<QConnection>(l) {}
    QConnectionListIt &operator=(const QConnectionListIt &i)
        { return (QConnectionListIt&)QPtrListIterator<QConnection>::operator=(i); }
};

class QSignalVec : public QPtrVector<QConnectionList>
{
public:
    QSignalVec(int size=17 )
        : QPtrVector<QConnectionList>(size) {}
    QSignalVec( const QSignalVec &dict )
        : QPtrVector<QConnectionList>(dict) {}
   ~QSignalVec() { clear(); }
    QSignalVec &operator=(const QSignalVec &dict)
        { return (QSignalVec&)QPtrVector<QConnectionList>::operator=(dict); }
    QConnectionList* at( uint index ) const {
        return index >= size()? 0 : QPtrVector<QConnectionList>::at(index);
    }
    bool insert( uint index, const QConnectionList* d ) {
        if (index >= size() )
            resize( 2*index + 1);
        return QPtrVector<QConnectionList>::insert(index, d);
    }
};

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 87 "/coolo/prod/qt-copy/include/qsignalslotimp.h" 2
# 200 "../kdecore/kapplication.moc" 2


void KApplication::kipcMessage( int t0, int t1 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 8 );
    if ( !clist )
        return;
    QUObject o[3];
    static_QUType_int.set(o+1,t0);
    static_QUType_int.set(o+2,t1);
    activate_signal( clist, o );
}


void KApplication::saveYourself()
{
    activate_signal( staticMetaObject()->signalOffset() + 9 );
}


void KApplication::shutDown()
{
    activate_signal( staticMetaObject()->signalOffset() + 10 );
}

bool KApplication::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: invokeBrowser((const QString&)static_QUType_QString.get(_o+1)); break;
    case 1: cut(); break;
    case 2: copy(); break;
    case 3: paste(); break;
    case 4: clear(); break;
    case 5: selectAll(); break;
    case 6: ref(); break;
    case 7: deref(); break;
    case 8: dcopFailure((const QString&)static_QUType_QString.get(_o+1)); break;
    case 9: dcopBlockUserInput((bool)static_QUType_bool.get(_o+1)); break;
    case 10: x11FilterDestroyed(); break;
    default:
        return QApplication::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KApplication::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: kdisplayPaletteChanged(); break;
    case 1: kdisplayStyleChanged(); break;
    case 2: kdisplayFontChanged(); break;
    case 3: appearanceChanged(); break;
    case 4: toolbarAppearanceChanged((int)static_QUType_int.get(_o+1)); break;
    case 5: backgroundChanged((int)static_QUType_int.get(_o+1)); break;
    case 6: settingsChanged((int)static_QUType_int.get(_o+1)); break;
    case 7: iconChanged((int)static_QUType_int.get(_o+1)); break;
    case 8: kipcMessage((int)static_QUType_int.get(_o+1),(int)static_QUType_int.get(_o+2)); break;
    case 9: saveYourself(); break;
    case 10: shutDown(); break;
    default:
        return QApplication::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KApplication::qt_property( int id, int f, QVariant* v)
{
    return QApplication::qt_property( id, f, v);
}

bool KApplication::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 2687 "/coolo/prod/kdelibs/kdecore/kapplication.cpp" 2
# 5 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kautoconfig.cpp" 1
# 20 "/coolo/prod/kdelibs/kdecore/kautoconfig.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kautoconfig.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kautoconfig.h"




class KConfig;
class QWidget;
# 87 "/coolo/prod/kdelibs/kdecore/kautoconfig.h"
class KAutoConfig : public QObject {

public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

protected:





  void settingsChanged();







  void settingsChanged( QWidget *widget );
# 114 "/coolo/prod/kdelibs/kdecore/kautoconfig.h"
  void widgetModified();


public:







  KAutoConfig( KConfig *kconfig, QObject *parent=0, const char *name=0 );
# 134 "/coolo/prod/kdelibs/kdecore/kautoconfig.h"
  KAutoConfig( QObject *parent=0, const char *name=0 );




  ~KAutoConfig();
# 151 "/coolo/prod/kdelibs/kdecore/kautoconfig.h"
  void addWidget( QWidget *widget, const QString &group );







  void ignoreSubWidget( QWidget *widget );







  bool hasChanged() const;







  bool isDefault() const;
# 194 "/coolo/prod/kdelibs/kdecore/kautoconfig.h"
  inline void addWidgetChangedSignal( const QString &widgetName,
                  const QCString &signal){
    changedMap.insert( widgetName, signal );
  }


public :
# 209 "/coolo/prod/kdelibs/kdecore/kautoconfig.h"
  bool retrieveSettings( bool trackChanges=false );







  bool saveSettings();







  void resetSettings();


protected:



  KConfig *config;



  QMap<QString, QCString> changedMap;
# 250 "/coolo/prod/kdelibs/kdecore/kautoconfig.h"
  bool parseChildren( const QWidget *widget,
                  QPtrList<QWidget>&currentGroup, bool trackChanges );


private:
  class KAutoConfigPrivate;



  KAutoConfigPrivate *d;

};
# 21 "/coolo/prod/kdelibs/kdecore/kautoconfig.cpp" 2



# 1 "/coolo/prod/qt-copy/include/qobjectlist.h" 1
# 39 "/coolo/prod/qt-copy/include/qobjectlist.h"
# 53 "/coolo/prod/qt-copy/include/qobjectlist.h"
class QObjectList : public QPtrList<QObject>
{
public:
    QObjectList() : QPtrList<QObject>() {}
    QObjectList( const QObjectList &list ) : QPtrList<QObject>(list) {}
   ~QObjectList() { clear(); }
    QObjectList &operator=(const QObjectList &list)
        { return (QObjectList&)QPtrList<QObject>::operator=(list); }
};

class QObjectListIterator : public QPtrListIterator<QObject>
{
public:
    QObjectListIterator( const QObjectList &l )
        : QPtrListIterator<QObject>( l ) { }
    QObjectListIterator &operator=( const QObjectListIterator &i )
        { return (QObjectListIterator&)
                 QPtrListIterator<QObject>::operator=( i ); }
};
# 80 "/coolo/prod/qt-copy/include/qobjectlist.h"
class QObjectListIt : public QPtrListIterator<QObject>
{
public:
    QObjectListIt( const QObjectList &l ) : QPtrListIterator<QObject>(l) {}
    QObjectListIt &operator=(const QObjectListIt &i)
        { return (QObjectListIt&)QPtrListIterator<QObject>::operator=(i); }
};
# 25 "/coolo/prod/kdelibs/kdecore/kautoconfig.cpp" 2






class KAutoConfig::KAutoConfigPrivate {

public:
  KAutoConfigPrivate() : changed(false)

    , retrievedSettings(false)

  { init(); }


  QPtrList<QWidget> widgets;

  QMap<QWidget*, QString> groups;


  QPtrList<QWidget> ignore;


  bool changed;



  bool retrievedSettings;



  QMap<QWidget*, QPtrList<QWidget> > autoWidgets;

  QMap<QWidget*, QVariant> defaultValues;

  QAsciiDict<int> ignoreTheseWidgets;

  void init(){
    ignoreTheseWidgets.insert("QLabel", new int(1));
    ignoreTheseWidgets.insert("QFrame", new int(2));
    ignoreTheseWidgets.insert("QGroupBox", new int(3));
    ignoreTheseWidgets.insert("QButtonGroup", new int(4));
    ignoreTheseWidgets.insert("QWidget", new int(5));
    ignoreTheseWidgets.setAutoDelete(true);

    static bool defaultKDEPropertyMapInstalled = false;
    if ( !defaultKDEPropertyMapInstalled && KApplication::kApplication() ) {
      KApplication::kApplication()->installKDEPropertyMap();
      defaultKDEPropertyMapInstalled = true;
    }
  }
};

KAutoConfig::KAutoConfig(KConfig *kconfig, QObject *parent,
    const char *name) : QObject(parent, name), config(kconfig) {
  d = new KAutoConfigPrivate();
}

KAutoConfig::KAutoConfig(QObject *parent, const char *name) :
    QObject(parent, name), config(KGlobal::config()) {
  d = new KAutoConfigPrivate();
}

KAutoConfig::~KAutoConfig(){
  delete d;
}

void KAutoConfig::addWidget(QWidget *widget, const QString &group){
  d->groups.insert(widget, group);
  d->widgets.append(widget);
  QPtrList<QWidget> newAutoConfigWidget;
  d->autoWidgets.insert(widget, newAutoConfigWidget );
}

void KAutoConfig::ignoreSubWidget(QWidget *widget){
  d->ignore.append(widget);
}

bool KAutoConfig::retrieveSettings(bool trackChanges){

  if(d->retrievedSettings){
      kdDebug(180) << "This should not happen.  Function "
       "KAutoConfig::retrieveSettings() called more then once, returning "
       "first.  It is not recommended unless you know the implementation "
       "details of KAutoConfig and what this breaks.  Please fix." << endl;
    return false;
  }
  d->retrievedSettings = true;


  if(trackChanges){

    changedMap.insert("QButton", "2""stateChanged(int)");
    changedMap.insert("QCheckBox", "2""stateChanged(int)");
    changedMap.insert("QPushButton", "2""stateChanged(int)");
    changedMap.insert("QRadioButton", "2""stateChanged(int)");
    changedMap.insert("QComboBox", "2""activated (int)");


    changedMap.insert("QDateEdit", "2""valueChanged(const QDate &)");
    changedMap.insert("QDateTimeEdit", "2""valueChanged(const QDateTime &)");
    changedMap.insert("QDial", "2""valueChanged (int)");
    changedMap.insert("QLineEdit", "2""textChanged(const QString &)");
    changedMap.insert("QSlider", "2""valueChanged(int)");
    changedMap.insert("QSpinBox", "2""valueChanged(int)");
    changedMap.insert("QTimeEdit", "2""valueChanged(const QTime &)");
    changedMap.insert("QTextEdit", "2""textChanged()");
    changedMap.insert("QTextBrowser", "2""sourceChanged(const QString &)");
    changedMap.insert("QMultiLineEdit", "2""textChanged()");
    changedMap.insert("QListBox", "2""selectionChanged()");
    changedMap.insert("QTabWidget", "2""currentChanged(QWidget *)");


    changedMap.insert( "KComboBox", "2""activated (int)");
    changedMap.insert( "KFontCombo", "2""activated (int)");
    changedMap.insert( "KFontRequester", "2""fontSelected(const QFont &)");
    changedMap.insert( "KFontChooser", "2""fontSelected(const QFont &)");
    changedMap.insert( "KHistoryCombo", "2""activated (int)");

    changedMap.insert( "KColorButton", "2""changed(const QColor &)");
    changedMap.insert( "KDatePicker", "2""dateSelected (QDate)");
    changedMap.insert( "KEditListBox", "2""changed()");
    changedMap.insert( "KListBox", "2""selectionChanged()");
    changedMap.insert( "KLineEdit", "2""textChanged(const QString &)");
    changedMap.insert( "KPasswordEdit", "2""textChanged(const QString &)");
    changedMap.insert( "KRestrictedLine", "2""textChanged(const QString &)");
    changedMap.insert( "KTextBrowser", "2""sourceChanged(const QString &)");
    changedMap.insert( "KTextEdit", "2""textChanged()");
    changedMap.insert( "KURLRequester", "2""textChanged (const QString& )");
    changedMap.insert( "KIntNumInput", "2""valueChanged (int)");
    changedMap.insert( "KIntSpinBox", "2""valueChanged (int)");
    changedMap.insert( "KDoubleNumInput", "2""valueChanged (double)");
  }


  QPtrListIterator<QWidget> it( d->widgets );
  QWidget *widget = 0;
  bool usingDefaultValues = false;
  while ( (widget = it.current()) != 0 ) {
    ++it;
    config->setGroup(d->groups[widget]);
    usingDefaultValues |= parseChildren(widget, d->autoWidgets[widget], trackChanges);
  }
  return usingDefaultValues;
}

bool KAutoConfig::saveSettings() {

  if(!d->retrievedSettings){
      kdDebug(180) << "KAutoConfig::saveSettings() called before "
      "KAutoConfig::retrieveSettings().  This should NEVER happen.  "
      "Please Fix." << endl;
    return false;
  }


  QSqlPropertyMap *propertyMap = QSqlPropertyMap::defaultMap();

  QPtrListIterator<QWidget> it( d->widgets );
  QWidget *widget = 0;
  while ( (widget = it.current()) != 0 ) {
    ++it;
    config->setGroup(d->groups[widget]);


    QPtrListIterator<QWidget> it( d->autoWidgets[widget] );
    QWidget *groupWidget;
    bool widgetChanged = false;
    while ( (groupWidget = it.current()) != 0 ){
      ++it;
      QVariant defaultValue = d->defaultValues[groupWidget];
      QVariant currentValue = propertyMap->property(groupWidget);

      if(!config->hasDefault(groupWidget->name()) && currentValue == defaultValue){
        config->revertToDefault(groupWidget->name());
        widgetChanged = true;
      }
      else{
        QVariant savedValue = config->readPropertyEntry(groupWidget->name(),
                                                             defaultValue);
        if(savedValue != currentValue){
          config->writeEntry(groupWidget->name(), currentValue);
          widgetChanged = true;
        }
      }
    }
    d->changed |= widgetChanged;
    if(widgetChanged)
      ( settingsChanged(widget) );
  }

  if(d->changed){
    ( settingsChanged() );
    d->changed = false;
    config->sync();
    return true;
  }
  return false;
}

bool KAutoConfig::hasChanged() const {

  if(!d->retrievedSettings){
    kdDebug(180) << "KAutoConfig::hasChanged() called before "
      "KAutoConfig::retrieveSettings().  This should NEVER happen.  "
      "Please Fix." << endl;
    return false;
  }


  QSqlPropertyMap *propertyMap = QSqlPropertyMap::defaultMap();

  QPtrListIterator<QWidget> it( d->widgets );
  QWidget *widget = 0;
  while ( (widget = it.current()) != 0 ) {
    ++it;
    config->setGroup(d->groups[widget]);

    QPtrListIterator<QWidget> it( d->autoWidgets[widget] );
    QWidget *groupWidget;
    while ( (groupWidget = it.current()) != 0 ){
      ++it;
      QVariant defaultValue = d->defaultValues[groupWidget];
      QVariant currentValue = propertyMap->property(groupWidget);
      QVariant savedValue = config->readPropertyEntry(groupWidget->name(),
      defaultValue);

      if((currentValue == defaultValue && savedValue != currentValue) ||
         (savedValue != currentValue))
        return true;
    }
  }
  return false;
}

bool KAutoConfig::isDefault() const {

  if(!d->retrievedSettings){
    kdDebug(180) << "KAutoConfig::isDefault() called before "
      "KAutoConfig::retrieveSettings().  This should NEVER happen.  "
      "Please Fix." << endl;
    return false;
  }


  QSqlPropertyMap *propertyMap = QSqlPropertyMap::defaultMap();

  QPtrListIterator<QWidget> it( d->widgets );
  QWidget *widget = 0;
  while ( (widget = it.current()) != 0 ) {
    ++it;
    config->setGroup(d->groups[widget]);

    QPtrListIterator<QWidget> it( d->autoWidgets[widget] );
    QWidget *groupWidget;
    while ( (groupWidget = it.current()) != 0 ){
      ++it;
      QVariant defaultValue = d->defaultValues[groupWidget];
      QVariant currentValue = propertyMap->property(groupWidget);
      if(currentValue != defaultValue){

        return false;
      }
    }
  }
  return true;
}

void KAutoConfig::resetSettings(){

  if(!d->retrievedSettings){
    kdDebug(180) << "KAutoConfig::resetSettings() called before "
      "KAutoConfig::retrieveSettings().  This should NEVER happen.  "
      "Please Fix." << endl;
    return;
  }


  QSqlPropertyMap *propertyMap = QSqlPropertyMap::defaultMap();

  QPtrListIterator<QWidget> it( d->widgets );
  QWidget *widget = 0;
  while ( (widget = it.current()) != 0 ) {
    ++it;
    config->setGroup(d->groups[widget]);


    QPtrListIterator<QWidget> it( d->autoWidgets[widget] );
    QWidget *groupWidget;
    while ( (groupWidget = it.current()) != 0 ){
      ++it;
      QVariant defaultValue = d->defaultValues[groupWidget];
      if(defaultValue != propertyMap->property(groupWidget)){
        propertyMap->setProperty(groupWidget, defaultValue);
        d->changed = true;
      }
    }
  }
}

bool KAutoConfig::parseChildren(const QWidget *widget,
    QPtrList<QWidget>& currentGroup, bool trackChanges){
  bool valueChanged = false;
  const QPtrList<QObject> *listOfChildren = widget->children();
  if(!listOfChildren)
    return valueChanged;

  QSqlPropertyMap *propertyMap = QSqlPropertyMap::defaultMap();
  QPtrListIterator<QObject> it( *listOfChildren );
  QObject *object;
  while ( (object = it.current()) != 0 )
  {
    ++it;
    if(!object->isWidgetType()){
      continue;
    }
    QWidget *childWidget = (QWidget *)object;
    if(d->ignore.containsRef(childWidget)){
      continue;
    }

    bool parseTheChildren = true;
    if( d->ignoreTheseWidgets[childWidget->className()] == 0 &&
      childWidget->name(0) != __null )
    {
      QVariant defaultSetting = propertyMap->property(childWidget);
      if(defaultSetting.isValid())
      {
        parseTheChildren = false;

        if(config->entryIsImmutable( childWidget->name()))
          childWidget->setEnabled(false);
        else
        {



          currentGroup.append(childWidget);
          d->defaultValues.insert(childWidget, defaultSetting);
        }

        QVariant setting =
         config->readPropertyEntry(childWidget->name(), defaultSetting);
        if(setting != defaultSetting)
        {
          propertyMap->setProperty(childWidget, setting);
          valueChanged = true;
        }
        if(trackChanges && changedMap.find(childWidget->className()) !=
            changedMap.end())
        {
          connect(childWidget, changedMap[childWidget->className()],
                  this, "2""widgetModified()");
        }

        else if(trackChanges &&
          changedMap.find(childWidget->className()) == changedMap.end())
        {
          kdDebug(180) << "KAutoConfig::retrieveSettings, Unknown changed "
           "signal for widget:" << childWidget->className() << endl;
        }


      }

      else
      {
          kdDebug(180) << "KAutoConfig::retrieveSettings, Unknown widget:"
           << childWidget->className() << endl;
      }

    }
    if(parseTheChildren)
    {


      valueChanged |= parseChildren(childWidget, currentGroup, trackChanges);
    }
  }
  return valueChanged;
}

# 1 "../kdecore/kautoconfig.moc" 1
# 11 "../kdecore/kautoconfig.moc"
# 1 "../../../prod/kdelibs/kdecore/kautoconfig.h" 1
# 12 "../kdecore/kautoconfig.moc" 2
# 22 "../kdecore/kautoconfig.moc"
const char *KAutoConfig::className() const
{
    return "KAutoConfig";
}

QMetaObject *KAutoConfig::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KAutoConfig( "KAutoConfig", &KAutoConfig::staticMetaObject );
# 50 "../kdecore/kautoconfig.moc"
QMetaObject* KAutoConfig::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { 0, &static_QUType_bool, 0, QUParameter::Out }
    };
    static const QUMethod slot_0 = {"retrieveSettings", 1, param_slot_0 };
    static const QUParameter param_slot_1[] = {
        { 0, &static_QUType_bool, 0, QUParameter::Out },
        { "trackChanges", &static_QUType_bool, 0, QUParameter::In }
    };
    static const QUMethod slot_1 = {"retrieveSettings", 2, param_slot_1 };
    static const QUParameter param_slot_2[] = {
        { 0, &static_QUType_bool, 0, QUParameter::Out }
    };
    static const QUMethod slot_2 = {"saveSettings", 1, param_slot_2 };
    static const QUMethod slot_3 = {"resetSettings", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "retrieveSettings()", &slot_0, QMetaData::Public },
        { "retrieveSettings(bool)", &slot_1, QMetaData::Public },
        { "saveSettings()", &slot_2, QMetaData::Public },
        { "resetSettings()", &slot_3, QMetaData::Public }
    };
    static const QUMethod signal_0 = {"settingsChanged", 0, 0 };
    static const QUParameter param_signal_1[] = {
        { "widget", &static_QUType_ptr, "QWidget", QUParameter::In }
    };
    static const QUMethod signal_1 = {"settingsChanged", 1, param_signal_1 };
    static const QUMethod signal_2 = {"widgetModified", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "settingsChanged()", &signal_0, QMetaData::Private },
        { "settingsChanged(QWidget*)", &signal_1, QMetaData::Private },
        { "widgetModified()", &signal_2, QMetaData::Private }
    };
    metaObj = QMetaObject::new_metaobject(
        "KAutoConfig", parentObject,
        slot_tbl, 4,
        signal_tbl, 3,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KAutoConfig.setMetaObject( metaObj );
    return metaObj;
}

void* KAutoConfig::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KAutoConfig" ) )
        return this;
    return QObject::qt_cast( clname );
}


void KAutoConfig::settingsChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 0 );
}





void KAutoConfig::settingsChanged( QWidget* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 1 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}


void KAutoConfig::widgetModified()
{
    activate_signal( staticMetaObject()->signalOffset() + 2 );
}

bool KAutoConfig::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: static_QUType_bool.set(_o,retrieveSettings()); break;
    case 1: static_QUType_bool.set(_o,retrieveSettings((bool)static_QUType_bool.get(_o+1))); break;
    case 2: static_QUType_bool.set(_o,saveSettings()); break;
    case 3: resetSettings(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KAutoConfig::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: settingsChanged(); break;
    case 1: settingsChanged((QWidget*)static_QUType_ptr.get(_o+1)); break;
    case 2: widgetModified(); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KAutoConfig::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KAutoConfig::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 409 "/coolo/prod/kdelibs/kdecore/kautoconfig.cpp" 2
# 6 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 1
# 32 "/coolo/prod/kdelibs/kdecore/kdebug.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kdebugdcopiface.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kdebugdcopiface.h"







class KDebugDCOPIface : virtual public DCOPObject
{
        public: virtual bool process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData); QCStringList functions(); QCStringList interfaces(); private:
public:
        KDebugDCOPIface();
        ~KDebugDCOPIface();

public:




        void notifyKDebugConfigChanged();
};
# 33 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2
# 42 "/coolo/prod/kdelibs/kdecore/kdebug.cpp"
# 1 "/coolo/prod/qt-copy/include/qintdict.h" 1
# 39 "/coolo/prod/qt-copy/include/qintdict.h"





template<class type>
class QIntDict



        : public QGDict

{
public:
    QIntDict(int size=17) : QGDict(size,IntKey,0,0) {}
    QIntDict( const QIntDict<type> &d ) : QGDict(d) {}
   ~QIntDict() { clear(); }
    QIntDict<type> &operator=(const QIntDict<type> &d)
                        { return (QIntDict<type>&)QGDict::operator=(d); }
    uint count() const { return QGDict::count(); }
    uint size() const { return QGDict::size(); }
    bool isEmpty() const { return QGDict::count() == 0; }
    void insert( long k, const type *d )
                                        { QGDict::look_int(k,(Item)d,1); }
    void replace( long k, const type *d )
                                        { QGDict::look_int(k,(Item)d,2); }
    bool remove( long k ) { return QGDict::remove_int(k); }
    type *take( long k ) { return (type*)QGDict::take_int(k); }
    type *find( long k ) const
                { return (type *)((QGDict*)this)->QGDict::look_int(k,0,0); }
    type *operator[]( long k ) const
                { return (type *)((QGDict*)this)->QGDict::look_int(k,0,0); }
    void clear() { QGDict::clear(); }
    void resize( uint n ) { QGDict::resize(n); }
    void statistics() const { QGDict::statistics(); }







private:
    void deleteItem( Item d );
};


template<> inline void QIntDict<void>::deleteItem( QPtrCollection::Item )
{
}


template<class type> inline void QIntDict<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type*)d;
}

template<class type>
class QIntDictIterator : public QGDictIterator
{
public:
    QIntDictIterator(const QIntDict<type> &d) :QGDictIterator((QGDict &)d) {}
   ~QIntDictIterator() {}
    uint count() const { return dict->count(); }
    bool isEmpty() const { return dict->count() == 0; }
    type *toFirst() { return (type *)QGDictIterator::toFirst(); }
    operator type *() const { return (type *)QGDictIterator::get(); }
    type *current() const { return (type *)QGDictIterator::get(); }
    long currentKey() const { return QGDictIterator::getKeyInt(); }
    type *operator()() { return (type *)QGDictIterator::operator()(); }
    type *operator++() { return (type *)QGDictIterator::operator++(); }
    type *operator+=(uint j) { return (type *)QGDictIterator::operator+=(j);}
};

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 116 "/coolo/prod/qt-copy/include/qintdict.h" 2
# 43 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2







# 1 "/coolo/prod/qt-copy/include/qpen.h" 1
# 39 "/coolo/prod/qt-copy/include/qpen.h"







class QPen: public Qt
{
public:
    QPen();
    QPen( PenStyle );
    QPen( const QColor &color, uint width=0, PenStyle style=SolidLine );
    QPen( const QColor &cl, uint w, PenStyle s, PenCapStyle c, PenJoinStyle j);
    QPen( const QPen & );
   ~QPen();
    QPen &operator=( const QPen & );

    PenStyle style() const { return data->style; }
    void setStyle( PenStyle );
    uint width() const { return data->width; }
    void setWidth( uint );
    const QColor &color() const { return data->color; }
    void setColor( const QColor & );
    PenCapStyle capStyle() const;
    void setCapStyle( PenCapStyle );
    PenJoinStyle joinStyle() const;
    void setJoinStyle( PenJoinStyle );

    bool operator==( const QPen &p ) const;
    bool operator!=( const QPen &p ) const
                                        { return !(operator==(p)); }

private:
    friend class QPainter;




    QPen copy() const;
    void detach();
    void init( const QColor &, uint, uint );
    struct QPenData : public QShared {
        PenStyle style;
        uint width;
        QColor color;
        Q_UINT16 linest;
    } *data;
};






 QDataStream &operator<<( QDataStream &, const QPen & );
 QDataStream &operator>>( QDataStream &, QPen & );
# 51 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2







# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stdarg.h" 1 3 4
# 34 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stdarg.h" 3 4
# 50 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stdarg.h" 3 4



# 111 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stdarg.h" 3 4









# 59 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 25 "/usr/include/ctype.h" 3 4




extern "C" {
# 45 "/usr/include/ctype.h" 3 4


enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__const));











extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();



# 237 "/usr/include/ctype.h" 3 4








extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 281 "/usr/include/ctype.h" 3 4














}
# 60 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2
# 1 "/usr/include/syslog.h" 1 3 4
# 1 "/usr/include/sys/syslog.h" 1 3 4
# 33 "/usr/include/sys/syslog.h" 3 4





# 51 "/usr/include/sys/syslog.h" 3 4


# 93 "/usr/include/sys/syslog.h" 3 4




# 153 "/usr/include/sys/syslog.h" 3 4








extern "C" {


extern void closelog (void) throw ();


extern void openlog (__const char *__ident, int __option, int __facility)
     throw ();


extern int setlogmask (int __mask) throw ();


extern void syslog (int __pri, __const char *__fmt, ...) throw ()
     __attribute__ ((__format__(__printf__, 2, 3)));



extern void vsyslog (int __pri, __const char *__fmt, __gnuc_va_list __ap)
     throw () __attribute__ ((__format__(__printf__, 2, 0)));


}
# 2 "/usr/include/syslog.h" 2 3 4
# 61 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2
# 1 "/usr/include/errno.h" 1 3 4
# 62 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/kstaticdeleter.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kstaticdeleter.h"
# 39 "/coolo/prod/kdelibs/kdecore/kstaticdeleter.h"
class KStaticDeleterBase {
public:
    virtual ~KStaticDeleterBase() { }





    virtual void destructObject();
};
# 65 "/coolo/prod/kdelibs/kdecore/kstaticdeleter.h"
template<class type> class KStaticDeleter : public KStaticDeleterBase {
public:
    KStaticDeleter() { deleteit = 0; globalReference = 0; array = false; }







    __attribute__ ((deprecated)) type *setObject( type *obj, bool isArray = false) {
        deleteit = obj;
        globalReference = 0;
        array = isArray;
        if (obj)
            KGlobal::registerStaticDeleter(this);
        else
            KGlobal::unregisterStaticDeleter(this);
        return obj;
    }
# 93 "/coolo/prod/kdelibs/kdecore/kstaticdeleter.h"
    type *setObject( type* & globalRef, type *obj, bool isArray = false) {
        globalReference = &globalRef;
        deleteit = obj;
        array = isArray;
        if (obj)
            KGlobal::registerStaticDeleter(this);
        else
            KGlobal::unregisterStaticDeleter(this);
        globalRef = obj;
        return obj;
    }





    virtual void destructObject() {
        if (globalReference)
           *globalReference = 0;
        if (array)
           delete [] deleteit;
        else
           delete deleteit;
        deleteit = 0;
    }
    virtual ~KStaticDeleter() {
        KGlobal::unregisterStaticDeleter(this);
        destructObject();
    }
private:
    type *deleteit;
    type **globalReference;
    bool array;
};
# 65 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 66 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2


# 1 "/usr/include/execinfo.h" 1 3 4
# 20 "/usr/include/execinfo.h" 3 4



extern "C" {



extern int backtrace (void **__array, int __size) throw ();




extern char **backtrace_symbols (void *__const *__array, int __size) throw ();





extern void backtrace_symbols_fd (void *__const *__array, int __size,
                                  int __fd) throw ();

}
# 69 "/coolo/prod/kdelibs/kdecore/kdebug.cpp" 2


class KDebugEntry;

class KDebugEntry
{
public:
    KDebugEntry (int n, QString d) {number=n; descr=d;}
    unsigned int number;
    QString descr;
};

static QIntDict<KDebugEntry> *KDebugCache;

static KStaticDeleter< QIntDict<KDebugEntry> > kdd;

static QString getDescrFromNum(unsigned int _num)
{
  if (!KDebugCache) {
    kdd.setObject(KDebugCache, new QIntDict<KDebugEntry>);

    KGlobal::unregisterStaticDeleter(&kdd);
    KDebugCache->setAutoDelete(true);
  }

  KDebugEntry *ent = KDebugCache->find( _num );
  if ( ent )
    return ent->descr;

  if ( !KDebugCache->isEmpty() )
    return QString::null;

  QString filename(locate("config","kdebug.areas"));
  if (filename.isEmpty())
      return QString::null;

  QFile file(filename);
  if (!file.open(0x0001)) {
    qWarning("Couldn't open %s", filename.local8Bit().data());
    file.close();
    return QString::null;
  }

  unsigned long number = 0;
  bool longOK;

  QTextStream *ts = new QTextStream(&file);
  ts->setEncoding( QTextStream::Latin1 );
  while (!ts->eof()) {
    const QString data(ts->readLine());
    int i = 0;
    int len = data.length();

    QChar ch = data[0];
    if (ch == '#' || ch.isNull()) {
      continue;
    }
    while (ch.isSpace()) {
      if (!(i < len))
        continue;
      ++i;
      ch = data[i];
    }
    if (ch.isNumber()) {
        int numStart = i ;
        while (ch.isNumber()) {
          if (!(i < len))
            continue;
          ++i;
          ch = data[i];
        }
        number = data.mid(numStart,i).toULong(&longOK);
    }
    while (ch.isSpace()) {
      if (!(i < len))
        continue;
      ++i;
      ch = data[i];
    }
    const QString description(data.mid(i, len));


    KDebugCache->insert(number, new KDebugEntry(number,description));
  }

  delete ts;
  file.close();

  ent = KDebugCache->find( _num );
  if ( ent )
      return ent->descr;

  return QString::null;
}

enum DebugLevels {
    KDEBUG_INFO= 0,
    KDEBUG_WARN= 1,
    KDEBUG_ERROR= 2,
    KDEBUG_FATAL= 3
};


struct kDebugPrivate {
  kDebugPrivate() :
        oldarea(0), config(0) { }

  ~kDebugPrivate() { delete config; }

  QString aAreaName;
  unsigned int oldarea;
  KConfig *config;
};

static kDebugPrivate *kDebug_data = 0;
static KStaticDeleter<kDebugPrivate> pcd;
static KStaticDeleter<KDebugDCOPIface> dcopsd;
static KDebugDCOPIface* kDebugDCOPIface = 0;

static void kDebugBackend( unsigned short nLevel, unsigned int nArea, const char *data)
{
  if ( !kDebug_data )
  {
      pcd.setObject(kDebug_data, new kDebugPrivate());

      KGlobal::unregisterStaticDeleter(&pcd);


      if (!kDebugDCOPIface)
      {
          kDebugDCOPIface = dcopsd.setObject(kDebugDCOPIface, new KDebugDCOPIface);
      }
  }

  if (!kDebug_data->config && KGlobal::_instance )
  {
      kDebug_data->config = new KConfig("kdebugrc", false, false);
      kDebug_data->config->setGroup("0");



      if ( KGlobal::_instance )
        kDebug_data->aAreaName = KGlobal::instance()->instanceName();
  }

  if (kDebug_data->config && kDebug_data->oldarea != nArea) {
    kDebug_data->config->setGroup( QString::number(static_cast<int>(nArea)) );
    kDebug_data->oldarea = nArea;
    if ( nArea > 0 && KGlobal::_instance )
      kDebug_data->aAreaName = getDescrFromNum(nArea);
    if ((nArea == 0) || kDebug_data->aAreaName.isEmpty())
      if ( KGlobal::_instance )
        kDebug_data->aAreaName = KGlobal::instance()->instanceName();
  }

  int nPriority = 0;
  QString aCaption;



    QString key;
    switch( nLevel )
      {
      case KDEBUG_INFO:
        key = "InfoOutput";
        aCaption = "Info";
        nPriority = 6;
        break;
      case KDEBUG_WARN:
        key = "WarnOutput";
        aCaption = "Warning";
        nPriority = 4;
        break;
      case KDEBUG_FATAL:
        key = "FatalOutput";
        aCaption = "Fatal Error";
        nPriority = 2;
        break;
      case KDEBUG_ERROR:
      default:

        key = "ErrorOutput";
        aCaption = "Error";
        nPriority = 3;
        break;
      }

  short nOutput = kDebug_data->config ? kDebug_data->config->readNumEntry(key, 2) : 2;



  if (!KApplication::kApplication() && (nOutput == 1))
    nOutput = 2;


  switch( nOutput )
        {
        case 0:
          {
                QString aKey;
                switch( nLevel )
                {
                    case KDEBUG_INFO:
                        aKey = "InfoFilename";
                        break;
                    case KDEBUG_WARN:
                        aKey = "WarnFilename";
                        break;
                    case KDEBUG_FATAL:
                        aKey = "FatalFilename";
                        break;
                    case KDEBUG_ERROR:
                    default:
                        aKey = "ErrorFilename";
                        break;
                }
                QString aOutputFileName = kDebug_data->config->readPathEntry(aKey, "kdebug.dbg");

                const int BUFSIZE = 4096;
                char buf[BUFSIZE];
                int nSize;
                if ( !kDebug_data->aAreaName.isEmpty() )
                    nSize = snprintf( buf, BUFSIZE, "%s: %s", kDebug_data->aAreaName.ascii(), data);
                else
                    nSize = snprintf( buf, BUFSIZE, "%s", data);

                QFile aOutputFile( aOutputFileName );
                aOutputFile.open( 0x0002 | 0x0004 );
                if ( ( nSize == -1 ) || ( nSize >= BUFSIZE ) )
                    aOutputFile.writeBlock( buf, BUFSIZE-1 );
                else
                    aOutputFile.writeBlock( buf, nSize );
                aOutputFile.close();
                break;
          }
        case 1:
          {


              if ( !kDebug_data->aAreaName.isEmpty() ) aCaption += QString("(")+kDebug_data->aAreaName+")";
              QMessageBox::warning( 0L, aCaption, data, i18n("&OK") );
              break;
          }
        case 2:
          {
              FILE *output;




                  output = stderr;


              if ( !kDebug_data->aAreaName.isEmpty() ) fprintf( output, "%s: ", kDebug_data->aAreaName.ascii() );
              fputs( data, output);
              break;
          }
        case 3:
          {
              syslog( nPriority, "%s", data);
              break;
          }
        case 4:
          {
              break;
          }
        }


  if( ( nLevel == KDEBUG_FATAL )
      && ( !kDebug_data->config || kDebug_data->config->readNumEntry( "AbortFatal", 1 ) ) )
        abort();
}

kdbgstream &perror( kdbgstream &s) { return s << QString::fromLocal8Bit(strerror((*__errno_location ()))); }
kdbgstream kdDebug(int area) { return kdbgstream(area, KDEBUG_INFO); }
kdbgstream kdDebug(bool cond, int area) { if (cond) return kdbgstream(area, KDEBUG_INFO); else return kdbgstream(0, 0, false); }

kdbgstream kdError(int area) { return kdbgstream("ERROR: ", area, KDEBUG_ERROR); }
kdbgstream kdError(bool cond, int area) { if (cond) return kdbgstream("ERROR: ", area, KDEBUG_ERROR); else return kdbgstream(0,0,false); }
kdbgstream kdWarning(int area) { return kdbgstream("WARNING: ", area, KDEBUG_WARN); }
kdbgstream kdWarning(bool cond, int area) { if (cond) return kdbgstream("WARNING: ", area, KDEBUG_WARN); else return kdbgstream(0,0,false); }
kdbgstream kdFatal(int area) { return kdbgstream("FATAL: ", area, KDEBUG_FATAL); }
kdbgstream kdFatal(bool cond, int area) { if (cond) return kdbgstream("FATAL: ", area, KDEBUG_FATAL); else return kdbgstream(0,0,false); }

void kdbgstream::flush() {
    if (output.isEmpty() || !print)
        return;
    kDebugBackend( level, area, output.local8Bit().data() );
    output = QString::null;
}

kdbgstream &kdbgstream::form(const char *format, ...)
{
    char buf[4096];
    va_list arguments;
    __builtin_va_start(arguments,format);
    vsnprintf( buf, sizeof(buf), format, arguments );
    __builtin_va_end(arguments);
    *this << buf;
    return *this;
}

kdbgstream::~kdbgstream() {
    if (!output.isEmpty()) {
        fprintf(stderr, "ASSERT: debug output not ended with \\n\n");
        fprintf(stderr, "%s", kdBacktrace().latin1());
        *this << "\n";
    }
}

kdbgstream& kdbgstream::operator << (char ch)
{
  if (!print) return *this;
  if (!isprint(ch))
    output += "\\x" + QString::number( static_cast<uint>( ch ) + 0x100, 16 ).right(2);
  else {
    output += ch;
    if (ch == '\n') flush();
  }
  return *this;
}

kdbgstream& kdbgstream::operator << (QWidget* widget)
{
    return *this << const_cast< const QWidget* >( widget );
}

kdbgstream& kdbgstream::operator << (const QWidget* widget)
{
  QString string, temp;

  if(widget==0)
    {
      string=(QString)"[Null pointer]";
    } else {
      temp.setNum((ulong)widget, 16);
      string=(QString)"["+widget->className()+" pointer "
        + "(0x" + temp + ")";
      if(widget->name(0)==0)
        {
          string += " to unnamed widget, ";
        } else {
          string += (QString)" to widget " + widget->name() + ", ";
        }
      string += "geometry="
        + QString().setNum(widget->width())
        + "x"+QString().setNum(widget->height())
        + "+"+QString().setNum(widget->x())
        + "+"+QString().setNum(widget->y())
        + "]";
    }
  if (!print)
    {
      return *this;
    }
  output += string;
  if (output.at(output.length() -1 ) == '\n')
    {
      flush();
    }
  return *this;
}





kdbgstream& kdbgstream::operator<<( const QDateTime& time) {
    *this << time.toString();
    return *this;
}
kdbgstream& kdbgstream::operator<<( const QDate& date) {
    *this << date.toString();

    return *this;
}
kdbgstream& kdbgstream::operator<<( const QTime& time ) {
    *this << time.toString();
    return *this;
}
kdbgstream& kdbgstream::operator<<( const QPoint& p ) {
    *this << "(" << p.x() << ", " << p.y() << ")";
    return *this;
}
kdbgstream& kdbgstream::operator<<( const QSize& s ) {
    *this << "[" << s.width() << "x" << s.height() << "]";
    return *this;
}
kdbgstream& kdbgstream::operator<<( const QRect& r ) {
    *this << "[" << r.left() << ", " << r.top() << " - " << r.right() << ", " << r.bottom() << "]";
    return *this;
}
kdbgstream& kdbgstream::operator<<( const QRegion& reg ) {
    *this<< "[ ";

    QMemArray<QRect>rs=reg.rects();
    for (uint i=0;i<rs.size();++i)
        *this << QString("[%1, %2 - %3, %4] ").arg(rs[i].left()).arg(rs[i].top()).arg(rs[i].right()).arg(rs[i].bottom() ) ;

    *this <<"]";
    return *this;
}
kdbgstream& kdbgstream::operator<<( const KURL& u ) {
    *this << u.prettyURL();
    return *this;
}
kdbgstream& kdbgstream::operator<<( const QStringList& l ) {
    *this << "(";
    *this << l.join(",");
    *this << ")";

    return *this;
}
kdbgstream& kdbgstream::operator<<( const QColor& c ) {
    if ( c.isValid() )
        *this <<c.name();
    else
        *this << "(invalid/default)";
    return *this;
}
kdbgstream& kdbgstream::operator<<( const QPen& p ) {
    static const char* const s_penStyles[] = {
        "NoPen", "SolidLine", "DashLine", "DotLine", "DashDotLine",
        "DashDotDotLine" };
    static const char* const s_capStyles[] = {
        "FlatCap", "SquareCap", "RoundCap" };
    *this << "[ style:";
    *this << s_penStyles[ p.style() ];
    *this << " width:";
    *this << p.width();
    *this << " color:";
    if ( p.color().isValid() )
        *this << p.color().name();
    else
        *this <<"(invalid/default)";
    if ( p.width() > 0 )
    {
        *this << " capstyle:";
        *this << s_capStyles[ p.capStyle() >> 4 ];

    }
    *this <<" ]";
    return *this;
}
kdbgstream& kdbgstream::operator<<( const QBrush& b) {
    static const char* const s_brushStyles[] = {
        "NoBrush", "SolidPattern", "Dense1Pattern", "Dense2Pattern", "Dense3Pattern",
        "Dense4Pattern", "Dense5Pattern", "Dense6Pattern", "Dense7Pattern",
        "HorPattern", "VerPattern", "CrossPattern", "BDiagPattern", "FDiagPattern",
        "DiagCrossPattern" };

    *this <<"[ style: ";
    *this <<s_brushStyles[ b.style() ];
    *this <<" color: ";

    if ( b.color().isValid() )
        *this <<b.color().name() ;
    else
        *this <<"(invalid/default)";
    if ( b.pixmap() )
        *this <<" has a pixmap";
    *this <<" ]";
    return *this;
}

QString kdBacktrace(int levels)
{
    QString s;

    void* trace[256];
    int n = backtrace(trace, 256);
    char** strings = backtrace_symbols (trace, n);

    if ( levels != -1 )
        n = ((n) < (levels) ? (n) : (levels));
    s = "[\n";

    for (int i = 0; i < n; ++i)
        s += QString::number(i) +
             QString::fromLatin1(": ") +
             QString::fromLatin1(strings[i]) + QString::fromLatin1("\n");
    s += "]\n";
    free (strings);

    return s;
}

QString kdBacktrace()
{
    return kdBacktrace(-1 );
}

void kdClearDebugConfig()
{
    delete kDebug_data->config;
    kDebug_data->config = 0;
}
# 7 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/netwm.cpp" 1
# 35 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
# 1 "/usr/include/assert.h" 1 3 4
# 35 "/usr/include/assert.h" 3 4



# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 36 "/coolo/prod/kdelibs/kdecore/netwm.cpp" 2


# 1 "/usr/X11R6/include/X11/Xmd.h" 1
# 49 "/usr/X11R6/include/X11/Xmd.h"
# 99 "/usr/X11R6/include/X11/Xmd.h"
# 128 "/usr/X11R6/include/X11/Xmd.h"




typedef long INT32;

typedef short INT16;



typedef signed char INT8;
# 149 "/usr/X11R6/include/X11/Xmd.h"
typedef unsigned long CARD32;

typedef unsigned short CARD16;
typedef unsigned char CARD8;

typedef CARD32 BITS32;
typedef CARD16 BITS16;


typedef CARD8 BYTE;
typedef CARD8 BOOL;
# 179 "/usr/X11R6/include/X11/Xmd.h"
# 202 "/usr/X11R6/include/X11/Xmd.h"
# 39 "/coolo/prod/kdelibs/kdecore/netwm.cpp" 2

# 1 "/coolo/prod/kdelibs/kdecore/netwm_p.h" 1
# 28 "/coolo/prod/kdelibs/kdecore/netwm_p.h"
# 39 "/coolo/prod/kdelibs/kdecore/netwm_p.h"
template <class Z> class NETRArray {
public:




    NETRArray();





    ~NETRArray();






    Z &operator[](int);





    int size() const { return sz; }




    void reset();

private:
    int sz;
    int capacity;
    Z *d;
};







struct NETRootInfoPrivate {

    Display *display;
    NETSize rootSize;
    Window root;
    Window supportwindow;
    const char *name;
    int screen;



    NETRArray<NETPoint> viewport;
    NETRArray<NETRect> workarea;
    NETSize geometry;
    Window active;
    Window *clients, *stacking, *virtual_roots, *kde_system_tray_windows;
    NETRArray<const char *> desktop_names;
    int number_of_desktops;
    int current_desktop;

    unsigned long clients_count, stacking_count, virtual_roots_count,
        kde_system_tray_windows_count;

    unsigned long properties[ 5 ];
    unsigned long client_properties[ 5 ];

    int ref;
};







struct NETWinInfoPrivate {
    Display *display;
    Window window, root;
    NET::MappingState mapping_state;
    Bool mapping_state_dirty;

    NETRArray<NETIcon> icons;
    int icon_count;

    NETRect icon_geom, win_geom;
    unsigned long state;
    NETStrut strut, frame_strut;
    NETRArray<NET::WindowType> types;
    char *name, *visible_name, *icon_name, *visible_icon_name;
    int desktop;
    int pid;
    int handled_icons;
    Window kde_system_tray_win_for;
    Time user_time;
    char* startup_id;
    Window transient_for, window_group;
    unsigned long allowed_actions;

    unsigned long properties[ 2 ];

    int ref;
};
# 41 "/coolo/prod/kdelibs/kdecore/netwm.cpp" 2


static Atom UTF8_STRING = 0;


static Atom net_supported = 0;
static Atom net_client_list = 0;
static Atom net_client_list_stacking = 0;
static Atom net_desktop_geometry = 0;
static Atom net_desktop_viewport = 0;
static Atom net_current_desktop = 0;
static Atom net_desktop_names = 0;
static Atom net_number_of_desktops = 0;
static Atom net_active_window = 0;
static Atom net_workarea = 0;
static Atom net_supporting_wm_check = 0;
static Atom net_virtual_roots = 0;


static Atom net_close_window = 0;
static Atom net_wm_moveresize = 0;


static Atom net_wm_name = 0;
static Atom net_wm_visible_name = 0;
static Atom net_wm_icon_name = 0;
static Atom net_wm_visible_icon_name = 0;
static Atom net_wm_desktop = 0;
static Atom net_wm_window_type = 0;
static Atom net_wm_state = 0;
static Atom net_wm_strut = 0;
static Atom net_wm_icon_geometry = 0;
static Atom net_wm_icon = 0;
static Atom net_wm_pid = 0;
static Atom net_wm_user_time = 0;
static Atom net_wm_handled_icons = 0;
static Atom net_startup_id = 0;
static Atom net_wm_allowed_actions = 0;


static Atom kde_net_system_tray_windows = 0;
static Atom kde_net_wm_system_tray_window_for = 0;
static Atom kde_net_wm_frame_strut = 0;
static Atom kde_net_wm_window_type_override = 0;
static Atom kde_net_wm_window_type_topmenu = 0;


static Atom wm_protocols = 0;
static Atom net_wm_ping = 0;


static Atom net_wm_window_type_normal = 0;
static Atom net_wm_window_type_desktop = 0;
static Atom net_wm_window_type_dock = 0;
static Atom net_wm_window_type_toolbar = 0;
static Atom net_wm_window_type_menu = 0;
static Atom net_wm_window_type_dialog = 0;
static Atom net_wm_window_type_utility = 0;
static Atom net_wm_window_type_splash = 0;


static Atom net_wm_state_modal = 0;
static Atom net_wm_state_sticky = 0;
static Atom net_wm_state_max_vert = 0;
static Atom net_wm_state_max_horiz = 0;
static Atom net_wm_state_shaded = 0;
static Atom net_wm_state_skip_taskbar = 0;
static Atom net_wm_state_skip_pager = 0;
static Atom net_wm_state_hidden = 0;
static Atom net_wm_state_fullscreen = 0;
static Atom net_wm_state_above = 0;
static Atom net_wm_state_below = 0;
static Atom net_wm_state_demands_attention = 0;


static Atom net_wm_action_move = 0;
static Atom net_wm_action_resize = 0;
static Atom net_wm_action_minimize = 0;
static Atom net_wm_action_shade = 0;
static Atom net_wm_action_stick = 0;
static Atom net_wm_action_max_vert = 0;
static Atom net_wm_action_max_horiz = 0;
static Atom net_wm_action_fullscreen = 0;
static Atom net_wm_action_change_desk = 0;
static Atom net_wm_action_close = 0;


static Atom net_wm_state_stays_on_top = 0;


static Atom xa_wm_state = 0;

static Bool netwm_atoms_created = 0;
const unsigned long netwm_sendevent_mask = ((1L<<20)|
                                             (1L<<19));


const long MAX_PROP_SIZE = 100000;

static char *nstrdup(const char *s1) {
    if (! s1) return (char *) 0;

    int l = strlen(s1) + 1;
    char *s2 = new char[l];
    strncpy(s2, s1, l);
    return s2;
}


static char *nstrndup(const char *s1, int l) {
    if (! s1 || l == 0) return (char *) 0;

    char *s2 = new char[l+1];
    strncpy(s2, s1, l);
    s2[l] = '\0';
    return s2;
}


static Window *nwindup(Window *w1, int n) {
    if (! w1 || n == 0) return (Window *) 0;

    Window *w2 = new Window[n];
    while (n--) w2[n] = w1[n];
    return w2;
}


static void refdec_nri(NETRootInfoPrivate *p) {





    if (! --p->ref) {





        if (p->name) delete [] p->name;
        if (p->stacking) delete [] p->stacking;
        if (p->clients) delete [] p->clients;
        if (p->virtual_roots) delete [] p->virtual_roots;
        if (p->kde_system_tray_windows) delete [] p->kde_system_tray_windows;

        int i;
        for (i = 0; i < p->desktop_names.size(); i++)
            if (p->desktop_names[i]) delete [] p->desktop_names[i];
    }
}


static void refdec_nwi(NETWinInfoPrivate *p) {





    if (! --p->ref) {





        if (p->name) delete [] p->name;
        if (p->visible_name) delete [] p->visible_name;
        if (p->icon_name) delete [] p->icon_name;
        if (p->visible_icon_name) delete [] p->visible_icon_name;
        if (p->startup_id) delete[] p->startup_id;

        int i;
        for (i = 0; i < p->icons.size(); i++)
            if (p->icons[i].data) delete [] p->icons[i].data;
    }
}


static int wcmp(const void *a, const void *b) {
    return *((Window *) a) - *((Window *) b);
}


static const int netAtomCount = 69;
static void create_atoms(Display *d) {
    static const char * const names[netAtomCount] =
    {
        "UTF8_STRING",
            "_NET_SUPPORTED",
            "_NET_SUPPORTING_WM_CHECK",
            "_NET_CLIENT_LIST",
            "_NET_CLIENT_LIST_STACKING",
            "_NET_NUMBER_OF_DESKTOPS",
            "_NET_DESKTOP_GEOMETRY",
            "_NET_DESKTOP_VIEWPORT",
            "_NET_CURRENT_DESKTOP",
            "_NET_DESKTOP_NAMES",
            "_NET_ACTIVE_WINDOW",
            "_NET_WORKAREA",
            "_NET_VIRTUAL_ROOTS",
            "_NET_CLOSE_WINDOW",

            "_NET_WM_MOVERESIZE",
            "_NET_WM_NAME",
            "_NET_WM_VISIBLE_NAME",
            "_NET_WM_ICON_NAME",
            "_NET_WM_VISIBLE_ICON_NAME",
            "_NET_WM_DESKTOP",
            "_NET_WM_WINDOW_TYPE",
            "_NET_WM_STATE",
            "_NET_WM_STRUT",
            "_NET_WM_ICON_GEOMETRY",
            "_NET_WM_ICON",
            "_NET_WM_PID",
            "_NET_WM_USER_TIME",
            "_NET_WM_HANDLED_ICONS",
            "_KDE_STARTUP_ID",


            "_NET_AM_ALLOWED_ACTIONS",
            "_NET_WM_PING",

            "_NET_WM_WINDOW_TYPE_NORMAL",
            "_NET_WM_WINDOW_TYPE_DESKTOP",
            "_NET_WM_WINDOW_TYPE_DOCK",
            "_NET_WM_WINDOW_TYPE_TOOLBAR",
            "_NET_WM_WINDOW_TYPE_MENU",
            "_NET_WM_WINDOW_TYPE_DIALOG",
            "_NET_WM_WINDOW_TYPE_UTILITY",
            "_NET_WM_WINDOW_TYPE_SPLASH",

            "_NET_WM_STATE_MODAL",
            "_NET_WM_STATE_STICKY",
            "_NET_WM_STATE_MAXIMIZED_VERT",
            "_NET_WM_STATE_MAXIMIZED_HORZ",
            "_NET_WM_STATE_SHADED",
            "_NET_WM_STATE_SKIP_TASKBAR",
            "_NET_WM_STATE_SKIP_PAGER",
            "_NET_WM_STATE_HIDDEN",
            "_NET_WM_STATE_FULLSCREEN",
            "_NET_WM_STATE_ABOVE",
            "_NET_WM_STATE_BELOW",
            "_NET_WM_STATE_DEMANDS_ATTENTION",

            "_NET_WM_ACTION_MOVE",
            "_NET_WM_ACTION_RESIZE",
            "_NET_WM_ACTION_MINIMIZE",
            "_NET_WM_ACTION_SHADE",
            "_NET_WM_ACTION_STICK",
            "_NET_WM_ACTION_MAXIMIZE_VERT",
            "_NET_WM_ACTION_MAXIMIZE_HORZ",
            "_NET_WM_ACTION_FULLSCREEN",
            "_NET_WM_ACTION_CHANGE_DESKTOP",
            "_NET_WM_ACTION_CLOSE",

            "_NET_WM_STATE_STAYS_ON_TOP",

            "_KDE_NET_SYSTEM_TRAY_WINDOWS",
            "_KDE_NET_WM_SYSTEM_TRAY_WINDOW_FOR",
            "_KDE_NET_WM_FRAME_STRUT",
            "_KDE_NET_WM_WINDOW_TYPE_OVERRIDE",
            "_KDE_NET_WM_WINDOW_TYPE_TOPMENU",

            "WM_STATE",
            "WM_PROTOCOLS"
            };

    Atom atoms[netAtomCount], *atomsp[netAtomCount] =
    {
        &UTF8_STRING,
            &net_supported,
            &net_supporting_wm_check,
            &net_client_list,
            &net_client_list_stacking,
            &net_number_of_desktops,
            &net_desktop_geometry,
            &net_desktop_viewport,
            &net_current_desktop,
            &net_desktop_names,
            &net_active_window,
            &net_workarea,
            &net_virtual_roots,
            &net_close_window,

            &net_wm_moveresize,
            &net_wm_name,
            &net_wm_visible_name,
            &net_wm_icon_name,
            &net_wm_visible_icon_name,
            &net_wm_desktop,
            &net_wm_window_type,
            &net_wm_state,
            &net_wm_strut,
            &net_wm_icon_geometry,
            &net_wm_icon,
            &net_wm_pid,
            &net_wm_user_time,
            &net_wm_handled_icons,
            &net_startup_id,
            &net_wm_allowed_actions,
            &net_wm_ping,

            &net_wm_window_type_normal,
            &net_wm_window_type_desktop,
            &net_wm_window_type_dock,
            &net_wm_window_type_toolbar,
            &net_wm_window_type_menu,
            &net_wm_window_type_dialog,
            &net_wm_window_type_utility,
            &net_wm_window_type_splash,

            &net_wm_state_modal,
            &net_wm_state_sticky,
            &net_wm_state_max_vert,
            &net_wm_state_max_horiz,
            &net_wm_state_shaded,
            &net_wm_state_skip_taskbar,
            &net_wm_state_skip_pager,
            &net_wm_state_hidden,
            &net_wm_state_fullscreen,
            &net_wm_state_above,
            &net_wm_state_below,
            &net_wm_state_demands_attention,

            &net_wm_action_move,
            &net_wm_action_resize,
            &net_wm_action_minimize,
            &net_wm_action_shade,
            &net_wm_action_stick,
            &net_wm_action_max_vert,
            &net_wm_action_max_horiz,
            &net_wm_action_fullscreen,
            &net_wm_action_change_desk,
            &net_wm_action_close,

            &net_wm_state_stays_on_top,

            &kde_net_system_tray_windows,
            &kde_net_wm_system_tray_window_for,
            &kde_net_wm_frame_strut,
            &kde_net_wm_window_type_override,
            &kde_net_wm_window_type_topmenu,

            &xa_wm_state,
            &wm_protocols
            };

    int i = netAtomCount;
    while (i--)
        atoms[i] = 0;

    XInternAtoms(d, (char **) names, netAtomCount, 0, atoms);

    i = netAtomCount;
    while (i--)
        *atomsp[i] = atoms[i];

    netwm_atoms_created = 1;
}


static void readIcon(NETWinInfoPrivate *p) {





    Atom type_ret;
    int format_ret;
    unsigned long nitems_ret = 0, after_ret = 0;
    unsigned char *data_ret = 0;


    for (int i = 0; i < p->icons.size(); i++)
        delete [] p->icons[i].data;
    p->icons.reset();
    p->icon_count = 0;


    unsigned char *buffer = 0;
    unsigned long offset = 0;
    unsigned long buffer_offset = 0;
    unsigned long bufsize = 0;


    do {
        if (XGetWindowProperty(p->display, p->window, net_wm_icon, offset,
                               MAX_PROP_SIZE, 0, ((Atom) 6), &type_ret,
                               &format_ret, &nitems_ret, &after_ret, &data_ret)
            == Success) {
            if (!bufsize)
            {
               if (nitems_ret < 3 || type_ret != ((Atom) 6) ||
                  format_ret != 32) {




                  if ( data_ret )
                     XFree(data_ret);
                  return;
               }

               bufsize = nitems_ret * sizeof(long) + after_ret;
               buffer = (unsigned char *) malloc(bufsize);
            }
            else if (buffer_offset + nitems_ret*sizeof(long) > bufsize)
            {
fprintf(stderr, "NETWM: Warning readIcon() needs buffer adjustment!\n");
               bufsize = buffer_offset + nitems_ret * sizeof(long) + after_ret;
               buffer = (unsigned char *) realloc(buffer, bufsize);
            }
            memcpy((buffer + buffer_offset), data_ret, nitems_ret * sizeof(long));
            buffer_offset += nitems_ret * sizeof(long);
            offset += nitems_ret;

            if ( data_ret )
                XFree(data_ret);
        } else {
            if (buffer)
               free(buffer);
            return;
        }
    }
    while (after_ret > 0);

    CARD32 *data32;
    unsigned long i, j, k, sz, s;
    unsigned long *d = (unsigned long *) buffer;
    for (i = 0, j = 0; i < bufsize; i++) {
        p->icons[j].size.width = *d++;
        i += sizeof(long);
        p->icons[j].size.height = *d++;
        i += sizeof(long);

        sz = p->icons[j].size.width * p->icons[j].size.height;
        s = sz * sizeof(long);

        if ( i + s - 1 > bufsize ) {
            break;
        }

        if (p->icons[j].data) delete [] p->icons[j].data;
        data32 = new CARD32[sz];
        p->icons[j].data = (unsigned char *) data32;
        for (k = 0; k < sz; k++, i += sizeof(long)) {
            *data32++ = (CARD32) *d++;
        }
        j++;
        p->icon_count++;
    }





    free(buffer);
}


template <class Z>
NETRArray<Z>::NETRArray()
  : sz(0), capacity(2)
{
    d = (Z*) calloc(capacity, sizeof(Z));
}


template <class Z>
NETRArray<Z>::~NETRArray() {
    free(d);
}


template <class Z>
void NETRArray<Z>::reset() {
    sz = 0;
    capacity = 2;
    d = (Z*) realloc(d, sizeof(Z)*capacity);
    memset( (void*) d, 0, sizeof(Z)*capacity );
}

template <class Z>
Z &NETRArray<Z>::operator[](int index) {
    if (index >= capacity) {



        int newcapacity = 2*capacity > index+1 ? 2*capacity : index+1;

        d = (Z*) realloc(d, sizeof(Z)*newcapacity);
        memset( (void*) &d[capacity], 0, sizeof(Z)*(newcapacity-capacity) );
        capacity = newcapacity;
    }
    if (index >= sz)
        sz = index + 1;

    return d[index];
}




NETRootInfo::NETRootInfo(Display *display, Window supportWindow, const char *wmName,
                         const unsigned long properties[], int properties_size,
                         int screen, bool doActivate)
{





    p = new NETRootInfoPrivate;
    p->ref = 1;

    p->display = display;
    p->name = nstrdup(wmName);

    if (screen != -1) {
        p->screen = screen;
    } else {
        p->screen = (((_XPrivDisplay)p->display)->default_screen);
    }

    p->root = ((&((_XPrivDisplay)p->display)->screens[p->screen])->root);
    p->supportwindow = supportWindow;
    p->number_of_desktops = p->current_desktop = 0;
    p->active = None;
    p->clients = p->stacking = p->virtual_roots = (Window *) 0;
    p->clients_count = p->stacking_count = p->virtual_roots_count = 0;
    p->kde_system_tray_windows = 0;
    p->kde_system_tray_windows_count = 0;
    setDefaultProperties();
    if( properties_size > PROPERTIES_SIZE ) {
        fprintf( stderr, "NETRootInfo::NETRootInfo(): properties array too large\n");
        properties_size = PROPERTIES_SIZE;
    }
    for( int i = 0; i < properties_size; ++i )
        p->properties[ i ] = properties[ i ];

    p->properties[ PROTOCOLS ] |= ( Supported | SupportingWMCheck );
    p->client_properties[ PROTOCOLS ] = DesktopNames
                                        | WMPing;
    p->client_properties[ PROTOCOLS2 ] = 0;

    role = WindowManager;

    if (! netwm_atoms_created) create_atoms(p->display);

    if (doActivate) activate();
}

NETRootInfo::NETRootInfo(Display *display, Window supportWindow, const char *wmName,
                         unsigned long properties, int screen, bool doActivate)
{





    p = new NETRootInfoPrivate;
    p->ref = 1;

    p->display = display;
    p->name = nstrdup(wmName);

    if (screen != -1) {
        p->screen = screen;
    } else {
        p->screen = (((_XPrivDisplay)p->display)->default_screen);
    }

    p->root = ((&((_XPrivDisplay)p->display)->screens[p->screen])->root);
    p->supportwindow = supportWindow;
    p->number_of_desktops = p->current_desktop = 0;
    p->active = None;
    p->clients = p->stacking = p->virtual_roots = (Window *) 0;
    p->clients_count = p->stacking_count = p->virtual_roots_count = 0;
    p->kde_system_tray_windows = 0;
    p->kde_system_tray_windows_count = 0;
    setDefaultProperties();
    p->properties[ PROTOCOLS ] = properties;

    p->properties[ PROTOCOLS ] |= ( Supported | SupportingWMCheck );
    p->client_properties[ PROTOCOLS ] = DesktopNames
                                        | WMPing;
    p->client_properties[ PROTOCOLS2 ] = 0;

    role = WindowManager;

    if (! netwm_atoms_created) create_atoms(p->display);

    if (doActivate) activate();
}


NETRootInfo::NETRootInfo(Display *display, const unsigned long properties[], int properties_size,
                         int screen, bool doActivate)
{





    p = new NETRootInfoPrivate;
    p->ref = 1;

    p->name = 0;

    p->display = display;

    if (screen != -1) {
        p->screen = screen;
    } else {
        p->screen = (((_XPrivDisplay)p->display)->default_screen);
    }

    p->root = ((&((_XPrivDisplay)p->display)->screens[p->screen])->root);
    p->rootSize.width = (((&((_XPrivDisplay)p->display)->screens[p->screen]))->width);
    p->rootSize.height = (((&((_XPrivDisplay)p->display)->screens[p->screen]))->height);

    p->supportwindow = None;
    p->number_of_desktops = p->current_desktop = 0;
    p->active = None;
    p->clients = p->stacking = p->virtual_roots = (Window *) 0;
    p->clients_count = p->stacking_count = p->virtual_roots_count = 0;
    p->kde_system_tray_windows = 0;
    p->kde_system_tray_windows_count = 0;
    setDefaultProperties();
    if( properties_size > PROPERTIES_SIZE ) {
        fprintf( stderr, "NETWinInfo::NETWinInfo(): properties array too large\n");
        properties_size = PROPERTIES_SIZE;
    }
    for( int i = 0; i < properties_size; ++i )
        p->client_properties[ i ] = properties[ i ];
    for( int i = 0; i < PROPERTIES_SIZE; ++i )
        p->properties[ i ] = 0;

    role = Client;

    if (! netwm_atoms_created) create_atoms(p->display);

    if (doActivate) activate();
}

NETRootInfo::NETRootInfo(Display *display, unsigned long properties, int screen,
                         bool doActivate)
{





    p = new NETRootInfoPrivate;
    p->ref = 1;

    p->name = 0;

    p->display = display;

    if (screen != -1) {
        p->screen = screen;
    } else {
        p->screen = (((_XPrivDisplay)p->display)->default_screen);
    }

    p->root = ((&((_XPrivDisplay)p->display)->screens[p->screen])->root);
    p->rootSize.width = (((&((_XPrivDisplay)p->display)->screens[p->screen]))->width);
    p->rootSize.height = (((&((_XPrivDisplay)p->display)->screens[p->screen]))->height);

    p->supportwindow = None;
    p->number_of_desktops = p->current_desktop = 0;
    p->active = None;
    p->clients = p->stacking = p->virtual_roots = (Window *) 0;
    p->clients_count = p->stacking_count = p->virtual_roots_count = 0;
    p->kde_system_tray_windows = 0;
    p->kde_system_tray_windows_count = 0;
    setDefaultProperties();
    p->client_properties[ PROTOCOLS ] = properties;
    for( int i = 0; i < PROPERTIES_SIZE; ++i )
        p->properties[ i ] = 0;

    role = Client;

    if (! netwm_atoms_created) create_atoms(p->display);

    if (doActivate) activate();
}


NETRootInfo2::NETRootInfo2(Display *display, Window supportWindow, const char *wmName,
                         unsigned long properties[], int properties_size,
                         int screen, bool doActivate)
    : NETRootInfo( display, supportWindow, wmName, properties, properties_size,
        screen, doActivate )
{
}



NETRootInfo::NETRootInfo(const NETRootInfo &rootinfo) {





    p = rootinfo.p;
    role = rootinfo.role;

    p->ref++;
}




NETRootInfo::~NETRootInfo() {
    refdec_nri(p);

    if (! p->ref) delete p;
}


void NETRootInfo::setDefaultProperties()
{
    p->properties[ PROTOCOLS ] = Supported | SupportingWMCheck;
    p->properties[ WINDOW_TYPES ] = NormalMask | DesktopMask | DockMask
        | ToolbarMask | MenuMask | DialogMask;
    p->properties[ STATES ] = Modal | Sticky | MaxVert | MaxHoriz | Shaded
        | SkipTaskbar | StaysOnTop;
    p->properties[ PROTOCOLS2 ] = 0;
    p->properties[ ACTIONS ] = 0;
    p->client_properties[ PROTOCOLS ] = 0;
    p->client_properties[ WINDOW_TYPES ] = 0;
    p->client_properties[ STATES ] = 0;
    p->client_properties[ PROTOCOLS2 ] = 0;
    p->client_properties[ ACTIONS ] = 0;
}

void NETRootInfo::activate() {
    if (role == WindowManager) {






        setSupported();
    } else {





        update(p->client_properties);
    }
}


void NETRootInfo::setClientList(Window *windows, unsigned int count) {
    if (role != WindowManager) return;

    p->clients_count = count;

    if (p->clients) delete [] p->clients;
    p->clients = nwindup(windows, count);






    XChangeProperty(p->display, p->root, net_client_list, ((Atom) 33), 32,
                    0, (unsigned char *)p->clients,
                    p->clients_count);
}


void NETRootInfo::setClientListStacking(Window *windows, unsigned int count) {
    if (role != WindowManager) return;

    p->stacking_count = count;
    if (p->stacking) delete [] p->stacking;
    p->stacking = nwindup(windows, count);







    XChangeProperty(p->display, p->root, net_client_list_stacking, ((Atom) 33), 32,
                    0, (unsigned char *) p->stacking,
                    p->stacking_count);
}


void NETRootInfo::setKDESystemTrayWindows(Window *windows, unsigned int count) {
    if (role != WindowManager) return;

    p->kde_system_tray_windows_count = count;
    if (p->kde_system_tray_windows) delete [] p->kde_system_tray_windows;
    p->kde_system_tray_windows = nwindup(windows, count);







    XChangeProperty(p->display, p->root, kde_net_system_tray_windows, ((Atom) 33), 32,
                    0,
                    (unsigned char *) p->kde_system_tray_windows,
                    p->kde_system_tray_windows_count);
}


void NETRootInfo::setNumberOfDesktops(int numberOfDesktops) {







    if (role == WindowManager) {
        p->number_of_desktops = numberOfDesktops;
        long d = numberOfDesktops;
        XChangeProperty(p->display, p->root, net_number_of_desktops, ((Atom) 6), 32,
                        0, (unsigned char *) &d, 1);
    } else {
        XEvent e;

        e.xclient.type = 33;
        e.xclient.message_type = net_number_of_desktops;
        e.xclient.display = p->display;
        e.xclient.window = p->root;
        e.xclient.format = 32;
        e.xclient.data.l[0] = numberOfDesktops;
        e.xclient.data.l[1] = 0l;
        e.xclient.data.l[2] = 0l;
        e.xclient.data.l[3] = 0l;
        e.xclient.data.l[4] = 0l;

        XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
    }
}


void NETRootInfo::setCurrentDesktop(int desktop) {







    if (role == WindowManager) {
        p->current_desktop = desktop;
        long d = p->current_desktop - 1;
        XChangeProperty(p->display, p->root, net_current_desktop, ((Atom) 6), 32,
                        0, (unsigned char *) &d, 1);
    } else {
        XEvent e;

        e.xclient.type = 33;
        e.xclient.message_type = net_current_desktop;
        e.xclient.display = p->display;
        e.xclient.window = p->root;
        e.xclient.format = 32;
        e.xclient.data.l[0] = desktop - 1;
        e.xclient.data.l[1] = 0l;
        e.xclient.data.l[2] = 0l;
        e.xclient.data.l[3] = 0l;
        e.xclient.data.l[4] = 0l;

        XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
    }
}


void NETRootInfo::setDesktopName(int desktop, const char *desktopName) {

    if (desktop < 1) return;

    if (p->desktop_names[desktop - 1]) delete [] p->desktop_names[desktop - 1];
    p->desktop_names[desktop - 1] = nstrdup(desktopName);

    unsigned int i, proplen,
        num = ((p->number_of_desktops > p->desktop_names.size()) ?
               p->number_of_desktops : p->desktop_names.size());
    for (i = 0, proplen = 0; i < num; i++)
        proplen += (p->desktop_names[i] != 0 ? strlen(p->desktop_names[i])+1 : 1 );

    char *prop = new char[proplen], *propp = prop;

    for (i = 0; i < num; i++)
        if (p->desktop_names[i]) {
            strcpy(propp, p->desktop_names[i]);
            propp += strlen(p->desktop_names[i]) + 1;
        } else
            *propp++ = '\0';
# 950 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
    XChangeProperty(p->display, p->root, net_desktop_names, UTF8_STRING, 8,
                    0, (unsigned char *) prop, proplen);

    delete [] prop;
}


void NETRootInfo::setDesktopGeometry(int , const NETSize &geometry) {






    if (role == WindowManager) {
        p->geometry = geometry;

        long data[2];
        data[0] = p->geometry.width;
        data[1] = p->geometry.height;

        XChangeProperty(p->display, p->root, net_desktop_geometry, ((Atom) 6), 32,
                        0, (unsigned char *) data, 2);
    } else {
        XEvent e;

        e.xclient.type = 33;
        e.xclient.message_type = net_desktop_geometry;
        e.xclient.display = p->display;
        e.xclient.window = p->root;
        e.xclient.format = 32;
        e.xclient.data.l[0] = geometry.width;
        e.xclient.data.l[1] = geometry.height;
        e.xclient.data.l[2] = 0l;
        e.xclient.data.l[3] = 0l;
        e.xclient.data.l[4] = 0l;

        XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
    }
}


void NETRootInfo::setDesktopViewport(int desktop, const NETPoint &viewport) {






    if (desktop < 1) return;

    if (role == WindowManager) {
        p->viewport[desktop - 1] = viewport;

        int d, i, l;
        l = p->number_of_desktops * 2;
        long *data = new long[l];
        for (d = 0, i = 0; d < p->number_of_desktops; d++) {
            data[i++] = p->viewport[d].x;
            data[i++] = p->viewport[d].y;
        }

        XChangeProperty(p->display, p->root, net_desktop_viewport, ((Atom) 6), 32,
                        0, (unsigned char *) data, l);

        delete [] data;
    } else {
        XEvent e;

        e.xclient.type = 33;
        e.xclient.message_type = net_desktop_viewport;
        e.xclient.display = p->display;
        e.xclient.window = p->root;
        e.xclient.format = 32;
        e.xclient.data.l[0] = viewport.x;
        e.xclient.data.l[1] = viewport.y;
        e.xclient.data.l[2] = 0l;
        e.xclient.data.l[3] = 0l;
        e.xclient.data.l[4] = 0l;

        XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
    }
}


void NETRootInfo::setSupported() {
    if (role != WindowManager) {




        return;
    }

    Atom atoms[netAtomCount];
    int pnum = 2;


    atoms[0] = net_supported;
    atoms[1] = net_supporting_wm_check;

    if (p->properties[ PROTOCOLS ] & ClientList)
        atoms[pnum++] = net_client_list;

    if (p->properties[ PROTOCOLS ] & ClientListStacking)
        atoms[pnum++] = net_client_list_stacking;

    if (p->properties[ PROTOCOLS ] & NumberOfDesktops)
        atoms[pnum++] = net_number_of_desktops;

    if (p->properties[ PROTOCOLS ] & DesktopGeometry)
        atoms[pnum++] = net_desktop_geometry;

    if (p->properties[ PROTOCOLS ] & DesktopViewport)
        atoms[pnum++] = net_desktop_viewport;

    if (p->properties[ PROTOCOLS ] & CurrentDesktop)
        atoms[pnum++] = net_current_desktop;

    if (p->properties[ PROTOCOLS ] & DesktopNames)
        atoms[pnum++] = net_desktop_names;

    if (p->properties[ PROTOCOLS ] & ActiveWindow)
        atoms[pnum++] = net_active_window;

    if (p->properties[ PROTOCOLS ] & WorkArea)
        atoms[pnum++] = net_workarea;

    if (p->properties[ PROTOCOLS ] & VirtualRoots)
        atoms[pnum++] = net_virtual_roots;

    if (p->properties[ PROTOCOLS ] & CloseWindow)
        atoms[pnum++] = net_close_window;



    if (p->properties[ PROTOCOLS ] & WMMoveResize)
        atoms[pnum++] = net_wm_moveresize;

    if (p->properties[ PROTOCOLS ] & WMName)
        atoms[pnum++] = net_wm_name;

    if (p->properties[ PROTOCOLS ] & WMVisibleName)
        atoms[pnum++] = net_wm_visible_name;

    if (p->properties[ PROTOCOLS ] & WMIconName)
        atoms[pnum++] = net_wm_icon_name;

    if (p->properties[ PROTOCOLS ] & WMVisibleIconName)
        atoms[pnum++] = net_wm_visible_icon_name;

    if (p->properties[ PROTOCOLS ] & WMDesktop)
        atoms[pnum++] = net_wm_desktop;

    if (p->properties[ PROTOCOLS ] & WMWindowType) {
        atoms[pnum++] = net_wm_window_type;


        if (p->properties[ WINDOW_TYPES ] & NormalMask)
            atoms[pnum++] = net_wm_window_type_normal;
        if (p->properties[ WINDOW_TYPES ] & DesktopMask)
            atoms[pnum++] = net_wm_window_type_desktop;
        if (p->properties[ WINDOW_TYPES ] & DockMask)
            atoms[pnum++] = net_wm_window_type_dock;
        if (p->properties[ WINDOW_TYPES ] & ToolbarMask)
            atoms[pnum++] = net_wm_window_type_toolbar;
        if (p->properties[ WINDOW_TYPES ] & MenuMask)
            atoms[pnum++] = net_wm_window_type_menu;
        if (p->properties[ WINDOW_TYPES ] & DialogMask)
            atoms[pnum++] = net_wm_window_type_dialog;
        if (p->properties[ WINDOW_TYPES ] & UtilityMask)
            atoms[pnum++] = net_wm_window_type_utility;
        if (p->properties[ WINDOW_TYPES ] & SplashMask)
            atoms[pnum++] = net_wm_window_type_splash;

        if (p->properties[ WINDOW_TYPES ] & OverrideMask)
            atoms[pnum++] = kde_net_wm_window_type_override;
        if (p->properties[ WINDOW_TYPES ] & TopMenuMask)
            atoms[pnum++] = kde_net_wm_window_type_topmenu;
    }

    if (p->properties[ PROTOCOLS ] & WMState) {
        atoms[pnum++] = net_wm_state;


        if (p->properties[ STATES ] & Modal)
            atoms[pnum++] = net_wm_state_modal;
        if (p->properties[ STATES ] & Sticky)
            atoms[pnum++] = net_wm_state_sticky;
        if (p->properties[ STATES ] & MaxVert)
            atoms[pnum++] = net_wm_state_max_vert;
        if (p->properties[ STATES ] & MaxHoriz)
            atoms[pnum++] = net_wm_state_max_horiz;
        if (p->properties[ STATES ] & Shaded)
            atoms[pnum++] = net_wm_state_shaded;
        if (p->properties[ STATES ] & SkipTaskbar)
            atoms[pnum++] = net_wm_state_skip_taskbar;
        if (p->properties[ STATES ] & SkipPager)
            atoms[pnum++] = net_wm_state_skip_pager;
        if (p->properties[ STATES ] & Hidden)
            atoms[pnum++] = net_wm_state_hidden;
        if (p->properties[ STATES ] & FullScreen)
            atoms[pnum++] = net_wm_state_fullscreen;
        if (p->properties[ STATES ] & KeepAbove)
            atoms[pnum++] = net_wm_state_above;
        if (p->properties[ STATES ] & KeepBelow)
            atoms[pnum++] = net_wm_state_below;
        if (p->properties[ STATES ] & DemandsAttention)
            atoms[pnum++] = net_wm_state_demands_attention;

        if (p->properties[ STATES ] & StaysOnTop)
            atoms[pnum++] = net_wm_state_stays_on_top;
    }

    if (p->properties[ PROTOCOLS ] & WMStrut)
        atoms[pnum++] = net_wm_strut;

    if (p->properties[ PROTOCOLS ] & WMIconGeometry)
        atoms[pnum++] = net_wm_icon_geometry;

    if (p->properties[ PROTOCOLS ] & WMIcon)
        atoms[pnum++] = net_wm_icon;

    if (p->properties[ PROTOCOLS ] & WMPid)
        atoms[pnum++] = net_wm_pid;

    if (p->properties[ PROTOCOLS ] & WMHandledIcons)
        atoms[pnum++] = net_wm_handled_icons;

    if (p->properties[ PROTOCOLS ] & WMPing)
        atoms[pnum++] = net_wm_ping;

    if (p->properties[ PROTOCOLS2 ] & WM2UserTime)
        atoms[pnum++] = net_wm_user_time;

    if (p->properties[ PROTOCOLS2 ] & WM2StartupId)
        atoms[pnum++] = net_startup_id;

    if (p->properties[ PROTOCOLS2 ] & WM2AllowedActions) {
        atoms[pnum++] = net_wm_allowed_actions;


        if (p->properties[ ACTIONS ] & ActionMove)
            atoms[pnum++] = net_wm_action_move;
        if (p->properties[ ACTIONS ] & ActionResize)
            atoms[pnum++] = net_wm_action_resize;
        if (p->properties[ ACTIONS ] & ActionMinimize)
            atoms[pnum++] = net_wm_action_minimize;
        if (p->properties[ ACTIONS ] & ActionShade)
            atoms[pnum++] = net_wm_action_shade;
        if (p->properties[ ACTIONS ] & ActionStick)
            atoms[pnum++] = net_wm_action_stick;
        if (p->properties[ ACTIONS ] & ActionMaxVert)
            atoms[pnum++] = net_wm_action_max_vert;
        if (p->properties[ ACTIONS ] & ActionMaxHoriz)
            atoms[pnum++] = net_wm_action_max_horiz;
        if (p->properties[ ACTIONS ] & ActionFullScreen)
            atoms[pnum++] = net_wm_action_fullscreen;
        if (p->properties[ ACTIONS ] & ActionChangeDesktop)
            atoms[pnum++] = net_wm_action_change_desk;
        if (p->properties[ ACTIONS ] & ActionClose)
            atoms[pnum++] = net_wm_action_close;
    }


    if (p->properties[ PROTOCOLS ] & KDESystemTrayWindows)
        atoms[pnum++] = kde_net_system_tray_windows;

    if (p->properties[ PROTOCOLS ] & WMKDESystemTrayWinFor)
        atoms[pnum++] = kde_net_wm_system_tray_window_for;

    if (p->properties[ PROTOCOLS ] & WMKDEFrameStrut)
        atoms[pnum++] = kde_net_wm_frame_strut;

    XChangeProperty(p->display, p->root, net_supported, ((Atom) 4), 32,
                    0, (unsigned char *) atoms, pnum);
    XChangeProperty(p->display, p->root, net_supporting_wm_check, ((Atom) 33), 32,
                    0, (unsigned char *) &(p->supportwindow), 1);
# 1236 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
    XChangeProperty(p->display, p->supportwindow, net_supporting_wm_check,
                    ((Atom) 33), 32, 0,
                    (unsigned char *) &(p->supportwindow), 1);
    XChangeProperty(p->display, p->supportwindow, net_wm_name, UTF8_STRING, 8,
                    0, (unsigned char *) p->name,
                    strlen(p->name));
}

void NETRootInfo::updateSupportedProperties( Atom atom )
{
    if( atom == net_supported )
        p->properties[ PROTOCOLS ] |= Supported;

    else if( atom == net_supporting_wm_check )
        p->properties[ PROTOCOLS ] |= SupportingWMCheck;

    else if( atom == net_client_list )
        p->properties[ PROTOCOLS ] |= ClientList;

    else if( atom == net_client_list_stacking )
        p->properties[ PROTOCOLS ] |= ClientListStacking;

    else if( atom == net_number_of_desktops )
        p->properties[ PROTOCOLS ] |= NumberOfDesktops;

    else if( atom == net_desktop_geometry )
        p->properties[ PROTOCOLS ] |= DesktopGeometry;

    else if( atom == net_desktop_viewport )
        p->properties[ PROTOCOLS ] |= DesktopViewport;

    else if( atom == net_current_desktop )
        p->properties[ PROTOCOLS ] |= CurrentDesktop;

    else if( atom == net_desktop_names )
        p->properties[ PROTOCOLS ] |= DesktopNames;

    else if( atom == net_active_window )
        p->properties[ PROTOCOLS ] |= ActiveWindow;

    else if( atom == net_workarea )
        p->properties[ PROTOCOLS ] |= WorkArea;

    else if( atom == net_virtual_roots )
        p->properties[ PROTOCOLS ] |= VirtualRoots;

    else if( atom == net_close_window )
        p->properties[ PROTOCOLS ] |= CloseWindow;



    else if( atom == net_wm_moveresize )
        p->properties[ PROTOCOLS ] |= WMMoveResize;

    else if( atom == net_wm_name )
        p->properties[ PROTOCOLS ] |= WMName;

    else if( atom == net_wm_visible_name )
        p->properties[ PROTOCOLS ] |= WMVisibleName;

    else if( atom == net_wm_icon_name )
        p->properties[ PROTOCOLS ] |= WMIconName;

    else if( atom == net_wm_visible_icon_name )
        p->properties[ PROTOCOLS ] |= WMVisibleIconName;

    else if( atom == net_wm_desktop )
        p->properties[ PROTOCOLS ] |= WMDesktop;

    else if( atom == net_wm_window_type )
        p->properties[ PROTOCOLS ] |= WMWindowType;


    else if( atom == net_wm_window_type_normal )
        p->properties[ WINDOW_TYPES ] |= NormalMask;
    else if( atom == net_wm_window_type_desktop )
        p->properties[ WINDOW_TYPES ] |= DesktopMask;
    else if( atom == net_wm_window_type_dock )
        p->properties[ WINDOW_TYPES ] |= DockMask;
    else if( atom == net_wm_window_type_toolbar )
        p->properties[ WINDOW_TYPES ] |= ToolbarMask;
    else if( atom == net_wm_window_type_menu )
        p->properties[ WINDOW_TYPES ] |= MenuMask;
    else if( atom == net_wm_window_type_dialog )
        p->properties[ WINDOW_TYPES ] |= DialogMask;
    else if( atom == net_wm_window_type_utility )
        p->properties[ WINDOW_TYPES ] |= UtilityMask;
    else if( atom == net_wm_window_type_splash )
        p->properties[ WINDOW_TYPES ] |= SplashMask;

    else if( atom == kde_net_wm_window_type_override )
        p->properties[ WINDOW_TYPES ] |= OverrideMask;
    else if( atom == kde_net_wm_window_type_topmenu )
        p->properties[ WINDOW_TYPES ] |= TopMenuMask;

    else if( atom == net_wm_state )
        p->properties[ PROTOCOLS ] |= WMState;


    else if( atom == net_wm_state_modal )
        p->properties[ STATES ] |= Modal;
    else if( atom == net_wm_state_sticky )
        p->properties[ STATES ] |= Sticky;
    else if( atom == net_wm_state_max_vert )
        p->properties[ STATES ] |= MaxVert;
    else if( atom == net_wm_state_max_horiz )
        p->properties[ STATES ] |= MaxHoriz;
    else if( atom == net_wm_state_shaded )
        p->properties[ STATES ] |= Shaded;
    else if( atom == net_wm_state_skip_taskbar )
        p->properties[ STATES ] |= SkipTaskbar;
    else if( atom == net_wm_state_skip_pager )
        p->properties[ STATES ] |= SkipPager;
    else if( atom == net_wm_state_hidden )
        p->properties[ STATES ] |= Hidden;
    else if( atom == net_wm_state_fullscreen )
        p->properties[ STATES ] |= FullScreen;
    else if( atom == net_wm_state_above )
        p->properties[ STATES ] |= KeepAbove;
    else if( atom == net_wm_state_below )
        p->properties[ STATES ] |= KeepBelow;
    else if( atom == net_wm_state_demands_attention )
        p->properties[ STATES ] |= DemandsAttention;

    else if( atom == net_wm_state_stays_on_top )
        p->properties[ STATES ] |= StaysOnTop;

    else if( atom == net_wm_strut )
        p->properties[ PROTOCOLS ] |= WMStrut;

    else if( atom == net_wm_icon_geometry )
        p->properties[ PROTOCOLS ] |= WMIconGeometry;

    else if( atom == net_wm_icon )
        p->properties[ PROTOCOLS ] |= WMIcon;

    else if( atom == net_wm_pid )
        p->properties[ PROTOCOLS ] |= WMPid;

    else if( atom == net_wm_handled_icons )
        p->properties[ PROTOCOLS ] |= WMHandledIcons;

    else if( atom == net_wm_ping )
        p->properties[ PROTOCOLS ] |= WMPing;

    else if( atom == net_wm_user_time )
        p->properties[ PROTOCOLS2 ] |= WM2UserTime;

    else if( atom == net_startup_id )
        p->properties[ PROTOCOLS2 ] |= WM2StartupId;

    else if( atom == net_wm_allowed_actions )
        p->properties[ PROTOCOLS2 ] |= WM2AllowedActions;


    else if( atom == net_wm_action_move )
        p->properties[ ACTIONS ] |= ActionMove;
    else if( atom == net_wm_action_resize )
        p->properties[ ACTIONS ] |= ActionResize;
    else if( atom == net_wm_action_minimize )
        p->properties[ ACTIONS ] |= ActionMinimize;
    else if( atom == net_wm_action_shade )
        p->properties[ ACTIONS ] |= ActionShade;
    else if( atom == net_wm_action_stick )
        p->properties[ ACTIONS ] |= ActionStick;
    else if( atom == net_wm_action_max_vert )
        p->properties[ ACTIONS ] |= ActionMaxVert;
    else if( atom == net_wm_action_max_horiz )
        p->properties[ ACTIONS ] |= ActionMaxHoriz;
    else if( atom == net_wm_action_fullscreen )
        p->properties[ ACTIONS ] |= ActionFullScreen;
    else if( atom == net_wm_action_change_desk )
        p->properties[ ACTIONS ] |= ActionChangeDesktop;
    else if( atom == net_wm_action_close )
        p->properties[ ACTIONS ] |= ActionClose;


    else if( atom == kde_net_system_tray_windows )
        p->properties[ PROTOCOLS ] |= KDESystemTrayWindows;

    else if( atom == kde_net_wm_system_tray_window_for )
        p->properties[ PROTOCOLS ] |= WMKDESystemTrayWinFor;

    else if( atom == kde_net_wm_frame_strut )
        p->properties[ PROTOCOLS ] |= WMKDEFrameStrut;
}

extern Time qt_x_last_input_time;
void NETRootInfo::setActiveWindow(Window window) {
    setActiveWindow( window, FromUnknown, qt_x_last_input_time );
}

void NETRootInfo::setActiveWindow(Window window, NET::RequestSource src,
    Time timestamp ) {






    if (role == WindowManager) {
        p->active = window;
        XChangeProperty(p->display, p->root, net_active_window, ((Atom) 33), 32,
                        0, (unsigned char *) &(p->active), 1);
    } else {
        XEvent e;

        e.xclient.type = 33;
        e.xclient.message_type = net_active_window;
        e.xclient.display = p->display;
        e.xclient.window = window;
        e.xclient.format = 32;
        e.xclient.data.l[0] = src;
        e.xclient.data.l[1] = timestamp;
        e.xclient.data.l[2] = 0l;
        e.xclient.data.l[3] = 0l;
        e.xclient.data.l[4] = 0l;

        XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
    }
}


void NETRootInfo::setWorkArea(int desktop, const NETRect &workarea) {







    if (role != WindowManager || desktop < 1) return;

    p->workarea[desktop - 1] = workarea;

    long *wa = new long[p->number_of_desktops * 4];
    int i, o;
    for (i = 0, o = 0; i < p->number_of_desktops; i++) {
        wa[o++] = p->workarea[i].pos.x;
        wa[o++] = p->workarea[i].pos.y;
        wa[o++] = p->workarea[i].size.width;
        wa[o++] = p->workarea[i].size.height;
    }

    XChangeProperty(p->display, p->root, net_workarea, ((Atom) 6), 32,
                    0, (unsigned char *) wa,
                    p->number_of_desktops * 4);

    delete [] wa;
}


void NETRootInfo::setVirtualRoots(Window *windows, unsigned int count) {
    if (role != WindowManager) return;

    p->virtual_roots_count = count;
    p->virtual_roots = windows;






    XChangeProperty(p->display, p->root, net_virtual_roots, ((Atom) 33), 32,
                    0, (unsigned char *) p->virtual_roots,
                    p->virtual_roots_count);
}


void NETRootInfo::closeWindowRequest(Window window) {






    XEvent e;

    e.xclient.type = 33;
    e.xclient.message_type = net_close_window;
    e.xclient.display = p->display;
    e.xclient.window = window;
    e.xclient.format = 32;
    e.xclient.data.l[0] = 0l;
    e.xclient.data.l[1] = 0l;
    e.xclient.data.l[2] = 0l;
    e.xclient.data.l[3] = 0l;
    e.xclient.data.l[4] = 0l;

    XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
}


void NETRootInfo::moveResizeRequest(Window window, int x_root, int y_root,
                                    Direction direction)
{







    XEvent e;

    e.xclient.type = 33;
    e.xclient.message_type = net_wm_moveresize;
    e.xclient.display = p->display;
    e.xclient.window = window,
    e.xclient.format = 32;
    e.xclient.data.l[0] = x_root;
    e.xclient.data.l[1] = y_root;
    e.xclient.data.l[2] = direction;
    e.xclient.data.l[3] = 0l;
    e.xclient.data.l[4] = 0l;

    XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
}

void NETRootInfo2::sendPing( Window window, Time timestamp )
{
    if (role != WindowManager) return;




    XEvent e;
    e.xclient.type = 33;
    e.xclient.message_type = wm_protocols;
    e.xclient.display = p->display;
    e.xclient.window = window,
    e.xclient.format = 32;
    e.xclient.data.l[0] = net_wm_ping;
    e.xclient.data.l[1] = timestamp;
    e.xclient.data.l[2] = window;
    e.xclient.data.l[3] = 0;
    e.xclient.data.l[4] = 0;

    XSendEvent(p->display, window, 0, 0, &e);
}





const NETRootInfo &NETRootInfo::operator=(const NETRootInfo &rootinfo) {





    if (p != rootinfo.p) {
        refdec_nri(p);

        if (! p->ref) delete p;
    }

    p = rootinfo.p;
    role = rootinfo.role;
    p->ref++;

    return *this;
}

unsigned long NETRootInfo::event(XEvent *ev )
{
    unsigned long props[ 1 ];
    event( ev, props, 1 );
    return props[ 0 ];
}

void NETRootInfo::event(XEvent *event, unsigned long* properties, int properties_size )
{
    unsigned long props[ PROPERTIES_SIZE ] = { 0, 0, 0, 0, 0 };
    (static_cast<void> ((PROPERTIES_SIZE == 5) ? 0 : (__assert_fail ("PROPERTIES_SIZE == 5", "/coolo/prod/kdelibs/kdecore/netwm.cpp", 1610, __PRETTY_FUNCTION__), 0)));
    unsigned long& dirty = props[ PROTOCOLS ];
    unsigned long& dirty2 = props[ PROTOCOLS2 ];
    bool do_update = false;

    (void)dirty2;;



    if (role == WindowManager && event->type == 33 &&
        event->xclient.format == 32) {




        if (event->xclient.message_type == net_number_of_desktops) {
            dirty = NumberOfDesktops;






            changeNumberOfDesktops(event->xclient.data.l[0]);
        } else if (event->xclient.message_type == net_desktop_geometry) {
            dirty = DesktopGeometry;

            NETSize sz;
            sz.width = event->xclient.data.l[0];
            sz.height = event->xclient.data.l[1];






            changeDesktopGeometry(~0, sz);
        } else if (event->xclient.message_type == net_desktop_viewport) {
            dirty = DesktopViewport;

            NETPoint pt;
            pt.x = event->xclient.data.l[0];
            pt.y = event->xclient.data.l[1];






            changeDesktopViewport(p->current_desktop, pt);
        } else if (event->xclient.message_type == net_current_desktop) {
            dirty = CurrentDesktop;






            changeCurrentDesktop(event->xclient.data.l[0] + 1);
        } else if (event->xclient.message_type == net_active_window) {
            dirty = ActiveWindow;






            changeActiveWindow(event->xclient.window);
            if( NETRootInfo2* this2 = dynamic_cast< NETRootInfo2* >( this ))
            {
                RequestSource src = FromUnknown;

                if( event->xclient.data.l[0] >= FromUnknown
                    && event->xclient.data.l[0] <= FromTool )
                    src = static_cast< RequestSource >( event->xclient.data.l[0] );
                this2->changeActiveWindow( event->xclient.window, src,
                    event->xclient.data.l[1]);
            }
        } else if (event->xclient.message_type == net_wm_moveresize) {
# 1699 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
            moveResize(event->xclient.window,
                       event->xclient.data.l[0],
                       event->xclient.data.l[1],
                       event->xclient.data.l[2]);
        } else if (event->xclient.message_type == net_close_window) {






            closeWindow(event->xclient.window);
        } else if (event->xclient.message_type == wm_protocols
            && (Atom)event->xclient.data.l[ 0 ] == net_wm_ping) {
            dirty = WMPing;





            if( NETRootInfo2* this2 = dynamic_cast< NETRootInfo2* >( this ))
                this2->gotPing( event->xclient.data.l[2], event->xclient.data.l[1]);
        }
    }

    if (event->type == 28) {





        XEvent pe = *event;

        Bool done = 0;
        Bool compaction = 0;
        while (! done) {





            if (pe.xproperty.atom == net_client_list)
                dirty |= ClientList;
            else if (pe.xproperty.atom == net_client_list_stacking)
                dirty |= ClientListStacking;
            else if (pe.xproperty.atom == kde_net_system_tray_windows)
                dirty |= KDESystemTrayWindows;
            else if (pe.xproperty.atom == net_desktop_names)
                dirty |= DesktopNames;
            else if (pe.xproperty.atom == net_workarea)
                dirty |= WorkArea;
            else if (pe.xproperty.atom == net_number_of_desktops)
                dirty |= NumberOfDesktops;
            else if (pe.xproperty.atom == net_desktop_geometry)
                dirty |= DesktopGeometry;
            else if (pe.xproperty.atom == net_desktop_viewport)
                dirty |= DesktopViewport;
            else if (pe.xproperty.atom == net_current_desktop)
                dirty |= CurrentDesktop;
            else if (pe.xproperty.atom == net_active_window)
                dirty |= ActiveWindow;
            else {





                if ( compaction )
                    XPutBackEvent(p->display, &pe);
                break;
            }

            if (XCheckTypedWindowEvent(p->display, p->root, 28, &pe) )
                compaction = 1;
            else
                break;
        }

        do_update = true;
    }

    if( do_update )
        update( props );






    if( properties_size > PROPERTIES_SIZE )
        properties_size = PROPERTIES_SIZE;
    for( int i = 0;
         i < properties_size;
         ++i )
        properties[ i ] = props[ i ];
}




void NETRootInfo::update( const unsigned long dirty_props[] )
{
    Atom type_ret;
    int format_ret;
    unsigned char *data_ret;
    unsigned long nitems_ret, unused;
    unsigned long props[ PROPERTIES_SIZE ];
    for( int i = 0;
         i < PROPERTIES_SIZE;
         ++i )
        props[ i ] = dirty_props[ i ] & p->client_properties[ i ];
    const unsigned long& dirty = props[ PROTOCOLS ];
    const unsigned long& dirty2 = props[ PROTOCOLS2 ];

    (void)dirty2;;

    if (dirty & Supported ) {

        for( int i = 0; i < PROPERTIES_SIZE; ++i )
            p->properties[ i ] = 0;
        if( XGetWindowProperty(p->display, p->root, net_supported,
                               0l, MAX_PROP_SIZE, 0, ((Atom) 4), &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success ) {
            if( type_ret == ((Atom) 4) && format_ret == 32 ) {
                Atom* atoms = (Atom*) data_ret;
                for( unsigned int i = 0;
                     i < nitems_ret;
                     ++i )
                    updateSupportedProperties( atoms[ i ] );
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & ClientList) {
        bool read_ok = false;
        if (XGetWindowProperty(p->display, p->root, net_client_list,
                               0l, MAX_PROP_SIZE, 0, ((Atom) 33), &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 33) && format_ret == 32) {
                Window *wins = (Window *) data_ret;

                qsort(wins, nitems_ret, sizeof(Window), wcmp);

                if (p->clients) {
                    if (role == Client) {
                        unsigned long new_index = 0, old_index = 0;
                        unsigned long new_count = nitems_ret,
                                      old_count = p->clients_count;

                        while (old_index < old_count || new_index < new_count) {
                            if (old_index == old_count) {
                                addClient(wins[new_index++]);
                            } else if (new_index == new_count) {
                                removeClient(p->clients[old_index++]);
                            } else {
                                if (p->clients[old_index] <
                                    wins[new_index]) {
                                    removeClient(p->clients[old_index++]);
                                } else if (wins[new_index] <
                                           p->clients[old_index]) {
                                    addClient(wins[new_index++]);
                                } else {
                                    new_index++;
                                    old_index++;
                                }
                            }
                        }
                    }

                    delete [] p->clients;
                } else {




                    unsigned long n;
                    for (n = 0; n < nitems_ret; n++) {
                        addClient(wins[n]);
                    }
                }

                p->clients_count = nitems_ret;
                p->clients = nwindup(wins, p->clients_count);
                read_ok = true;
            }

            if ( data_ret )
                XFree(data_ret);
        }
        if( !read_ok ) {
            for( unsigned int i = 0; i < p->clients_count; ++ i )
                removeClient(p->clients[i]);
            p->clients_count = 0;
            delete[] p->clients;
            p->clients = __null;
        }





    }

    if (dirty & KDESystemTrayWindows) {
        bool read_ok = false;
        if (XGetWindowProperty(p->display, p->root, kde_net_system_tray_windows,
                               0l, MAX_PROP_SIZE, 0, ((Atom) 33), &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 33) && format_ret == 32) {
                Window *wins = (Window *) data_ret;

                qsort(wins, nitems_ret, sizeof(Window), wcmp);

                if (p->kde_system_tray_windows) {
                    if (role == Client) {
                        unsigned long new_index = 0, new_count = nitems_ret;
                        unsigned long old_index = 0,
                                      old_count = p->kde_system_tray_windows_count;

                        while(old_index < old_count || new_index < new_count) {
                            if (old_index == old_count) {
                                addSystemTrayWin(wins[new_index++]);
                            } else if (new_index == new_count) {
                                removeSystemTrayWin(p->kde_system_tray_windows[old_index++]);
                            } else {
                                if (p->kde_system_tray_windows[old_index] <
                                    wins[new_index]) {
                                    removeSystemTrayWin(p->kde_system_tray_windows[old_index++]);
                                } else if (wins[new_index] <
                                           p->kde_system_tray_windows[old_index]) {
                                    addSystemTrayWin(wins[new_index++]);
                                } else {
                                    new_index++;
                                    old_index++;
                                }
                            }
                        }
                    }

                } else {
                    unsigned long n;
                    for (n = 0; n < nitems_ret; n++) {
                        addSystemTrayWin(wins[n]);
                    }
                }

                p->kde_system_tray_windows_count = nitems_ret;
                if (p->kde_system_tray_windows)
                    delete [] p->kde_system_tray_windows;
                p->kde_system_tray_windows =
                    nwindup(wins, p->kde_system_tray_windows_count);
                read_ok = true;
            }

            if ( data_ret )
                XFree(data_ret);
        }
        if( !read_ok ) {
            for( unsigned int i = 0; i < p->kde_system_tray_windows_count; ++i )
                removeSystemTrayWin(p->kde_system_tray_windows[i]);
            p->kde_system_tray_windows_count = 0;
            delete [] p->kde_system_tray_windows;
            p->kde_system_tray_windows = __null;
        }
    }

    if (dirty & ClientListStacking) {
        p->stacking_count = 0;
        delete[] p->stacking;
        p->stacking = __null;
        if (XGetWindowProperty(p->display, p->root, net_client_list_stacking,
                               0, MAX_PROP_SIZE, 0, ((Atom) 33), &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 33) && format_ret == 32) {
                Window *wins = (Window *) data_ret;

                p->stacking_count = nitems_ret;
                p->stacking = nwindup(wins, p->stacking_count);
            }






            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & NumberOfDesktops) {
        p->number_of_desktops = 0;

        if (XGetWindowProperty(p->display, p->root, net_number_of_desktops,
                               0l, 1l, 0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 && nitems_ret == 1) {
                p->number_of_desktops = *((long *) data_ret);
            }





            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & DesktopGeometry) {
        p->geometry = p->rootSize;
        if (XGetWindowProperty(p->display, p->root, net_desktop_geometry,
                               0l, 2l, 0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 &&
                nitems_ret == 2) {
                long *data = (long *) data_ret;

                p->geometry.width = data[0];
                p->geometry.height = data[1];




            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & DesktopViewport) {
        for (int i = 0; i < p->viewport.size(); i++)
            p->viewport[i].x = p->viewport[i].y = 0;
        if (XGetWindowProperty(p->display, p->root, net_desktop_viewport,
                               0l, 2l, 0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 &&
                nitems_ret == 2) {
                long *data = (long *) data_ret;

                int d, i, n;
                n = nitems_ret / 2;
                for (d = 0, i = 0; d < n; d++) {
                    p->viewport[d].x = data[i++];
                    p->viewport[d].y = data[i++];
                }
# 2066 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & CurrentDesktop) {
        p->current_desktop = 0;
        if (XGetWindowProperty(p->display, p->root, net_current_desktop,
                               0l, 1l, 0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 && nitems_ret == 1) {
                p->current_desktop = *((long *) data_ret) + 1;
            }





            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & DesktopNames) {
        for( int i = 0; i < p->desktop_names.size(); ++i )
            delete[] p->desktop_names[ i ];
        p->desktop_names.reset();
        if (XGetWindowProperty(p->display, p->root, net_desktop_names,
                               0l, MAX_PROP_SIZE, 0, UTF8_STRING, &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == UTF8_STRING && format_ret == 8) {
                const char *d = (const char *) data_ret;
                unsigned int s, n, index;

                for (s = 0, n = 0, index = 0; n < nitems_ret; n++) {
                    if (d[n] == '\0') {
                        if (p->desktop_names[index])
                            delete [] p->desktop_names[index];
                        p->desktop_names[index++] = nstrndup((d + s), n - s + 1);
                        s = n + 1;
                    }
                }
            }





            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & ActiveWindow) {
        p->active = None;
        if (XGetWindowProperty(p->display, p->root, net_active_window, 0l, 1l,
                               0, ((Atom) 33), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 33) && format_ret == 32 && nitems_ret == 1) {
                p->active = *((Window *) data_ret);
            }





            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WorkArea) {
        p->workarea.reset();
        if (XGetWindowProperty(p->display, p->root, net_workarea, 0l,
                               (p->number_of_desktops * 4), 0, ((Atom) 6),
                               &type_ret, &format_ret, &nitems_ret, &unused,
                               &data_ret)
            == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 &&
                nitems_ret == (unsigned) (p->number_of_desktops * 4)) {
                long *d = (long *) data_ret;
                int i, j;
                for (i = 0, j = 0; i < p->number_of_desktops; i++) {
                    p->workarea[i].pos.x = d[j++];
                    p->workarea[i].pos.y = d[j++];
                    p->workarea[i].size.width = d[j++];
                    p->workarea[i].size.height = d[j++];
                }
            }





            if ( data_ret )
                XFree(data_ret);
        }
    }


    if (dirty & SupportingWMCheck) {
        p->supportwindow = None;
        delete[] p->name;
        p->name = __null;
        if (XGetWindowProperty(p->display, p->root, net_supporting_wm_check,
                               0l, 1l, 0, ((Atom) 33), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 33) && format_ret == 32 && nitems_ret == 1) {
                p->supportwindow = *((Window *) data_ret);

                unsigned char *name_ret;
                if (XGetWindowProperty(p->display, p->supportwindow,
                                       net_wm_name, 0l, MAX_PROP_SIZE, 0,
                                       UTF8_STRING, &type_ret, &format_ret,
                                       &nitems_ret, &unused, &name_ret)
                    == Success) {
                    if (type_ret == UTF8_STRING && format_ret == 8)
                        p->name = nstrndup((const char *) name_ret, nitems_ret);

                    if ( name_ret )
                        XFree(name_ret);
                }
            }






            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & VirtualRoots) {
        p->virtual_roots_count = 0;
        delete[] p->virtual_roots;
        p->virtual_roots = __null;
        if (XGetWindowProperty(p->display, p->root, net_virtual_roots,
                               0, MAX_PROP_SIZE, 0, ((Atom) 33), &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 33) && format_ret == 32) {
                Window *wins = (Window *) data_ret;

                p->virtual_roots_count = nitems_ret;
                p->virtual_roots = nwindup(wins, p->virtual_roots_count);
            }





            if ( data_ret )
                XFree(data_ret);
        }
    }
}


Display *NETRootInfo::x11Display() const {
    return p->display;
}


Window NETRootInfo::rootWindow() const {
    return p->root;
}


Window NETRootInfo::supportWindow() const {
    return p->supportwindow;
}


const char *NETRootInfo::wmName() const {
    return p->name; }


int NETRootInfo::screenNumber() const {
    return p->screen;
}


unsigned long NETRootInfo::supported() const {
    return role == WindowManager
        ? p->properties[ PROTOCOLS ]
        : p->client_properties[ PROTOCOLS ];
}

const unsigned long* NETRootInfo::supportedProperties() const {
    return p->properties;
}

const unsigned long* NETRootInfo::passedProperties() const {
    return role == WindowManager
        ? p->properties
        : p->client_properties;
}

bool NETRootInfo::isSupported( NET::Property property ) const {
    return p->properties[ PROTOCOLS ] & property;
}

bool NETRootInfo::isSupported( NET::Property2 property ) const {
    return p->properties[ PROTOCOLS2 ] & property;
}

bool NETRootInfo::isSupported( NET::WindowType type ) const {
    return p->properties[ WINDOW_TYPES ] & type;
}

bool NETRootInfo::isSupported( NET::State state ) const {
    return p->properties[ STATES ] & state;
}

bool NETRootInfo::isSupported( NET::Action action ) const {
    return p->properties[ ACTIONS ] & action;
}

const Window *NETRootInfo::clientList() const {
    return p->clients;
}


int NETRootInfo::clientListCount() const {
    return p->clients_count;
}


const Window *NETRootInfo::clientListStacking() const {
    return p->stacking;
}


int NETRootInfo::clientListStackingCount() const {
    return p->stacking_count;
}


const Window *NETRootInfo::kdeSystemTrayWindows() const {
    return p->kde_system_tray_windows;
}


int NETRootInfo::kdeSystemTrayWindowsCount() const {
    return p->kde_system_tray_windows_count;
}


NETSize NETRootInfo::desktopGeometry(int) const {
    return p->geometry.width != 0 ? p->geometry : p->rootSize;
}


NETPoint NETRootInfo::desktopViewport(int desktop) const {
    if (desktop < 1) {
        NETPoint pt;
        return pt;
    }

    return p->viewport[desktop - 1];
}


NETRect NETRootInfo::workArea(int desktop) const {
    if (desktop < 1) {
        NETRect rt;
        return rt;
    }

    return p->workarea[desktop - 1];
}


const char *NETRootInfo::desktopName(int desktop) const {
    if (desktop < 1) {
        return 0;
    }

    return p->desktop_names[desktop - 1];
}


const Window *NETRootInfo::virtualRoots( ) const {
    return p->virtual_roots;
}


int NETRootInfo::virtualRootsCount() const {
    return p->virtual_roots_count;
}


int NETRootInfo::numberOfDesktops() const {
    return p->number_of_desktops == 0 ? 1 : p->number_of_desktops;
}


int NETRootInfo::currentDesktop() const {
    return p->current_desktop == 0 ? 1 : p->current_desktop;
}


Window NETRootInfo::activeWindow() const {
    return p->active;
}




const int NETWinInfo::OnAllDesktops = NET::OnAllDesktops;

NETWinInfo::NETWinInfo(Display *display, Window window, Window rootWindow,
                       const unsigned long properties[], int properties_size,
                       Role role)
{






    p = new NETWinInfoPrivate;
    p->ref = 1;

    p->display = display;
    p->window = window;
    p->root = rootWindow;
    p->mapping_state = Withdrawn;
    p->mapping_state_dirty = 1;
    p->state = 0;
    p->types[ 0 ] = Unknown;
    p->name = (char *) 0;
    p->visible_name = (char *) 0;
    p->icon_name = (char *) 0;
    p->visible_icon_name = (char *) 0;
    p->desktop = p->pid = p->handled_icons = 0;
    p->user_time = -1U;
    p->startup_id = __null;
    p->transient_for = None;
    p->window_group = None;
    p->allowed_actions = 0;





    p->kde_system_tray_win_for = 0;

    for( int i = 0;
         i < PROPERTIES_SIZE;
         ++i )
        p->properties[ i ] = 0;
    if( properties_size > PROPERTIES_SIZE )
        properties_size = PROPERTIES_SIZE;
    for( int i = 0;
         i < properties_size;
         ++i )
        p->properties[ i ] = properties[ i ];

    p->icon_count = 0;

    this->role = role;

    if (! netwm_atoms_created) create_atoms(p->display);

    update(p->properties);
}


NETWinInfo::NETWinInfo(Display *display, Window window, Window rootWindow,
                       unsigned long properties, Role role)
{






    p = new NETWinInfoPrivate;
    p->ref = 1;

    p->display = display;
    p->window = window;
    p->root = rootWindow;
    p->mapping_state = Withdrawn;
    p->mapping_state_dirty = 1;
    p->state = 0;
    p->types[ 0 ] = Unknown;
    p->name = (char *) 0;
    p->visible_name = (char *) 0;
    p->icon_name = (char *) 0;
    p->visible_icon_name = (char *) 0;
    p->desktop = p->pid = p->handled_icons = 0;
    p->user_time = -1U;
    p->startup_id = __null;
    p->transient_for = None;
    p->window_group = None;
    p->allowed_actions = 0;





    p->kde_system_tray_win_for = 0;

    for( int i = 0;
         i < PROPERTIES_SIZE;
         ++i )
        p->properties[ i ] = 0;
    p->properties[ PROTOCOLS ] = properties;

    p->icon_count = 0;

    this->role = role;

    if (! netwm_atoms_created) create_atoms(p->display);

    update(p->properties);
}


NETWinInfo::NETWinInfo(const NETWinInfo &wininfo) {
    p = wininfo.p;
    p->ref++;
}


NETWinInfo::~NETWinInfo() {
    refdec_nwi(p);

    if (! p->ref) delete p;
}




const NETWinInfo &NETWinInfo::operator=(const NETWinInfo &wininfo) {





    if (p != wininfo.p) {
        refdec_nwi(p);

        if (! p->ref) delete p;
    }

    p = wininfo.p;
    role = wininfo.role;
    p->ref++;

    return *this;
}


void NETWinInfo::setIcon(NETIcon icon, Bool replace) {
    if (role != Client) return;

    int proplen, i, sz, j;

    if (replace) {

        for (i = 0; i < p->icons.size(); i++) {
            if (p->icons[i].data) delete [] p->icons[i].data;
            p->icons[i].data = 0;
            p->icons[i].size.width = 0;
            p->icons[i].size.height = 0;
        }

        p->icon_count = 0;
    }


    p->icons[p->icon_count] = icon;
    p->icon_count++;


    NETIcon &ni = p->icons[p->icon_count - 1];
    sz = ni.size.width * ni.size.height;
    CARD32 *d = new CARD32[sz];
    ni.data = (unsigned char *) d;
    memcpy(d, icon.data, sz * sizeof(CARD32));


    for (i = 0, proplen = 0; i < p->icon_count; i++) {
        proplen += 2 + (p->icons[i].size.width *
                        p->icons[i].size.height);
    }

    CARD32 *d32;
    long *prop = new long[proplen], *pprop = prop;
    for (i = 0; i < p->icon_count; i++) {

        *pprop++ = p->icons[i].size.width;
        *pprop++ = p->icons[i].size.height;


        sz = (p->icons[i].size.width * p->icons[i].size.height);
        d32 = (CARD32 *) p->icons[i].data;
        for (j = 0; j < sz; j++) *pprop++ = *d32++;
    }

    XChangeProperty(p->display, p->window, net_wm_icon, ((Atom) 6), 32,
                    0, (unsigned char *) prop, proplen);

    delete [] prop;
}


void NETWinInfo::setIconGeometry(NETRect geometry) {
    if (role != Client) return;

    p->icon_geom = geometry;

    long data[4];
    data[0] = geometry.pos.x;
    data[1] = geometry.pos.y;
    data[2] = geometry.size.width;
    data[3] = geometry.size.height;

    XChangeProperty(p->display, p->window, net_wm_icon_geometry, ((Atom) 6),
                    32, 0, (unsigned char *) data, 4);
}


void NETWinInfo::setStrut(NETStrut strut) {
    if (role != Client) return;

    p->strut = strut;

    long data[4];
    data[0] = strut.left;
    data[1] = strut.right;
    data[2] = strut.top;
    data[3] = strut.bottom;

    XChangeProperty(p->display, p->window, net_wm_strut, ((Atom) 6), 32,
                    0, (unsigned char *) data, 4);
}


void NETWinInfo::setState(unsigned long state, unsigned long mask) {
    if (p->mapping_state_dirty)
        updateWMState();

    if (role == Client && p->mapping_state != Withdrawn) {






        XEvent e;
        e.xclient.type = 33;
        e.xclient.message_type = net_wm_state;
        e.xclient.display = p->display;
        e.xclient.window = p->window;
        e.xclient.format = 32;
        e.xclient.data.l[3] = 0l;
        e.xclient.data.l[4] = 0l;

        if ((mask & Modal) && ((p->state & Modal) != (state & Modal))) {
            e.xclient.data.l[0] = (state & Modal) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_modal;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & Sticky) && ((p->state & Sticky) != (state & Sticky))) {
            e.xclient.data.l[0] = (state & Sticky) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_sticky;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & Max) && (( (p->state&mask) & Max) != (state & Max))) {

            unsigned long wishstate = (p->state & ~mask) | (state & mask);
            if ( ( (wishstate & MaxHoriz) != (p->state & MaxHoriz) )
                 && ( (wishstate & MaxVert) != (p->state & MaxVert) ) ) {
                if ( (wishstate & Max) == Max ) {
                    e.xclient.data.l[0] = 1;
                    e.xclient.data.l[1] = net_wm_state_max_horiz;
                    e.xclient.data.l[2] = net_wm_state_max_vert;
                    XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
                } else if ( (wishstate & Max) == 0 ) {
                    e.xclient.data.l[0] = 0;
                    e.xclient.data.l[1] = net_wm_state_max_horiz;
                    e.xclient.data.l[2] = net_wm_state_max_vert;
                    XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
                } else {
                    e.xclient.data.l[0] = ( wishstate & MaxHoriz ) ? 1 : 0;
                    e.xclient.data.l[1] = net_wm_state_max_horiz;
                    e.xclient.data.l[2] = 0;
                    XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
                    e.xclient.data.l[0] = ( wishstate & MaxVert ) ? 1 : 0;
                    e.xclient.data.l[1] = net_wm_state_max_vert;
                    e.xclient.data.l[2] = 0;
                    XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
                }
            } else if ( (wishstate & MaxVert) != (p->state & MaxVert) ) {
                e.xclient.data.l[0] = ( wishstate & MaxVert ) ? 1 : 0;
                e.xclient.data.l[1] = net_wm_state_max_vert;
                e.xclient.data.l[2] = 0;
                XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
            } else if ( (wishstate & MaxHoriz) != (p->state & MaxHoriz) ) {
                e.xclient.data.l[0] = ( wishstate & MaxHoriz ) ? 1 : 0;
                e.xclient.data.l[1] = net_wm_state_max_horiz;
                e.xclient.data.l[2] = 0;
                XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
            }
        }

        if ((mask & Shaded) && ((p->state & Shaded) != (state & Shaded))) {
            e.xclient.data.l[0] = (state & Shaded) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_shaded;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & SkipTaskbar) &&
            ((p->state & SkipTaskbar) != (state & SkipTaskbar))) {
            e.xclient.data.l[0] = (state & SkipTaskbar) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_skip_taskbar;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & SkipPager) &&
            ((p->state & SkipPager) != (state & SkipPager))) {
            e.xclient.data.l[0] = (state & SkipPager) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_skip_pager;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & Hidden) &&
            ((p->state & Hidden) != (state & Hidden))) {
            e.xclient.data.l[0] = (state & Hidden) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_hidden;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & FullScreen) &&
            ((p->state & FullScreen) != (state & FullScreen))) {
            e.xclient.data.l[0] = (state & FullScreen) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_fullscreen;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & KeepAbove) &&
            ((p->state & KeepAbove) != (state & KeepAbove))) {
            e.xclient.data.l[0] = (state & KeepAbove) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_above;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & KeepBelow) &&
            ((p->state & KeepBelow) != (state & KeepBelow))) {
            e.xclient.data.l[0] = (state & KeepBelow) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_below;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & StaysOnTop) && ((p->state & StaysOnTop) != (state & StaysOnTop))) {
            e.xclient.data.l[0] = (state & StaysOnTop) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_stays_on_top;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

        if ((mask & DemandsAttention) &&
            ((p->state & DemandsAttention) != (state & DemandsAttention))) {
            e.xclient.data.l[0] = (state & DemandsAttention) ? 1 : 0;
            e.xclient.data.l[1] = net_wm_state_demands_attention;
            e.xclient.data.l[2] = 0l;

            XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
        }

    } else {
        p->state &= ~mask;
        p->state |= state;

        long data[50];
        int count = 0;


        if (p->state & Modal) data[count++] = net_wm_state_modal;
        if (p->state & MaxVert) data[count++] = net_wm_state_max_vert;
        if (p->state & MaxHoriz) data[count++] = net_wm_state_max_horiz;
        if (p->state & Shaded) data[count++] = net_wm_state_shaded;
        if (p->state & Hidden) data[count++] = net_wm_state_hidden;
        if (p->state & FullScreen) data[count++] = net_wm_state_fullscreen;
        if (p->state & DemandsAttention) data[count++] = net_wm_state_demands_attention;


        if (p->state & KeepAbove) data[count++] = net_wm_state_above;
        if (p->state & KeepBelow) data[count++] = net_wm_state_below;
        if (p->state & StaysOnTop) data[count++] = net_wm_state_stays_on_top;
        if (p->state & Sticky) data[count++] = net_wm_state_sticky;
        if (p->state & SkipTaskbar) data[count++] = net_wm_state_skip_taskbar;
        if (p->state & SkipPager) data[count++] = net_wm_state_skip_pager;
# 2799 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
        XChangeProperty(p->display, p->window, net_wm_state, ((Atom) 4), 32,
                        0, (unsigned char *) data, count);
    }
}


void NETWinInfo::setWindowType(WindowType type) {
    if (role != Client) return;

    int len;
    long data[2];

    switch (type) {
    case Override:


        data[0] = kde_net_wm_window_type_override;
        data[1] = net_wm_window_type_normal;
        len = 2;
        break;

    case Dialog:
        data[0] = net_wm_window_type_dialog;
        data[1] = None;
        len = 1;
        break;

    case Menu:
        data[0] = net_wm_window_type_menu;
        data[1] = None;
        len = 1;
        break;

    case TopMenu:


        data[0] = kde_net_wm_window_type_topmenu;
        data[1] = net_wm_window_type_dock;
        len = 2;
        break;

    case Tool:
        data[0] = net_wm_window_type_toolbar;
        data[1] = None;
        len = 1;
        break;

    case Dock:
        data[0] = net_wm_window_type_dock;
        data[1] = None;
        len = 1;
        break;

    case Desktop:
        data[0] = net_wm_window_type_desktop;
        data[1] = None;
        len = 1;
        break;

    case Utility:
        data[0] = net_wm_window_type_utility;
        data[1] = net_wm_window_type_dialog;
        len = 2;
        break;

    case Splash:
        data[0] = net_wm_window_type_splash;
        data[1] = net_wm_window_type_dock;
        len = 2;
        break;

    default:
    case Normal:
        data[0] = net_wm_window_type_normal;
        data[1] = None;
        len = 1;
        break;
    }

    XChangeProperty(p->display, p->window, net_wm_window_type, ((Atom) 4), 32,
                    0, (unsigned char *) &data, len);
}


void NETWinInfo::setName(const char *name) {
    if (role != Client) return;

    if (p->name) delete [] p->name;
    p->name = nstrdup(name);
    XChangeProperty(p->display, p->window, net_wm_name, UTF8_STRING, 8,
                    0, (unsigned char *) p->name,
                    strlen(p->name));
}


void NETWinInfo::setVisibleName(const char *visibleName) {
    if (role != WindowManager) return;

    if (p->visible_name) delete [] p->visible_name;
    p->visible_name = nstrdup(visibleName);
    XChangeProperty(p->display, p->window, net_wm_visible_name, UTF8_STRING, 8,
                    0, (unsigned char *) p->visible_name,
                    strlen(p->visible_name));
}


void NETWinInfo::setIconName(const char *iconName) {
    if (role != Client) return;

    if (p->icon_name) delete [] p->icon_name;
    p->icon_name = nstrdup(iconName);
    XChangeProperty(p->display, p->window, net_wm_icon_name, UTF8_STRING, 8,
                    0, (unsigned char *) p->icon_name,
                    strlen(p->icon_name));
}


void NETWinInfo::setVisibleIconName(const char *visibleIconName) {
    if (role != WindowManager) return;

    if (p->visible_icon_name) delete [] p->visible_icon_name;
    p->visible_icon_name = nstrdup(visibleIconName);
    XChangeProperty(p->display, p->window, net_wm_visible_icon_name, UTF8_STRING, 8,
                    0, (unsigned char *) p->visible_icon_name,
                    strlen(p->visible_icon_name));
}


void NETWinInfo::setDesktop(int desktop) {
    if (p->mapping_state_dirty)
        updateWMState();

    if (role == Client && p->mapping_state != Withdrawn) {


        if ( desktop == 0 )
            return;

        XEvent e;

        e.xclient.type = 33;
        e.xclient.message_type = net_wm_desktop;
        e.xclient.display = p->display;
        e.xclient.window = p->window;
        e.xclient.format = 32;
        e.xclient.data.l[0] = desktop == OnAllDesktops ? OnAllDesktops : desktop - 1;
        e.xclient.data.l[1] = 0l;
        e.xclient.data.l[2] = 0l;
        e.xclient.data.l[3] = 0l;
        e.xclient.data.l[4] = 0l;

        XSendEvent(p->display, p->root, 0, netwm_sendevent_mask, &e);
    } else {

        p->desktop = desktop;
        long d = desktop;

        if ( d != OnAllDesktops ) {
            if ( d == 0 ) {
                XDeleteProperty( p->display, p->window, net_wm_desktop );
                return;
            }

            d -= 1;
        }

        XChangeProperty(p->display, p->window, net_wm_desktop, ((Atom) 6), 32,
                        0, (unsigned char *) &d, 1);
    }
}


void NETWinInfo::setPid(int pid) {
    if (role != Client) return;

    p->pid = pid;
    long d = pid;
    XChangeProperty(p->display, p->window, net_wm_pid, ((Atom) 6), 32,
                    0, (unsigned char *) &d, 1);
}


void NETWinInfo::setHandledIcons(Bool handled) {
    if (role != Client) return;

    p->handled_icons = handled;
    long d = handled;
    XChangeProperty(p->display, p->window, net_wm_handled_icons, ((Atom) 6), 32,
                    0, (unsigned char *) &d, 1);
}

void NETWinInfo::setStartupId(const char* id) {
    if (role != Client) return;

    if(p->startup_id) delete[] p->startup_id;
    p->startup_id = nstrdup(id);
    XChangeProperty(p->display, p->window, net_startup_id, ((Atom) 31), 8,

        0, reinterpret_cast< unsigned char* >( p->startup_id ),
        strlen( p->startup_id ));
}

void NETWinInfo::setAllowedActions( unsigned long actions ) {
    if( role != WindowManager )
        return;
    long data[50];
    int count = 0;

    p->allowed_actions = actions;
    if (p->allowed_actions & ActionMove) data[count++] = net_wm_action_move;
    if (p->allowed_actions & ActionResize) data[count++] = net_wm_action_resize;
    if (p->allowed_actions & ActionMinimize) data[count++] = net_wm_action_minimize;
    if (p->allowed_actions & ActionShade) data[count++] = net_wm_action_shade;
    if (p->allowed_actions & ActionStick) data[count++] = net_wm_action_stick;
    if (p->allowed_actions & ActionMaxVert) data[count++] = net_wm_action_max_vert;
    if (p->allowed_actions & ActionMaxHoriz) data[count++] = net_wm_action_max_horiz;
    if (p->allowed_actions & ActionFullScreen) data[count++] = net_wm_action_fullscreen;
    if (p->allowed_actions & ActionChangeDesktop) data[count++] = net_wm_action_change_desk;
    if (p->allowed_actions & ActionClose) data[count++] = net_wm_action_close;
# 3026 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
    XChangeProperty(p->display, p->window, net_wm_allowed_actions, ((Atom) 4), 32,
                    0, (unsigned char *) data, count);
}

void NETWinInfo::setKDESystemTrayWinFor(Window window) {
    if (role != Client) return;

    p->kde_system_tray_win_for = window;
    XChangeProperty(p->display, p->window, kde_net_wm_system_tray_window_for,
                    ((Atom) 33), 32, 0,
                    (unsigned char *) &(p->kde_system_tray_win_for), 1);
}


void NETWinInfo::setKDEFrameStrut(NETStrut strut) {
    if (role != WindowManager) return;

    p->frame_strut = strut;

    long d[4];
    d[0] = strut.left;
    d[1] = strut.right;
    d[2] = strut.top;
    d[3] = strut.bottom;

    XChangeProperty(p->display, p->window, kde_net_wm_frame_strut, ((Atom) 6), 32,
                    0, (unsigned char *) d, 4);
}


void NETWinInfo::kdeGeometry(NETRect& frame, NETRect& window) {
    if (p->win_geom.size.width == 0 || p->win_geom.size.height == 0) {
        Window unused;
        int x, y;
        unsigned int w, h, junk;
        XGetGeometry(p->display, p->window, &unused, &x, &y, &w, &h, &junk, &junk);
        XTranslateCoordinates(p->display, p->window, p->root, 0, 0, &x, &y, &unused
                              );

        p->win_geom.pos.x = x;
        p->win_geom.pos.y = y;

        p->win_geom.size.width = w;
        p->win_geom.size.height = h;
    }

    window = p->win_geom;

    frame.pos.x = window.pos.x - p->frame_strut.left;
    frame.pos.y = window.pos.y - p->frame_strut.top;
    frame.size.width = window.size.width + p->frame_strut.left + p->frame_strut.right;
    frame.size.height = window.size.height + p->frame_strut.top + p->frame_strut.bottom;
}


NETIcon NETWinInfo::icon(int width, int height) const {
    NETIcon result;

    if ( !p->icon_count ) {
        result.size.width = 0;
        result.size.height = 0;
        result.data = 0;
        return result;
    }

    result = p->icons[0];



    if (width == height && height == -1) return result;

    int i;
    for (i = 0; i < p->icons.size(); i++) {
        if ((p->icons[i].size.width >= width &&
             p->icons[i].size.width < result.size.width) &&
            (p->icons[i].size.height >= height &&
             p->icons[i].size.height < result.size.height))
            result = p->icons[i];
    }

    return result;
}

void NETWinInfo::setUserTime( Time time ) {
    if (role != Client) return;

    p->user_time = time;
    long d = time;
    XChangeProperty(p->display, p->window, net_wm_user_time, ((Atom) 6), 32,
                    0, (unsigned char *) &d, 1);
}


unsigned long NETWinInfo::event(XEvent *ev )
{
    unsigned long props[ 1 ];
    event( ev, props, 1 );
    return props[ 0 ];
}

void NETWinInfo::event(XEvent *event, unsigned long* properties, int properties_size ) {
    unsigned long props[ PROPERTIES_SIZE ] = { 0, 0 };
    (static_cast<void> ((PROPERTIES_SIZE == 2) ? 0 : (__assert_fail ("PROPERTIES_SIZE == 2", "/coolo/prod/kdelibs/kdecore/netwm.cpp", 3128, __PRETTY_FUNCTION__), 0)));
    unsigned long& dirty = props[ PROTOCOLS ];
    unsigned long& dirty2 = props[ PROTOCOLS2 ];
    bool do_update = false;

    if (role == WindowManager && event->type == 33 &&
        event->xclient.format == 32) {





        if (event->xclient.message_type == net_wm_state) {
            dirty = WMState;
# 3150 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
            int i;
            long state = 0, mask = 0;

            for (i = 1; i < 3; i++) {






                if ((Atom) event->xclient.data.l[i] == net_wm_state_modal)
                    mask |= Modal;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_sticky)
                    mask |= Sticky;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_max_vert)
                    mask |= MaxVert;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_max_horiz)
                    mask |= MaxHoriz;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_shaded)
                    mask |= Shaded;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_skip_taskbar)
                    mask |= SkipTaskbar;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_skip_pager)
                    mask |= SkipPager;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_hidden)
                    mask |= Hidden;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_fullscreen)
                    mask |= FullScreen;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_above)
                    mask |= KeepAbove;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_below)
                    mask |= KeepBelow;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_demands_attention)
                    mask |= DemandsAttention;
                else if ((Atom) event->xclient.data.l[i] == net_wm_state_stays_on_top)
                    mask |= StaysOnTop;
            }


            switch (event->xclient.data.l[0]) {
            case 1:

                state = mask;
                break;

            case 2:

                state = (p->state & mask) ^ mask;
                break;

            default:

                ;
            }






            changeState(state, mask);
        } else if (event->xclient.message_type == net_wm_desktop) {
            dirty = WMDesktop;

            if( event->xclient.data.l[0] == OnAllDesktops )
                changeDesktop( OnAllDesktops );
            else
                changeDesktop(event->xclient.data.l[0] + 1);
        }
    }

    if (event->type == 28) {





        XEvent pe = *event;

        Bool done = 0;
        Bool compaction = 0;
        while (! done) {





            if (pe.xproperty.atom == net_wm_name)
                dirty |= WMName;
            else if (pe.xproperty.atom == net_wm_visible_name)
                dirty |= WMVisibleName;
            else if (pe.xproperty.atom == net_wm_desktop)
                dirty |= WMDesktop;
            else if (pe.xproperty.atom == net_wm_window_type)
                dirty |=WMWindowType;
            else if (pe.xproperty.atom == net_wm_state)
                dirty |= WMState;
            else if (pe.xproperty.atom == net_wm_strut)
                dirty |= WMStrut;
            else if (pe.xproperty.atom == net_wm_icon_geometry)
                dirty |= WMIconGeometry;
            else if (pe.xproperty.atom == net_wm_icon)
                dirty |= WMIcon;
            else if (pe.xproperty.atom == net_wm_pid)
                dirty |= WMPid;
            else if (pe.xproperty.atom == net_wm_handled_icons)
                dirty |= WMHandledIcons;
            else if (pe.xproperty.atom == net_startup_id)
                dirty2 |= WM2StartupId;
            else if (pe.xproperty.atom == net_wm_allowed_actions)
                dirty2 |= WM2AllowedActions;
            else if (pe.xproperty.atom == kde_net_wm_system_tray_window_for)
                dirty |= WMKDESystemTrayWinFor;
            else if (pe.xproperty.atom == xa_wm_state)
                dirty |= XAWMState;
            else if (pe.xproperty.atom == kde_net_wm_frame_strut)
                dirty |= WMKDEFrameStrut;
            else if (pe.xproperty.atom == net_wm_icon_name)
                dirty |= WMIconName;
            else if (pe.xproperty.atom == net_wm_visible_icon_name)
                dirty |= WMVisibleIconName;
            else if (pe.xproperty.atom == net_wm_user_time)
                dirty2 |= WM2UserTime;
            else if (pe.xproperty.atom == ((Atom) 35))
                dirty2 |= WM2GroupLeader;
            else if (pe.xproperty.atom == ((Atom) 68))
                dirty2 |= WM2TransientFor;
            else {





                if ( compaction )
                    XPutBackEvent(p->display, &pe);
                break;
            }

            if (XCheckTypedWindowEvent(p->display, p->window, 28, &pe) )
                compaction = 1;
            else
                break;
        }

        do_update = true;
    } else if (event->type == 22) {





        dirty |= WMGeometry;


        p->win_geom.pos.x = event->xconfigure.x;
        p->win_geom.pos.y = event->xconfigure.y;
        p->win_geom.size.width = event->xconfigure.width;
        p->win_geom.size.height = event->xconfigure.height;
    }

    if( do_update )
        update( props );

    if( properties_size > PROPERTIES_SIZE )
        properties_size = PROPERTIES_SIZE;
    for( int i = 0;
         i < properties_size;
         ++i )
        properties[ i ] = props[ i ];
}

void NETWinInfo::updateWMState() {
    unsigned long props[ PROPERTIES_SIZE ] = { XAWMState, 0 };
    (static_cast<void> ((PROPERTIES_SIZE == 2) ? 0 : (__assert_fail ("PROPERTIES_SIZE == 2", "/coolo/prod/kdelibs/kdecore/netwm.cpp", 3323, __PRETTY_FUNCTION__), 0)));
    update( props );
}

void NETWinInfo::update(const unsigned long dirty_props[]) {
    Atom type_ret;
    int format_ret;
    unsigned long nitems_ret, unused;
    unsigned char *data_ret;
    unsigned long props[ PROPERTIES_SIZE ];
    for( int i = 0;
         i < PROPERTIES_SIZE;
         ++i )
        props[ i ] = dirty_props[ i ] & p->properties[ i ];
    const unsigned long& dirty = props[ PROTOCOLS ];
    const unsigned long& dirty2 = props[ PROTOCOLS2 ];


    if( dirty_props[ PROTOCOLS ] & XAWMState )
        props[ PROTOCOLS ] |= XAWMState;

    if (dirty & XAWMState) {
        p->mapping_state = Withdrawn;
        if (XGetWindowProperty(p->display, p->window, xa_wm_state, 0l, 1l,
                               0, xa_wm_state, &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == xa_wm_state && format_ret == 32 &&
                nitems_ret == 1) {
                long *state = (long *) data_ret;

                switch(*state) {
                    case 3:
                        p->mapping_state = Iconic;
                        break;
                    case 1:
                        p->mapping_state = Visible;
                        break;
                    case 0:
                    default:
                        p->mapping_state = Withdrawn;
                        break;
                }

                p->mapping_state_dirty = 0;
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMState) {
        p->state = 0;
        if (XGetWindowProperty(p->display, p->window, net_wm_state, 0l, 2048l,
                               0, ((Atom) 4), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 4) && format_ret == 32 && nitems_ret > 0) {






                long *states = (long *) data_ret;
                unsigned long count;

                for (count = 0; count < nitems_ret; count++) {







                    if ((Atom) states[count] == net_wm_state_modal)
                        p->state |= Modal;
                    else if ((Atom) states[count] == net_wm_state_sticky)
                        p->state |= Sticky;
                    else if ((Atom) states[count] == net_wm_state_max_vert)
                        p->state |= MaxVert;
                    else if ((Atom) states[count] == net_wm_state_max_horiz)
                        p->state |= MaxHoriz;
                    else if ((Atom) states[count] == net_wm_state_shaded)
                        p->state |= Shaded;
                    else if ((Atom) states[count] == net_wm_state_skip_taskbar)
                        p->state |= SkipTaskbar;
                    else if ((Atom) states[count] == net_wm_state_skip_pager)
                        p->state |= SkipPager;
                    else if ((Atom) states[count] == net_wm_state_hidden)
                        p->state |= Hidden;
                    else if ((Atom) states[count] == net_wm_state_fullscreen)
                        p->state |= FullScreen;
                    else if ((Atom) states[count] == net_wm_state_above)
                        p->state |= KeepAbove;
                    else if ((Atom) states[count] == net_wm_state_below)
                        p->state |= KeepBelow;
                    else if ((Atom) states[count] == net_wm_state_demands_attention)
                        p->state |= DemandsAttention;
                    else if ((Atom) states[count] == net_wm_state_stays_on_top)
                        p->state |= StaysOnTop;
                }
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMDesktop) {
        p->desktop = 0;
        if (XGetWindowProperty(p->display, p->window, net_wm_desktop, 0l, 1l,
                               0, ((Atom) 6), &type_ret,
                               &format_ret, &nitems_ret,
                               &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 &&
                nitems_ret == 1) {
                p->desktop = *((long *) data_ret);
                if ((signed) p->desktop != OnAllDesktops)
                    p->desktop++;

                if ( p->desktop == 0 )
                    p->desktop = OnAllDesktops;
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMName) {
        delete[] p->name;
        p->name = __null;
        if (XGetWindowProperty(p->display, p->window, net_wm_name, 0l,
                               MAX_PROP_SIZE, 0, UTF8_STRING, &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == UTF8_STRING && format_ret == 8 && nitems_ret > 0) {
                p->name = nstrndup((const char *) data_ret, nitems_ret);
            }

            if( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMVisibleName) {
        delete[] p->visible_name;
        p->visible_name = __null;
        if (XGetWindowProperty(p->display, p->window, net_wm_visible_name, 0l,
                               MAX_PROP_SIZE, 0, UTF8_STRING, &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == UTF8_STRING && format_ret == 8 && nitems_ret > 0) {
                p->visible_name = nstrndup((const char *) data_ret, nitems_ret);
            }

            if( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMIconName) {
        delete[] p->icon_name;
        p->icon_name = __null;
        char* text_ret = 0;
        if (XGetWindowProperty(p->display, p->window, net_wm_icon_name, 0l,
                               MAX_PROP_SIZE, 0, UTF8_STRING, &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == UTF8_STRING && format_ret == 8 && nitems_ret > 0) {
                p->icon_name = nstrndup((const char *) data_ret, nitems_ret);
            }

            if( data_ret )
                XFree(data_ret);
        }

        if ( !p->visible_icon_name && XGetIconName(p->display, p->window, &text_ret) ) {
            p->icon_name = nstrdup(text_ret);

            if( text_ret )
                XFree(text_ret);
        }
    }

    if (dirty & WMVisibleIconName)
    {
        delete[] p->visible_icon_name;
        p->visible_icon_name = __null;
        if (XGetWindowProperty(p->display, p->window, net_wm_visible_icon_name, 0l,
                               MAX_PROP_SIZE, 0, UTF8_STRING, &type_ret,
                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == UTF8_STRING && format_ret == 8 && nitems_ret > 0) {
                p->visible_icon_name = nstrndup((const char *) data_ret, nitems_ret);
            }

            if( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMWindowType) {
        p->types.reset();
        p->types[ 0 ] = Unknown;
        if (XGetWindowProperty(p->display, p->window, net_wm_window_type, 0l, 2048l,
                               0, ((Atom) 4), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 4) && format_ret == 32 && nitems_ret > 0) {






                unsigned long count = 0;
                long *types = (long *) data_ret;
                int pos = 0;

                while (count < nitems_ret) {
# 3552 "/coolo/prod/kdelibs/kdecore/netwm.cpp"
                    if ((Atom) types[count] == net_wm_window_type_normal)
                        p->types[ pos++ ] = Normal;
                    else if ((Atom) types[count] == net_wm_window_type_desktop)
                        p->types[ pos++ ] = Desktop;
                    else if ((Atom) types[count] == net_wm_window_type_dock)
                        p->types[ pos++ ] = Dock;
                    else if ((Atom) types[count] == net_wm_window_type_toolbar)
                        p->types[ pos++ ] = Tool;
                    else if ((Atom) types[count] == net_wm_window_type_menu)
                        p->types[ pos++ ] = Menu;
                    else if ((Atom) types[count] == net_wm_window_type_dialog)
                        p->types[ pos++ ] = Dialog;
                    else if ((Atom) types[count] == net_wm_window_type_utility)
                        p->types[ pos++ ] = Utility;
                    else if ((Atom) types[count] == net_wm_window_type_splash)
                        p->types[ pos++ ] = Splash;
                    else if ((Atom) types[count] == kde_net_wm_window_type_override)
                        p->types[ pos++ ] = Override;
                    else if ((Atom) types[count] == kde_net_wm_window_type_topmenu)
                        p->types[ pos++ ] = TopMenu;

                    count++;
                }
            }

            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMStrut) {
        p->strut = NETStrut();
        if (XGetWindowProperty(p->display, p->window, net_wm_strut, 0l, 4l,
                               0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 &&
                nitems_ret == 4) {
                long *d = (long *) data_ret;
                p->strut.left = d[0];
                p->strut.right = d[1];
                p->strut.top = d[2];
                p->strut.bottom = d[3];
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMIconGeometry) {
        p->icon_geom = NETRect();
        if (XGetWindowProperty(p->display, p->window, net_wm_icon_geometry, 0l, 4l,
                               0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 &&
                nitems_ret == 4) {
                long *d = (long *) data_ret;
                p->icon_geom.pos.x = d[0];
                p->icon_geom.pos.y = d[1];
                p->icon_geom.size.width = d[2];
                p->icon_geom.size.height = d[3];
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMIcon) {
        readIcon(p);
    }

    if (dirty & WMKDESystemTrayWinFor) {
        p->kde_system_tray_win_for = 0;
        if (XGetWindowProperty(p->display, p->window, kde_net_wm_system_tray_window_for,
                               0l, 1l, 0, ((Atom) 33), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 33) && format_ret == 32 &&
                nitems_ret == 1) {
                p->kde_system_tray_win_for = *((Window *) data_ret);
                if ( p->kde_system_tray_win_for == 0 )
                    p->kde_system_tray_win_for = p->root;
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMKDEFrameStrut) {
        p->frame_strut = NETStrut();
        if (XGetWindowProperty(p->display, p->window, kde_net_wm_frame_strut,
                               0l, 4l, 0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret) == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 && nitems_ret == 4) {
                long *d = (long *) data_ret;

                p->frame_strut.left = d[0];
                p->frame_strut.right = d[1];
                p->frame_strut.top = d[2];
                p->frame_strut.bottom = d[3];
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty & WMPid) {
        p->pid = 0;
        if (XGetWindowProperty(p->display, p->window, net_wm_pid, 0l, 1l,
                               0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret) == Success) {
            if (type_ret == ((Atom) 6) && format_ret == 32 && nitems_ret == 1) {
                p->pid = *((long *) data_ret);
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty2 & WM2StartupId)
    {
        delete[] p->startup_id;
        p->startup_id = __null;
        if (XGetWindowProperty(p->display, p->window, net_startup_id, 0l,
                               MAX_PROP_SIZE, 0, ((Atom) 31), &type_ret,

                               &format_ret, &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 31) && format_ret == 8 && nitems_ret > 0) {
                p->startup_id = nstrndup((const char *) data_ret, nitems_ret);
            }

            if( data_ret )
                XFree(data_ret);
        }
    }

    if( dirty2 & WM2AllowedActions ) {
        p->allowed_actions = 0;
        if (XGetWindowProperty(p->display, p->window, net_wm_allowed_actions, 0l, 2048l,
                               0, ((Atom) 4), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret)
            == Success) {
            if (type_ret == ((Atom) 4) && format_ret == 32 && nitems_ret > 0) {






                long *actions = (long *) data_ret;
                unsigned long count;

                for (count = 0; count < nitems_ret; count++) {







                    if ((Atom) actions[count] == net_wm_action_move)
                        p->allowed_actions |= ActionMove;
                    if ((Atom) actions[count] == net_wm_action_resize)
                        p->allowed_actions |= ActionResize;
                    if ((Atom) actions[count] == net_wm_action_minimize)
                        p->allowed_actions |= ActionMinimize;
                    if ((Atom) actions[count] == net_wm_action_shade)
                        p->allowed_actions |= ActionShade;
                    if ((Atom) actions[count] == net_wm_action_stick)
                        p->allowed_actions |= ActionStick;
                    if ((Atom) actions[count] == net_wm_action_max_vert)
                        p->allowed_actions |= ActionMaxVert;
                    if ((Atom) actions[count] == net_wm_action_max_horiz)
                        p->allowed_actions |= ActionMaxHoriz;
                    if ((Atom) actions[count] == net_wm_action_fullscreen)
                        p->allowed_actions |= ActionFullScreen;
                    if ((Atom) actions[count] == net_wm_action_change_desk)
                        p->allowed_actions |= ActionChangeDesktop;
                    if ((Atom) actions[count] == net_wm_action_close)
                        p->allowed_actions |= ActionClose;
                }
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty2 & WM2UserTime) {
        p->user_time = -1U;
        if (XGetWindowProperty(p->display, p->window, net_wm_user_time, 0l, 1l,
                               0, ((Atom) 6), &type_ret, &format_ret,
                               &nitems_ret, &unused, &data_ret) == Success) {

            if (type_ret == ((Atom) 6) && format_ret == 32 ) {
                p->user_time = *((long *) data_ret);
            }
            if ( data_ret )
                XFree(data_ret);
        }
    }

    if (dirty2 & WM2TransientFor) {
        p->transient_for = None;
        XGetTransientForHint(p->display, p->window, &p->transient_for);
    }

    if (dirty2 & WM2GroupLeader) {
        XWMHints *hints = XGetWMHints(p->display, p->window);
        p->window_group = None;
        if ( hints )
        {
            if( hints->flags & (1L << 6) )
                p->window_group = hints->window_group;
            XFree( reinterpret_cast< char* >( hints ));
        }
    }

}


NETRect NETWinInfo::iconGeometry() const {
    return p->icon_geom;
}


unsigned long NETWinInfo::state() const {
    return p->state;
}


NETStrut NETWinInfo::strut() const {
    return p->strut;
}

NET::WindowType NETWinInfo::windowType( unsigned long supported_types ) const {
    for( int i = 0;
         i < p->types.size();
         ++i ) {
        switch( p->types[ i ] ) {





            case Normal: if( supported_types & NormalMask ) return Normal; break;
            case Desktop: if( supported_types & DesktopMask ) return Desktop; break;
            case Dock: if( supported_types & DockMask ) return Dock; break;
            case Toolbar: if( supported_types & ToolbarMask ) return Toolbar; break;
            case Menu: if( supported_types & MenuMask ) return Menu; break;
            case Dialog: if( supported_types & DialogMask ) return Dialog; break;
            case Override: if( supported_types & OverrideMask ) return Override; break;
            case TopMenu: if( supported_types & TopMenuMask ) return TopMenu; break;
            case Utility: if( supported_types & UtilityMask ) return Utility; break;
            case Splash: if( supported_types & SplashMask ) return Splash; break;
#undef CHECK_TYPE_MASK
            default:
                break;
        }
    }
    return Unknown;
}

NET::WindowType NETWinInfo::windowType() const {
    return p->types[ 0 ];
}


const char *NETWinInfo::name() const {
    return p->name;
}


const char *NETWinInfo::visibleName() const {
    return p->visible_name;
}


const char *NETWinInfo::iconName() const {
    return p->icon_name;
}


const char *NETWinInfo::visibleIconName() const {
    return p->visible_icon_name;
}


int NETWinInfo::desktop() const {
    return p->desktop;
}

int NETWinInfo::pid() const {
    return p->pid;
}

Time NETWinInfo::userTime() const {
    return p->user_time;
}

const char* NETWinInfo::startupId() const {
    return p->startup_id;
}

unsigned long NETWinInfo::allowedActions() const {
    return p->allowed_actions;
}

Window NETWinInfo::transientFor() const {
    return p->transient_for;
}

Window NETWinInfo::groupLeader() const {
    return p->window_group;
}

Bool NETWinInfo::handledIcons() const {
    return p->handled_icons;
}


Window NETWinInfo::kdeSystemTrayWinFor() const {
    return p->kde_system_tray_win_for;
}

const unsigned long* NETWinInfo::passedProperties() const {
    return p->properties;
}

unsigned long NETWinInfo::properties() const {
    return p->properties[ PROTOCOLS ];
}


NET::MappingState NETWinInfo::mappingState() const {
    return p->mapping_state;
}

void NETRootInfo::virtual_hook( int, void* )
{ }

void NETWinInfo::virtual_hook( int, void* )
{ }
# 8 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kconfigbase.cpp" 1
# 33 "/coolo/prod/kdelibs/kdecore/kconfigbase.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kcharsets.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kcharsets.h"






class KGlobal;
class KCharsetsPrivate;

class QTextCodec;
# 44 "/coolo/prod/kdelibs/kdecore/kcharsets.h"
class KCharsets
{
    friend class KGlobal;

protected:



    KCharsets();

public:




    virtual ~KCharsets();







    QTextCodec *codecForName(const QString &name) const;
# 76 "/coolo/prod/kdelibs/kdecore/kcharsets.h"
    QTextCodec *codecForName(const QString &n, bool &ok) const;







    static QChar fromEntity(const QString &str);
# 94 "/coolo/prod/kdelibs/kdecore/kcharsets.h"
    static QChar fromEntity(const QString &str, int &len);







    static QString toEntity(const QChar &ch);
# 111 "/coolo/prod/kdelibs/kdecore/kcharsets.h"
    static QString resolveEntities( const QString &text );





    QStringList availableEncodingNames();





    QStringList descriptiveEncodingNames();





    QStringList languages();






    QStringList encodingsForLanguage( const QString &language );






    QString languageForEncoding( const QString &encoding );






    QString encodingForName( const QString &descriptiveName );

private:
    KCharsetsPrivate *d;
};
# 34 "/coolo/prod/kdelibs/kdecore/kconfigbase.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"





class QFile;
class KConfigBackEndPrivate;
# 47 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
class KConfigBackEnd
{
  friend class KConfig;
public:
# 66 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
  KConfigBackEnd(KConfigBase *_config, const QString &_fileName,
                 const char * _resType, bool _useKDEGlobals);




  virtual ~KConfigBackEnd() {};







  virtual bool parseConfigFiles() = 0;
# 91 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
  virtual void sync(bool bMerge = true) = 0;
# 103 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
  void changeFileName(const QString &_fileName, const char * _resType,
                      bool _useKDEGlobals);






  virtual KConfigBase::ConfigState getConfigState() const
    { return mConfigState; }





  QString fileName() const { return mfileName; }





  const char * resource() const { return resType; }






  void setLocaleString(const QCString &_localeString) { localeString = _localeString; }





  void setFileWriteMode(int mode);






  bool checkConfigFilesWritable(bool warnUser);







  __attribute__ ((deprecated)) QString filename() const { return mfileName; }


protected:
  KConfigBase *pConfig;

  QString mfileName;
  QCString resType;
  bool useKDEGlobals : 1;
  bool bFileImmutable : 1;
  QCString localeString;
  QString mLocalFileName;
  QString mGlobalFileName;
  KConfigBase::ConfigState mConfigState;
  int mFileMode;

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KConfigBackEndPrivate *d;
};

class KConfigINIBackEndPrivate;
# 183 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
class KConfigINIBackEnd : public KConfigBackEnd
{

public:
# 202 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
  KConfigINIBackEnd(KConfigBase *_config, const QString &_fileName,
                    const char * _resType, bool _useKDEGlobals = true)
    : KConfigBackEnd(_config, _fileName, _resType, _useKDEGlobals) {}




  virtual ~KConfigINIBackEnd() {};






  bool parseConfigFiles();
# 225 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
  virtual void sync(bool bMerge = true);

protected:
# 243 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
  void parseSingleConfigFile(QFile& rFile, KEntryMap *pWriteBackMap = 0L,
                             bool bGlobal = false, bool bDefault = false);
# 260 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
  bool writeConfigFile(QString filename, bool bGlobal = false, bool bMerge = true);
# 274 "/coolo/prod/kdelibs/kdecore/kconfigbackend.h"
  bool getEntryMap(KEntryMap &map, bool bGlobal, QFile *mergeFile);


  void writeEntries(FILE *pStream, const KEntryMap &aTempMap);

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KConfigINIBackEndPrivate *d;
};
# 37 "/coolo/prod/kdelibs/kdecore/kconfigbase.cpp" 2



static bool isUtf8(const char *buf) {
  int i, n;
  register unsigned char c;
  bool gotone = false;


  static const unsigned char text_chars[256] = {

        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0,

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,

        3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
  };


  for (i = 0; (c = buf[i]); i++) {
    if ((c & 0x80) == 0) {





      if (text_chars[c] != 1)
        return false;

    } else if ((c & 0x40) == 0) {
      return false;
    } else {
      int following;

    if ((c & 0x20) == 0) {
      following = 1;
    } else if ((c & 0x10) == 0) {
      following = 2;
    } else if ((c & 0x08) == 0) {
      following = 3;
    } else if ((c & 0x04) == 0) {
      following = 4;
    } else if ((c & 0x02) == 0) {
      following = 5;
    } else
      return false;

      for (n = 0; n < following; n++) {
        i++;
        if (!(c = buf[i]))
          goto done;

        if ((c & 0x80) == 0 || (c & 0x40))
          return false;
      }
      gotone = true;
    }
  }
done:
  return gotone;
}

#undef F
#undef T
#undef I
#undef X

class KConfigBase::KConfigBasePrivate
{
public:
     KConfigBasePrivate() : readDefaults(false) { };

public:
     bool readDefaults;
};

KConfigBase::KConfigBase()
  : backEnd(0L), bDirty(false), bLocaleInitialized(false),
    bReadOnly(false), bExpand(false), d(0)
{
    setGroup(QString::null);
}

KConfigBase::~KConfigBase()
{
    delete d;
}

void KConfigBase::setLocale()
{
  bLocaleInitialized = true;

  if (KGlobal::locale())
    aLocaleString = KGlobal::locale()->language().utf8();
  else
    aLocaleString = KLocale::defaultLanguage().utf8();
  if (backEnd)
     backEnd->setLocaleString(aLocaleString);
}

QString KConfigBase::locale() const
{
  return QString::fromUtf8(aLocaleString);
}

void KConfigBase::setGroup( const QString& group )
{
  if ( group.isEmpty() )
    mGroup = "<default>";
  else
    mGroup = group.utf8();
}

void KConfigBase::setGroup( const char *pGroup )
{
  setGroup(QCString(pGroup));
}

void KConfigBase::setGroup( const QCString &group )
{
  if ( group.isEmpty() )
    mGroup = "<default>";
  else
    mGroup = group;
}

QString KConfigBase::group() const {
  return QString::fromUtf8(mGroup);
}

void KConfigBase::setDesktopGroup()
{
  mGroup = "Desktop Entry";
}

bool KConfigBase::hasKey(const QString &key) const
{
   return hasKey(key.utf8().data());
}

bool KConfigBase::hasKey(const char *pKey) const
{
  KEntryKey aEntryKey(mGroup, 0);
  aEntryKey.c_key = pKey;
  aEntryKey.bDefault = readDefaults();

  if (!locale().isNull()) {

    aEntryKey.bLocal = true;
    KEntry entry = lookupData(aEntryKey);
    if (!entry.mValue.isNull())
       return true;
    aEntryKey.bLocal = false;
  }


  KEntry entry = lookupData(aEntryKey);
  return !entry.mValue.isNull();
}

bool KConfigBase::hasGroup(const QString &group) const
{
  return internalHasGroup( group.utf8());
}

bool KConfigBase::hasGroup(const char *_pGroup) const
{
  return internalHasGroup( QCString(_pGroup));
}

bool KConfigBase::hasGroup(const QCString &_pGroup) const
{
  return internalHasGroup( _pGroup);
}

bool KConfigBase::isImmutable() const
{
  return (getConfigState() != ReadWrite);
}

bool KConfigBase::groupIsImmutable(const QString &group) const
{
  if (getConfigState() != ReadWrite)
     return true;

  KEntryKey groupKey(group.utf8(), 0);
  KEntry entry = lookupData(groupKey);
  return entry.bImmutable;
}

bool KConfigBase::entryIsImmutable(const QString &key) const
{
  if (getConfigState() != ReadWrite)
     return true;

  KEntryKey entryKey(mGroup, 0);
  KEntry aEntryData = lookupData(entryKey);
  if (aEntryData.bImmutable)
    return true;

  QCString utf8_key = key.utf8();
  entryKey.c_key = utf8_key.data();
  aEntryData = lookupData(entryKey);
  if (aEntryData.bImmutable)
    return true;

  entryKey.bLocal = true;
  aEntryData = lookupData(entryKey);
  return aEntryData.bImmutable;
}


QString KConfigBase::readEntryUntranslated( const QString& pKey,
                                const QString& aDefault ) const
{
   return KConfigBase::readEntryUntranslated(pKey.utf8().data(), aDefault);
}


QString KConfigBase::readEntryUntranslated( const char *pKey,
                                const QString& aDefault ) const
{
   QCString result = readEntryUtf8(pKey);
   if (result.isNull())
      return aDefault;
   return QString::fromUtf8(result);
}


QString KConfigBase::readEntry( const QString& pKey,
                                const QString& aDefault ) const
{
   return KConfigBase::readEntry(pKey.utf8().data(), aDefault);
}

QString KConfigBase::readEntry( const char *pKey,
                                const QString& aDefault ) const
{




  if (!bLocaleInitialized && KGlobal::_locale) {

    KConfigBase *that = const_cast<KConfigBase *>(this);
    that->setLocale();
  }

  QString aValue;

  bool expand = false;


  KEntry aEntryData;
  KEntryKey entryKey(mGroup, 0);
  entryKey.c_key = pKey;
  entryKey.bDefault = readDefaults();
  entryKey.bLocal = true;
  aEntryData = lookupData(entryKey);
  if (!aEntryData.mValue.isNull()) {



    if ( isUtf8(aEntryData.mValue.data() ) )
      aValue = QString::fromUtf8( aEntryData.mValue.data() );
    else
      aValue = QString::fromLocal8Bit(aEntryData.mValue.data());
    expand = aEntryData.bExpand;



    if (aValue.isNull())
    {
      static const QString &emptyString = KGlobal::staticQString("");
      aValue = emptyString;
    }
  } else {
    entryKey.bLocal = false;
    aEntryData = lookupData(entryKey);
    if (!aEntryData.mValue.isNull()) {
      aValue = QString::fromUtf8(aEntryData.mValue.data());
      if (aValue.isNull())
      {
        static const QString &emptyString = KGlobal::staticQString("");
        aValue = emptyString;
      }
      expand = aEntryData.bExpand;
    } else {
      aValue = aDefault;
    }
  }


  if( expand || bExpand )
    {

      int nDollarPos = aValue.find( '$' );

      while( nDollarPos != -1 && nDollarPos+1 < static_cast<int>(aValue.length())) {

        if( (aValue)[nDollarPos+1] == '(' ) {
          uint nEndPos = nDollarPos+1;

          while ( (nEndPos <= aValue.length()) && (aValue[nEndPos]!=')') )
              nEndPos++;
          nEndPos++;
          QString cmd = aValue.mid( nDollarPos+2, nEndPos-nDollarPos-3 );

          QString result;
          FILE *fs = popen(QFile::encodeName(cmd).data(), "r");
          if (fs)
          {
             QTextStream ts(fs, 0x0001);
             result = ts.read().stripWhiteSpace();
             pclose(fs);
          }
          aValue.replace( nDollarPos, nEndPos-nDollarPos, result );
        } else if( (aValue)[nDollarPos+1] != '$' ) {
          uint nEndPos = nDollarPos+1;

          QString aVarName;
          if (aValue[nEndPos]=='{')
          {
            while ( (nEndPos <= aValue.length()) && (aValue[nEndPos]!='}') )
                nEndPos++;
            nEndPos++;
            aVarName = aValue.mid( nDollarPos+2, nEndPos-nDollarPos-3 );
          }
          else
          {
            while ( nEndPos <= aValue.length() && (aValue[nEndPos].isNumber()
                    || aValue[nEndPos].isLetter() || aValue[nEndPos]=='_' ) )
                nEndPos++;
            aVarName = aValue.mid( nDollarPos+1, nEndPos-nDollarPos-1 );
          }
          const char* pEnv = 0;
          if (!aVarName.isEmpty())
               pEnv = getenv( aVarName.ascii() );
          if( pEnv ) {



            if (isUtf8( pEnv ))
                aValue.replace( nDollarPos, nEndPos-nDollarPos, QString::fromUtf8(pEnv) );
            else
                aValue.replace( nDollarPos, nEndPos-nDollarPos, QString::fromLocal8Bit(pEnv) );
          } else
            aValue.remove( nDollarPos, nEndPos-nDollarPos );
        } else {

          aValue.remove( nDollarPos, 1 );
          nDollarPos++;
        }
        nDollarPos = aValue.find( '$', nDollarPos );
      }
    }

  return aValue;
}

QCString KConfigBase::readEntryUtf8( const char *pKey) const
{

  KEntryKey entryKey(mGroup, 0);
  entryKey.bDefault = readDefaults();
  entryKey.c_key = pKey;
  KEntry aEntryData = lookupData(entryKey);
  if (aEntryData.bExpand)
  {

     return readEntry(pKey, QString::null).utf8();
  }
  return aEntryData.mValue;
}

QVariant KConfigBase::readPropertyEntry( const QString& pKey,
                                          QVariant::Type type ) const
{
  return readPropertyEntry(pKey.utf8().data(), type);
}

QVariant KConfigBase::readPropertyEntry( const char *pKey,
                                          QVariant::Type type ) const
{
  QVariant va;
  if ( !hasKey( pKey ) ) return va;
  (void)va.cast(type);
  return readPropertyEntry(pKey, va);
}

QVariant KConfigBase::readPropertyEntry( const QString& pKey,
                                         const QVariant &aDefault ) const
{
  return readPropertyEntry(pKey.utf8().data(), aDefault);
}

QVariant KConfigBase::readPropertyEntry( const char *pKey,
                                         const QVariant &aDefault ) const
{
  if ( !hasKey( pKey ) ) return aDefault;

  QVariant tmp = aDefault;

  switch( aDefault.type() )
  {
      case QVariant::Invalid:
          return QVariant();
      case QVariant::String:
          return QVariant( readEntry( pKey, aDefault.toString() ) );
      case QVariant::StringList:
          return QVariant( readListEntry( pKey ) );
      case QVariant::List: {
          QStringList strList = readListEntry( pKey );
          QStringList::ConstIterator it = strList.begin();
          QStringList::ConstIterator end = strList.end();
          QValueList<QVariant> list;

          for (; it != end; ++it ) {
              tmp = *it;
              list.append( tmp );
          }
          return QVariant( list );
      }
      case QVariant::Font:
          return QVariant( readFontEntry( pKey, &tmp.asFont() ) );
      case QVariant::Point:
          return QVariant( readPointEntry( pKey, &tmp.asPoint() ) );
      case QVariant::Rect:
          return QVariant( readRectEntry( pKey, &tmp.asRect() ) );
      case QVariant::Size:
          return QVariant( readSizeEntry( pKey, &tmp.asSize() ) );
      case QVariant::Color:
          return QVariant( readColorEntry( pKey, &tmp.asColor() ) );
      case QVariant::Int:
          return QVariant( readNumEntry( pKey, aDefault.toInt() ) );
      case QVariant::UInt:
          return QVariant( readUnsignedNumEntry( pKey, aDefault.toUInt() ) );
      case QVariant::Bool:
          return QVariant( readBoolEntry( pKey, aDefault.toBool() ), 0 );
      case QVariant::Double:
          return QVariant( readDoubleNumEntry( pKey, aDefault.toDouble() ) );
      case QVariant::DateTime:
          return QVariant( readDateTimeEntry( pKey, &tmp.asDateTime() ) );
      case QVariant::Date:
          return QVariant(readDateTimeEntry( pKey, &tmp.asDateTime() ).date());

      case QVariant::Pixmap:
      case QVariant::Image:
      case QVariant::Brush:
      case QVariant::Palette:
      case QVariant::ColorGroup:
      case QVariant::Map:
      case QVariant::IconSet:
      case QVariant::CString:
      case QVariant::PointArray:
      case QVariant::Region:
      case QVariant::Bitmap:
      case QVariant::Cursor:
      case QVariant::SizePolicy:
      case QVariant::Time:
      case QVariant::ByteArray:
      case QVariant::BitArray:
      case QVariant::KeySequence:
      case QVariant::Pen:
          break;
  }

  ((0) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","0","/coolo/prod/kdelibs/kdecore/kconfigbase.cpp",521));
  return QVariant();
}

int KConfigBase::readListEntry( const QString& pKey,
                                QStrList &list, char sep ) const
{
  return readListEntry(pKey.utf8().data(), list, sep);
}

int KConfigBase::readListEntry( const char *pKey,
                                QStrList &list, char sep ) const
{
  if( !hasKey( pKey ) )
    return 0;

  QCString str_list = readEntryUtf8( pKey );
  if (str_list.isEmpty())
    return 0;

  list.clear();
  QCString value = "";
  int len = str_list.length();

  for (int i = 0; i < len; i++) {
    if (str_list[i] != sep && str_list[i] != '\\') {
      value += str_list[i];
      continue;
    }
    if (str_list[i] == '\\') {
      i++;
      if ( i < len )
        value += str_list[i];
      continue;
    }





    list.append( value );
    value.truncate(0);
  }

  if ( str_list[len-1] != sep || ( len > 1 && str_list[len-2] == '\\' ) )
    list.append( value );
  return list.count();
}

QStringList KConfigBase::readListEntry( const QString& pKey, char sep ) const
{
  return readListEntry(pKey.utf8().data(), sep);
}

QStringList KConfigBase::readListEntry( const char *pKey, char sep ) const
{
  static const QString& emptyString = KGlobal::staticQString("");

  QStringList list;
  if( !hasKey( pKey ) )
    return list;
  QString str_list = readEntry( pKey );
  if( str_list.isEmpty() )
    return list;
  QString value(emptyString);
  int len = str_list.length();

  value.reserve( len );
  for( int i = 0; i < len; i++ )
    {
      if( str_list[i] != sep && str_list[i] != '\\' )
        {
          value += str_list[i];
          continue;
        }
      if( str_list[i] == '\\' )
        {
          i++;
          if ( i < len )
            value += str_list[i];
          continue;
        }
      QString finalvalue( value );
      finalvalue.squeeze();
      list.append( finalvalue );
      value.truncate( 0 );
    }
  if ( str_list[len-1] != sep || ( len > 1 && str_list[len-2] == '\\' ) )
  {
    value.squeeze();
    list.append( value );
  }
  return list;
}

QValueList<int> KConfigBase::readIntListEntry( const QString& pKey ) const
{
  return readIntListEntry(pKey.utf8().data());
}

QValueList<int> KConfigBase::readIntListEntry( const char *pKey ) const
{
  QStringList strlist = readListEntry(pKey);
  QValueList<int> list;
  for (QStringList::ConstIterator it = strlist.begin(); it != strlist.end(); it++)


    list << (*it).toInt();

  return list;
}

QString KConfigBase::readPathEntry( const QString& pKey, const QString& pDefault ) const
{
  return readPathEntry(pKey.utf8().data(), pDefault);
}

QString KConfigBase::readPathEntry( const char *pKey, const QString& pDefault ) const
{
  const bool bExpandSave = bExpand;
  bExpand = true;
  QString aValue = readEntry( pKey, pDefault );
  bExpand = bExpandSave;
  return aValue;
}

QStringList KConfigBase::readPathListEntry( const QString& pKey, char sep ) const
{
  return readPathListEntry(pKey.utf8().data(), sep);
}

QStringList KConfigBase::readPathListEntry( const char *pKey, char sep ) const
{
  const bool bExpandSave = bExpand;
  bExpand = true;
  QStringList aValue = readListEntry( pKey, sep );
  bExpand = bExpandSave;
  return aValue;
}

int KConfigBase::readNumEntry( const QString& pKey, int nDefault) const
{
  return readNumEntry(pKey.utf8().data(), nDefault);
}

int KConfigBase::readNumEntry( const char *pKey, int nDefault) const
{
  QCString aValue = readEntryUtf8( pKey );
  if( aValue.isNull() )
    return nDefault;
  else if( aValue == "true" || aValue == "on" || aValue == "yes" )
    return 1;
  else
    {
      bool ok;
      int rc = aValue.toInt( &ok );
      return( ok ? rc : nDefault );
    }
}


unsigned int KConfigBase::readUnsignedNumEntry( const QString& pKey, unsigned int nDefault) const
{
  return readUnsignedNumEntry(pKey.utf8().data(), nDefault);
}

unsigned int KConfigBase::readUnsignedNumEntry( const char *pKey, unsigned int nDefault) const
{
  QCString aValue = readEntryUtf8( pKey );
  if( aValue.isNull() )
    return nDefault;
  else
    {
      bool ok;
      unsigned int rc = aValue.toUInt( &ok );
      return( ok ? rc : nDefault );
    }
}


long KConfigBase::readLongNumEntry( const QString& pKey, long nDefault) const
{
  return readLongNumEntry(pKey.utf8().data(), nDefault);
}

long KConfigBase::readLongNumEntry( const char *pKey, long nDefault) const
{
  QCString aValue = readEntryUtf8( pKey );
  if( aValue.isNull() )
    return nDefault;
  else
    {
      bool ok;
      long rc = aValue.toLong( &ok );
      return( ok ? rc : nDefault );
    }
}


unsigned long KConfigBase::readUnsignedLongNumEntry( const QString& pKey, unsigned long nDefault) const
{
  return readUnsignedLongNumEntry(pKey.utf8().data(), nDefault);
}

unsigned long KConfigBase::readUnsignedLongNumEntry( const char *pKey, unsigned long nDefault) const
{
  QCString aValue = readEntryUtf8( pKey );
  if( aValue.isNull() )
    return nDefault;
  else
    {
      bool ok;
      unsigned long rc = aValue.toULong( &ok );
      return( ok ? rc : nDefault );
    }
}

double KConfigBase::readDoubleNumEntry( const QString& pKey, double nDefault) const
{
  return readDoubleNumEntry(pKey.utf8().data(), nDefault);
}

double KConfigBase::readDoubleNumEntry( const char *pKey, double nDefault) const
{
  QCString aValue = readEntryUtf8( pKey );
  if( aValue.isNull() )
    return nDefault;
  else
    {
      bool ok;
      double rc = aValue.toDouble( &ok );
      return( ok ? rc : nDefault );
    }
}


bool KConfigBase::readBoolEntry( const QString& pKey, const bool bDefault ) const
{
   return readBoolEntry(pKey.utf8().data(), bDefault);
}

bool KConfigBase::readBoolEntry( const char *pKey, const bool bDefault ) const
{
  QCString aValue = readEntryUtf8( pKey );

  if( aValue.isNull() )
    return bDefault;
  else
    {
      if( aValue == "true" || aValue == "on" || aValue == "yes" || aValue == "1" )
        return true;
      else
        {
          bool bOK;
          int val = aValue.toInt( &bOK );
          if( bOK && val != 0 )
            return true;
          else
            return false;
        }
    }
}

QFont KConfigBase::readFontEntry( const QString& pKey, const QFont* pDefault ) const
{
  return readFontEntry(pKey.utf8().data(), pDefault);
}

QFont KConfigBase::readFontEntry( const char *pKey, const QFont* pDefault ) const
{
  QFont aRetFont;

  QString aValue = readEntry( pKey );
  if( !aValue.isNull() ) {
    if ( aValue.contains( ',' ) > 5 ) {

      if ( !aRetFont.fromString( aValue ) && pDefault )
        aRetFont = *pDefault;
    }
    else {



      int nIndex = aValue.find( ',' );
      if( nIndex == -1 ){
        if( pDefault )
          aRetFont = *pDefault;
        return aRetFont;
      }
      aRetFont.setFamily( aValue.left( nIndex ) );


      int nOldIndex = nIndex;
      nIndex = aValue.find( ',', nOldIndex+1 );
      if( nIndex == -1 ){
        if( pDefault )
          aRetFont = *pDefault;
        return aRetFont;
      }

      aRetFont.setPointSize( aValue.mid( nOldIndex+1,
                                         nIndex-nOldIndex-1 ).toInt() );


      nOldIndex = nIndex;
      nIndex = aValue.find( ',', nOldIndex+1 );

      if( nIndex == -1 ){
        if( pDefault )
          aRetFont = *pDefault;
        return aRetFont;
      }

      aRetFont.setStyleHint( (QFont::StyleHint)aValue.mid( nOldIndex+1, nIndex-nOldIndex-1 ).toUInt() );


      nOldIndex = nIndex;
      nIndex = aValue.find( ',', nOldIndex+1 );

      if( nIndex == -1 ){
        if( pDefault )
          aRetFont = *pDefault;
        return aRetFont;
      }

      QString chStr=aValue.mid( nOldIndex+1,
                                nIndex-nOldIndex-1 );

      nOldIndex = nIndex;
      nIndex = aValue.find( ',', nOldIndex+1 );

      if( nIndex == -1 ){
        if( pDefault )
          aRetFont = *pDefault;
        return aRetFont;
      }

      aRetFont.setWeight( aValue.mid( nOldIndex+1,
                                      nIndex-nOldIndex-1 ).toUInt() );


      uint nFontBits = aValue.right( aValue.length()-nIndex-1 ).toUInt();

      aRetFont.setItalic( nFontBits & 0x01 );
      aRetFont.setUnderline( nFontBits & 0x02 );
      aRetFont.setStrikeOut( nFontBits & 0x04 );
      aRetFont.setFixedPitch( nFontBits & 0x08 );
      aRetFont.setRawMode( nFontBits & 0x20 );
    }
  }
  else
    {
      if( pDefault )
        aRetFont = *pDefault;
    }

  return aRetFont;
}


QRect KConfigBase::readRectEntry( const QString& pKey, const QRect* pDefault ) const
{
  return readRectEntry(pKey.utf8().data(), pDefault);
}

QRect KConfigBase::readRectEntry( const char *pKey, const QRect* pDefault ) const
{
  QCString aValue = readEntryUtf8(pKey);

  if (!aValue.isEmpty())
  {
    int left, top, width, height;

    if (sscanf(aValue.data(), "%d,%d,%d,%d", &left, &top, &width, &height) == 4)
    {
       return QRect(left, top, width, height);
    }
  }
  if (pDefault)
    return *pDefault;
  return QRect();
}


QPoint KConfigBase::readPointEntry( const QString& pKey,
                                    const QPoint* pDefault ) const
{
  return readPointEntry(pKey.utf8().data(), pDefault);
}

QPoint KConfigBase::readPointEntry( const char *pKey,
                                    const QPoint* pDefault ) const
{
  QCString aValue = readEntryUtf8(pKey);

  if (!aValue.isEmpty())
  {
    int x,y;

    if (sscanf(aValue.data(), "%d,%d", &x, &y) == 2)
    {
       return QPoint(x,y);
    }
  }
  if (pDefault)
    return *pDefault;
  return QPoint();
}

QSize KConfigBase::readSizeEntry( const QString& pKey,
                                  const QSize* pDefault ) const
{
  return readSizeEntry(pKey.utf8().data(), pDefault);
}

QSize KConfigBase::readSizeEntry( const char *pKey,
                                  const QSize* pDefault ) const
{
  QCString aValue = readEntryUtf8(pKey);

  if (!aValue.isEmpty())
  {
    int width,height;

    if (sscanf(aValue.data(), "%d,%d", &width, &height) == 2)
    {
       return QSize(width, height);
    }
  }
  if (pDefault)
    return *pDefault;
  return QSize();
}


QColor KConfigBase::readColorEntry( const QString& pKey,
                                    const QColor* pDefault ) const
{
  return readColorEntry(pKey.utf8().data(), pDefault);
}

QColor KConfigBase::readColorEntry( const char *pKey,
                                    const QColor* pDefault ) const
{
  QColor aRetColor;
  int nRed = 0, nGreen = 0, nBlue = 0;

  QString aValue = readEntry( pKey );
  if( !aValue.isEmpty() )
    {
      if ( aValue.at(0) == '#' )
        {
          aRetColor.setNamedColor(aValue);
        }
      else
        {

          bool bOK;


          int nIndex = aValue.find( ',' );

          if( nIndex == -1 ){

            if( pDefault )
              aRetColor = *pDefault;
            return aRetColor;
          }

          nRed = aValue.left( nIndex ).toInt( &bOK );


          int nOldIndex = nIndex;
          nIndex = aValue.find( ',', nOldIndex+1 );

          if( nIndex == -1 ){

            if( pDefault )
              aRetColor = *pDefault;
            return aRetColor;
          }
          nGreen = aValue.mid( nOldIndex+1,
                               nIndex-nOldIndex-1 ).toInt( &bOK );


          nBlue = aValue.right( aValue.length()-nIndex-1 ).toInt( &bOK );

          aRetColor.setRgb( nRed, nGreen, nBlue );
        }
    }
  else {

    if( pDefault )
      aRetColor = *pDefault;
  }

  return aRetColor;
}


QDateTime KConfigBase::readDateTimeEntry( const QString& pKey,
                                          const QDateTime* pDefault ) const
{
  return readDateTimeEntry(pKey.utf8().data(), pDefault);
}


QDateTime KConfigBase::readDateTimeEntry( const char *pKey,
                                          const QDateTime* pDefault ) const
{
  if( !hasKey( pKey ) )
    {
      if( pDefault )
        return *pDefault;
      else
        return QDateTime::currentDateTime();
    }

  QStrList list;
  int count = readListEntry( pKey, list, ',' );
  if( count == 6 ) {
    QDate date( atoi( list.at( 0 ) ), atoi( list.at( 1 ) ),
                atoi( list.at( 2 ) ) );
    QTime time( atoi( list.at( 3 ) ), atoi( list.at( 4 ) ),
                atoi( list.at( 5 ) ) );

    return QDateTime( date, time );
  }

  return QDateTime::currentDateTime();
}

void KConfigBase::writeEntry( const QString& pKey, const QString& value,
                                 bool bPersistent,
                                 bool bGlobal,
                                 bool bNLS )
{
   writeEntry(pKey.utf8().data(), value, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry( const char *pKey, const QString& value,
                                 bool bPersistent,
                                 bool bGlobal,
                                 bool bNLS )
{





  if( bPersistent )
    setDirty(true);

  if (!bLocaleInitialized && KGlobal::locale())
    setLocale();

  KEntryKey entryKey(mGroup, pKey);
  entryKey.bLocal = bNLS;

  KEntry aEntryData;
  aEntryData.mValue = value.utf8();
  aEntryData.bGlobal = bGlobal;
  aEntryData.bNLS = bNLS;

  if (bPersistent)
    aEntryData.bDirty = true;


  putData(entryKey, aEntryData, true);
}

void KConfigBase::writePathEntry( const QString& pKey, const QString & path,
                                  bool bPersistent, bool bGlobal,
                                  bool bNLS)
{
   writePathEntry(pKey.utf8().data(), path, bPersistent, bGlobal, bNLS);
}


static bool cleanHomeDirPath( QString &path, const QString &homeDir )
{
   if (!path.startsWith(homeDir))
        return false;

   unsigned int len = homeDir.length();

   if (path.length() == len || path[len] == '/') {
        path = path.replace(0, len, QString::fromLatin1("$HOME"));
        return true;
   } else
        return false;
}

static QString translatePath( QString path )
{
   if (path.isEmpty())
       return path;

   bool startsWithFile = path.left(5).lower() == QString::fromLatin1("file:");



   if (!startsWithFile && path[0] != '/' ||
        startsWithFile && path[5] != '/')
        return path;

   if (startsWithFile)
        path.remove(0,5);





   QString homeDir0 = QFile::decodeName(getenv("HOME"));
   QString homeDir1 = QDir::homeDirPath();
   QString homeDir2 = QDir(homeDir1).canonicalPath();
   if (cleanHomeDirPath(path, homeDir0) ||
       cleanHomeDirPath(path, homeDir1) ||
       cleanHomeDirPath(path, homeDir2) ) {

   }

   if (startsWithFile)
      path.prepend( "file:" );

   return path;
}

void KConfigBase::writePathEntry( const char *pKey, const QString & path,
                                  bool bPersistent, bool bGlobal,
                                  bool bNLS)
{
   writeEntry(pKey, translatePath(path), bPersistent, bGlobal, bNLS);
}

void KConfigBase::writePathEntry ( const QString& pKey, const QStringList &list,
                               char sep , bool bPersistent,
                               bool bGlobal, bool bNLS )
{
  writePathEntry(pKey.utf8().data(), list, sep, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writePathEntry ( const char *pKey, const QStringList &list,
                               char sep , bool bPersistent,
                               bool bGlobal, bool bNLS )
{
  if( list.isEmpty() )
    {
      writeEntry( pKey, QString::fromLatin1(""), bPersistent );
      return;
    }
  QStringList new_list;
  QStringList::ConstIterator it = list.begin();
  for( ; it != list.end(); ++it )
    {
      QString value = *it;
      new_list.append( translatePath(value) );
    }
  writeEntry( pKey, new_list, sep, bPersistent, bGlobal, bNLS );
}

void KConfigBase::deleteEntry( const QString& pKey,
                                 bool bNLS,
                                 bool bGlobal)
{
   deleteEntry(pKey.utf8().data(), bNLS, bGlobal);
}

void KConfigBase::deleteEntry( const char *pKey,
                                 bool bNLS,
                                 bool bGlobal)
{





  setDirty(true);

  if (!bLocaleInitialized && KGlobal::locale())
    setLocale();

  KEntryKey entryKey(mGroup, pKey);
  KEntry aEntryData;

  aEntryData.bGlobal = bGlobal;
  aEntryData.bNLS = bNLS;
  aEntryData.bDirty = true;
  aEntryData.bDeleted = true;


  putData(entryKey, aEntryData, true);
}

bool KConfigBase::deleteGroup( const QString& group, bool bDeep, bool bGlobal )
{
  KEntryMap aEntryMap = internalEntryMap(group);

  if (!bDeep) {

    return aEntryMap.isEmpty();
  }

  bool dirty = false;
  bool checkGroup = true;

  KEntryMapIterator aIt;
  for (aIt = aEntryMap.begin(); aIt != aEntryMap.end(); ++aIt)
  {
    if (!aIt.key().mKey.isEmpty() && !aIt.key().bDefault && !(*aIt).bDeleted)
    {
      (*aIt).bDeleted = true;
      (*aIt).bDirty = true;
      (*aIt).bGlobal = bGlobal;
      (*aIt).mValue = 0;
      putData(aIt.key(), *aIt, checkGroup);
      checkGroup = false;
      dirty = true;
    }
  }
  if (dirty)
     setDirty(true);
  return true;
}

void KConfigBase::writeEntry ( const QString& pKey, const QVariant &prop,
                               bool bPersistent,
                               bool bGlobal, bool bNLS )
{
  writeEntry(pKey.utf8().data(), prop, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry ( const char *pKey, const QVariant &prop,
                               bool bPersistent,
                               bool bGlobal, bool bNLS )
{
  switch( prop.type() )
    {
    case QVariant::Invalid:
      writeEntry( pKey, "", bPersistent, bGlobal, bNLS );
      return;
    case QVariant::String:
      writeEntry( pKey, prop.toString(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::StringList:
      writeEntry( pKey, prop.toStringList(), ',', bPersistent, bGlobal, bNLS );
      return;
    case QVariant::List: {
        QValueList<QVariant> list = prop.toList();
        QValueList<QVariant>::ConstIterator it = list.begin();
        QValueList<QVariant>::ConstIterator end = list.end();
        QStringList strList;

        for (; it != end; ++it )
            strList.append( (*it).toString() );

        writeEntry( pKey, strList, ',', bPersistent, bGlobal, bNLS );

        return;
    }
    case QVariant::Font:
      writeEntry( pKey, prop.toFont(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::Point:
      writeEntry( pKey, prop.toPoint(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::Rect:
      writeEntry( pKey, prop.toRect(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::Size:
      writeEntry( pKey, prop.toSize(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::Color:
      writeEntry( pKey, prop.toColor(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::Int:
      writeEntry( pKey, prop.toInt(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::UInt:
      writeEntry( pKey, prop.toUInt(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::Bool:
      writeEntry( pKey, prop.toBool(), bPersistent, bGlobal, bNLS );
      return;
    case QVariant::Double:
      writeEntry( pKey, prop.toDouble(), bPersistent, bGlobal, 'g', 6, bNLS );
      return;
    case QVariant::DateTime:
      writeEntry( pKey, prop.toDateTime(), bPersistent, bGlobal, bNLS);
      return;
    case QVariant::Date:
      writeEntry( pKey, QDateTime(prop.toDate()), bPersistent, bGlobal, bNLS);
      return;

    case QVariant::Pixmap:
    case QVariant::Image:
    case QVariant::Brush:
    case QVariant::Palette:
    case QVariant::ColorGroup:
    case QVariant::Map:
    case QVariant::IconSet:
    case QVariant::CString:
    case QVariant::PointArray:
    case QVariant::Region:
    case QVariant::Bitmap:
    case QVariant::Cursor:
    case QVariant::SizePolicy:
    case QVariant::Time:
    case QVariant::ByteArray:
    case QVariant::BitArray:
    case QVariant::KeySequence:
    case QVariant::Pen:
        break;
    }

  ((0) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","0","/coolo/prod/kdelibs/kdecore/kconfigbase.cpp",1336));
}

void KConfigBase::writeEntry ( const QString& pKey, const QStrList &list,
                               char sep , bool bPersistent,
                               bool bGlobal, bool bNLS )
{
  writeEntry(pKey.utf8().data(), list, sep, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry ( const char *pKey, const QStrList &list,
                               char sep , bool bPersistent,
                               bool bGlobal, bool bNLS )
{
  if( list.isEmpty() )
    {
      writeEntry( pKey, QString::fromLatin1(""), bPersistent );
      return;
    }
  QString str_list;
  QStrListIterator it( list );
  for( ; it.current(); ++it )
    {
      uint i;
      QString value;



      if (isUtf8(it.current()))
        value = QString::fromUtf8(it.current());
      else
        value = QString::fromLocal8Bit(it.current());
      for( i = 0; i < value.length(); i++ )
        {
          if( value[i] == sep || value[i] == '\\' )
            str_list += '\\';
          str_list += value[i];
        }
      str_list += sep;
    }
  if( str_list.at(str_list.length() - 1) == sep )
    str_list.truncate( str_list.length() -1 );
  writeEntry( pKey, str_list, bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry ( const QString& pKey, const QStringList &list,
                               char sep , bool bPersistent,
                               bool bGlobal, bool bNLS )
{
  writeEntry(pKey.utf8().data(), list, sep, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry ( const char *pKey, const QStringList &list,
                               char sep , bool bPersistent,
                               bool bGlobal, bool bNLS )
{
  if( list.isEmpty() )
    {
      writeEntry( pKey, QString::fromLatin1(""), bPersistent );
      return;
    }
  QString str_list;
  QStringList::ConstIterator it = list.begin();
  for( ; it != list.end(); ++it )
    {
      QString value = *it;
      uint i;
      for( i = 0; i < value.length(); i++ )
        {
          if( value[i] == sep || value[i] == '\\' )
            str_list += '\\';
          str_list += value[i];
        }
      str_list += sep;
    }
  if( str_list.at(str_list.length() - 1) == sep )
    str_list.truncate( str_list.length() -1 );
  writeEntry( pKey, str_list, bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry ( const QString& pKey, const QValueList<int> &list,
                               bool bPersistent, bool bGlobal, bool bNLS )
{
  writeEntry(pKey.utf8().data(), list, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry ( const char *pKey, const QValueList<int> &list,
                               bool bPersistent, bool bGlobal, bool bNLS )
{
    QStringList strlist;
    QValueList<int>::ConstIterator end = list.end();
    for (QValueList<int>::ConstIterator it = list.begin(); it != end; it++)
        strlist << QString::number(*it);
    writeEntry(pKey, strlist, ',', bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry( const QString& pKey, int nValue,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue), bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry( const char *pKey, int nValue,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue), bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, unsigned int nValue,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue), bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry( const char *pKey, unsigned int nValue,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue), bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, long nValue,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue), bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry( const char *pKey, long nValue,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue), bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, unsigned long nValue,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue), bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry( const char *pKey, unsigned long nValue,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue), bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, double nValue,
                                 bool bPersistent, bool bGlobal,
                                 char format, int precision,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue, format, precision),
                     bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry( const char *pKey, double nValue,
                                 bool bPersistent, bool bGlobal,
                                 char format, int precision,
                                 bool bNLS )
{
  writeEntry( pKey, QString::number(nValue, format, precision),
                     bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, bool bValue,
                                 bool bPersistent,
                                 bool bGlobal,
                                 bool bNLS )
{
  writeEntry(pKey.utf8().data(), bValue, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry( const char *pKey, bool bValue,
                                 bool bPersistent,
                                 bool bGlobal,
                                 bool bNLS )
{
  QString aValue;

  if( bValue )
    aValue = "true";
  else
    aValue = "false";

  writeEntry( pKey, aValue, bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, const QFont& rFont,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry(pKey.utf8().data(), rFont, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry( const char *pKey, const QFont& rFont,
                                 bool bPersistent, bool bGlobal,
                                 bool bNLS )
{
  writeEntry( pKey, rFont.toString(), bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, const QRect& rRect,
                              bool bPersistent, bool bGlobal,
                              bool bNLS )
{
  writeEntry(pKey.utf8().data(), rRect, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry( const char *pKey, const QRect& rRect,
                              bool bPersistent, bool bGlobal,
                              bool bNLS )
{
  QStrList list;
  QCString tempstr;
  list.insert( 0, tempstr.setNum( rRect.left() ) );
  list.insert( 1, tempstr.setNum( rRect.top() ) );
  list.insert( 2, tempstr.setNum( rRect.width() ) );
  list.insert( 3, tempstr.setNum( rRect.height() ) );

  writeEntry( pKey, list, ',', bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, const QPoint& rPoint,
                              bool bPersistent, bool bGlobal,
                              bool bNLS )
{
  writeEntry(pKey.utf8().data(), rPoint, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry( const char *pKey, const QPoint& rPoint,
                              bool bPersistent, bool bGlobal,
                              bool bNLS )
{
  QStrList list;
  QCString tempstr;
  list.insert( 0, tempstr.setNum( rPoint.x() ) );
  list.insert( 1, tempstr.setNum( rPoint.y() ) );

  writeEntry( pKey, list, ',', bPersistent, bGlobal, bNLS );
}


void KConfigBase::writeEntry( const QString& pKey, const QSize& rSize,
                              bool bPersistent, bool bGlobal,
                              bool bNLS )
{
  writeEntry(pKey.utf8().data(), rSize, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry( const char *pKey, const QSize& rSize,
                              bool bPersistent, bool bGlobal,
                              bool bNLS )
{
  QStrList list;
  QCString tempstr;
  list.insert( 0, tempstr.setNum( rSize.width() ) );
  list.insert( 1, tempstr.setNum( rSize.height() ) );

  writeEntry( pKey, list, ',', bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry( const QString& pKey, const QColor& rColor,
                              bool bPersistent,
                              bool bGlobal,
                              bool bNLS )
{
  writeEntry( pKey.utf8().data(), rColor, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry( const char *pKey, const QColor& rColor,
                              bool bPersistent,
                              bool bGlobal,
                              bool bNLS )
{
  QString aValue;
  if (rColor.isValid())
      aValue.sprintf( "%d,%d,%d", rColor.red(), rColor.green(), rColor.blue() );
  else
      aValue = "invalid";

  writeEntry( pKey, aValue, bPersistent, bGlobal, bNLS );
}

void KConfigBase::writeEntry( const QString& pKey, const QDateTime& rDateTime,
                              bool bPersistent, bool bGlobal,
                              bool bNLS )
{
  writeEntry(pKey.utf8().data(), rDateTime, bPersistent, bGlobal, bNLS);
}

void KConfigBase::writeEntry( const char *pKey, const QDateTime& rDateTime,
                              bool bPersistent, bool bGlobal,
                              bool bNLS )
{
  QStrList list;
  QCString tempstr;

  QTime time = rDateTime.time();
  QDate date = rDateTime.date();

  list.insert( 0, tempstr.setNum( date.year() ) );
  list.insert( 1, tempstr.setNum( date.month() ) );
  list.insert( 2, tempstr.setNum( date.day() ) );

  list.insert( 3, tempstr.setNum( time.hour() ) );
  list.insert( 4, tempstr.setNum( time.minute() ) );
  list.insert( 5, tempstr.setNum( time.second() ) );

  writeEntry( pKey, list, ',', bPersistent, bGlobal, bNLS );
}

void KConfigBase::parseConfigFiles()
{
  if (!bLocaleInitialized && KGlobal::_locale) {
    setLocale();
  }
  if (backEnd)
  {
     backEnd->parseConfigFiles();
     bReadOnly = (backEnd->getConfigState() == ReadOnly);
  }
}

void KConfigBase::sync()
{
  if (isReadOnly())
    return;

  if (backEnd)
     backEnd->sync();
  if (bDirty)
    rollback();
}

KConfigBase::ConfigState KConfigBase::getConfigState() const {
    if (backEnd)
       return backEnd->getConfigState();
    return ReadOnly;
}

void KConfigBase::rollback( bool )
{
  bDirty = false;
}


void KConfigBase::setReadDefaults(bool b)
{
  if (!d)
  {
     if (!b) return;
     d = new KConfigBasePrivate();
  }

  d->readDefaults = b;
}

bool KConfigBase::readDefaults() const
{
  return (d && d->readDefaults);
}

void KConfigBase::revertToDefault(const QString &key)
{
  setDirty(true);

  KEntryKey aEntryKey(mGroup, key.utf8());
  aEntryKey.bDefault = true;

  if (!locale().isNull()) {

    aEntryKey.bLocal = true;
    KEntry entry = lookupData(aEntryKey);
    if (entry.mValue.isNull())
        entry.bDeleted = true;

    entry.bDirty = true;
    putData(aEntryKey, entry, true);
    aEntryKey.bLocal = false;
  }


  KEntry entry = lookupData(aEntryKey);
  if (entry.mValue.isNull())
     entry.bDeleted = true;
  entry.bDirty = true;
  putData(aEntryKey, entry, true);
}

bool KConfigBase::hasDefault(const QString &key) const
{
  KEntryKey aEntryKey(mGroup, key.utf8());
  aEntryKey.bDefault = true;

  if (!locale().isNull()) {

    aEntryKey.bLocal = true;
    KEntry entry = lookupData(aEntryKey);
    if (!entry.mValue.isNull())
        return true;

    aEntryKey.bLocal = false;
  }


  KEntry entry = lookupData(aEntryKey);
  if (!entry.mValue.isNull())
     return true;

  return false;
}



KConfigGroup::KConfigGroup(KConfigBase *master, const QString &group)
{
  mMaster = master;
  backEnd = mMaster->backEnd;
  bLocaleInitialized = true;
  bReadOnly = mMaster->bReadOnly;
  bExpand = false;
  bDirty = false;
  mGroup = group.utf8();
  aLocaleString = mMaster->aLocaleString;
  setReadDefaults(mMaster->readDefaults());
}

KConfigGroup::KConfigGroup(KConfigBase *master, const QCString &group)
{
  mMaster = master;
  backEnd = mMaster->backEnd;
  bLocaleInitialized = true;
  bReadOnly = mMaster->bReadOnly;
  bExpand = false;
  bDirty = false;
  mGroup = group;
  aLocaleString = mMaster->aLocaleString;
  setReadDefaults(mMaster->readDefaults());
}

KConfigGroup::KConfigGroup(KConfigBase *master, const char * group)
{
  mMaster = master;
  backEnd = mMaster->backEnd;
  bLocaleInitialized = true;
  bReadOnly = mMaster->bReadOnly;
  bExpand = false;
  bDirty = false;
  mGroup = group;
  aLocaleString = mMaster->aLocaleString;
  setReadDefaults(mMaster->readDefaults());
}

void KConfigGroup::deleteGroup(bool bGlobal)
{
  mMaster->deleteGroup(KConfigBase::group(), false, bGlobal);
}

void KConfigGroup::setDirty(bool b)
{
  mMaster->setDirty(b);
}

void KConfigGroup::putData(const KEntryKey &_key, const KEntry &_data, bool _checkGroup)
{
  mMaster->putData(_key, _data, _checkGroup);
}

KEntry KConfigGroup::lookupData(const KEntryKey &_key) const
{
  return mMaster->lookupData(_key);
}

void KConfigGroup::sync()
{
  mMaster->sync();
}

void KConfigBase::virtual_hook( int, void* )
{ }

void KConfigGroup::virtual_hook( int id, void* data )
{ KConfigBase::virtual_hook( id, data ); }

bool KConfigBase::checkConfigFilesWritable(bool warnUser)
{
  if (backEnd)
    return backEnd->checkConfigFilesWritable(warnUser);
  else
    return FALSE;
}

# 1 "../kdecore/kconfigbase.moc" 1
# 11 "../kdecore/kconfigbase.moc"
# 1 "../../../prod/kdelibs/kdecore/kconfigbase.h" 1
# 12 "../kdecore/kconfigbase.moc" 2
# 22 "../kdecore/kconfigbase.moc"
const char *KConfigBase::className() const
{
    return "KConfigBase";
}

QMetaObject *KConfigBase::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KConfigBase( "KConfigBase", &KConfigBase::staticMetaObject );
# 50 "../kdecore/kconfigbase.moc"
QMetaObject* KConfigBase::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KConfigBase", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KConfigBase.setMetaObject( metaObj );
    return metaObj;
}

void* KConfigBase::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KConfigBase" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KConfigBase::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KConfigBase::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KConfigBase::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KConfigBase::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 1843 "/coolo/prod/kdelibs/kdecore/kconfigbase.cpp" 2
# 9 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kconfig.cpp" 1
# 24 "/coolo/prod/kdelibs/kdecore/kconfig.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 25 "/coolo/prod/kdelibs/kdecore/kconfig.cpp" 2
# 43 "/coolo/prod/kdelibs/kdecore/kconfig.cpp"
KConfig::KConfig( const QString& fileName,
                 bool bReadOnly, bool bUseKderc, const char *resType )
  : KConfigBase(), bGroupImmutable(false), bFileImmutable(false),
    bForceGlobal(false)
{

  setReadOnly(bReadOnly);




  KConfigINIBackEnd *aBackEnd = new KConfigINIBackEnd(this,
                                                      fileName,
                                                      resType,
                                                      bUseKderc);

  backEnd = aBackEnd;


  reparseConfiguration();
# 72 "/coolo/prod/kdelibs/kdecore/kconfig.cpp"
  if (KGlobal::dirs()->addCustomized(this))
      reparseConfiguration();
}

KConfig::KConfig(KConfigBackEnd *aBackEnd, bool bReadOnly)
    : bGroupImmutable(false), bFileImmutable(false),
    bForceGlobal(false)
{
  setReadOnly(bReadOnly);
  backEnd = aBackEnd;
  reparseConfiguration();
}

KConfig::~KConfig()
{
  sync();

  delete backEnd;
}

void KConfig::rollback(bool bDeep)
{
  KConfigBase::rollback(bDeep);

  if (!bDeep)
    return;


  for (KEntryMapIterator aIt = aEntryMap.begin();
       aIt != aEntryMap.end(); ++aIt)
    (*aIt).bDirty = false;
}

QStringList KConfig::groupList() const
{
  QStringList retList;

  KEntryMapConstIterator aIt = aEntryMap.begin();
  KEntryMapConstIterator aEnd = aEntryMap.end();
  for (; aIt != aEnd; ++aIt)
  {
    while(aIt.key().mKey.isEmpty())
    {
      QCString group = aIt.key().mGroup;
      ++aIt;
      while (true)
      {
         if (aIt == aEnd)
            return retList;

         if (aIt.key().mKey.isEmpty())
            break;

         if (!aIt.key().bDefault && !(*aIt).bDeleted)
         {
            if (group != "$Version")
               retList.append(QString::fromUtf8(group));
            break;
         }
         ++aIt;
      }
    }
  }

  return retList;
}

QMap<QString, QString> KConfig::entryMap(const QString &pGroup) const
{
  QCString pGroup_utf = pGroup.utf8();
  KEntryKey groupKey( pGroup_utf, 0 );
  QMap<QString, QString> tmpMap;

  KEntryMapConstIterator aIt = aEntryMap.find(groupKey);
  if (aIt == aEntryMap.end())
     return tmpMap;
  ++aIt;
  for (; aIt.key().mGroup == pGroup_utf && aIt != aEntryMap.end(); ++aIt)
  {

    if (!aIt.key().bDefault && !(*aIt).bDeleted)
      tmpMap.insert(QString::fromUtf8(aIt.key().mKey), QString::fromUtf8((*aIt).mValue.data(), (*aIt).mValue.length()));
  }

  return tmpMap;
}

void KConfig::reparseConfiguration()
{
  aEntryMap.clear();


  KEntryKey groupKey("<default>", 0);
  aEntryMap.insert(groupKey, KEntry());

  bFileImmutable = false;
  parseConfigFiles();
  bFileImmutable = bReadOnly;
}

KEntryMap KConfig::internalEntryMap(const QString &pGroup) const
{
  QCString pGroup_utf = pGroup.utf8();
  KEntry aEntry;
  KEntryMapConstIterator aIt;
  KEntryKey aKey(pGroup_utf, 0);
  KEntryMap tmpEntryMap;

  aIt = aEntryMap.find(aKey);
  if (aIt == aEntryMap.end()) {



    return tmpEntryMap;
  }

  for (; aIt.key().mGroup == pGroup_utf && aIt != aEntryMap.end(); ++aIt)
  {
    tmpEntryMap.insert(aIt.key(), *aIt);
  }

  return tmpEntryMap;
}

void KConfig::putData(const KEntryKey &_key, const KEntry &_data, bool _checkGroup)
{
  if (bFileImmutable)
    return;



  if (_checkGroup)
  {
    KEntryKey groupKey( _key.mGroup, 0);
    KEntry &entry = aEntryMap[groupKey];
    bGroupImmutable = entry.bImmutable;
  }
  if (bGroupImmutable)
    return;


  KEntry &entry = aEntryMap[_key];
  if (entry.bImmutable)
    return;

  entry = _data;

  entry.bGlobal |= bForceGlobal;

  if (_key.bDefault)
  {


     KEntryKey key(_key);
     key.bDefault = false;
     aEntryMap[key] = _data;
  }
}

KEntry KConfig::lookupData(const KEntryKey &_key) const
{
  KEntryMapConstIterator aIt = aEntryMap.find(_key);
  if (aIt != aEntryMap.end())
  {
    const KEntry &entry = *aIt;
    if (entry.bDeleted)
       return KEntry();
    else
       return entry;
  }
  else {
    return KEntry();
  }
}

bool KConfig::internalHasGroup(const QCString &group) const
{
  KEntryKey groupKey( group, 0);

  KEntryMapConstIterator aIt = aEntryMap.find(groupKey);
  KEntryMapConstIterator aEnd = aEntryMap.end();

  if (aIt == aEnd)
     return false;
  ++aIt;
  for(; (aIt != aEnd); ++aIt)
  {
     if (aIt.key().mKey.isEmpty())
        break;

     if (!aIt.key().bDefault && !(*aIt).bDeleted)
        return true;
  }
  return false;
}

void KConfig::setFileWriteMode(int mode)
{
  backEnd->setFileWriteMode(mode);
}

void KConfig::checkUpdate(const QString &id, const QString &updateFile)
{
  QString oldGroup = group();
  setGroup("$Version");
  QString cfg_id = updateFile+":"+id;
  QStringList ids = readListEntry("update_info");
  if (!ids.contains(cfg_id))
  {
     QStringList args;
     args << "--check" << updateFile;
     KApplication::kdeinitExecWait("kconf_update", args);
     reparseConfiguration();
  }
  setGroup(oldGroup);
}

KConfig* KConfig::copyTo(const QString &file)
{
  KConfig *config = new KConfig(QString::null, false, false);
  config->backEnd->changeFileName(file, "config", false);
  config->setReadOnly(false);
  config->bFileImmutable = false;
  config->backEnd->mConfigState = ReadWrite;

  QStringList groups = groupList();
  for(QStringList::ConstIterator it = groups.begin();
      it != groups.end(); ++it)
  {
     QMap<QString, QString> map = entryMap(*it);
     config->setGroup(*it);
     for (QMap<QString,QString>::Iterator it2 = map.begin();
          it2 != map.end(); ++it2)
     {
        config->writeEntry(it2.key(), it2.data());
     }

  }
  return config;
}

void KConfig::virtual_hook( int id, void* data )
{ KConfigBase::virtual_hook( id, data ); }



# 1 "../kdecore/kconfig.moc" 1
# 11 "../kdecore/kconfig.moc"
# 1 "../../../prod/kdelibs/kdecore/kconfig.h" 1
# 12 "../kdecore/kconfig.moc" 2
# 22 "../kdecore/kconfig.moc"
const char *KConfig::className() const
{
    return "KConfig";
}

QMetaObject *KConfig::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KConfig( "KConfig", &KConfig::staticMetaObject );
# 50 "../kdecore/kconfig.moc"
QMetaObject* KConfig::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KConfigBase::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KConfig", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KConfig.setMetaObject( metaObj );
    return metaObj;
}

void* KConfig::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KConfig" ) )
        return this;
    return KConfigBase::qt_cast( clname );
}

bool KConfig::qt_invoke( int _id, QUObject* _o )
{
    return KConfigBase::qt_invoke(_id,_o);
}

bool KConfig::qt_emit( int _id, QUObject* _o )
{
    return KConfigBase::qt_emit(_id,_o);
}


bool KConfig::qt_property( int id, int f, QVariant* v)
{
    return KConfigBase::qt_property( id, f, v);
}

bool KConfig::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 319 "/coolo/prod/kdelibs/kdecore/kconfig.cpp" 2
# 10 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 23 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.cpp" 2
# 39 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.cpp"
KSimpleConfig::KSimpleConfig(const QString &fileName, bool bReadOnly)
  : KConfig(QString::fromLatin1(""), bReadOnly, false)
{


  if (!fileName.isNull() && fileName[0] != '/') {
     backEnd->changeFileName( KGlobal::dirs()->
        saveLocation("config", QString::null, !bReadOnly)+fileName, "config", false);
  } else {
     backEnd->changeFileName(fileName, "config", false);
  }
  setReadOnly( bReadOnly );
  reparseConfiguration();
}

KSimpleConfig::KSimpleConfig(KConfigBackEnd *backEnd, bool bReadOnly)
  : KConfig(backEnd, bReadOnly)
{}

KSimpleConfig::~KSimpleConfig()
{




  sync();
}

void KSimpleConfig::sync()
{
   if (isReadOnly())
       return;
   backEnd->sync(false);

   if (isDirty())
     rollback();
}

void KSimpleConfig::virtual_hook( int id, void* data )
{ KConfig::virtual_hook( id, data ); }

# 1 "../kdecore/ksimpleconfig.moc" 1
# 11 "../kdecore/ksimpleconfig.moc"
# 1 "../../../prod/kdelibs/kdecore/ksimpleconfig.h" 1
# 12 "../kdecore/ksimpleconfig.moc" 2
# 22 "../kdecore/ksimpleconfig.moc"
const char *KSimpleConfig::className() const
{
    return "KSimpleConfig";
}

QMetaObject *KSimpleConfig::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KSimpleConfig( "KSimpleConfig", &KSimpleConfig::staticMetaObject );
# 50 "../kdecore/ksimpleconfig.moc"
QMetaObject* KSimpleConfig::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KConfig::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KSimpleConfig", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KSimpleConfig.setMetaObject( metaObj );
    return metaObj;
}

void* KSimpleConfig::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KSimpleConfig" ) )
        return this;
    return KConfig::qt_cast( clname );
}

bool KSimpleConfig::qt_invoke( int _id, QUObject* _o )
{
    return KConfig::qt_invoke(_id,_o);
}

bool KSimpleConfig::qt_emit( int _id, QUObject* _o )
{
    return KConfig::qt_emit(_id,_o);
}


bool KSimpleConfig::qt_property( int id, int f, QVariant* v)
{
    return KConfig::qt_property( id, f, v);
}

bool KSimpleConfig::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 81 "/coolo/prod/kdelibs/kdecore/ksimpleconfig.cpp" 2
# 11 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kconfigbackend.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/kconfigbackend.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 23 "/coolo/prod/kdelibs/kdecore/kconfigbackend.cpp" 2
# 38 "/coolo/prod/kdelibs/kdecore/kconfigbackend.cpp"
# 1 "/coolo/prod/qt-copy/include/qtextcodec.h" 1
# 39 "/coolo/prod/qt-copy/include/qtextcodec.h"







class QTextCodec;
class QIODevice;
class QFont;

class QTextEncoder {
public:
    virtual ~QTextEncoder();
    virtual QCString fromUnicode(const QString& uc, int& lenInOut) = 0;
};

class QTextDecoder {
public:
    virtual ~QTextDecoder();
    virtual QString toUnicode(const char* chars, int len) = 0;
};

class QTextCodec {
public:
    virtual ~QTextCodec();


    static QTextCodec* loadCharmap(QIODevice*);
    static QTextCodec* loadCharmapFile(QString filename);

    static QTextCodec* codecForMib(int mib);
    static QTextCodec* codecForName(const char* hint, int accuracy=0);
    static QTextCodec* codecForContent(const char* chars, int len);
    static QTextCodec* codecForIndex(int i);
    static QTextCodec* codecForLocale();
    static void setCodecForLocale(QTextCodec *c);

    static QTextCodec* codecForTr();
    static void setCodecForTr(QTextCodec *c);
    static QTextCodec* codecForCStrings();
    static void setCodecForCStrings(QTextCodec *c);

    static void deleteAllCodecs();

    static const char* locale();

    virtual const char* name() const = 0;
    virtual const char* mimeName() const;
    virtual int mibEnum() const = 0;

    virtual QTextDecoder* makeDecoder() const;
    virtual QTextEncoder* makeEncoder() const;

    virtual QString toUnicode(const char* chars, int len) const;
    virtual QCString fromUnicode(const QString& uc, int& lenInOut) const;

    QCString fromUnicode(const QString& uc) const;
    QString toUnicode(const QByteArray&, int len) const;
    QString toUnicode(const QByteArray&) const;
    QString toUnicode(const QCString&, int len) const;
    QString toUnicode(const QCString&) const;
    QString toUnicode(const char* chars) const;
    virtual bool canEncode( QChar ) const;
    virtual bool canEncode( const QString& ) const;

    virtual int heuristicContentMatch(const char* chars, int len) const = 0;
    virtual int heuristicNameMatch(const char* hint) const;

    virtual QByteArray fromUnicode(const QString& uc, int from, int len) const;
    virtual unsigned short characterFromUnicode(const QString &str, int pos) const;

protected:
    QTextCodec();
    static int simpleHeuristicNameMatch(const char* name, const char* hint);

private:
    friend class QFont;
    friend class QFontEngineXLFD;
    void fromUnicodeInternal( const QChar *in, unsigned short *out, int length );

    static QTextCodec *cftr;
    static QTextCodec *cfcs;
};

inline QTextCodec* QTextCodec::codecForTr() { return cftr; }
inline void QTextCodec::setCodecForTr(QTextCodec *c) { cftr = c; }
inline QTextCodec* QTextCodec::codecForCStrings() { return cfcs; }
inline void QTextCodec::setCodecForCStrings(QTextCodec *c) { cfcs = c; }
# 39 "/coolo/prod/kdelibs/kdecore/kconfigbackend.cpp" 2
# 48 "/coolo/prod/kdelibs/kdecore/kconfigbackend.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/ksavefile.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/ksavefile.h"



# 1 "/usr/include/errno.h" 1 3 4
# 26 "/coolo/prod/kdelibs/kdecore/ksavefile.h" 2
# 1 "/coolo/prod/kdelibs/kdecore/ktempfile.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/ktempfile.h"



# 1 "/usr/include/errno.h" 1 3 4
# 26 "/coolo/prod/kdelibs/kdecore/ktempfile.h" 2

class QFile;
class QTextStream;
class QDataStream;
class KSaveFile;
class KTempFilePrivate;
# 54 "/coolo/prod/kdelibs/kdecore/ktempfile.h"
class KTempFile
{
   friend class KSaveFile;
public:
# 70 "/coolo/prod/kdelibs/kdecore/ktempfile.h"
   KTempFile(QString filePrefix=QString::null,
             QString fileExtension=QString::null,
             int mode = 0600 );






   ~KTempFile();






   void setAutoDelete(bool autoDelete) { bAutoDelete = autoDelete; }
# 99 "/coolo/prod/kdelibs/kdecore/ktempfile.h"
   int status() const;
# 121 "/coolo/prod/kdelibs/kdecore/ktempfile.h"
   QString name() const;






   int handle() const;






   FILE *fstream();






   QTextStream *textStream();






   QDataStream *dataStream();






   QFile *file();





   void unlink();







   bool close();

protected:



   KTempFile(bool);





   bool create(const QString &filePrefix,
               const QString &fileExtension, int mode);

   void setError(int error) { mError = error; }
private:
   int mError;
   QString mTmpName;
   int mFd;
   FILE *mStream;
   QFile *mFile;
   QTextStream *mTextStream;
   QDataStream *mDataStream;
   bool bOpen;
   bool bAutoDelete;

   KTempFilePrivate *d;
};
# 27 "/coolo/prod/kdelibs/kdecore/ksavefile.h" 2

class KSaveFilePrivate;
# 41 "/coolo/prod/kdelibs/kdecore/ksavefile.h"
class KSaveFile
{
public:





   KSaveFile(const QString &filename, int mode = 0666 );




   ~KSaveFile();
# 67 "/coolo/prod/kdelibs/kdecore/ksavefile.h"
   int status() const
        { return mTempFile.status(); }






   QString name() const;






   int handle() const
        { return mTempFile.handle(); }






   FILE *fstream()
        { return mTempFile.fstream(); }






   QFile *file()
        { return mTempFile.file(); }






   QTextStream *textStream()
        { return mTempFile.textStream(); }






   QDataStream *dataStream()
        { return mTempFile.dataStream(); }





   void abort();







   bool close();
# 140 "/coolo/prod/kdelibs/kdecore/ksavefile.h"
   static bool backupFile( const QString& filename,
                           const QString& backupDir = QString::null,
                           const QString& backupExtension = QString::fromLatin1( "~" ) );

private:
   QString mFileName;
   KTempFile mTempFile;

   KSaveFilePrivate *d;
};
# 49 "/coolo/prod/kdelibs/kdecore/kconfigbackend.cpp" 2


extern bool checkAccess(const QString& pathname, int mode);

static QCString printableToString(const char *str, int l)
{

  while((l>0) &&
        ((*str == ' ') || (*str == '\t') || (*str == '\r')))
  {
     str++; l--;
  }


  while((l>0) &&
        ((str[l-1] == ' ') || (str[l-1] == '\t') || (str[l-1] == '\r')))
  {
     l--;
  }

  QCString result(l + 1);
  char *r = result.data();

  for(int i = 0; i < l;i++, str++)
  {
     if (*str == '\\')
     {
        i++, str++;
        if (i >= l)
        {
           *r++ = '\\';
           break;
        }
        switch(*str)
        {
           case 's':
              *r++ = ' ';
              break;
           case 't':
              *r++ = '\t';
              break;
           case 'n':
              *r++ = '\n';
              break;
           case 'r':
              *r++ = '\r';
              break;
           case '\\':
              *r++ = '\\';
              break;
           default:
              *r++ = '\\';
              *r++ = *str;
        }
     }
     else
     {
        *r++ = *str;
     }
  }
  result.truncate(r-result.data());
  return result;
}

static QCString stringToPrintable(const QCString& str){
  QCString result(str.length()*2);
  register char *r = result.data();
  register char *s = str.data();

  if (!s) return QCString("");


  if (*s == ' ')
  {
     *r++ = '\\'; *r++ = 's';
     s++;
  }

  if (*s)
  {
   while(*s)
   {
    if (*s == '\n')
    {
      *r++ = '\\'; *r++ = 'n';
    }
    else if (*s == '\t')
    {
      *r++ = '\\'; *r++ = 't';
    }
    else if (*s == '\r')
    {
      *r++ = '\\'; *r++ = 'r';
    }
    else if (*s == '\\')
    {
      *r++ = '\\'; *r++ = '\\';
    }
    else
    {
      *r++ = *s;
    }
    s++;
   }

   if (*(r-1) == ' ')
   {
      *(r-1) = '\\'; *r++ = 's';
   }
  }

  result.truncate(r - result.data());
  return result;
}

void KConfigBackEnd::changeFileName(const QString &_fileName,
                                    const char * _resType,
                                    bool _useKDEGlobals)
{
   mfileName = _fileName;
   resType = _resType;
   useKDEGlobals = _useKDEGlobals;
   if (mfileName.isEmpty())
      mLocalFileName = QString::null;
   else if (mfileName[0] == '/')
      mLocalFileName = mfileName;
   else
      mLocalFileName = KGlobal::dirs()->saveLocation(resType) + mfileName;

   if (useKDEGlobals)
      mGlobalFileName = KGlobal::dirs()->saveLocation("config") +
              QString::fromLatin1("kdeglobals");
   else
      mGlobalFileName = QString::null;
}

KConfigBackEnd::KConfigBackEnd(KConfigBase *_config,
                               const QString &_fileName,
                               const char * _resType,
                               bool _useKDEGlobals)
  : pConfig(_config), bFileImmutable(false), mConfigState(KConfigBase::NoAccess), mFileMode(-1)
{
   changeFileName(_fileName, _resType, _useKDEGlobals);
}

void KConfigBackEnd::setFileWriteMode(int mode)
{
  mFileMode = mode;
}

bool KConfigINIBackEnd::parseConfigFiles()
{

  mConfigState = KConfigBase::ReadOnly;
  if (!mLocalFileName.isEmpty() && !pConfig->isReadOnly())
  {
     if (checkAccess(mLocalFileName, 2))
     {
        mConfigState = KConfigBase::ReadWrite;
     }
     else
     {

        KURL path;
        path.setPath(mLocalFileName);
        QString dir=path.directory();
        KStandardDirs::makeDir(dir);

        if (checkAccess(mLocalFileName, 2))
        {
           mConfigState = KConfigBase::ReadWrite;
        }
     }
  }


  bFileImmutable = false;


  if (useKDEGlobals) {
    QStringList kdercs = KGlobal::dirs()->
      findAllResources("config", QString::fromLatin1("kdeglobals"));

    if (checkAccess(QString::fromLatin1("/etc/kderc"), 4))
      kdercs += QString::fromLatin1("/etc/kderc");

    kdercs += KGlobal::dirs()->
      findAllResources("config", QString::fromLatin1("system.kdeglobals"));

    QStringList::ConstIterator it;

    for (it = kdercs.fromLast(); it != kdercs.end(); --it) {

      QFile aConfigFile( *it );
      if (!aConfigFile.open( 0x0001 ))
           continue;
      parseSingleConfigFile( aConfigFile, 0L, true, (*it != mGlobalFileName) );
      aConfigFile.close();
      if (bFileImmutable)
         break;
    }
  }

  bool bReadFile = !mfileName.isEmpty();
  while(bReadFile) {
    bReadFile = false;
    QString bootLanguage;
    if (useKDEGlobals && localeString.isEmpty() && !KGlobal::_locale) {

       bootLanguage = KLocale::_initLanguage(pConfig);
       setLocaleString(bootLanguage.utf8());
    }

    bFileImmutable = false;
    QStringList list = KGlobal::dirs()->
      findAllResources(resType, mfileName);

    QStringList::ConstIterator it;

    for (it = list.fromLast(); it != list.end(); --it) {

      QFile aConfigFile( *it );

      bool bIsLocal = (*it == mLocalFileName);
      if (aConfigFile.open( 0x0001 )) {
         parseSingleConfigFile( aConfigFile, 0L, false, !bIsLocal );
         aConfigFile.close();
         if (bFileImmutable)
            break;
      }
    }
    if (KGlobal::dirs()->isRestrictedResource(resType, mfileName))
       bFileImmutable = true;
    QString currentLanguage;
    if (!bootLanguage.isEmpty())
    {
       currentLanguage = KLocale::_initLanguage(pConfig);


       if (bootLanguage != currentLanguage)
       {
          bReadFile = true;
          setLocaleString(currentLanguage.utf8());
       }
    }
  }
  if (bFileImmutable)
     mConfigState = KConfigBase::ReadOnly;

  return true;
}



static const char **mmap_pEof;

static void mmap_sigbus_handler(int)
{
   *mmap_pEof = 0;
   write(2, "SIGBUS\n", 7);
   signal(7, mmap_sigbus_handler);
}



void KConfigINIBackEnd::parseSingleConfigFile(QFile &rFile,
                                              KEntryMap *pWriteBackMap,
                                              bool bGlobal, bool bDefault)
{
   void (*old_sighandler)(int) = 0;

   if (!rFile.isOpen())
      return;






   QCString aCurrentGroup("<default>");

   const char *s, *eof;
   QByteArray data;

   unsigned int ll = localeString.length();


   const char *map = ( const char* ) mmap(0, rFile.size(), 0x1, 0x02,
                                          rFile.handle(), 0);

   if (map)
   {
      s = map;
      eof = s + rFile.size();


      mmap_pEof = &eof;
      old_sighandler = signal(7, mmap_sigbus_handler);

   }
   else

   {
      rFile.at(0);
      data = rFile.readAll();
      s = data.data();
      eof = s + data.size();
   }

   bool fileOptionImmutable = false;
   bool groupOptionImmutable = false;
   bool groupSkip = false;

   int line = 0;
   for(; s < eof; s++)
   {
      line++;

      while((s < eof) && isspace(*s) && (*s != '\n'))
         s++;


      if ((s < eof) && ((*s == '\n') || (*s == '#')))
      {
    sktoeol:
         while ((s < eof) && (*s != '\n'))
            s++;
         continue;
      }
      const char *startLine = s;

      if (*s == '[')
      {
         while ((s < eof) && (*s != '\n') && (*s != ']')) s++;
         const char *e = s;
         while ((s < eof) && (*s != '\n')) s++;
         if ((e >= eof) || (*e != ']'))
         {
            fprintf(stderr, "Invalid group header at %s:%d\n", rFile.name().latin1(), line);
            continue;
         }


         if ((e-startLine == 3) &&
             (startLine[1] == '$') &&
             (startLine[2] == 'i'))
         {
            fileOptionImmutable = true;
            continue;
         }

         aCurrentGroup = QCString(startLine + 1, e - startLine);



         if (aCurrentGroup == "KDE Desktop Entry")
            aCurrentGroup = "Desktop Entry";

         groupOptionImmutable = fileOptionImmutable;

         e++;
         if ((e+2 < eof) && (*e++ == '[') && (*e++ == '$'))
         {
            if (*e == 'i')
            {
               groupOptionImmutable = true;
            }
         }

         KEntryKey groupKey(aCurrentGroup, 0);
         KEntry entry = pConfig->lookupData(groupKey);
         groupSkip = entry.bImmutable;

         if (groupSkip)
            continue;

         entry.bImmutable = groupOptionImmutable;
         pConfig->putData(groupKey, entry, false);

         if (pWriteBackMap)
         {

            (*pWriteBackMap)[groupKey] = entry;
         }

         continue;
      }
      if (groupSkip)
        goto sktoeol;

      bool optionImmutable = groupOptionImmutable;
      bool optionDeleted = false;
      bool optionExpand = false;
      const char *endOfKey = 0, *locale = 0, *elocale = 0;
      for (; (s < eof) && (*s != '\n'); s++)
      {
         if (*s == '=')
         {
            if (!endOfKey)
                endOfKey = s;
            goto haveeq;
         }
         if (*s == '[')
         {
            const char *option;
            const char *eoption;
            endOfKey = s;
            option = ++s;
            for (;; s++)
            {
                if ((s >= eof) || (*s == '\n') || (*s == '=')) {
                    fprintf(stderr, "Invalid entry (missing ']') at %s:%d\n", rFile.name().latin1(), line);
                    goto sktoeol;
                }
                if (*s == ']')
                    break;
            }
            eoption = s;
            if (*option != '$')
            {

              if (locale) {
                fprintf(stderr, "Invalid entry (second locale!?) at %s:%d\n", rFile.name().latin1(), line);
                goto sktoeol;
              }
              locale = option;
              elocale = eoption;
            }
            else
            {

              while (option < eoption)
              {
                 option++;
                 if (*option == 'i')
                    optionImmutable = true;
                 else if (*option == 'e')
                    optionExpand = true;
                 else if (*option == 'd')
                 {
                    optionDeleted = true;
                    goto haveeq;
                 }
                 else if (*option == ']')
                    break;
              }
            }
         }
      }
      fprintf(stderr, "Invalid entry (missing '=') at %s:%d\n", rFile.name().latin1(), line);
      continue;

   haveeq:
      for (endOfKey--; ; endOfKey--)
      {
         if (endOfKey < startLine)
         {
           fprintf(stderr, "Invalid entry (empty key) at %s:%d\n", rFile.name().latin1(), line);
           goto sktoeol;
         }
         if (!isspace(*endOfKey))
            break;
      }

      const char *st = ++s;
      while ((s < eof) && (*s != '\n')) s++;

      if (locale) {
          unsigned int cl = static_cast<unsigned int>(elocale - locale);
          if ((ll != cl) || memcmp(locale, localeString.data(), ll))
          {

              if ( cl != 1 || ll != 5 || memcmp(locale, "C", 1) || memcmp(localeString.data(), "en_US", 5)) {


                  if (!pWriteBackMap)
                      continue;

                  endOfKey = elocale;
                  locale = 0;
              }
          }
      }


      QCString key(startLine, endOfKey - startLine + 2);
      QCString val = printableToString(st, s - st);


      KEntryKey aEntryKey(aCurrentGroup, key);
      aEntryKey.bLocal = (locale != 0);
      aEntryKey.bDefault = bDefault;

      KEntry aEntry;
      aEntry.mValue = val;
      aEntry.bGlobal = bGlobal;
      aEntry.bImmutable = optionImmutable;
      aEntry.bDeleted = optionDeleted;
      aEntry.bExpand = optionExpand;
      aEntry.bNLS = (locale != 0);

      if (pWriteBackMap) {


         pWriteBackMap->insert(aEntryKey, aEntry);
      } else {



         pConfig->putData(aEntryKey, aEntry, false);
      }
   }
   if (fileOptionImmutable)
      bFileImmutable = true;


   if (map)
   {
      munmap(( char* )map, rFile.size());

      signal(7, old_sighandler);

   }

}


void KConfigINIBackEnd::sync(bool bMerge)
{

  if (!pConfig->isDirty())
    return;

  bool bEntriesLeft = true;




  if (!mfileName.isEmpty()) {

    if ((resType!="config") && mLocalFileName[0]=='/')
    {
       KURL path;
       path.setPath(mLocalFileName);
       QString dir=path.directory();
       KStandardDirs::makeDir(dir);
    }





    if (checkAccess(mLocalFileName, 2)) {

      bEntriesLeft = writeConfigFile( mLocalFileName, false, bMerge );
    }
  }




  if (bEntriesLeft && useKDEGlobals) {



    if (checkAccess ( mGlobalFileName, 2 )) {
      writeConfigFile( mGlobalFileName, true, bMerge );
    }
  }

}

static void writeEntries(FILE *pStream, const KEntryMap& entryMap, bool defaultGroup, bool &firstEntry, const QCString &localeString)
{

  QCString currentGroup;
  for (KEntryMapConstIterator aIt = entryMap.begin();
       aIt != entryMap.end(); ++aIt)
  {
     const KEntryKey &key = aIt.key();


     if ((key.mGroup != "<default>") == defaultGroup)
        continue;


     if ((key.bDefault) || key.mKey.isEmpty())
        continue;

     const KEntry &currentEntry = *aIt;

     KEntryMapConstIterator aTestIt = aIt;
     ++aTestIt;
     bool hasDefault = (aTestIt != entryMap.end());
     if (hasDefault)
     {
        const KEntryKey &defaultKey = aTestIt.key();
        if ((!defaultKey.bDefault) ||
            (defaultKey.mKey != key.mKey) ||
            (defaultKey.mGroup != key.mGroup) ||
            (defaultKey.bLocal != key.bLocal))
           hasDefault = false;
     }


     if (hasDefault)
     {

        if ((currentEntry.mValue == (*aTestIt).mValue) &&
            (currentEntry.bDeleted == (*aTestIt).bDeleted))
           continue;
     }
     else
     {

        if (currentEntry.bDeleted)
           continue;
     }

     if (!defaultGroup && (currentGroup != key.mGroup)) {
        if (!firstEntry)
            fprintf(pStream, "\n");
        currentGroup = key.mGroup;
        fprintf(pStream, "[%s]\n", currentGroup.data());
     }

     firstEntry = false;

     fputs(key.mKey.data(), pStream);

     if ( currentEntry.bNLS )
     {
        fputc('[', pStream);
        fputs(localeString.data(), pStream);
        fputc(']', pStream);
     }

     if (currentEntry.bDeleted)
     {
        fputs("[$d]\n", pStream);
     }
     else
     {
        if (currentEntry.bImmutable || currentEntry.bExpand)
        {
           fputc('[', pStream);
           fputc('$', pStream);
           if (currentEntry.bImmutable)
              fputc('i', pStream);
           if (currentEntry.bExpand)
              fputc('e', pStream);

           fputc(']', pStream);
        }
        fputc('=', pStream);
        fputs(stringToPrintable(currentEntry.mValue).data(), pStream);
        fputc('\n', pStream);
     }
  }
}

bool KConfigINIBackEnd::getEntryMap(KEntryMap &aTempMap, bool bGlobal,
                                    QFile *mergeFile)
{
  bool bEntriesLeft = false;
  bFileImmutable = false;
  if (mergeFile)
  {

    if (mergeFile->open(0x0001))
    {

       parseSingleConfigFile(*mergeFile, &aTempMap, bGlobal, false );

       if (bFileImmutable)
          return bEntriesLeft;
    }

    KEntryMap aMap = pConfig->internalEntryMap();


    for (KEntryMapIterator aIt = aMap.begin();
          aIt != aMap.end(); ++aIt)
    {
      const KEntry &currentEntry = *aIt;
      if(aIt.key().bDefault)
      {
         aTempMap.replace(aIt.key(), currentEntry);
         continue;
      }

      if (!currentEntry.bDirty)
         continue;



      if (currentEntry.bGlobal != bGlobal)
      {

        bEntriesLeft = true;
        continue;
      }



      KEntryMapIterator aIt2 = aTempMap.find(aIt.key());
      if (aIt2 != aTempMap.end() && (*aIt2).bImmutable)
        continue;

      aTempMap.insert(aIt.key(), currentEntry, true);
    }
  }
  else
  {

    aTempMap = pConfig->internalEntryMap();
    bEntriesLeft = true;
  }

  return bEntriesLeft;
}


bool KConfigINIBackEnd::writeConfigFile(QString filename, bool bGlobal,
                                        bool bMerge)
{

  if (pConfig->isReadOnly())
    return true;

  KEntryMap aTempMap;
  QFile *mergeFile = (bMerge ? new QFile(filename) : 0);
  bool bEntriesLeft = getEntryMap(aTempMap, bGlobal, mergeFile);
  delete mergeFile;
  if (bFileImmutable) return true;






  int fileMode = -1;
  bool createNew = true;

  struct stat buf;
  if (lstat(QFile::encodeName(filename), &buf) == 0)
  {
     if (((((buf.st_mode)) & 0170000) == (0120000)))
     {

        if (stat(QFile::encodeName(filename), &buf) == 0)
        {

           createNew = false;
        }
     }
     else if (buf.st_uid == getuid())
     {

        fileMode = buf.st_mode & 0777;
     }
     else
     {


        createNew = false;
     }
  }

  KSaveFile *pConfigFile = 0;
  FILE *pStream = 0;

  if (createNew)
  {
     pConfigFile = new KSaveFile( filename, 0600 );

     if (pConfigFile->status() != 0)
     {
        delete pConfigFile;
        return bEntriesLeft;
     }

     if (!bGlobal && (fileMode == -1))
        fileMode = mFileMode;

     if (fileMode != -1)
     {
        fchmod(pConfigFile->handle(), fileMode);
     }

     pStream = pConfigFile->fstream();
  }
  else
  {


     int fd = open( QFile::encodeName(filename), 01 | 01000);
     if (fd < 0)
        return bEntriesLeft;
     pStream = fdopen( fd, "w");
     if (!pStream)
     {
        close(fd);
        return bEntriesLeft;
     }
  }

  writeEntries(pStream, aTempMap);

  if (pConfigFile)
  {
     pConfigFile->close();
     delete pConfigFile;
  }
  else
  {
     fclose(pStream);
  }

  return bEntriesLeft;
}

void KConfigINIBackEnd::writeEntries(FILE *pStream, const KEntryMap &aTempMap)
{
  bool firstEntry = true;


  ::writeEntries(pStream, aTempMap, true, firstEntry, localeString);


  ::writeEntries(pStream, aTempMap, false, firstEntry, localeString);
}

void KConfigBackEnd::virtual_hook( int, void* )
{ }

void KConfigINIBackEnd::virtual_hook( int id, void* data )
{ KConfigBackEnd::virtual_hook( id, data ); }

bool KConfigBackEnd::checkConfigFilesWritable(bool warnUser)
{

  bool allWritable = TRUE;
  QString errorMsg( ("Will not save configuration.\n") );
  if ( !mLocalFileName.isEmpty() && !bFileImmutable && !checkAccess(mLocalFileName,2) )
  {
    allWritable = FALSE;
    errorMsg = errorMsg + QString(("Configuration file \"%1\" not writable.\n")).arg(mLocalFileName);
  }


  if ( !mGlobalFileName.isEmpty() && useKDEGlobals && !bFileImmutable && !checkAccess(mGlobalFileName,2) )
  {
    errorMsg = errorMsg + QString(("Configuration file \"%1\" not writable.\n")).arg(mGlobalFileName);
    allWritable = FALSE;
  }

  if (warnUser && !allWritable)
  {

    errorMsg = errorMsg + QString(("Please contact your systems administrator.\n"));
    QString cmdToExec = KStandardDirs::findExe(QString("kdialog"));
    KApplication *app = KApplication::kApplication();
    if (!cmdToExec.isEmpty() && app)
    {
      KProcess lprocess;
      lprocess << cmdToExec << "--title" << app->instanceName() << "--msgbox" << errorMsg;
      lprocess.start( KProcess::Block );
    }
  }
  return allWritable;
}
# 12 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kmanagerselection.cpp" 1
# 28 "/coolo/prod/kdelibs/kdecore/kmanagerselection.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 29 "/coolo/prod/kdelibs/kdecore/kmanagerselection.cpp" 2
# 46 "/coolo/prod/kdelibs/kdecore/kmanagerselection.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kmanagerselection.h" 1
# 28 "/coolo/prod/kdelibs/kdecore/kmanagerselection.h"






class KSelectionOwnerPrivate;


class KSelectionOwner
    : public QObject
    {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    public:
        KSelectionOwner( Atom selection, int screen_P = -1 );
        KSelectionOwner( const char* selection, int screen_P = -1 );
        virtual ~KSelectionOwner();
        bool claim( bool force, bool force_kill = true );
        void release();
        void filterEvent( XEvent* ev_P );
    protected:
        void lostOwnership();
    protected:
        virtual bool genericReply( Atom target, Atom property, Window requestor );
        virtual void replyTargets( Atom property, Window requestor );
        virtual void getAtoms();
        void setData( long extra1, long extra2 );
    private:
        void filter_selection_request( XSelectionRequestEvent& ev_P );
        bool handle_selection( Atom target_P, Atom property_P, Window requestor_P );
        const Atom selection;
        const int screen;
        Window window;
        Time timestamp;
        long extra1, extra2;
        static Atom manager_atom;
        static Atom xa_multiple;
        static Atom xa_targets;
        static Atom xa_timestamp;
    protected:
        virtual void virtual_hook( int id, void* data );
    private:
        KSelectionOwnerPrivate* d;
    };

class KSelectionWatcherPrivate;


class KSelectionWatcher
    : public QObject
    {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    public:
        KSelectionWatcher( Atom selection_P, int screen_P = -1 );
        KSelectionWatcher( const char* selection_P, int screen_P = -1 );
        virtual ~KSelectionWatcher();
        Window owner();
        void filterEvent( XEvent* ev_P );
    protected:
        void newOwner( Window owner );
        void lostOwner();
    private:
        void init();
        const Atom selection;
        const int screen;
        Window selection_owner;
        static Atom manager_atom;
    protected:
        virtual void virtual_hook( int id, void* data );
    private:
        KSelectionWatcherPrivate* d;
    };
# 47 "/coolo/prod/kdelibs/kdecore/kmanagerselection.cpp" 2




# 1 "/coolo/prod/kdelibs/kdecore/kxerrorhandler.h" 1
# 26 "/coolo/prod/kdelibs/kdecore/kxerrorhandler.h"
# 56 "/coolo/prod/kdelibs/kdecore/kxerrorhandler.h"
class KXErrorHandler
    {
    public:




        KXErrorHandler( Display* dpy = qt_xdisplay());





        KXErrorHandler( bool (*handler)( int request, int error_code, unsigned long resource_id ), Display* dpy = qt_xdisplay());






        KXErrorHandler( int (*handler)( Display*, XErrorEvent* ), Display* dpy = qt_xdisplay());
# 85 "/coolo/prod/kdelibs/kdecore/kxerrorhandler.h"
        bool error( bool sync ) const;
        ~KXErrorHandler();
    private:
        void addHandler();
        int handle( Display* dpy, XErrorEvent* e );
        bool (*user_handler1)( int request, int error_code, unsigned long resource_id );
        int (*user_handler2)( Display*, XErrorEvent* );
        int (*old_handler)( Display*, XErrorEvent* );
        unsigned long first_request;
        Display* display;
        bool was_error;
        static int handler_wrapper( Display*, XErrorEvent* );
        static KXErrorHandler** handlers;
        static int pos;
        static int size;
        class KXErrorHandlerPrivate* d;
    };
# 52 "/coolo/prod/kdelibs/kdecore/kmanagerselection.cpp" 2


class KSelectionOwnerPrivate
    : public QWidget
    {
    public:
        KSelectionOwnerPrivate( KSelectionOwner* owner );
    protected:
        virtual bool x11Event( XEvent* ev );
    private:
        KSelectionOwner* owner;
    };

KSelectionOwnerPrivate::KSelectionOwnerPrivate( KSelectionOwner* owner_P )
    : owner( owner_P )
    {
    KApplication::kApplication()->installX11EventFilter( this );
    }

bool KSelectionOwnerPrivate::x11Event( XEvent* ev_P )
    {
    owner->filterEvent( ev_P );
    return false;
    }

KSelectionOwner::KSelectionOwner( Atom selection_P, int screen_P )
    : selection( selection_P ),
        screen( screen_P >= 0 ? screen_P : (((_XPrivDisplay)qt_xdisplay())->default_screen)),
        window( None ),
        timestamp( 0L ),
        extra1( 0 ), extra2( 0 ),
        d( new KSelectionOwnerPrivate( this ))
    {
    }

KSelectionOwner::KSelectionOwner( const char* selection_P, int screen_P )
    : selection( XInternAtom( qt_xdisplay(), selection_P, 0 )),
        screen( screen_P >= 0 ? screen_P : (((_XPrivDisplay)qt_xdisplay())->default_screen)),
        window( None ),
        timestamp( 0L ),
        extra1( 0 ), extra2( 0 ),
        d( new KSelectionOwnerPrivate( this ))
    {
    }

KSelectionOwner::~KSelectionOwner()
    {
    release();
    delete d;
    }

bool KSelectionOwner::claim( bool force_P, bool force_kill_P )
    {
    if( manager_atom == None )
        getAtoms();
    if( timestamp != 0L )
        release();
    Display* const dpy = qt_xdisplay();
    Window prev_owner = XGetSelectionOwner( dpy, selection );
    if( prev_owner != None )
        {
        if( !force_P )
            {

            return false;
            }
        XSelectInput( dpy, prev_owner, (1L<<17) );
        }
    XSetWindowAttributes attrs;
    attrs.override_redirect = 1;
    window = XCreateWindow( dpy, ((&((_XPrivDisplay)dpy)->screens[screen])->root), 0, 0, 1, 1,
        0, 0L, 2, 0L, (1L<<9), &attrs );

    Atom tmp = ((Atom) 4);
    XSelectInput( dpy, window, (1L<<22) );
    XChangeProperty( dpy, window, ((Atom) 4), ((Atom) 4), 32, 0,
        reinterpret_cast< unsigned char* >( &tmp ), 1 );
    XEvent ev;
    XSync( dpy, 0 );
    XCheckTypedWindowEvent( dpy, window, 28, &ev );
    timestamp = ev.xproperty.time;
    XSelectInput( dpy, window, (1L<<17) );
    XSetSelectionOwner( dpy, selection, window, timestamp );
    Window new_owner = XGetSelectionOwner( dpy, selection );
    if( new_owner != window )
        {

        XDestroyWindow( dpy, window );
        timestamp = 0L;
        return false;
        }
    if( prev_owner != None )
        {

        for( int cnt = 0;
             ;
             ++cnt )
            {
            if( XCheckTypedWindowEvent( dpy, prev_owner, 17, &ev ) == 1 )
                break;
            struct timeval tm = { 0, 50000 };
            select( 0, __null, __null, __null, &tm );
            if( cnt == 19 )
                {
                if( force_kill_P )
                    {

                    XKillClient( dpy, prev_owner );
                    }
                break;
                }
            }
        }
    ev.type = 33;
    ev.xclient.window = ((&((_XPrivDisplay)dpy)->screens[screen])->root);
    ev.xclient.display = dpy;
    ev.xclient.message_type = manager_atom;
    ev.xclient.format = 32;
    ev.xclient.data.l[ 0 ] = timestamp;
    ev.xclient.data.l[ 1 ] = selection;
    ev.xclient.data.l[ 2 ] = window;
    ev.xclient.data.l[ 3 ] = extra1;
    ev.xclient.data.l[ 4 ] = extra2;
    XSendEvent( dpy, ((&((_XPrivDisplay)dpy)->screens[screen])->root), 0, (1L<<17), &ev );

    return true;
    }


void KSelectionOwner::release()
    {
    if( timestamp == 0L )
        return;
    XDestroyWindow( qt_xdisplay(), window );

    timestamp = 0L;
    }

void KSelectionOwner::setData( long extra1_P, long extra2_P )
    {
    extra1 = extra1_P;
    extra2 = extra2_P;
    }

void KSelectionOwner::filterEvent( XEvent* ev_P )
    {
    switch( ev_P->type )
        {
        case 29:
            {
            if( timestamp == 0L || ev_P->xselectionclear.selection != selection )
                return;
            timestamp = 0L;

            lostOwnership();
            XSelectInput( qt_xdisplay(), window, 0 );
            XDestroyWindow( qt_xdisplay(), window );
          return;
            }
        case 17:
            {
            if( timestamp == 0L || ev_P->xdestroywindow.window != window )
                return;
            timestamp = 0L;

            lostOwnership();
          return;
            }
        case 31:
            {
            if( timestamp == 0L || ev_P->xselection.selection != selection )
                return;

          return;
            }
        case 30:
            filter_selection_request( ev_P->xselectionrequest );
          return;
        }
    }

void KSelectionOwner::filter_selection_request( XSelectionRequestEvent& ev_P )
    {
    if( timestamp == 0L || ev_P.selection != selection )
        return;
    if( ev_P.time != 0L
        && ev_P.time - timestamp > 1U << 31 )
        return;

    bool handled = false;
    if( ev_P.target == xa_multiple )
        {
        if( ev_P.property != None )
            {
            const int MAX_ATOMS = 100;
            int format;
            Atom type;
            unsigned long items;
            unsigned long after;
            unsigned char* data;
            if( XGetWindowProperty( qt_xdisplay(), ev_P.requestor, ev_P.property, 0,
                MAX_ATOMS, 0, 0L, &type, &format, &items, &after,
                &data ) == Success && format == 32 && items % 2 == 0 )
                {
                bool handled_array[ MAX_ATOMS ];
                Atom* atoms = reinterpret_cast< Atom* >( data );
                for( unsigned int i = 0;
                     i < items / 2;
                     ++i )
                    handled_array[ i ] = handle_selection(
                        atoms[ i * 2 ], atoms[ i * 2 + 1 ], ev_P.requestor );
                bool all_handled = true;
                for( unsigned int i = 0;
                     i < items / 2;
                     ++i )
                    if( !handled_array[ i ] )
                        {
                        all_handled = false;
                        atoms[ i * 2 + 1 ] = None;
                        }
                if( !all_handled )
                    XChangeProperty( qt_xdisplay(), ev_P.requestor, ev_P.property, ((Atom) 4),
                        32, 0, reinterpret_cast< unsigned char* >( atoms ), items );
                handled = true;
                XFree( data );
                }
            }
        }
    else
        {
        if( ev_P.property == None )
            ev_P.property = ev_P.target;
        handled = handle_selection( ev_P.target, ev_P.property, ev_P.requestor );
        }
    XEvent ev;
    ev.xselection.type = 31;
    ev.xselection.display = qt_xdisplay();
    ev.xselection.requestor = ev_P.requestor;
    ev.xselection.target = ev_P.target;
    ev.xselection.property = handled ? ev_P.property : None;
    XSendEvent( qt_xdisplay(), ev_P.requestor, 0, 0, &ev );
    }

bool KSelectionOwner::handle_selection( Atom target_P, Atom property_P, Window requestor_P )
    {
    if( target_P == xa_timestamp )
        {

        XChangeProperty( qt_xdisplay(), requestor_P, property_P, ((Atom) 19), 32,
            0, reinterpret_cast< unsigned char* >( &timestamp ), 1 );
        }
    else if( target_P == xa_targets )
        replyTargets( property_P, requestor_P );
    else if( genericReply( target_P, property_P, requestor_P ))
        ;
    else
        return false;
    return true;
    }

void KSelectionOwner::replyTargets( Atom property_P, Window requestor_P )
    {
    Atom atoms[ 3 ] = { xa_multiple, xa_timestamp, xa_targets };

    XChangeProperty( qt_xdisplay(), requestor_P, property_P, ((Atom) 4), 32, 0,
        reinterpret_cast< unsigned char* >( atoms ), 3 );
    }

bool KSelectionOwner::genericReply( Atom, Atom, Window )
    {
    return false;
    }

void KSelectionOwner::getAtoms()
    {
    if( manager_atom == None )
        {
        Atom atoms[ 4 ];
        const char* const names[] =
            { "MANAGER", "MULTIPLE", "TARGETS", "TIMESTAMP" };
        XInternAtoms( qt_xdisplay(), const_cast< char** >( names ), 4, 0, atoms );
        manager_atom = atoms[ 0 ];
        xa_multiple = atoms[ 1];
        xa_targets = atoms[ 2 ];
        xa_timestamp = atoms[ 3 ];
        }
    }

Atom KSelectionOwner::manager_atom = None;
Atom KSelectionOwner::xa_multiple = None;
Atom KSelectionOwner::xa_targets = None;
Atom KSelectionOwner::xa_timestamp = None;






class KSelectionWatcherPrivate
    : public QWidget
    {
    public:
        KSelectionWatcherPrivate( KSelectionWatcher* watcher );
    protected:
        virtual bool x11Event( XEvent* ev );
    private:
        KSelectionWatcher* watcher;
    };

KSelectionWatcherPrivate::KSelectionWatcherPrivate( KSelectionWatcher* watcher_P )
    : watcher( watcher_P )
    {
    KApplication::kApplication()->installX11EventFilter( this );
    }

bool KSelectionWatcherPrivate::x11Event( XEvent* ev_P )
    {
    watcher->filterEvent( ev_P );
    return false;
    }


KSelectionWatcher::KSelectionWatcher( Atom selection_P, int screen_P )
    : selection( selection_P ),
        screen( screen_P >= 0 ? screen_P : (((_XPrivDisplay)qt_xdisplay())->default_screen)),
        selection_owner( None ),
        d( new KSelectionWatcherPrivate( this ))
    {
    init();
    }

KSelectionWatcher::KSelectionWatcher( const char* selection_P, int screen_P )
    : selection( XInternAtom( qt_xdisplay(), selection_P, 0 )),
        screen( screen_P >= 0 ? screen_P : (((_XPrivDisplay)qt_xdisplay())->default_screen)),
        selection_owner( None ),
        d( new KSelectionWatcherPrivate( this ))
    {
    init();
    }

KSelectionWatcher::~KSelectionWatcher()
    {
    delete d;
    }

void KSelectionWatcher::init()
    {
    if( manager_atom == None )
        {
        Display* const dpy = qt_xdisplay();
        manager_atom = XInternAtom( dpy, "MANAGER", 0 );
        XWindowAttributes attrs;
        XGetWindowAttributes( dpy, ((&((_XPrivDisplay)dpy)->screens[screen])->root), &attrs );
        long event_mask = attrs.your_event_mask;

        XSelectInput( dpy, ((&((_XPrivDisplay)dpy)->screens[screen])->root), event_mask | (1L<<17) );
        }
    }

Window KSelectionWatcher::owner()
    {
    Display* const dpy = qt_xdisplay();
    KXErrorHandler handler;
    Window current_owner = XGetSelectionOwner( dpy, selection );
    if( current_owner == None )
        return None;
    if( current_owner == selection_owner )
        return selection_owner;
    XSelectInput( dpy, current_owner, (1L<<17) );
    if( !handler.error( true ) && current_owner == XGetSelectionOwner( dpy, selection ))
        {

        selection_owner = current_owner;
        }
    else
        selection_owner = None;
    return selection_owner;
    }


void KSelectionWatcher::filterEvent( XEvent* ev_P )
    {
    if( ev_P->type == 33 )
        {

        if( ev_P->xclient.message_type != manager_atom
            || ev_P->xclient.data.l[ 1 ] != static_cast< long >( selection ))
            return;

        if( ev_P->xclient.data.l[ 2 ] == static_cast< long >( selection_owner ))
            {

            return;
            }
        if( static_cast< long >( owner()) == ev_P->xclient.data.l[ 2 ] )
            {

            newOwner( selection_owner );
            }
        return;
        }
    if( ev_P->type == 17 )
        {
        if( selection_owner == None || ev_P->xdestroywindow.window != selection_owner )
            return;
        if( owner() == None )
            lostOwner();
        else
            newOwner( selection_owner );
        return;
        }
    return;
    }

Atom KSelectionWatcher::manager_atom = None;

void KSelectionOwner::virtual_hook( int, void* )
{ }

void KSelectionWatcher::virtual_hook( int, void* )
{ }

# 1 "../kdecore/kmanagerselection.moc" 1
# 11 "../kdecore/kmanagerselection.moc"
# 1 "../../../prod/kdelibs/kdecore/kmanagerselection.h" 1
# 12 "../kdecore/kmanagerselection.moc" 2
# 22 "../kdecore/kmanagerselection.moc"
const char *KSelectionOwner::className() const
{
    return "KSelectionOwner";
}

QMetaObject *KSelectionOwner::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KSelectionOwner( "KSelectionOwner", &KSelectionOwner::staticMetaObject );
# 50 "../kdecore/kmanagerselection.moc"
QMetaObject* KSelectionOwner::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod signal_0 = {"lostOwnership", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "lostOwnership()", &signal_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KSelectionOwner", parentObject,
        0, 0,
        signal_tbl, 1,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KSelectionOwner.setMetaObject( metaObj );
    return metaObj;
}

void* KSelectionOwner::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KSelectionOwner" ) )
        return this;
    return QObject::qt_cast( clname );
}


void KSelectionOwner::lostOwnership()
{
    activate_signal( staticMetaObject()->signalOffset() + 0 );
}

bool KSelectionOwner::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KSelectionOwner::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: lostOwnership(); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KSelectionOwner::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KSelectionOwner::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }



const char *KSelectionWatcher::className() const
{
    return "KSelectionWatcher";
}

QMetaObject *KSelectionWatcher::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KSelectionWatcher( "KSelectionWatcher", &KSelectionWatcher::staticMetaObject );
# 138 "../kdecore/kmanagerselection.moc"
QMetaObject* KSelectionWatcher::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_signal_0[] = {
        { "owner", &static_QUType_ptr, "Window", QUParameter::In }
    };
    static const QUMethod signal_0 = {"newOwner", 1, param_signal_0 };
    static const QUMethod signal_1 = {"lostOwner", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "newOwner(Window)", &signal_0, QMetaData::Public },
        { "lostOwner()", &signal_1, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KSelectionWatcher", parentObject,
        0, 0,
        signal_tbl, 2,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KSelectionWatcher.setMetaObject( metaObj );
    return metaObj;
}

void* KSelectionWatcher::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KSelectionWatcher" ) )
        return this;
    return QObject::qt_cast( clname );
}





void KSelectionWatcher::newOwner( Window t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 0 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,&t0);
    activate_signal( clist, o );
}


void KSelectionWatcher::lostOwner()
{
    activate_signal( staticMetaObject()->signalOffset() + 1 );
}

bool KSelectionWatcher::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KSelectionWatcher::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: newOwner((Window)(*((Window*)static_QUType_ptr.get(_o+1)))); break;
    case 1: lostOwner(); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KSelectionWatcher::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KSelectionWatcher::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 475 "/coolo/prod/kdelibs/kdecore/kmanagerselection.cpp" 2
# 13 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kdesktopfile.cpp" 1
# 34 "/coolo/prod/kdelibs/kdecore/kdesktopfile.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kmountpoint.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kmountpoint.h"
# 35 "/coolo/prod/kdelibs/kdecore/kmountpoint.h"
class KMountPoint : public KShared
{
   typedef signed long long int filesize_t;
public:
  typedef KSharedPtr<KMountPoint> Ptr;
  typedef QValueList<Ptr> List;
public:
   enum { NeedMountOptions = 1, NeedRealDeviceName = 2 };






   static KMountPoint::List possibleMountPoints(int infoNeeded=0);






   static KMountPoint::List currentMountPoints(int infoNeeded=0);





   QString mountedFrom() const { return m_mountedFrom; }






   QString realDeviceName() const { return m_device; }




   QString mountPoint() const { return m_mountPoint; }




   QString mountType() const { return m_mountType; }





   QStringList mountOptions() const { return m_mountOptions; }




   ~KMountPoint();

private:



   KMountPoint();

   QString m_mountedFrom;
   QString m_device;
   QString m_mountPoint;
   QString m_mountType;
   QStringList m_mountOptions;

   class KMountPointPrivate;
   KMountPointPrivate *d;
};
# 35 "/coolo/prod/kdelibs/kdecore/kdesktopfile.cpp" 2

# 1 "/coolo/prod/kdelibs/kdecore/kdesktopfile.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kdesktopfile.h"




class KDesktopFilePrivate;
# 37 "/coolo/prod/kdelibs/kdecore/kdesktopfile.h"
class KDesktopFile : public KConfig
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
# 54 "/coolo/prod/kdelibs/kdecore/kdesktopfile.h"
  KDesktopFile( const QString &fileName, bool readOnly = false,
                const char * resType = "apps");






  virtual ~KDesktopFile();
# 73 "/coolo/prod/kdelibs/kdecore/kdesktopfile.h"
  static bool isDesktopFile(const QString& path);
# 84 "/coolo/prod/kdelibs/kdecore/kdesktopfile.h"
  static bool isAuthorizedDesktopFile(const QString& path);






  static QString locateLocal(const QString &path);





  QString readType() const;





  QString readIcon() const;





  QString readName() const;





  QString readComment() const;





  QString readGenericName() const;






  QString readPath() const __attribute__ ((deprecated));





  QString readDevice() const;





  QString readURL() const;





  QStringList readActions() const;





  void setActionGroup(const QString &group);






  bool hasActionGroup(const QString &group) const;







  bool hasLinkType() const;





  bool hasApplicationType() const;





  bool hasMimeTypeType() const;





  bool hasDeviceType() const;






  bool tryExec() const;





  QString fileName() const;





  QString resource() const;






  QString readDocPath() const;





  QStringList sortOrder() const;
# 226 "/coolo/prod/kdelibs/kdecore/kdesktopfile.h"
    __attribute__ ((deprecated)) QString filename() const { return fileName(); };

private:


  KDesktopFile( const KDesktopFile& );
  KDesktopFile& operator= ( const KDesktopFile& );

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KDesktopFilePrivate *d;
};
# 37 "/coolo/prod/kdelibs/kdecore/kdesktopfile.cpp" 2
# 1 "../kdecore/kdesktopfile.moc" 1
# 11 "../kdecore/kdesktopfile.moc"
# 1 "../../../prod/kdelibs/kdecore/kdesktopfile.h" 1
# 12 "../kdecore/kdesktopfile.moc" 2
# 22 "../kdecore/kdesktopfile.moc"
const char *KDesktopFile::className() const
{
    return "KDesktopFile";
}

QMetaObject *KDesktopFile::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KDesktopFile( "KDesktopFile", &KDesktopFile::staticMetaObject );
# 50 "../kdecore/kdesktopfile.moc"
QMetaObject* KDesktopFile::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KConfig::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KDesktopFile", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KDesktopFile.setMetaObject( metaObj );
    return metaObj;
}

void* KDesktopFile::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KDesktopFile" ) )
        return this;
    return KConfig::qt_cast( clname );
}

bool KDesktopFile::qt_invoke( int _id, QUObject* _o )
{
    return KConfig::qt_invoke(_id,_o);
}

bool KDesktopFile::qt_emit( int _id, QUObject* _o )
{
    return KConfig::qt_emit(_id,_o);
}


bool KDesktopFile::qt_property( int id, int f, QVariant* v)
{
    return KConfig::qt_property( id, f, v);
}

bool KDesktopFile::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 38 "/coolo/prod/kdelibs/kdecore/kdesktopfile.cpp" 2

KDesktopFile::KDesktopFile(const QString &fileName, bool bReadOnly,
                           const char * resType)
  : KConfig(QString::fromLatin1(""), bReadOnly, false)
{



  backEnd->changeFileName(fileName, resType, false);
  setReadOnly(bReadOnly);
  reparseConfiguration();
  setDesktopGroup();
}

KDesktopFile::~KDesktopFile()
{

}

QString KDesktopFile::locateLocal(const QString &path)
{
  QString local;
  if (path.endsWith(".directory"))
  {
    if (!path.startsWith("/"))
    {
      local = ::locateLocal("apps", path);
    }
    else
    {


      local = KGlobal::dirs()->relativeLocation("xdgdata-dirs", path);
      if (local.startsWith("/"))
      {

        local = path.mid(path.findRev('/')+1);
      }
      local = ::locateLocal("xdgdata-dirs", local);
    }
  }
  else
  {
    if (!path.startsWith("/"))
    {
      local = ::locateLocal("apps", path);
    }
    else
    {


      local = KGlobal::dirs()->relativeLocation("xdgdata-apps", path);
      if (local.startsWith("/"))
      {

        local = path.mid(path.findRev('/')+1);
      }
      local = ::locateLocal("xdgdata-apps", local);
    }
  }
  return local;
}

bool KDesktopFile::isDesktopFile(const QString& path)
{
  int len = path.length();

  if(len > 8 && path.right(8) == QString::fromLatin1(".desktop"))
    return true;
  else if(len > 7 && path.right(7) == QString::fromLatin1(".kdelnk"))
    return true;
  else
    return false;
}

bool KDesktopFile::isAuthorizedDesktopFile(const QString& path)
{
  if (!KApplication::kApplication() || KApplication::kApplication()->authorize("run_desktop_files"))
     return true;

  if (path.isEmpty())
     return false;

  if (path[0] != '/')
     return true;

  KStandardDirs *dirs = KGlobal::dirs();
  if (dirs->relativeLocation("apps", path)[0] != '/')
     return true;
  if (dirs->relativeLocation("xdgdata-apps", path)[0] != '/')
     return true;
  if (dirs->relativeLocation("services", path)[0] != '/')
     return true;
  if (dirs->relativeLocation("data", path).startsWith("kdesktop/Desktop"))
     return true;
  return false;
}

QString KDesktopFile::readType() const
{
  return readEntry("Type");
}

QString KDesktopFile::readIcon() const
{
  return readEntry("Icon");
}

QString KDesktopFile::readName() const
{
  return readEntry("Name");
}

QString KDesktopFile::readComment() const
{
  return readEntry("Comment");
}

QString KDesktopFile::readGenericName() const
{
  return readEntry("GenericName");
}

QString KDesktopFile::readPath() const
{
  return readPathEntry("Path");
}

QString KDesktopFile::readDevice() const
{
  return readEntry("Dev");
}

QString KDesktopFile::readURL() const
{
    if (hasDeviceType()) {
        QString device = readDevice();
        KMountPoint::List mountPoints = KMountPoint::possibleMountPoints();

        for(KMountPoint::List::ConstIterator it = mountPoints.begin();
            it != mountPoints.end(); ++it)
        {
            KMountPoint *mp = *it;
            if (mp->mountedFrom() == device)
            {
                KURL u;
                u.setPath( mp->mountPoint() );
                return u.url();
            }
        }
        return QString::null;
    } else {
        QString url = readPathEntry("URL");
        if ( !url.isEmpty() && url[0] == '/' )
        {

            KURL u;
            u.setPath( url );
            return u.url();
        }
        return url;
    }
}

QStringList KDesktopFile::readActions() const
{
    return readListEntry("Actions", ';');
}

void KDesktopFile::setActionGroup(const QString &group)
{
    setGroup(QString::fromLatin1("Desktop Action ") + group);
}

bool KDesktopFile::hasActionGroup(const QString &group) const
{
  return hasGroup(QString::fromLatin1("Desktop Action ") + group);
}

bool KDesktopFile::hasLinkType() const
{
  return readEntry("Type") == QString::fromLatin1("Link");
}

bool KDesktopFile::hasApplicationType() const
{
  return readEntry("Type") == QString::fromLatin1("Application");
}

bool KDesktopFile::hasMimeTypeType() const
{
  return readEntry("Type") == QString::fromLatin1("MimeType");
}

bool KDesktopFile::hasDeviceType() const
{
  return readEntry("Type") == QString::fromLatin1("FSDev") ||
         readEntry("Type") == QString::fromLatin1("FSDevice");
}

bool KDesktopFile::tryExec() const
{

  QString te = readPathEntry("TryExec");

  if (!te.isEmpty()) {
    if (te[0] == '/') {
      if (::access(QFile::encodeName(te), 4 | 1))
        return false;
    } else {



      QStringList dirs = QStringList::split(':', QFile::decodeName(::getenv("PATH")));
      QStringList::Iterator it(dirs.begin());
      bool match = false;
      for (; it != dirs.end(); ++it) {
        QString fName = *it + "/" + te;
        if (::access(QFile::encodeName(fName), 4 | 1) == 0)
        {
          match = true;
          break;
        }
      }

      if (!match)
        return false;
    }
  }
  QStringList list = readListEntry("X-KDE-AuthorizeAction");
  if (KApplication::kApplication() && !list.isEmpty())
  {
     for(QStringList::ConstIterator it = list.begin();
         it != list.end();
         ++it)
     {
        if (!KApplication::kApplication()->authorize((*it).stripWhiteSpace()))
           return false;
     }
  }


  bool su = readBoolEntry("X-KDE-SubstituteUID");
  if (su)
  {
      QString user = readEntry("X-KDE-Username");
      if (user.isEmpty())
        user = ::getenv("ADMIN_ACCOUNT");
      if (user.isEmpty())
        user = "root";
      if (!KApplication::kApplication()->authorize("user/"+user))
        return false;
  }

  return true;
}




QString
KDesktopFile::fileName() const { return backEnd->fileName(); }




QString
KDesktopFile::resource() const { return backEnd->resource(); }

QStringList
KDesktopFile::sortOrder() const
{
  return readListEntry("SortOrder");
}

void KDesktopFile::virtual_hook( int id, void* data )
{ KConfig::virtual_hook( id, data ); }

QString KDesktopFile::readDocPath() const
{
        return readPathEntry( "DocPath" );
}
# 14 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp" 1
# 27 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 28 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp" 2


# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 31 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp" 2
# 1 "/usr/include/errno.h" 1 3 4
# 32 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp" 2




# 1 "/usr/include/dirent.h" 1 3 4
# 24 "/usr/include/dirent.h" 3 4



extern "C" {
# 62 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/bits/dirent.h" 1 3 4
# 23 "/usr/include/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };




# 63 "/usr/include/dirent.h" 2 3 4
# 86 "/usr/include/dirent.h" 3 4

# 98 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
  };







typedef struct __dirstream DIR;



extern DIR *opendir (__const char *__name) throw ();



extern int closedir (DIR *__dirp) throw ();
# 146 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) throw ();
# 156 "/usr/include/dirent.h" 3 4
extern struct dirent64 *readdir64 (DIR *__dirp) throw ();






extern int readdir_r (DIR *__restrict __dirp,
                      struct dirent *__restrict __entry,
                      struct dirent **__restrict __result) throw ();
# 179 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
                        struct dirent64 *__restrict __entry,
                        struct dirent64 **__restrict __result) throw ();




extern void rewinddir (DIR *__dirp) throw ();





extern void seekdir (DIR *__dirp, long int __pos) throw ();


extern long int telldir (DIR *__dirp) throw ();





extern int dirfd (DIR *__dirp) throw ();
# 213 "/usr/include/dirent.h" 3 4





# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 414 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
# 221 "/usr/include/dirent.h" 2 3 4






extern int scandir (__const char *__restrict __dir,
                    struct dirent ***__restrict __namelist,
                    int (*__selector) (__const struct dirent *),
                    int (*__cmp) (__const void *, __const void *)) throw ();
# 247 "/usr/include/dirent.h" 3 4
extern int scandir64 (__const char *__restrict __dir,
                      struct dirent64 ***__restrict __namelist,
                      int (*__selector) (__const struct dirent64 *),
                      int (*__cmp) (__const void *, __const void *)) throw ();




extern int alphasort (__const void *__e1, __const void *__e2)
     throw () __attribute__ ((__pure__));
# 269 "/usr/include/dirent.h" 3 4
extern int alphasort64 (__const void *__e1, __const void *__e2)
     throw () __attribute__ ((__pure__));





extern int versionsort (__const void *__e1, __const void *__e2)
     throw () __attribute__ ((__pure__));
# 290 "/usr/include/dirent.h" 3 4
extern int versionsort64 (__const void *__e1, __const void *__e2)
     throw () __attribute__ ((__pure__));
# 300 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
                                size_t __nbytes,
                                __off_t *__restrict __basep) throw ();
# 316 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
                                  size_t __nbytes,
                                  __off64_t *__restrict __basep) throw ();




}
# 37 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp" 2
# 1 "/usr/include/pwd.h" 1 3 4
# 24 "/usr/include/pwd.h" 3 4



extern "C" {



# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 414 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
# 34 "/usr/include/pwd.h" 2 3 4
# 50 "/usr/include/pwd.h" 3 4
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};









extern void setpwent (void) throw ();


extern void endpwent (void) throw ();


extern struct passwd *getpwent (void) throw ();




extern struct passwd *fgetpwent (FILE *__stream) throw ();


extern int putpwent (__const struct passwd *__restrict __p,
                     FILE *__restrict __f) throw ();



extern struct passwd *getpwuid (__uid_t __uid) throw ();


extern struct passwd *getpwnam (__const char *__name) throw ();






# 111 "/usr/include/pwd.h" 3 4
extern int getpwent_r (struct passwd *__restrict __resultbuf,
                       char *__restrict __buffer, size_t __buflen,
                       struct passwd **__restrict __result) throw ();


extern int getpwuid_r (__uid_t __uid,
                       struct passwd *__restrict __resultbuf,
                       char *__restrict __buffer, size_t __buflen,
                       struct passwd **__restrict __result) throw ();

extern int getpwnam_r (__const char *__restrict __name,
                       struct passwd *__restrict __resultbuf,
                       char *__restrict __buffer, size_t __buflen,
                       struct passwd **__restrict __result) throw ();





extern int fgetpwent_r (FILE *__restrict __stream,
                        struct passwd *__restrict __resultbuf,
                        char *__restrict __buffer, size_t __buflen,
                        struct passwd **__restrict __result) throw ();
# 142 "/usr/include/pwd.h" 3 4
extern int getpw (__uid_t __uid, char *__buffer) throw ();


}
# 38 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp" 2
# 52 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp"
# 1 "/usr/include/sys/param.h" 1 3 4
# 20 "/usr/include/sys/param.h" 3 4

# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 1 3 4
# 23 "/usr/include/sys/param.h" 2 3 4

# 1 "/usr/include/linux/param.h" 1 3 4


# 1 "/usr/include/asm/param.h" 1 3 4












# 5 "/usr/include/linux/param.h" 2 3 4
# 25 "/usr/include/sys/param.h" 2 3 4























# 53 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp" 2


template class QDict<QStringList>;

class KStandardDirs::KStandardDirsPrivate
{
public:
   KStandardDirsPrivate()
    : restrictionsActive(false),
      dataRestrictionActive(false)
   { }

   bool restrictionsActive;
   bool dataRestrictionActive;
   QAsciiDict<bool> restrictions;
   QStringList xdgdata_prefixes;
   QStringList xdgconf_prefixes;
};

static const char* const types[] = {"html", "icon", "apps", "sound",
                              "data", "locale", "services", "mime",
                              "servicetypes", "config", "exe",
                              "wallpaper", "lib", "pixmap", "templates",
                              "module", "qtplugins",
                              "xdgdata-apps", "xdgdata-dirs", "xdgconf-menu", 0 };

static int tokenize( QStringList& token, const QString& str,
                const QString& delim );

KStandardDirs::KStandardDirs( ) : addedCustoms(false)
{
    d = new KStandardDirsPrivate;
    dircache.setAutoDelete(true);
    relatives.setAutoDelete(true);
    absolutes.setAutoDelete(true);
    savelocations.setAutoDelete(true);
    addKDEDefaults();
}

KStandardDirs::~KStandardDirs()
{
    delete d;
}

bool KStandardDirs::isRestrictedResource(const char *type, const QString& relPath) const
{
   if (!d || !d->restrictionsActive)
      return false;

   if (d->restrictions[type])
      return true;

   if (strcmp(type, "data")==0)
   {
      applyDataRestrictions(relPath);
      if (d->dataRestrictionActive)
      {
         d->dataRestrictionActive = false;
         return true;
      }
   }
   return false;
}

void KStandardDirs::applyDataRestrictions(const QString &relPath) const
{
   QString key;
   int i = relPath.find('/');
   if (i != -1)
      key = "data_"+relPath.left(i);
   else
      key = "data_"+relPath;

   if (d && d->restrictions[key.latin1()])
      d->dataRestrictionActive = true;
}


QStringList KStandardDirs::allTypes() const
{
    QStringList list;
    for (int i = 0; types[i] != 0; ++i)
        list.append(QString::fromLatin1(types[i]));
    return list;
}

void KStandardDirs::addPrefix( const QString& _dir )
{
    if (_dir.isNull())
        return;

    QString dir = _dir;
    if (dir.at(dir.length() - 1) != '/')
        dir += '/';

    if (!prefixes.contains(dir)) {
        prefixes.append(dir);
        dircache.clear();
    }
}

void KStandardDirs::addXdgConfigPrefix( const QString& _dir )
{
    if (_dir.isNull())
        return;

    QString dir = _dir;
    if (dir.at(dir.length() - 1) != '/')
        dir += '/';

    if (!d->xdgconf_prefixes.contains(dir)) {
        d->xdgconf_prefixes.append(dir);
        dircache.clear();
    }
}

void KStandardDirs::addXdgDataPrefix( const QString& _dir )
{
    if (_dir.isNull())
        return;

    QString dir = _dir;
    if (dir.at(dir.length() - 1) != '/')
        dir += '/';

    if (!d->xdgdata_prefixes.contains(dir)) {
        d->xdgdata_prefixes.append(dir);
        dircache.clear();
    }
}


QString KStandardDirs::kfsstnd_prefixes()
{
   return prefixes.join(":");
}

bool KStandardDirs::addResourceType( const char *type,
                                     const QString& relativename )
{
    if (relativename.isNull())
       return false;

    QStringList *rels = relatives.find(type);
    if (!rels) {
        rels = new QStringList();
        relatives.insert(type, rels);
    }
    QString copy = relativename;
    if (copy.at(copy.length() - 1) != '/')
        copy += '/';
    if (!rels->contains(copy)) {
        rels->prepend(copy);
        dircache.remove(type);
        return true;
    }
    return false;
}

bool KStandardDirs::addResourceDir( const char *type,
                                    const QString& absdir)
{
    QStringList *paths = absolutes.find(type);
    if (!paths) {
        paths = new QStringList();
        absolutes.insert(type, paths);
    }
    QString copy = absdir;
    if (copy.at(copy.length() - 1) != '/')
      copy += '/';

    if (!paths->contains(copy)) {
        paths->append(copy);
        dircache.remove(type);
        return true;
    }
    return false;
}

QString KStandardDirs::findResource( const char *type,
                                     const QString& filename ) const
{
    if (filename.at(0) == '/')
        return filename;
# 248 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp"
    QString dir = findResourceDir(type, filename);
    if (dir.isNull())
        return dir;
    else return dir + filename;
}

static Q_UINT32 updateHash(const QString &file, Q_UINT32 hash)
{
    QCString cFile = QFile::encodeName(file);
    struct stat buff;
    if ((access(cFile, 4) == 0) &&
        (stat( cFile, &buff ) == 0) &&
        (((((buff.st_mode)) & 0170000) == (0100000))))
    {
       hash = hash + (Q_UINT32) buff.st_ctim.tv_sec;
    }
    return hash;
}

Q_UINT32 KStandardDirs::calcResourceHash( const char *type,
                              const QString& filename, bool deep) const
{
    Q_UINT32 hash = 0;

    if (filename.at(0) == '/')
    {

        return updateHash(filename, hash);
    }
    if (d && d->restrictionsActive && (strcmp(type, "data")==0))
       applyDataRestrictions(filename);
    QStringList candidates = resourceDirs(type);
    QString fullPath;

    for (QStringList::ConstIterator it = candidates.begin();
         it != candidates.end(); it++)
    {
        hash = updateHash(*it + filename, hash);
        if (!deep && hash)
           return hash;
    }
    return hash;
}


QStringList KStandardDirs::findDirs( const char *type,
                                     const QString& reldir ) const
{
    QStringList list;

    checkConfig();

    if (d && d->restrictionsActive && (strcmp(type, "data")==0))
       applyDataRestrictions(reldir);
    QStringList candidates = resourceDirs(type);
    QDir testdir;

    for (QStringList::ConstIterator it = candidates.begin();
         it != candidates.end(); it++) {
        testdir.setPath(*it + reldir);
        if (testdir.exists())
            list.append(testdir.absPath() + '/');
    }

    return list;
}

QString KStandardDirs::findResourceDir( const char *type,
                                        const QString& filename) const
{

    if (filename.isEmpty()) {
      kdWarning() << "filename for type " << type << " in KStandardDirs::findResourceDir is not supposed to be empty!!" << endl;
      return QString::null;
    }


    if (d && d->restrictionsActive && (strcmp(type, "data")==0))
       applyDataRestrictions(filename);
    QStringList candidates = resourceDirs(type);
    QString fullPath;

    for (QStringList::ConstIterator it = candidates.begin();
         it != candidates.end(); it++)
      if (exists(*it + filename))
        return *it;


    if(false && type != "locale")
      kdDebug() << "KStdDirs::findResDir(): can't find \"" << filename << "\" in type \"" << type << "\"." << endl;


    return QString::null;
}

bool KStandardDirs::exists(const QString &fullPath)
{
    struct stat buff;
    if (access(QFile::encodeName(fullPath), 4) == 0 && stat( QFile::encodeName(fullPath), &buff ) == 0)
        if (fullPath.at(fullPath.length() - 1) != '/') {
            if (((((buff.st_mode)) & 0170000) == (0100000)))
                return true;
        } else
            if (((((buff.st_mode)) & 0170000) == (0040000)))
                return true;
    return false;
}

static void lookupDirectory(const QString& path, const QString &relPart,
                            const QRegExp &regexp,
                            QStringList& list,
                            QStringList& relList,
                            bool recursive, bool uniq)
{
  QString pattern = regexp.pattern();
  if (recursive || pattern.contains('?') || pattern.contains('*'))
  {

    DIR *dp = opendir( QFile::encodeName(path));
    if (!dp)
      return;

    (static_cast<void> ((path.at(path.length() - 1) == '/') ? 0 : (__assert_fail ("path.at(path.length() - 1) == '/'", "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp", 370, __PRETTY_FUNCTION__), 0)));

    struct dirent *ep;
    struct stat buff;

    QString _dot(".");
    QString _dotdot("..");

    while( ( ep = readdir( dp ) ) != 0L )
    {
      QString fn( QFile::decodeName(ep->d_name));
      if (fn == _dot || fn == _dotdot || fn.at(fn.length() - 1).latin1() == '~')
        continue;

      if (!recursive && !regexp.exactMatch(fn))
        continue;

      QString pathfn = path + fn;
      if ( stat( QFile::encodeName(pathfn), &buff ) != 0 ) {
        kdDebug() << "Error stat'ing " << pathfn << " : " << perror << endl;
        continue;
      }
      if ( recursive ) {
        if ( ((((buff.st_mode)) & 0170000) == (0040000))) {
          lookupDirectory(pathfn + '/', relPart + fn + '/', regexp, list, relList, recursive, uniq);
        }
        if (!regexp.exactMatch(fn))
          continue;
      }
      if ( ((((buff.st_mode)) & 0170000) == (0100000)))
      {
        if (!uniq || !relList.contains(relPart + fn))
        {
            list.append( pathfn );
            relList.append( relPart + fn );
        }
      }
    }
    closedir( dp );
  }
  else
  {

     QString fn = pattern;
     QString pathfn = path + fn;
     struct stat buff;
     if ( stat( QFile::encodeName(pathfn), &buff ) != 0 )
        return;
     if ( ((((buff.st_mode)) & 0170000) == (0100000)))
     {
       if (!uniq || !relList.contains(relPart + fn))
       {
         list.append( pathfn );
         relList.append( relPart + fn );
       }
     }
  }
}

static void lookupPrefix(const QString& prefix, const QString& relpath,
                         const QString& relPart,
                         const QRegExp &regexp,
                         QStringList& list,
                         QStringList& relList,
                         bool recursive, bool uniq)
{
    if (relpath.isNull()) {
       lookupDirectory(prefix, relPart, regexp, list,
                       relList, recursive, uniq);
       return;
    }
    QString path;
    QString rest;

    if (relpath.length())
    {
       int slash = relpath.find('/');
       if (slash < 0)
           rest = relpath.left(relpath.length() - 1);
       else {
           path = relpath.left(slash);
           rest = relpath.mid(slash + 1);
       }
    }

    (static_cast<void> ((prefix.at(prefix.length() - 1) == '/') ? 0 : (__assert_fail ("prefix.at(prefix.length() - 1) == '/'", "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp", 455, __PRETTY_FUNCTION__), 0)));

    struct stat buff;

    if (path.contains('*') || path.contains('?')) {

        QRegExp pathExp(path, true, true);
        DIR *dp = opendir( QFile::encodeName(prefix) );
        if (!dp) {
            return;
        }

        struct dirent *ep;

        QString _dot(".");
        QString _dotdot("..");

        while( ( ep = readdir( dp ) ) != 0L )
            {
                QString fn( QFile::decodeName(ep->d_name));
                if (fn == _dot || fn == _dotdot || fn.at(fn.length() - 1) == '~')
                    continue;

                if (pathExp.search(fn) == -1)
                    continue;
                QString rfn = relPart+fn;
                fn = prefix + fn;
                if ( stat( QFile::encodeName(fn), &buff ) != 0 ) {
                    kdDebug() << "Error statting " << fn << " : " << perror << endl;
                    continue;
                }
                if ( ((((buff.st_mode)) & 0170000) == (0040000)))
                    lookupPrefix(fn + '/', rest, rfn + '/', regexp, list, relList, recursive, uniq);
            }

        closedir( dp );
    } else {


        lookupPrefix(prefix + path + '/', rest,
                     relPart + path + '/', regexp, list,
                     relList, recursive, uniq);
    }
}

QStringList
KStandardDirs::findAllResources( const char *type,
                                 const QString& filter,
                                 bool recursive,
                                 bool uniq,
                                 QStringList &relList) const
{
    QStringList list;
    if (filter.at(0) == '/')
    {
        list.append( filter);
        return list;
    }

    QString filterPath;
    QString filterFile;

    if (filter.length())
    {
       int slash = filter.findRev('/');
       if (slash < 0)
           filterFile = filter;
       else {
           filterPath = filter.left(slash + 1);
           filterFile = filter.mid(slash + 1);
       }
    }

    checkConfig();

    if (d && d->restrictionsActive && (strcmp(type, "data")==0))
       applyDataRestrictions(filter);
    QStringList candidates = resourceDirs(type);
    if (filterFile.isEmpty())
        filterFile = "*";

    QRegExp regExp(filterFile, true, true);

    for (QStringList::ConstIterator it = candidates.begin();
         it != candidates.end(); it++)
    {
        lookupPrefix(*it, filterPath, "", regExp, list,
                     relList, recursive, uniq);
    }

    return list;
}

QStringList
KStandardDirs::findAllResources( const char *type,
                                 const QString& filter,
                                 bool recursive,
                                 bool uniq) const
{
    QStringList relList;
    return findAllResources(type, filter, recursive, uniq, relList);
}

QString
KStandardDirs::realPath(const QString &dirname)
{
    char realpath_buffer[4096 + 1];
    memset(realpath_buffer, 0, 4096 + 1);


    if (realpath( QFile::encodeName(dirname).data(), realpath_buffer) != 0) {

        int len = strlen(realpath_buffer);
        realpath_buffer[len] = '/';
        realpath_buffer[len+1] = 0;
        return QFile::decodeName(realpath_buffer);
    }

    return dirname;
}

void KStandardDirs::createSpecialResource(const char *type)
{
   char hostname[256];
   hostname[0] = 0;
   gethostname(hostname, 255);
   QString dir = QString("%1%2-%3").arg(localkdedir()).arg(type).arg(hostname);
   char link[1024];
   link[1023] = 0;
   int result = readlink(QFile::encodeName(dir).data(), link, 1023);
   if ((result == -1) && ((*__errno_location ()) == 2))
   {
      QString srv = findExe(QString::fromLatin1("lnusertemp"), "/coolo/KDE"+QString::fromLatin1("/bin"));
      if (srv.isEmpty())
         srv = findExe(QString::fromLatin1("lnusertemp"));
      if (!srv.isEmpty())
      {
         system(QFile::encodeName(srv)+" "+type);
         result = readlink(QFile::encodeName(dir).data(), link, 1023);
      }
   }
   if (result > 0)
   {
      link[result] = 0;
      if (link[0] == '/')
         dir = QFile::decodeName(link);
      else
         dir = QDir::cleanDirPath(dir+QFile::decodeName(link));
   }
   addResourceDir(type, dir+'/');
}

QStringList KStandardDirs::resourceDirs(const char *type) const
{
    QStringList *candidates = dircache.find(type);

    if (!candidates) {
        if (strcmp(type, "socket") == 0)
           const_cast<KStandardDirs *>(this)->createSpecialResource(type);
        else if (strcmp(type, "tmp") == 0)
           const_cast<KStandardDirs *>(this)->createSpecialResource(type);
        else if (strcmp(type, "cache") == 0)
           const_cast<KStandardDirs *>(this)->createSpecialResource(type);

        QDir testdir;

        candidates = new QStringList();
        QStringList *dirs;

        bool restrictionActive = false;
        if (d && d->restrictionsActive)
        {
           if (d->dataRestrictionActive)
              restrictionActive = true;
           else if (d->restrictions["all"])
              restrictionActive = true;
           else if (d->restrictions[type])
              restrictionActive = true;
           d->dataRestrictionActive = false;
        }

        dirs = relatives.find(type);
        if (dirs)
        {
            bool local = true;
            const QStringList *prefixList = 0;
            if (strncmp(type, "xdgdata-", 8) == 0)
                prefixList = &(d->xdgdata_prefixes);
            else if (strncmp(type, "xdgconf-", 8) == 0)
                prefixList = &(d->xdgconf_prefixes);
            else
                prefixList = &prefixes;

            for (QStringList::ConstIterator pit = prefixList->begin();
                 pit != prefixList->end();
                 pit++)
            {
                for (QStringList::ConstIterator it = dirs->begin();
                     it != dirs->end(); ++it) {
                    QString path = realPath(*pit + *it);
                    testdir.setPath(path);
                    if (local && restrictionActive)
                       continue;
                    if ((local || testdir.exists()) && !candidates->contains(path))
                        candidates->append(path);
                }
                local = false;
            }
        }
        dirs = absolutes.find(type);
        if (dirs)
            for (QStringList::ConstIterator it = dirs->begin();
                 it != dirs->end(); ++it)
            {
                testdir.setPath(*it);
                if (testdir.exists())
                {
                    QString filename = realPath(*it);
                    if (!candidates->contains(filename))
                        candidates->append(filename);
                }
            }
        dircache.insert(type, candidates);
    }
# 691 "/coolo/prod/kdelibs/kdecore/kstandarddirs.cpp"
  return *candidates;
}

QString KStandardDirs::findExe( const QString& appname,
                                const QString& pstr, bool ignore)
{
    QFileInfo info;


    if (appname.startsWith(QString::fromLatin1("/")))
    {
        info.setFile( appname );
        if( info.exists() && ( ignore || info.isExecutable() )
            && info.isFile() ) {
            return appname;
        }
        return QString::null;
    }

    QString p = QString("%1/%2").arg("/coolo/KDE/bin").arg(appname);
    info.setFile( p );
    if( info.exists() && ( ignore || info.isExecutable() )
         && ( info.isFile() || info.isSymLink() ) ) {
         return p;
    }

    QStringList tokens;
    p = pstr;

    if( p.isNull() ) {
        p = getenv( "PATH" );
    }

    tokenize( tokens, p, ":\b" );


    for( unsigned i = 0; i < tokens.count(); i++ ) {
        p = tokens[ i ];

        if ( p[ 0 ] == '~' )
        {
            int len = p.find( '/' );
            if ( len == -1 )
                len = p.length();
            if ( len == 1 )
                p.replace( 0, 1, QDir::homeDirPath() );
            else
            {
                QString user = p.mid( 1, len - 1 );
                struct passwd *dir = getpwnam( user.local8Bit().data() );
                if ( dir && strlen( dir->pw_dir ) )
                    p.replace( 0, len, QString::fromLocal8Bit( dir->pw_dir ) );
            }
        }

        p += "/";
        p += appname;


        info.setFile( p );

        if( info.exists() && ( ignore || info.isExecutable() )
           && ( info.isFile() || info.isSymLink() ) ) {
            return p;
        }
    }




    return QString::null;
}

int KStandardDirs::findAllExe( QStringList& list, const QString& appname,
                        const QString& pstr, bool ignore )
{
    QString p = pstr;
    QFileInfo info;
    QStringList tokens;

    if( p.isNull() ) {
        p = getenv( "PATH" );
    }

    list.clear();
    tokenize( tokens, p, ":\b" );

    for ( unsigned i = 0; i < tokens.count(); i++ ) {
        p = tokens[ i ];
        p += "/";
        p += appname;

        info.setFile( p );

        if( info.exists() && (ignore || info.isExecutable())
            && info.isFile() ) {
            list.append( p );
        }

    }

    return list.count();
}

static int tokenize( QStringList& tokens, const QString& str,
                     const QString& delim )
{
    int len = str.length();
    QString token = "";

    for( int index = 0; index < len; index++)
    {
        if ( delim.find( str[ index ] ) >= 0 )
        {
            tokens.append( token );
            token = "";
        }
        else
        {
            token += str[ index ];
        }
    }
    if ( token.length() > 0 )
    {
        tokens.append( token );
    }

    return tokens.count();
}

QString KStandardDirs::kde_default(const char *type) {
    if (!strcmp(type, "data"))
        return "share/apps/";
    if (!strcmp(type, "html"))
        return "share/doc/HTML/";
    if (!strcmp(type, "icon"))
        return "share/icons/";
    if (!strcmp(type, "config"))
        return "share/config/";
    if (!strcmp(type, "pixmap"))
        return "share/pixmaps/";
    if (!strcmp(type, "apps"))
        return "share/applnk/";
    if (!strcmp(type, "sound"))
        return "share/sounds/";
    if (!strcmp(type, "locale"))
        return "share/locale/";
    if (!strcmp(type, "services"))
        return "share/services/";
    if (!strcmp(type, "servicetypes"))
        return "share/servicetypes/";
    if (!strcmp(type, "mime"))
        return "share/mimelnk/";
    if (!strcmp(type, "cgi"))
        return "cgi-bin/";
    if (!strcmp(type, "wallpaper"))
        return "share/wallpapers/";
    if (!strcmp(type, "templates"))
        return "share/templates/";
    if (!strcmp(type, "exe"))
        return "bin/";
    if (!strcmp(type, "lib"))
        return "lib/";
    if (!strcmp(type, "module"))
        return "lib/kde3/";
    if (!strcmp(type, "qtplugins"))
        return "lib/kde3/plugins";
    if (!strcmp(type, "xdgdata-apps"))
        return "applications/";
    if (!strcmp(type, "xdgdata-dirs"))
        return "desktop-directories/";
    if (!strcmp(type, "xdgconf-menu"))
        return "menus/";
    qFatal("unknown resource type %s", type);
    return QString::null;
}

QString KStandardDirs::saveLocation(const char *type,
                                    const QString& suffix,
                                    bool create) const
{
    checkConfig();

    QString *pPath = savelocations.find(type);
    if (!pPath)
    {
       QStringList *dirs = relatives.find(type);
       if (!dirs && (
                     (strcmp(type, "socket") == 0) ||
                     (strcmp(type, "tmp") == 0) ||
                     (strcmp(type, "cache") == 0) ))
       {
          (void) resourceDirs(type);
          dirs = relatives.find(type);
       }
       if (dirs)
       {

          if (strncmp(type, "xdgdata-", 8) == 0)
             pPath = new QString(realPath(localxdgdatadir() + dirs->last()));
          else if (strncmp(type, "xdgconf-", 8) == 0)
             pPath = new QString(realPath(localxdgconfdir() + dirs->last()));
          else
             pPath = new QString(realPath(localkdedir() + dirs->last()));
       }
       else {
          dirs = absolutes.find(type);
          if (!dirs)
             qFatal("KStandardDirs: The resource type %s is not registered", type);
          pPath = new QString(realPath(dirs->last()));
       }

       savelocations.insert(type, pPath);
    }
    QString fullPath = *pPath + suffix;

    struct stat st;
    if (stat(QFile::encodeName(fullPath), &st) != 0 || !(((((st.st_mode)) & 0170000) == (0040000)))) {
        if(!create) {

            qDebug("save location %s doesn't exist", fullPath.latin1());

            return fullPath;
        }
        if(!makeDir(fullPath, 0700)) {
            qWarning("failed to create %s", fullPath.latin1());
            return fullPath;
        }
        dircache.remove(type);
    }
    return fullPath;
}

QString KStandardDirs::relativeLocation(const char *type, const QString &absPath)
{
    QString fullPath = absPath;
    int i = absPath.findRev('/');
    if (i != -1)
    {
       fullPath = realPath(absPath.left(i+1))+absPath.mid(i+1);
    }

    QStringList candidates = resourceDirs(type);

    for (QStringList::ConstIterator it = candidates.begin();
         it != candidates.end(); it++)
      if (fullPath.startsWith(*it))
      {
        return fullPath.mid((*it).length());
      }

    return absPath;
}


bool KStandardDirs::makeDir(const QString& dir, int mode)
{

    if (dir.at(0) != '/')
        return false;

    QString target = dir;
    uint len = target.length();


    if (dir.at(len - 1) != '/')
        target += '/';

    QString base("");
    uint i = 1;

    while( i < len )
    {
        struct stat st;
        int pos = target.find('/', i);
        base += target.mid(i - 1, pos - i + 1);
        QCString baseEncoded = QFile::encodeName(base);

        if (stat(baseEncoded, &st) != 0)
        {


          if (lstat(baseEncoded, &st) == 0)
              (void)unlink(baseEncoded);

          if ( mkdir(baseEncoded, (mode_t) mode) != 0) {
            perror("trying to create local folder");
            return false;
          }
        }
        i = pos + 1;
    }
    return true;
}

static QString readEnvPath(const char *env)
{
   QCString c_path = getenv(env);
   if (c_path.isEmpty())
      return QString::null;
   return QFile::decodeName(c_path);
}

void KStandardDirs::addKDEDefaults()
{
    QStringList kdedirList;


    QString kdedirs = readEnvPath("KDEDIRS");
    if (!kdedirs.isEmpty())
    {
        tokenize(kdedirList, kdedirs, ":");
    }
    else
    {
        QString kdedir = readEnvPath("KDEDIR");
        if (!kdedir.isEmpty())
        {
           kdedir = KShell::tildeExpand(kdedir);
           kdedirList.append(kdedir);
        }
    }
    kdedirList.append("/coolo/KDE");


    QString execPrefix("NONE");
    if (execPrefix!="NONE")
       kdedirList.append(execPrefix);


    QString localKdeDir;
    if (getuid())
    {
       localKdeDir = readEnvPath("KDEHOME");
       if (!localKdeDir.isEmpty())
       {
          if (localKdeDir[localKdeDir.length()-1] != '/')
             localKdeDir += '/';
       }
       else
       {
          localKdeDir = QDir::homeDirPath() + "/.kde/";
       }
    }
    else
    {


       localKdeDir = readEnvPath("KDEROOTHOME");
       if (!localKdeDir.isEmpty())
       {
          if (localKdeDir[localKdeDir.length()-1] != '/')
             localKdeDir += '/';
       }
       else
       {
          struct passwd *pw = getpwuid(0);
          localKdeDir = QFile::decodeName((pw && pw->pw_dir) ? pw->pw_dir : "/root") + "/.kde/";
       }

    }

    if (localKdeDir != "-/")
    {
        localKdeDir = KShell::tildeExpand(localKdeDir);
        addPrefix(localKdeDir);
    }

    for (QStringList::ConstIterator it = kdedirList.begin();
         it != kdedirList.end(); it++)
    {
        QString dir = KShell::tildeExpand(*it);
        addPrefix(dir);
    }



    QStringList xdgdirList;
    QString xdgdirs = readEnvPath("XDG_CONFIG_DIRS");
    if (!xdgdirs.isEmpty())
    {
        tokenize(xdgdirList, xdgdirs, ":");
    }
    else
    {
        xdgdirList.clear();
        xdgdirList.append("/etc/xdg");
    }

    QString localXdgDir = readEnvPath("XDG_CONFIG_HOME");
    if (!localXdgDir.isEmpty())
    {
       if (localXdgDir[localXdgDir.length()-1] != '/')
          localXdgDir += '/';
    }
    else
    {
       if (getuid())
       {
          localXdgDir = QDir::homeDirPath() + "/.config/";
       }
       else
       {
          struct passwd *pw = getpwuid(0);
          localXdgDir = QFile::decodeName((pw && pw->pw_dir) ? pw->pw_dir : "/root") + "/.config/";
       }
    }

    localXdgDir = KShell::tildeExpand(localXdgDir);
    addXdgConfigPrefix(localXdgDir);

    for (QStringList::ConstIterator it = xdgdirList.begin();
         it != xdgdirList.end(); it++)
    {
        QString dir = KShell::tildeExpand(*it);
        addXdgConfigPrefix(dir);
    }



    xdgdirs = readEnvPath("XDG_DATA_DIRS");
    if (!xdgdirs.isEmpty())
    {
        tokenize(xdgdirList, xdgdirs, ":");
    }
    else
    {
        xdgdirList.clear();
        for (QStringList::ConstIterator it = kdedirList.begin();
           it != kdedirList.end(); it++)
        {
           QString dir = *it;
           if (dir[dir.length()-1] != '/')
             dir += '/';
           xdgdirList.append(dir+"share/");
        }

        xdgdirList.append("/usr/local/share/");
        xdgdirList.append("/usr/share/");
    }

    localXdgDir = readEnvPath("XDG_DATA_HOME");
    if (!localXdgDir.isEmpty())
    {
       if (localXdgDir[localXdgDir.length()-1] != '/')
          localXdgDir += '/';
    }
    else
    {
       if (getuid())
       {
          localXdgDir = QDir::homeDirPath() + "/.local/share/";
       }
       else
       {
          struct passwd *pw = getpwuid(0);
          localXdgDir = QFile::decodeName((pw && pw->pw_dir) ? pw->pw_dir : "/root") + "/.local/share/";
       }
    }

    localXdgDir = KShell::tildeExpand(localXdgDir);
    addXdgDataPrefix(localXdgDir);

    for (QStringList::ConstIterator it = xdgdirList.begin();
         it != xdgdirList.end(); it++)
    {
        QString dir = KShell::tildeExpand(*it);
        addXdgDataPrefix(dir);
    }



    uint index = 0;
    while (types[index] != 0) {
        addResourceType(types[index], kde_default(types[index]));
        index++;
    }

    addResourceDir("home", QDir::homeDirPath());
}

void KStandardDirs::checkConfig() const
{
    if (!addedCustoms && KGlobal::_instance && KGlobal::_instance->_config)
        const_cast<KStandardDirs*>(this)->addCustomized(KGlobal::_instance->_config);
}

bool KStandardDirs::addCustomized(KConfig *config)
{
    if (addedCustoms)
        return false;



    uint configdirs = resourceDirs("config").count();


    QString oldGroup = config->group();
    config->setGroup("Directories");

    QStringList list;
    QStringList::ConstIterator it;
    list = config->readListEntry("prefixes");
    for (it = list.begin(); it != list.end(); it++)
        addPrefix(*it);



    QMap<QString, QString> entries = config->entryMap("Directories");

    QMap<QString, QString>::ConstIterator it2;
    for (it2 = entries.begin(); it2 != entries.end(); it2++)
    {
        QString key = it2.key();
        if (key.left(4) == "dir_") {

            QStringList dirs = QStringList::split(',',
                                                  *it2);
            QStringList::Iterator sIt(dirs.begin());
            QString resType = key.mid(4, key.length());
            for (; sIt != dirs.end(); ++sIt) {
                addResourceDir(resType.latin1(), *sIt);
            }
        }
    }


    config->setGroup("KDE Resource Restrictions");
    entries = config->entryMap("KDE Resource Restrictions");
    for (it2 = entries.begin(); it2 != entries.end(); it2++)
    {
        QString key = it2.key();
        if (!config->readBoolEntry(key, true))
        {
           d->restrictionsActive = true;
           d->restrictions.insert(key.latin1(), &d->restrictionsActive);
           dircache.remove(key.latin1());
        }
    }


    addedCustoms = true;
    config->setGroup(oldGroup);


    return (resourceDirs("config").count() != configdirs);
}

QString KStandardDirs::localkdedir() const
{

    return prefixes.first();
}

QString KStandardDirs::localxdgdatadir() const
{

    return d->xdgdata_prefixes.first();
}

QString KStandardDirs::localxdgconfdir() const
{

    return d->xdgconf_prefixes.first();
}


QString locate( const char *type,
                const QString& filename, const KInstance* inst )
{
    return inst->dirs()->findResource(type, filename);
}

QString locateLocal( const char *type,
                     const QString& filename, const KInstance* inst )
{
    return locateLocal(type, filename, true, inst);
}

QString locateLocal( const char *type,
                     const QString& filename, bool createDir, const KInstance* inst )
{


    int slash = filename.findRev('/')+1;
    if (!slash)
        return inst->dirs()->saveLocation(type, QString::null, createDir) + filename;


    QString dir = filename.left(slash);
    QString file = filename.mid(slash);
    return inst->dirs()->saveLocation(type, dir, createDir) + file;
}
# 15 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/ksock.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2




# 1 "/usr/include/sys/socket.h" 1 3 4
# 21 "/usr/include/sys/socket.h" 3 4



extern "C" {

# 1 "/usr/include/sys/uio.h" 1 3 4
# 20 "/usr/include/sys/uio.h" 3 4





extern "C" {


# 1 "/usr/include/bits/uio.h" 1 3 4
# 38 "/usr/include/bits/uio.h" 3 4



struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 30 "/usr/include/sys/uio.h" 2 3 4







extern ssize_t readv (int __fd, __const struct iovec *__vector, int __count)
     throw ();






extern ssize_t writev (int __fd, __const struct iovec *__vector, int __count)
     throw ();

}
# 28 "/usr/include/sys/socket.h" 2 3 4
# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 414 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
# 30 "/usr/include/sys/socket.h" 2 3 4
# 40 "/usr/include/sys/socket.h" 3 4
struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,
  SHUT_WR,
  SHUT_RDWR
};
# 66 "/usr/include/sys/socket.h" 3 4
# 100 "/usr/include/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) throw ();





extern int socketpair (int __domain, int __type, int __protocol,
                       int __fds[2]) throw ();


extern int bind (int __fd, __const struct sockaddr * __addr, socklen_t __len)
     throw ();


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
                        socklen_t *__restrict __len) throw ();





extern int connect (int __fd, __const struct sockaddr * __addr, socklen_t __len)
     throw ();



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
                        socklen_t *__restrict __len) throw ();



extern ssize_t send (int __fd, __const void *__buf, size_t __n, int __flags)
     throw ();



extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags)
     throw ();



extern ssize_t sendto (int __fd, __const void *__buf, size_t __n,
                       int __flags, __const struct sockaddr * __addr,
                       socklen_t __addr_len) throw ();





extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n, int __flags,
                         struct sockaddr *__restrict __addr, socklen_t *__restrict __addr_len)
     throw ();




extern ssize_t sendmsg (int __fd, __const struct msghdr *__message, int __flags)
     throw ();



extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags)
     throw ();





extern int getsockopt (int __fd, int __level, int __optname,
                       void *__restrict __optval,
                       socklen_t *__restrict __optlen) throw ();




extern int setsockopt (int __fd, int __level, int __optname,
                       __const void *__optval, socklen_t __optlen) throw ();





extern int listen (int __fd, int __n) throw ();






extern int accept (int __fd, struct sockaddr *__restrict __addr,
                   socklen_t *__restrict __addr_len)
     throw ();







extern int shutdown (int __fd, int __how) throw ();




extern int sockatmark (int __fd) throw ();







extern int isfdtype (int __fd, int __fdtype) throw ();


}
# 29 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2


# 1 "/usr/include/sys/un.h" 1 3 4
# 20 "/usr/include/sys/un.h" 3 4






extern "C" {


struct sockaddr_un
  {
    sa_family_t sun_family;
    char sun_path[108];
  };









}
# 32 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2



extern "C" {


# 1 "/usr/include/arpa/inet.h" 1 3 4
# 20 "/usr/include/arpa/inet.h" 3 4
# 31 "/usr/include/arpa/inet.h" 3 4
extern "C" {



extern in_addr_t inet_addr (__const char *__cp) throw ();


extern in_addr_t inet_lnaof (struct in_addr __in) throw ();



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     throw ();


extern in_addr_t inet_netof (struct in_addr __in) throw ();



extern in_addr_t inet_network (__const char *__cp) throw ();



extern char *inet_ntoa (struct in_addr __in) throw ();




extern int inet_pton (int __af, __const char *__restrict __cp,
                      void *__restrict __buf) throw ();




extern __const char *inet_ntop (int __af, __const void *__restrict __cp,
                                char *__restrict __buf, socklen_t __len)
     throw ();






extern in_addr_t inet_aton (__const char *__cp, struct in_addr *__inp) throw ();



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) throw ();




extern char *inet_net_ntop (int __af, __const void *__cp, int __bits,
                            char *__buf, size_t __len) throw ();




extern int inet_net_pton (int __af, __const char *__cp,
                          void *__buf, size_t __len) throw ();




extern unsigned int inet_nsap_addr (__const char *__cp,
                                    unsigned char *__buf, int __len) throw ();



extern char *inet_nsap_ntoa (int __len, __const unsigned char *__cp,
                             char *__buf) throw ();


}
# 39 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2
}


# 1 "/coolo/prod/kdelibs/kdecore/ksock.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/ksock.h"
# 40 "/coolo/prod/kdelibs/kdecore/ksock.h"
class QSocketNotifier;
# 50 "/coolo/prod/kdelibs/kdecore/ksock.h"
typedef sockaddr_in ksockaddr_in;



class KSocketPrivate;
class KServerSocketPrivate;
# 85 "/coolo/prod/kdelibs/kdecore/ksock.h"
class KSocket : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:




    KSocket( int _sock );






    KSocket( const char *_host, unsigned short int _port, int timeOut = 30);





    KSocket( const char * _path );




    virtual ~KSocket();





    int socket() const { return sock; }
# 127 "/coolo/prod/kdelibs/kdecore/ksock.h"
    void enableRead( bool enable );
# 140 "/coolo/prod/kdelibs/kdecore/ksock.h"
    void enableWrite( bool enable );
# 151 "/coolo/prod/kdelibs/kdecore/ksock.h"
    unsigned long ipv4_addr() __attribute__ ((deprecated));







    static bool initSockaddr(ksockaddr_in *server_name, const char *hostname, unsigned short int port, int domain = 2) __attribute__ ((deprecated));


protected:







    void readEvent( KSocket *s );
# 183 "/coolo/prod/kdelibs/kdecore/ksock.h"
    void writeEvent( KSocket *s );





    void closeEvent( KSocket *s );

public :







    void slotWrite( int x);
# 208 "/coolo/prod/kdelibs/kdecore/ksock.h"
    void slotRead( int x );

protected:
    bool connect( const QString& _host, unsigned short int _port, int timeout = 0 );
    bool connect( const char *_path );





    int sock;

private:
    KSocket(const KSocket&);
    KSocket& operator=(const KSocket&);

    KSocketPrivate *d;

};
# 246 "/coolo/prod/kdelibs/kdecore/ksock.h"
class KServerSocket : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:







    KServerSocket( unsigned short int _port, bool _bind = true );
# 266 "/coolo/prod/kdelibs/kdecore/ksock.h"
    KServerSocket( const char *_path, bool _bind = true);




    virtual ~KServerSocket();







    bool bindAndListen();






    int socket() const { return sock; }





    unsigned short int port();
# 302 "/coolo/prod/kdelibs/kdecore/ksock.h"
    unsigned long ipv4_addr();


public :



    virtual void slotAccept( int );

protected:
# 321 "/coolo/prod/kdelibs/kdecore/ksock.h"
    void accepted( KSocket*s );

protected:
    bool init( unsigned short int );
    bool init( const char *_path );





    int sock;

private:
    KServerSocket(const KServerSocket&);
    KServerSocket& operator=(const KServerSocket&);

    KServerSocketPrivate *d;
};
# 44 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kextsock.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kextsock.h"







# 1 "/coolo/prod/kdelibs/kdecore/kbufferedio.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"



# 1 "/coolo/prod/kdelibs/kdecore/kasyncio.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kasyncio.h"





class KAsyncIOPrivate;
# 40 "/coolo/prod/kdelibs/kdecore/kasyncio.h"
class KAsyncIO: public QObject, public QIODevice
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
protected:
  KAsyncIO()
  { }

private:
  KAsyncIO(KAsyncIO&);

  KAsyncIO& operator=(KAsyncIO&);

public:






  virtual void enableRead(bool enable) = 0;







  virtual void enableWrite(bool enable) = 0;

protected:




  void readyRead();




  void readyWrite();
protected:

  virtual void virtual_hook( int id, void* data );
private:
  KAsyncIOPrivate* d;
};
# 29 "/coolo/prod/kdelibs/kdecore/kbufferedio.h" 2

class KBufferedIOPrivate;
# 59 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
class KBufferedIO: public KAsyncIO
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

protected:

  KBufferedIO();

public:



  enum closeModes
  {
    availRead = 0x01,
    dirtyWrite = 0x02,
    involuntary = 0x10,
    delayed = 0x20,
    closedNow = 0x40
  };





  virtual ~KBufferedIO();
# 94 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual void closeNow() = 0;
# 117 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual bool setBufferSize(int rsize, int wsize = -2);





  virtual int bytesAvailable() const;







  virtual int waitForMore(int msec) = 0;





  virtual int bytesToWrite() const;
# 147 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual bool canReadLine() const;
# 168 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual int peekBlock(char *data, uint maxlen) = 0;
# 182 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual int unreadBlock(const char *data, uint len);

protected:




  void bytesWritten(int nbytes);
# 208 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  void closed(int state);

protected:




  QPtrList<QByteArray> inBuf;





  QPtrList<QByteArray> outBuf;

  unsigned inBufIndex, outBufIndex;
# 235 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual unsigned consumeReadBuffer(unsigned nbytes, char *destbuffer, bool discard = true);
# 248 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual void consumeWriteBuffer(unsigned nbytes);
# 261 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual unsigned feedReadBuffer(unsigned nbytes, const char *buffer, bool atBeginning = false);
# 271 "/coolo/prod/kdelibs/kdecore/kbufferedio.h"
  virtual unsigned feedWriteBuffer(unsigned nbytes, const char *buffer);





  virtual unsigned readBufferSize() const;





  virtual unsigned writeBufferSize() const;

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KBufferedIOPrivate *d;
};
# 30 "/coolo/prod/kdelibs/kdecore/kextsock.h" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksockaddr.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
# 32 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
typedef unsigned ksocklen_t;

struct sockaddr;

class KExtendedSocket;

class KSocketAddressPrivate;
# 48 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
class KSocketAddress: public QObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
protected:



  KSocketAddress() { init(); }






  KSocketAddress(const sockaddr* sa, ksocklen_t size);

public:



  virtual ~KSocketAddress();





  virtual QString pretty() const;





  const sockaddr* address() const
  { return data; }





  virtual ksocklen_t size() const
  { return datasize; }






  operator const sockaddr*() const
  { return data; }





  int family() const;






  inline int ianaFamily() const
  { return ianaFamily(family()); }






  virtual bool isEqual(const KSocketAddress& other) const;
  bool isEqual(const KSocketAddress* other) const
  { return isEqual(*other); }





  bool operator==(const KSocketAddress& other) const
  { return isEqual(other); }
# 138 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  bool isCoreEqual(const KSocketAddress& other) const;
# 150 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  bool isCoreEqual(const KSocketAddress* other) const
  { return isCoreEqual(*other); }
# 160 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  virtual QString nodeName() const;
# 169 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  virtual QString serviceName() const;

protected:
  sockaddr* data;
  ksocklen_t datasize;
  bool owndata;

private:
  void init();

  KSocketAddress(KSocketAddress&);
  KSocketAddress& operator=(KSocketAddress&);

public:







  static KSocketAddress* newAddress(const struct sockaddr *sa, ksocklen_t size);
# 199 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  static int ianaFamily(int af);





  static int fromIanaFamily(int iana);

  friend class KExtendedSocket;
protected:
  virtual void virtual_hook( int id, void* data );
private:
  KSocketAddressPrivate* d;
};





struct sockaddr_in;
struct sockaddr_in6;
struct in_addr;
struct in6_addr;

class KInetSocketAddressPrivate;
# 236 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
class KInetSocketAddress: public KSocketAddress
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:



  KInetSocketAddress();




  KInetSocketAddress(const KInetSocketAddress&);






  KInetSocketAddress(const sockaddr_in* sin, ksocklen_t len);






  KInetSocketAddress(const sockaddr_in6* sin6, ksocklen_t len);






  KInetSocketAddress(const in_addr& addr, unsigned short port);






  KInetSocketAddress(const in6_addr& addr, unsigned short port);
# 287 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  KInetSocketAddress(const QString& addr, unsigned short port, int family = -1);




  virtual ~KInetSocketAddress();






  bool setAddress(const KInetSocketAddress& ksa);







  bool setAddress(const sockaddr_in* sin, ksocklen_t len);
# 317 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  bool setAddress(const sockaddr_in6* sin6, ksocklen_t len);







  bool setAddress(const in_addr& addr, unsigned short port);







  bool setAddress(const in6_addr& addr, unsigned short port);
# 352 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  bool setAddress(const QString& addr, unsigned short port, int family = -1);






  bool setHost(const in_addr& addr);






  bool setHost(const in6_addr& addr);







  bool setHost(const QString& addr, int family = -1);






  bool setPort(unsigned short port);
# 390 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  bool setFamily(int family);






  bool setFlowinfo(Q_UINT32 flowinfo);






  bool setScopeId(int scopeid);





  virtual QString pretty() const;





  virtual QString nodeName() const;






  virtual QString serviceName() const;
# 434 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  const sockaddr_in* addressV4() const;





  const sockaddr_in6* addressV6() const;






  in_addr hostV4() const;







  in6_addr hostV6() const;





  unsigned short port() const;





  Q_UINT32 flowinfo() const;





  int scopeId() const;






  virtual ksocklen_t size() const;
# 494 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  static bool areEqualInet(const KSocketAddress &s1, const KSocketAddress &s2, bool coreOnly);
# 507 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  static bool areEqualInet6(const KSocketAddress &s1, const KSocketAddress &s2, bool coreOnly);
# 517 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  operator const sockaddr_in*() const
  { return addressV4(); }






  operator const sockaddr_in6*() const
  { return addressV6(); }




  KInetSocketAddress& operator=(const KInetSocketAddress &other)
  { setAddress(other); return *this; }

private:

  void fromV4();
  void fromV6();

public:







  static QString addrToString(int family, const void *addr);
# 558 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  static bool stringToAddr(int family, const char *text, void *dest);

  friend class KExtendedSocket;
protected:
  virtual void virtual_hook( int id, void* data );
private:
  KInetSocketAddressPrivate* d;
};

extern const KInetSocketAddress addressAny, addressLoopback;




struct sockaddr_un;

class KUnixSocketAddressPrivate;
# 588 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
class KUnixSocketAddress: public KSocketAddress
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:



  KUnixSocketAddress();






  KUnixSocketAddress(const sockaddr_un* raw_data, ksocklen_t size);





  KUnixSocketAddress(QCString pathname);




  virtual ~KUnixSocketAddress();







  bool setAddress(const sockaddr_un* socket_address, ksocklen_t size);






  bool setAddress(QCString path);






  QCString pathname() const;





  virtual QString pretty() const;







  virtual QString serviceName() const;





  const sockaddr_un* address() const;






  operator const sockaddr_un*() const
  { return address(); }
# 675 "/coolo/prod/kdelibs/kdecore/ksockaddr.h"
  static bool areEqualUnix(const KSocketAddress &s1, const KSocketAddress &s2, bool coreOnly);

private:
  void init();

  friend class KExtendedSocket;
protected:
  virtual void virtual_hook( int id, void* data );
private:
  KUnixSocketAddressPrivate* d;
};
# 31 "/coolo/prod/kdelibs/kdecore/kextsock.h" 2


struct addrinfo;
struct kde_addrinfo;
class KAddressInfo;
class QSocketNotifier;
# 45 "/coolo/prod/kdelibs/kdecore/kextsock.h"

class KExtendedSocketPrivate;
# 83 "/coolo/prod/kdelibs/kdecore/kextsock.h"
class KExtendedSocket: public KBufferedIO
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:



  enum Flags
  {





    anySocket = 0x00,
    knownSocket = 0x01,
    unixSocket = knownSocket | 0x02,
    inetSocket = knownSocket | 0x04,
    ipv4Socket = inetSocket | 0x100,
    ipv6Socket = inetSocket | 0x200,

    passiveSocket = 0x1000,
    canonName = 0x2000,
    noResolve = 0x4000,

    streamSocket = 0x8000,
    datagramSocket = 0x10000,
    rawSocket = 0x20000,

    inputBufferedSocket = 0x200000,
    outputBufferedSocket = 0x400000,
    bufferedSocket = 0x600000
  };






  enum SockStatus
  {

    error = -1,

    nothing = 0,

    lookupInProgress = 50,
    lookupDone = 70,


    created = 100,
    bound = 140,

    connecting = 200,
    connected = 220,

    listening = 200,
    accepting = 220,

    closing = 350,

    done = 400
  };

public:



  KExtendedSocket();







  KExtendedSocket(const QString& host, int port, int flags = 0);







  KExtendedSocket(const QString& host, const QString& service, int flags = 0);





  virtual ~KExtendedSocket();






  void reset();
# 192 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  int socketStatus() const;







  int systemError() const;






  int setSocketFlags(int flags);






  int socketFlags() const;






  bool setHost(const QString& host);





  QString host() const;





  bool setPort(int port);






  bool setPort(const QString& port);





  QString port() const;







  bool setAddress(const QString& host, int port);







  bool setAddress(const QString& host, const QString& serv);






  bool setBindHost(const QString& host);





  bool unsetBindHost();





  QString bindHost() const;






  bool setBindPort(int port);






  bool setBindPort(const QString& service);





  bool unsetBindPort();





  QString bindPort() const;
# 316 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  bool setBindAddress(const QString& host, int port);
# 325 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  bool setBindAddress(const QString& host, const QString& service);






  bool unsetBindAddress();
# 345 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  bool setTimeout(int secs, int usecs = 0);





  timeval timeout() const;
# 361 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  bool setBlockingMode(bool enable);





  bool blockingMode();
# 378 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  bool setAddressReusable(bool enable);





  bool addressReusable();
# 404 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  bool setIPv6Only(bool enable);







  bool isIPv6Only();
# 431 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual bool setBufferSize(int rsize, int wsize = -2);






  const KSocketAddress *localAddress();







  const KSocketAddress *peerAddress();





  inline int fd() const
  { return sockfd; }
# 466 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int lookup();
# 486 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int startAsyncLookup();




  virtual void cancelAsyncLookup();
# 500 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int listen(int N = 5);
# 516 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int accept(KExtendedSocket *&sock);
# 541 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int connect();
# 557 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int startAsyncConnect();




  virtual void cancelAsyncConnect();
# 574 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual bool open(int mode = 0x0040 | 0x0003);
# 583 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual void close();






  virtual void closeNow();
# 605 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual void release();
# 626 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual void flush();





  virtual inline Q_ULONG size() const
  { return 0; }





  virtual inline Q_ULONG at() const
  { return 0; }






  virtual inline bool at(int i)
  { (void)i;;return true; }






  virtual inline bool atEnd() const
  { return false; }
# 687 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual Q_LONG readBlock(char *data, Q_ULONG maxlen);
# 712 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual Q_LONG writeBlock(const char *data, Q_ULONG len);
# 728 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int peekBlock(char *data, uint maxlen);







  virtual int unreadBlock(const char *data, uint len);
# 747 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int bytesAvailable() const;
# 758 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual int waitForMore(int msec);





  virtual int getch();






  virtual int putch(int ch);





  virtual int ungetch(int)
  { return -1; }
# 790 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual void enableRead(bool enable);
# 801 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  virtual void enableWrite(bool enable);

protected:





  void lookupFinished(int count);




  void connectionSuccess();






  void connectionFailed(int error);






  void readyAccept();

protected:
  int sockfd;

protected :

  void socketActivityRead();
  void socketActivityWrite();
  void dnsResultsReady();
  void startAsyncConnectSlot();
  void connectionEvent();

protected:

  QSocketNotifier *readNotifier();
  QSocketNotifier *writeNotifier();

private:


  KExtendedSocket(KExtendedSocket&);
  KExtendedSocket& operator=(KExtendedSocket&);





  static int doLookup(const QString& host, const QString& serv, addrinfo& hint,
                      kde_addrinfo** result);

protected:



  void setError(int errorkind, int error);

  inline void cleanError()
  { setError(0, 0); }




  void setSocketStatus(int status);

public:
# 886 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  static int resolve(sockaddr* sock, ksocklen_t len, QString& host, QString& port, int flags = 0);
# 900 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  static int resolve(KSocketAddress* sock, QString& host, QString& port, int flags = 0);
# 920 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  static QPtrList<KAddressInfo> lookup(const QString& host, const QString& port, int flags = 0, int *error = 0);







  static KSocketAddress *localAddress(int fd);
# 937 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  static KSocketAddress *peerAddress(int fd);







  static QString strError(int code, int syserr);
# 956 "/coolo/prod/kdelibs/kdecore/kextsock.h"
  static bool setAddressReusable(int fd, bool enable);

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KExtendedSocketPrivate *d;

  friend class KSocket;
  friend class KServerSocket;
};





class KAddressInfo
{
private:
  addrinfo *ai;
  KSocketAddress *addr;

  inline KAddressInfo() : ai(0), addr(0)
  { }

  KAddressInfo(addrinfo *ai);
  KAddressInfo(KAddressInfo&) { }
  KAddressInfo& operator=(KAddressInfo&) { return *this; }

public:
  ~KAddressInfo();





  inline operator const KSocketAddress*() const
  { return addr; }




  inline operator const addrinfo&() const
  { return *ai; }





  inline operator const addrinfo*() const
  { return ai; }






  inline const KSocketAddress* address() const
  { return addr; }





  int flags() const;





  int family() const;





  int socktype() const;





  int protocol() const;







  const char* canonname() const;





  inline int length() const
  { if (addr) return addr->size(); return 0; }

  friend class KExtendedSocket;
};
# 45 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/ksocks.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/ksocks.h"







class KSocksTable;
class KSocksPrivate;
class KLibrary;
class KConfigBase;
struct sockaddr;
# 44 "/coolo/prod/kdelibs/kdecore/ksocks.h"
class KSocks {
   friend class KStaticDeleter<KSocks>;

public:






   static KSocks *self();





   static bool activated();




   void disableSocks();




   void enableSocks();





   bool usingSocks();





   bool hasSocks();





   bool hasWorkingAsyncConnect();
# 97 "/coolo/prod/kdelibs/kdecore/ksocks.h"
    int connect (int sockfd, const sockaddr *serv_addr,
                                ksocklen_t addrlen);




    signed long int read (int fd, void *buf, unsigned long int count);




    signed long int write (int fd, const void *buf, unsigned long int count);




    int recvfrom (int s, void *buf, unsigned long int len, int flags,
                                sockaddr *from, ksocklen_t *fromlen);




    int sendto (int s, const void *msg, unsigned long int len, int flags,
                             const sockaddr *to, ksocklen_t tolen);




    int recv (int s, void *buf, unsigned long int len, int flags);




    int send (int s, const void *msg, unsigned long int len, int flags);




    int getsockname (int s, sockaddr *name, ksocklen_t *namelen);




    int getpeername (int s, sockaddr *name, ksocklen_t *namelen);




    int accept (int s, sockaddr *addr, ksocklen_t *addrlen);




    int select (int n, fd_set *readfds, fd_set *writefds,
                                fd_set *exceptfds, struct timeval *timeout);




    int listen (int s, int backlog);





    int bind (int sockfd, sockaddr *my_addr,
                                     ksocklen_t addrlen);
    int bind (int sockfd, const sockaddr *my_addr,
                                     ksocklen_t addrlen);






   void die();





   static void disable();





   static void setConfig(KConfigBase *config);

private:
   KSocks(KConfigBase *config);
   ~KSocks();

   void stopSocks();

   static KSocks *_me;
   static bool _disabled;
   QStringList _libNames;
   QStringList _libPaths;
   bool _useSocks, _hasSocks;
   KLibrary* _socksLib;


   KSocksTable *_st;
   KSocksPrivate *d;
};
# 48 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2

extern "C" {
# 1 "/usr/include/errno.h" 1 3 4
# 51 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2







# 1 "/usr/include/arpa/nameser.h" 1 3 4
# 52 "/usr/include/arpa/nameser.h" 3 4




# 1 "/usr/include/sys/bitypes.h" 1 3 4
# 59 "/usr/include/arpa/nameser.h" 2 3 4
# 72 "/usr/include/arpa/nameser.h" 3 4









typedef enum __ns_sect {
        ns_s_qd = 0,
        ns_s_zn = 0,
        ns_s_an = 1,
        ns_s_pr = 1,
        ns_s_ns = 2,
        ns_s_ud = 2,
        ns_s_ar = 3,
        ns_s_max = 4
} ns_sect;






typedef struct __ns_msg {
        const u_char *_msg, *_eom;
        u_int16_t _id, _flags, _counts[ns_s_max];
        const u_char *_sections[ns_s_max];
        ns_sect _sect;
        int _rrnum;
        const u_char *_ptr;
} ns_msg;


struct _ns_flagdata { int mask, shift; };
extern struct _ns_flagdata _ns_flagdata[];









typedef struct __ns_rr {
        char name[1025];
        u_int16_t type;
        u_int16_t rr_class;
        u_int32_t ttl;
        u_int16_t rdlength;
        const u_char * rdata;
} ns_rr;








typedef enum __ns_flag {
        ns_f_qr,
        ns_f_opcode,
        ns_f_aa,
        ns_f_tc,
        ns_f_rd,
        ns_f_ra,
        ns_f_z,
        ns_f_ad,
        ns_f_cd,
        ns_f_rcode,
        ns_f_max
} ns_flag;




typedef enum __ns_opcode {
        ns_o_query = 0,
        ns_o_iquery = 1,
        ns_o_status = 2,

        ns_o_notify = 4,
        ns_o_update = 5,
        ns_o_max = 6
} ns_opcode;




typedef enum __ns_rcode {
        ns_r_noerror = 0,
        ns_r_formerr = 1,
        ns_r_servfail = 2,
        ns_r_nxdomain = 3,
        ns_r_notimpl = 4,
        ns_r_refused = 5,

        ns_r_yxdomain = 6,
        ns_r_yxrrset = 7,
        ns_r_nxrrset = 8,
        ns_r_notauth = 9,
        ns_r_notzone = 10,
        ns_r_max = 11,

        ns_r_badsig = 16,
        ns_r_badkey = 17,
        ns_r_badtime = 18
} ns_rcode;


typedef enum __ns_update_operation {
        ns_uop_delete = 0,
        ns_uop_add = 1,
        ns_uop_max = 2
} ns_update_operation;




struct ns_tsig_key {
        char name[1025], alg[1025];
        unsigned char *data;
        int len;
};
typedef struct ns_tsig_key ns_tsig_key;




struct ns_tcp_tsig_state {
        int counter;
        struct dst_key *key;
        void *ctx;
        unsigned char sig[512];
        int siglen;
};
typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;






typedef enum __ns_type {
        ns_t_invalid = 0,
        ns_t_a = 1,
        ns_t_ns = 2,
        ns_t_md = 3,
        ns_t_mf = 4,
        ns_t_cname = 5,
        ns_t_soa = 6,
        ns_t_mb = 7,
        ns_t_mg = 8,
        ns_t_mr = 9,
        ns_t_null = 10,
        ns_t_wks = 11,
        ns_t_ptr = 12,
        ns_t_hinfo = 13,
        ns_t_minfo = 14,
        ns_t_mx = 15,
        ns_t_txt = 16,
        ns_t_rp = 17,
        ns_t_afsdb = 18,
        ns_t_x25 = 19,
        ns_t_isdn = 20,
        ns_t_rt = 21,
        ns_t_nsap = 22,
        ns_t_nsap_ptr = 23,
        ns_t_sig = 24,
        ns_t_key = 25,
        ns_t_px = 26,
        ns_t_gpos = 27,
        ns_t_aaaa = 28,
        ns_t_loc = 29,
        ns_t_nxt = 30,
        ns_t_eid = 31,
        ns_t_nimloc = 32,
        ns_t_srv = 33,
        ns_t_atma = 34,
        ns_t_naptr = 35,
        ns_t_kx = 36,
        ns_t_cert = 37,
        ns_t_a6 = 38,
        ns_t_dname = 39,
        ns_t_sink = 40,
        ns_t_opt = 41,
        ns_t_tsig = 250,
        ns_t_ixfr = 251,
        ns_t_axfr = 252,
        ns_t_mailb = 253,
        ns_t_maila = 254,
        ns_t_any = 255,
        ns_t_zxfr = 256,
        ns_t_max = 65536
} ns_type;










typedef enum __ns_class {
        ns_c_invalid = 0,
        ns_c_in = 1,
        ns_c_2 = 2,
        ns_c_chaos = 3,
        ns_c_hs = 4,

        ns_c_none = 254,
        ns_c_any = 255,
        ns_c_max = 65536
} ns_class;



typedef enum __ns_key_types {
        ns_kt_rsa = 1,
        ns_kt_dh = 2,
        ns_kt_dsa = 3,
        ns_kt_private = 254
} ns_key_types;

typedef enum __ns_cert_types {
        cert_t_pkix = 1,
        cert_t_spki = 2,
        cert_t_pgp = 3,
        cert_t_url = 253,
        cert_t_oid = 254
} ns_cert_types;


































# 447 "/usr/include/arpa/nameser.h" 3 4







# 468 "/usr/include/arpa/nameser.h" 3 4

extern "C" {
u_int __ns_get16 (const u_char *) throw ();
u_long __ns_get32 (const u_char *) throw ();
void __ns_put16 (u_int, u_char *) throw ();
void __ns_put32 (u_long, u_char *) throw ();
int __ns_initparse (const u_char *, int, ns_msg *) throw ();
int __ns_skiprr (const u_char *, const u_char *, ns_sect, int) throw ();
int __ns_parserr (ns_msg *, ns_sect, int, ns_rr *) throw ();
int __ns_sprintrr (const ns_msg *, const ns_rr *, const char *, const char *, char *, size_t) throw ();

int __ns_sprintrrf (const u_char *, size_t, const char *, ns_class, ns_type, u_long, const u_char *, size_t, const char *, const char *, char *, size_t) throw ();



int __ns_format_ttl (u_long, char *, size_t) throw ();
int __ns_parse_ttl (const char *, u_long *) throw ();
u_int32_t __ns_datetosecs (const char *cp, int *errp) throw ();
int __ns_name_ntol (const u_char *, u_char *, size_t) throw ();
int __ns_name_ntop (const u_char *, char *, size_t) throw ();
int __ns_name_pton (const char *, u_char *, size_t) throw ();
int __ns_name_unpack (const u_char *, const u_char *, const u_char *, u_char *, size_t) throw ();

int __ns_name_pack (const u_char *, u_char *, int, const u_char **, const u_char **) throw ();

int __ns_name_uncompress (const u_char *, const u_char *, const u_char *, char *, size_t) throw ();

int __ns_name_compress (const char *, u_char *, size_t, const u_char **, const u_char **) throw ();

int __ns_name_skip (const u_char **, const u_char *) throw ();
void __ns_name_rollback (const u_char *, const u_char **, const u_char **) throw ();

int __ns_sign (u_char *, int *, int, int, void *, const u_char *, int, u_char *, int *, time_t) throw ();

int __ns_sign_tcp (u_char *, int *, int, int, ns_tcp_tsig_state *, int) throw ();

int __ns_sign_tcp_init (void *, const u_char *, int, ns_tcp_tsig_state *) throw ();

u_char *__ns_find_tsig (u_char *, u_char *) throw ();
int __ns_verify (u_char *, int *, void *, const u_char *, int, u_char *, int *, time_t *, int) throw ();


int __ns_verify_tcp (u_char *, int *, ns_tcp_tsig_state *, int) throw ();
int __ns_verify_tcp_init (void *, const u_char *, int, ns_tcp_tsig_state *) throw ();

int __ns_samedomain (const char *, const char *) throw ();
int __ns_subdomain (const char *, const char *) throw ();
int __ns_makecanon (const char *, char *, size_t) throw ();
int __ns_samename (const char *, const char *) throw ();
}


# 1 "/usr/include/arpa/nameser_compat.h" 1 3 4
# 35 "/usr/include/arpa/nameser_compat.h" 3 4

# 48 "/usr/include/arpa/nameser_compat.h" 3 4
typedef struct {
        unsigned id :16;
# 66 "/usr/include/arpa/nameser_compat.h" 3 4
        unsigned rd :1;
        unsigned tc :1;
        unsigned aa :1;
        unsigned opcode :4;
        unsigned qr :1;

        unsigned rcode :4;
        unsigned cd: 1;
        unsigned ad: 1;
        unsigned unused :1;
        unsigned ra :1;


        unsigned qdcount :16;
        unsigned ancount :16;
        unsigned nscount :16;
        unsigned arcount :16;
} HEADER;













# 553 "/usr/include/arpa/nameser.h" 2 3 4
# 59 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2
# 1 "/usr/include/resolv.h" 1 3 4
# 60 "/usr/include/resolv.h" 3 4
# 69 "/usr/include/resolv.h" 3 4

typedef enum { res_goahead, res_nextns, res_modified, res_done, res_error }
        res_sendhookact;

typedef res_sendhookact (*res_send_qhook) (struct sockaddr_in * const *ns,
                                           const u_char **query,
                                           int *querylen,
                                           u_char *ans,
                                           int anssiz,
                                           int *resplen);

typedef res_sendhookact (*res_send_rhook) (const struct sockaddr_in *ns,
                                           const u_char *query,
                                           int querylen,
                                           u_char *ans,
                                           int anssiz,
                                           int *resplen);






struct __res_state {
        int retrans;
        int retry;
        u_long options;
        int nscount;
        struct sockaddr_in
                nsaddr_list[3];
        u_short id;
        char *dnsrch[6 +1];
        char defdname[256];
        u_long pfcode;
        unsigned ndots:4;
        unsigned nsort:4;
        char unused[3];
        struct {
                struct in_addr addr;
                u_int32_t mask;
        } sort_list[10];
        res_send_qhook qhook;
        res_send_rhook rhook;
        int res_h_errno;
        int _vcsock;
        u_int _flags;
        union {
                char pad[52];
                struct {
                        u_int16_t nscount;
                        u_int16_t nsmap[3];
                        int nssocks[3];
                        u_int16_t nscount6;
                        u_int16_t nsinit;
                        struct sockaddr_in6 *nsaddrs[3];
                } _ext;
        } _u;
};

typedef struct __res_state *res_state;
# 154 "/usr/include/resolv.h" 3 4
# 163 "/usr/include/resolv.h" 3 4


struct res_sym {
        int number;
        char * name;
        char * humanname;
};


















extern "C" {
extern struct __res_state *__res_state(void) __attribute__ ((__const__));
}



extern "C" {
void __fp_nquery (const u_char *, int, FILE *) throw ();
void __fp_query (const u_char *, FILE *) throw ();
const char * __hostalias (const char *) throw ();
void __p_query (const u_char *) throw ();
void __res_close (void) throw ();
int __res_init (void) throw ();
int __res_isourserver (const struct sockaddr_in *) throw ();
int __res_mkquery (int, const char *, int, int, const u_char *, int, const u_char *, u_char *, int) throw ();

int __res_query (const char *, int, int, u_char *, int) throw ();
int __res_querydomain (const char *, const char *, int, int, u_char *, int) throw ();

int __res_search (const char *, int, int, u_char *, int) throw ();
int __res_send (const u_char *, int, u_char *, int) throw ();
}


extern "C" {
int __res_hnok (const char *) throw ();
int __res_ownok (const char *) throw ();
int __res_mailok (const char *) throw ();
int __res_dnok (const char *) throw ();
int __sym_ston (const struct res_sym *, const char *, int *) throw ();
const char * __sym_ntos (const struct res_sym *, int, int *) throw ();
const char * __sym_ntop (const struct res_sym *, int, int *) throw ();
int __b64_ntop (u_char const *, size_t, char *, size_t) throw ();
int __b64_pton (char const *, u_char *, size_t) throw ();
int __loc_aton (const char *ascii, u_char *binary) throw ();
const char * __loc_ntoa (const u_char *binary, char *ascii) throw ();
int __dn_skipname (const u_char *, const u_char *) throw ();
void __putlong (u_int32_t, u_char *) throw ();
void __putshort (u_int16_t, u_char *) throw ();
const char * __p_class (int) throw ();
const char * __p_time (u_int32_t) throw ();
const char * __p_type (int) throw ();
const char * __p_rcode (int) throw ();
const u_char * __p_cdnname (const u_char *, const u_char *, int, FILE *) throw ();
const u_char * __p_cdname (const u_char *, const u_char *, FILE *) throw ();
const u_char * __p_fqnname (const u_char *cp, const u_char *msg, int, char *, int) throw ();

const u_char * __p_fqname (const u_char *, const u_char *, FILE *) throw ();
const char * __p_option (u_long option) throw ();
char * __p_secstodate (u_long) throw ();
int __dn_count_labels (const char *) throw ();
int __dn_comp (const char *, u_char *, int, u_char **, u_char **) throw ();

int __dn_expand (const u_char *, const u_char *, const u_char *, char *, int) throw ();

u_int __res_randomid (void) throw ();
int __res_nameinquery (const char *, int, int, const u_char *, const u_char *) throw ();

int __res_queriesmatch (const u_char *, const u_char *, const u_char *, const u_char *) throw ();

const char * __p_section (int section, int opcode) throw ();

int __res_ninit (res_state) throw ();
int __res_nisourserver (const res_state, const struct sockaddr_in *) throw ();

void __fp_resstat (const res_state, FILE *) throw ();
void __res_npquery (const res_state, const u_char *, int, FILE *) throw ();
const char * __res_hostalias (const res_state, const char *, char *, size_t) throw ();

int __res_nquery (res_state, const char *, int, int, u_char *, int) throw ();

int __res_nsearch (res_state, const char *, int, int, u_char *, int) throw ();

int __res_nquerydomain (res_state, const char *, const char *, int, int, u_char *, int) throw ();


int __res_nmkquery (res_state, int, const char *, int, int, const u_char *, int, const u_char *, u_char *, int) throw ();


int __res_nsend (res_state, const u_char *, int, u_char *, int) throw ();
void __res_nclose (res_state) throw ();
}
# 60 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2
}





# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 67 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2
# 84 "/coolo/prod/kdelibs/kdecore/ksock.cpp"
# 1 "/coolo/prod/qt-copy/include/qsocketnotifier.h" 1
# 39 "/coolo/prod/qt-copy/include/qsocketnotifier.h"






class QSocketNotifier : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    enum Type { Read, Write, Exception };

    QSocketNotifier( int socket, Type, QObject *parent=0, const char *name=0 );
   ~QSocketNotifier();

    int socket() const;
    Type type() const;

    bool isEnabled() const;
    virtual void setEnabled( bool );

protected:
    void activated( int socket );

protected:
    bool event( QEvent * );

private:
    int sockfd;
    Type sntype;
    bool snenabled;

private:

    QSocketNotifier( const QSocketNotifier & );
    QSocketNotifier &operator=( const QSocketNotifier & );

};


inline int QSocketNotifier::socket() const
{ return sockfd; }

inline QSocketNotifier::Type QSocketNotifier::type() const
{ return sntype; }

inline bool QSocketNotifier::isEnabled() const
{ return snenabled; }
# 85 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2

# 1 "/coolo/prod/kdelibs/kdecore/netsupp.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/netsupp.h"


# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 28 "/coolo/prod/kdelibs/kdecore/netsupp.h" 2
# 53 "/coolo/prod/kdelibs/kdecore/netsupp.h"
struct kde_in6_addr
{
  unsigned char __u6_addr[16];
};





struct kde_sockaddr_in6
{




  Q_UINT16 sin6_family;

  unsigned short sin6_port;
  Q_UINT32 sin6_flowinfo;
  struct kde_in6_addr sin6_addr;
  Q_UINT32 sin6_scope_id;
};

































# 141 "/coolo/prod/kdelibs/kdecore/netsupp.h"

struct addrinfo;
# 155 "/coolo/prod/kdelibs/kdecore/netsupp.h"
struct kde_addrinfo
{
  struct addrinfo *data;
  int origin;
};

extern int kde_getaddrinfo(const char *name, const char *service,
                           const struct addrinfo* hint,
                           struct kde_addrinfo** result);
extern void kde_freeaddrinfo(struct kde_addrinfo *p);
# 87 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2

class KSocketPrivate
{
public:
  QSocketNotifier *readNotifier;
  QSocketNotifier *writeNotifier;

  KSocketPrivate() :
    readNotifier(0), writeNotifier(0)
  { }
};



KSocket::KSocket( int _sock)
  : sock(_sock), d(new KSocketPrivate)
{
  struct sockaddr_in sin;
  ksocklen_t len = sizeof(sin);

  memset(&sin, 0, len);




  KSocks::self()->getsockname(_sock, (struct sockaddr *)&sin, &len);
}

KSocket::KSocket( const char *_host, unsigned short int _port, int _timeout ) :
  sock( -1 ), d(new KSocketPrivate)
{
    connect( _host, _port, _timeout );
}

KSocket::KSocket( const char *_path ) :
  sock( -1 ), d(new KSocketPrivate)
{
  connect( _path );
}

void KSocket::enableRead( bool _state )
{
  if ( _state )
    {
          if ( !d->readNotifier )
                {
                  d->readNotifier = new QSocketNotifier( sock, QSocketNotifier::Read );
                  QObject::connect( d->readNotifier, "2""activated(int)", this, "1""slotRead(int)" );
                }
          else
            d->readNotifier->setEnabled( true );
    }
  else if ( d->readNotifier )
        d->readNotifier->setEnabled( false );
}

void KSocket::enableWrite( bool _state )
{
  if ( _state )
    {
          if ( !d->writeNotifier )
                {
                  d->writeNotifier = new QSocketNotifier( sock, QSocketNotifier::Write );
                  QObject::connect( d->writeNotifier, "2""activated(int)", this,
                                                        "1""slotWrite(int)" );
                }
          else
            d->writeNotifier->setEnabled( true );
    }
  else if ( d->writeNotifier )
        d->writeNotifier->setEnabled( false );
}

void KSocket::slotRead( int )
{
  char buffer[2];

  int n = recv( sock, buffer, 1, MSG_PEEK );
  if ( n <= 0 )
        closeEvent( this );
  else
        readEvent( this );
}

void KSocket::slotWrite( int )
{
  writeEvent( this );
}




bool KSocket::connect( const char *_path )
{
  KExtendedSocket ks(QString::null, _path, KExtendedSocket::unixSocket);

  ks.connect();
  sock = ks.fd();
  ks.release();

  return sock >= 0;
}




bool KSocket::connect( const QString& _host, unsigned short int _port, int _timeout )
{
  KExtendedSocket ks(_host, _port, KExtendedSocket::inetSocket);
  ks.setTimeout(_timeout, 0);

  ks.connect();
  sock = ks.fd();
  ks.release();

  return sock >= 0;
}



unsigned long KSocket::ipv4_addr()
{
  unsigned long retval = 0;
  KSocketAddress *sa = KExtendedSocket::peerAddress(sock);
  if (sa == __null)
    return 0;

  if (sa->address() != __null && (sa->address()->sa_family == 2

                                || sa->address()->sa_family == 10

      ))
    {
      KInetSocketAddress *ksin = (KInetSocketAddress*)sa;
      const sockaddr_in *sin = ksin->addressV4();
      if (sin != __null)
        retval = *(unsigned long*)&sin->sin_addr;
    }
  delete sa;
  return retval;
}

bool KSocket::initSockaddr (ksockaddr_in *server_name, const char *hostname, unsigned short int port, int domain)
{



  kdWarning(170) << "deprecated KSocket::initSockaddr called" << endl;

  if (domain != 2)
    return false;

  QPtrList<KAddressInfo> list = KExtendedSocket::lookup(hostname, QString::number(port),
                                                        KExtendedSocket::ipv4Socket);
  list.setAutoDelete(true);

  if (list.isEmpty())
    return false;

  memset(server_name, 0, sizeof(*server_name));


  KInetSocketAddress *sin = (KInetSocketAddress*)list.getFirst()->address();
  if (sin == __null)
    return false;

  memcpy(server_name, sin->addressV4(), sizeof(*server_name));
  kdDebug(170) << "KSocket::initSockaddr: returning " << sin->pretty() << endl;
  return true;
}



KSocket::~KSocket()
{

  delete d->readNotifier;
  delete d->writeNotifier;

  delete d;

  if (sock != -1) {
    ::close( sock );
  }
}

class KServerSocketPrivate
{
public:
   bool bind;
   QCString path;
   unsigned short int port;
   KExtendedSocket *ks;
};


KServerSocket::KServerSocket( const char *_path, bool _bind ) :
  sock( -1 )
{
  d = new KServerSocketPrivate();
  d->bind = _bind;

  init ( _path );
}

KServerSocket::KServerSocket( unsigned short int _port, bool _bind ) :
  sock( -1 )
{
  d = new KServerSocketPrivate();
  d->bind = _bind;

  init ( _port );
}

bool KServerSocket::init( const char *_path )
{
  unlink(_path );
  d->path = _path;

  KExtendedSocket *ks = new KExtendedSocket(QString::null, _path, KExtendedSocket::passiveSocket |
                                            KExtendedSocket::unixSocket);
  d->ks = ks;

  if (d->bind)
    return bindAndListen();
  return true;
}


bool KServerSocket::init( unsigned short int _port )
{
  d->port = _port;
  KExtendedSocket *ks;
  ks = new KExtendedSocket(QString::null, _port, KExtendedSocket::passiveSocket |
                           KExtendedSocket::inetSocket);
  d->ks = ks;

  if (d->bind)
    return bindAndListen();
  return true;
}

bool KServerSocket::bindAndListen()
{
  if (d == __null || d->ks == __null)
    return false;


  int ret = d->ks->listen( 128 );
  if (ret < 0)
    {
        kdWarning(170) << "Error listening on socket: " << ret << "\n";
        delete d->ks;
        d->ks = __null;
        sock = -1;
        return false;
    }


  sock = d->ks->fd();

  connect( d->ks->readNotifier(), "2""activated(int)", this, "1""slotAccept(int)" );
  return true;
}


unsigned short int KServerSocket::port()
{
  if (d == __null || d->ks == __null || sock == -1)
    return 0;
  const KSocketAddress *sa = d->ks->localAddress();
  if (sa == __null)
    return 0;


  sockaddr_in *sin = (sockaddr_in*)sa->address();

  if (sin->sin_family == 2)

    return sin->sin_port;

  else if (sin->sin_family == 10)
    {
      kde_sockaddr_in6 *sin6 = (kde_sockaddr_in6*)sin;
      return sin6->sin6_port;
    }

  return 0;
}

unsigned long KServerSocket::ipv4_addr()
{
  if (d == __null || d->ks == __null || sock == -1)
    return 0;
  const KSocketAddress *sa = d->ks->localAddress();

  const sockaddr_in *sin = (sockaddr_in*)sa->address();

  if (sin->sin_family == 2)

    return ntohl(*(unsigned long*)&sin->sin_addr);

  else if (sin->sin_family == 10)
    {
      KInetSocketAddress *ksin = (KInetSocketAddress*)sa;
      sin = ksin->addressV4();
      if (sin != __null)
        return *(unsigned long*)&sin->sin_addr;
    }

  return 0;
}

void KServerSocket::slotAccept( int )
{
  if (d == __null || d->ks == __null || sock == -1)
    return;

  KExtendedSocket *s;
  if (d->ks->accept(s) < 0)
    {
        kdWarning(170) << "Error accepting\n";
        return;
    }

  int new_sock = s->fd();
  s->release();
  delete s;

  accepted( new KSocket( new_sock ) );
}

KServerSocket::~KServerSocket()
{
  if (d != __null)
    {
      if (d->ks != __null)
        delete d->ks;
      delete d;
    }


}

# 1 "../kdecore/ksock.moc" 1
# 11 "../kdecore/ksock.moc"
# 1 "../../../prod/kdelibs/kdecore/ksock.h" 1
# 12 "../kdecore/ksock.moc" 2
# 22 "../kdecore/ksock.moc"
const char *KSocket::className() const
{
    return "KSocket";
}

QMetaObject *KSocket::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KSocket( "KSocket", &KSocket::staticMetaObject );
# 50 "../kdecore/ksock.moc"
QMetaObject* KSocket::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { "x", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_0 = {"slotWrite", 1, param_slot_0 };
    static const QUParameter param_slot_1[] = {
        { "x", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_1 = {"slotRead", 1, param_slot_1 };
    static const QMetaData slot_tbl[] = {
        { "slotWrite(int)", &slot_0, QMetaData::Public },
        { "slotRead(int)", &slot_1, QMetaData::Public }
    };
    static const QUParameter param_signal_0[] = {
        { "s", &static_QUType_ptr, "KSocket", QUParameter::In }
    };
    static const QUMethod signal_0 = {"readEvent", 1, param_signal_0 };
    static const QUParameter param_signal_1[] = {
        { "s", &static_QUType_ptr, "KSocket", QUParameter::In }
    };
    static const QUMethod signal_1 = {"writeEvent", 1, param_signal_1 };
    static const QUParameter param_signal_2[] = {
        { "s", &static_QUType_ptr, "KSocket", QUParameter::In }
    };
    static const QUMethod signal_2 = {"closeEvent", 1, param_signal_2 };
    static const QMetaData signal_tbl[] = {
        { "readEvent(KSocket*)", &signal_0, QMetaData::Public },
        { "writeEvent(KSocket*)", &signal_1, QMetaData::Public },
        { "closeEvent(KSocket*)", &signal_2, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KSocket", parentObject,
        slot_tbl, 2,
        signal_tbl, 3,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KSocket.setMetaObject( metaObj );
    return metaObj;
}

void* KSocket::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KSocket" ) )
        return this;
    return QObject::qt_cast( clname );
}





void KSocket::readEvent( KSocket* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 0 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}


void KSocket::writeEvent( KSocket* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 1 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}


void KSocket::closeEvent( KSocket* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 2 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}

bool KSocket::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotWrite((int)static_QUType_int.get(_o+1)); break;
    case 1: slotRead((int)static_QUType_int.get(_o+1)); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KSocket::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: readEvent((KSocket*)static_QUType_ptr.get(_o+1)); break;
    case 1: writeEvent((KSocket*)static_QUType_ptr.get(_o+1)); break;
    case 2: closeEvent((KSocket*)static_QUType_ptr.get(_o+1)); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KSocket::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KSocket::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }



const char *KServerSocket::className() const
{
    return "KServerSocket";
}

QMetaObject *KServerSocket::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KServerSocket( "KServerSocket", &KServerSocket::staticMetaObject );
# 207 "../kdecore/ksock.moc"
QMetaObject* KServerSocket::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { 0, &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_0 = {"slotAccept", 1, param_slot_0 };
    static const QMetaData slot_tbl[] = {
        { "slotAccept(int)", &slot_0, QMetaData::Public }
    };
    static const QUParameter param_signal_0[] = {
        { "s", &static_QUType_ptr, "KSocket", QUParameter::In }
    };
    static const QUMethod signal_0 = {"accepted", 1, param_signal_0 };
    static const QMetaData signal_tbl[] = {
        { "accepted(KSocket*)", &signal_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KServerSocket", parentObject,
        slot_tbl, 1,
        signal_tbl, 1,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KServerSocket.setMetaObject( metaObj );
    return metaObj;
}

void* KServerSocket::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KServerSocket" ) )
        return this;
    return QObject::qt_cast( clname );
}


void KServerSocket::accepted( KSocket* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 0 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}

bool KServerSocket::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotAccept((int)static_QUType_int.get(_o+1)); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KServerSocket::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: accepted((KSocket*)static_QUType_ptr.get(_o+1)); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KServerSocket::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KServerSocket::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 432 "/coolo/prod/kdelibs/kdecore/ksock.cpp" 2
# 16 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 1
# 25 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kpty.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kpty.h"

struct KPtyPrivate;
# 35 "/coolo/prod/kdelibs/kdecore/kpty.h"
class KPty {

public:




  KPty();







  ~KPty();






  bool open();




  void close();





  void setCTty();
# 80 "/coolo/prod/kdelibs/kdecore/kpty.h"
  void login(const char *user = 0, const char *remotehost = 0);




  void logout();
# 94 "/coolo/prod/kdelibs/kdecore/kpty.h"
  void setWinSize(int lines, int columns);
# 103 "/coolo/prod/kdelibs/kdecore/kpty.h"
  void setXonXoff(bool useXonXoff);






  const char *ttyName() const;






  int masterFd() const;






  int slaveFd() const;

private:
  bool chownpty(bool grant);

  KPtyPrivate *d;
};
# 26 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2


# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 29 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2
# 52 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
# 1 "/usr/include/sys/ioctl.h" 1 3 4
# 20 "/usr/include/sys/ioctl.h" 3 4



extern "C" {


# 1 "/usr/include/bits/ioctls.h" 1 3 4
# 24 "/usr/include/bits/ioctls.h" 3 4
# 1 "/usr/include/asm/ioctls.h" 1 3 4


# 1 "/usr/include/asm/ioctl.h" 1 3 4






# 27 "/usr/include/asm/ioctl.h" 3 4


















# 5 "/usr/include/asm/ioctls.h" 2 3 4








# 25 "/usr/include/bits/ioctls.h" 2 3 4


















# 103 "/usr/include/bits/ioctls.h" 3 4





# 28 "/usr/include/sys/ioctl.h" 2 3 4


# 1 "/usr/include/bits/ioctl-types.h" 1 3 4
# 28 "/usr/include/bits/ioctl-types.h" 3 4
struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };

struct termio
  {
    unsigned short int c_iflag;
    unsigned short int c_oflag;
    unsigned short int c_cflag;
    unsigned short int c_lflag;
    unsigned char c_line;
    unsigned char c_cc[8];
};






# 31 "/usr/include/sys/ioctl.h" 2 3 4






# 1 "/usr/include/sys/ttydefaults.h" 1 3 4
# 41 "/usr/include/sys/ttydefaults.h" 3 4

















# 38 "/usr/include/sys/ioctl.h" 2 3 4




extern int ioctl (int __fd, unsigned long int __request, ...) throw ();

}
# 53 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2
# 62 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
# 1 "/usr/include/sys/stropts.h" 1 3 4
# 1 "/usr/include/stropts.h" 1 3 4
# 20 "/usr/include/stropts.h" 3 4



# 1 "/usr/include/bits/xtitypes.h" 1 3 4
# 25 "/usr/include/bits/xtitypes.h" 3 4




typedef long int __t_scalar_t;
typedef unsigned long int __t_uscalar_t;
# 25 "/usr/include/stropts.h" 2 3 4
# 36 "/usr/include/stropts.h" 3 4
typedef __t_uscalar_t t_uscalar_t;


# 1 "/usr/include/bits/stropts.h" 1 3 4
# 24 "/usr/include/bits/stropts.h" 3 4





















































































struct bandinfo
  {
    unsigned char bi_pri;
    int bi_flag;
  };

struct strbuf
  {
    int maxlen;
    int len;
    char *buf;
  };

struct strpeek
  {
    struct strbuf ctlbuf;
    struct strbuf databuf;
    t_uscalar_t flags;
  };

struct strfdinsert
  {
    struct strbuf ctlbuf;
    struct strbuf databuf;
    t_uscalar_t flags;
    int fildes;
    int offset;
  };

struct strioctl
  {
    int ic_cmd;
    int ic_timout;
    int ic_len;
    char *ic_dp;
  };

struct strrecvfd
  {
    int fd;
    uid_t uid;
    gid_t gid;
    char __fill[8];
  };


struct str_mlist
  {
    char l_name[8 + 1];
  };

struct str_list
  {
    int sl_nmods;
    struct str_mlist *sl_modlist;
  };
# 40 "/usr/include/stropts.h" 2 3 4


extern "C" {


extern int isastream (int __fildes) throw ();


extern int getmsg (int __fildes, struct strbuf *__restrict __ctlptr,
                   struct strbuf *__restrict __dataptr,
                   int *__restrict __flagsp) throw ();



extern int getpmsg (int __fildes, struct strbuf *__restrict __ctlptr,
                    struct strbuf *__restrict __dataptr,
                    int *__restrict __bandp, int *__restrict __flagsp)
     throw ();




extern int ioctl (int __fd, unsigned long int __request, ...) throw ();


extern int putmsg (int __fildes, __const struct strbuf *__ctlptr,
                   __const struct strbuf *__dataptr, int __flags) throw ();


extern int putpmsg (int __fildes, __const struct strbuf *__ctlptr,
                    __const struct strbuf *__dataptr, int __band, int __flags)
     throw ();



extern int fattach (int __fildes, __const char *__path) throw ();


extern int fdetach (__const char *__path) throw ();

}
# 2 "/usr/include/sys/stropts.h" 2 3 4
# 63 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2





# 1 "/usr/include/errno.h" 1 3 4
# 70 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2






# 1 "/usr/include/grp.h" 1 3 4
# 24 "/usr/include/grp.h" 3 4



extern "C" {



# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 414 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
# 34 "/usr/include/grp.h" 2 3 4
# 43 "/usr/include/grp.h" 3 4
struct group
  {
    char *gr_name;
    char *gr_passwd;
    __gid_t gr_gid;
    char **gr_mem;
  };









extern void setgrent (void) throw ();


extern void endgrent (void) throw ();


extern struct group *getgrent (void) throw ();




extern struct group *fgetgrent (FILE *__stream) throw ();




extern int putgrent (__const struct group *__restrict __p,
                     FILE *__restrict __f) throw ();



extern struct group *getgrgid (__gid_t __gid) throw ();


extern struct group *getgrnam (__const char *__name) throw ();






# 103 "/usr/include/grp.h" 3 4
extern int getgrent_r (struct group *__restrict __resultbuf,
                       char *__restrict __buffer, size_t __buflen,
                       struct group **__restrict __result) throw ();



extern int getgrgid_r (__gid_t __gid, struct group *__restrict __resultbuf,
                       char *__restrict __buffer, size_t __buflen,
                       struct group **__restrict __result) throw ();


extern int getgrnam_r (__const char *__restrict __name,
                       struct group *__restrict __resultbuf,
                       char *__restrict __buffer, size_t __buflen,
                       struct group **__restrict __result) throw ();




extern int fgetgrent_r (FILE *__restrict __stream,
                        struct group *__restrict __resultbuf,
                        char *__restrict __buffer, size_t __buflen,
                        struct group **__restrict __result) throw ();







# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 1 3 4
# 235 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef __need_size_t
# 397 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
#undef NULL

# 414 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/stddef.h" 3 4
# 135 "/usr/include/grp.h" 2 3 4


extern int setgroups (size_t __n, __const __gid_t *__groups) throw ();




extern int getgrouplist (__const char *__user, __gid_t __group,
                         __gid_t *__groups, int *__ngroups) throw ();




extern int initgroups (__const char *__user, __gid_t __group) throw ();



}
# 77 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2
# 93 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
extern "C" {
# 1 "/usr/include/termios.h" 1 3 4
# 24 "/usr/include/termios.h" 3 4
# 36 "/usr/include/termios.h" 3 4
extern "C" {



# 1 "/usr/include/bits/termios.h" 1 3 4
# 24 "/usr/include/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;

struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;
  };




































# 41 "/usr/include/termios.h" 2 3 4







extern speed_t cfgetospeed (__const struct termios *__termios_p) throw ();


extern speed_t cfgetispeed (__const struct termios *__termios_p) throw ();


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) throw ();


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) throw ();



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) throw ();




extern int tcgetattr (int __fd, struct termios *__termios_p) throw ();



extern int tcsetattr (int __fd, int __optional_actions,
                      __const struct termios *__termios_p) throw ();




extern void cfmakeraw (struct termios *__termios_p) throw ();



extern int tcsendbreak (int __fd, int __duration) throw ();


extern int tcdrain (int __fd) throw ();



extern int tcflush (int __fd, int __queue_selector) throw ();



extern int tcflow (int __fd, int __action) throw ();




extern __pid_t tcgetsid (int __fd) throw ();




# 1 "/usr/include/sys/ttydefaults.h" 1 3 4
# 103 "/usr/include/termios.h" 2 3 4


}
# 95 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2
}





# 1 "/usr/include/termio.h" 1 3 4
# 102 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2
# 111 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
# 121 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
# 131 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
# 1 "/usr/include/pty.h" 1 3 4
# 21 "/usr/include/pty.h" 3 4







extern "C" {




extern int openpty (int *__amaster, int *__aslave, char *__name,
                    struct termios *__termp, struct winsize *__winp) throw ();



extern int forkpty (int *__amaster, char *__name,
                    struct termios *__termp, struct winsize *__winp) throw ();

}
# 132 "/coolo/prod/kdelibs/kdecore/kpty.cpp" 2
# 140 "/coolo/prod/kdelibs/kdecore/kpty.cpp"





class KProcess_Utmp : public KProcess
{
public:
   int commSetupDoneC()
   {
     dup2(cmdFd, 0);
     dup2(cmdFd, 1);
     dup2(cmdFd, 3);
     return 1;
   }
   int cmdFd;
};








struct KPtyPrivate {
   KPtyPrivate() :
     xonXoff(false), needGrantPty(false),
     masterFd(-1), slaveFd(-1)
   {
     memset(&winSize, 0, sizeof(winSize));
     winSize.ws_row = 24;
     winSize.ws_col = 80;
   }

   bool xonXoff : 1;
   bool needGrantPty : 1;
   int masterFd;
   int slaveFd;
   struct winsize winSize;

   QCString ttyName;
};





KPty::KPty()
{
  d = new KPtyPrivate;
}

KPty::~KPty()
{
  close();
  delete d;
}

bool KPty::open()
{
  if (d->masterFd >= 0)
    return true;

  QCString ptyName;

  d->needGrantPty = true;
# 218 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
    if (openpty(&d->masterFd, &d->slaveFd, __null, __null, __null) == 0)
    {
      d->ttyName = ttyname(d->slaveFd);

      d->needGrantPty = false;


      struct group* p = getgrnam("tty");
      gid_t gid = p ? p->gr_gid : getgid ();

      if (fchown(d->slaveFd, (uid_t) -1, gid) < 0)
      {
         int e = (*__errno_location ());
         d->needGrantPty = true;
         kdWarning(175) << "Cannot chown " << d->ttyName << endl
                        << "Reason " << strerror(e) << endl;
      }
      else if (fchmod(d->slaveFd, 0400|0200|(0200 >> 3)) < 0)
      {
         int e = (*__errno_location ());
         d->needGrantPty = true;
         kdWarning(175) << "Cannot chmod " << d->ttyName << endl
                        << "Reason " << strerror(e) << endl;
      }
      goto gotpty;
    }







    d->masterFd = ::open("/dev/ptmx",02);

    if (d->masterFd >= 0)
    {
      char *ptsn = ptsname(d->masterFd);
      if (ptsn) {
          d->ttyName = ptsn;
          grantpt(d->masterFd);
          d->needGrantPty = false;
          goto gotpty;
      } else {
          ::close(d->masterFd);
          d->masterFd = -1;
      }
    }



    for (const char* s3 = "pqrstuvwxyzabcdefghijklmno"; *s3 != 0; s3++)
    {
      for (const char* s4 = "0123456789abcdefghijklmnopqrstuvwxyz"; *s4 != 0; s4++)
      {
        ptyName.sprintf("/dev/pty%c%c", *s3, *s4);
        d->ttyName.sprintf("/dev/tty%c%c", *s3, *s4);



        d->masterFd = ::open(ptyName.data(), 02);
        if (d->masterFd >= 0)
        {
          if (geteuid() == 0 || access(d->ttyName.data(),4|2) == 0)
            goto gotpty;
          ::close(d->masterFd);
          d->masterFd = -1;
        }
      }
    }

    kdWarning(175) << "Can't open a pseudo teletype" << endl;
    return false;

 gotpty:
  if (!chownpty(true))
  {
    kdWarning(175)
      << "chownpty failed for device " << ptyName << "::" << d->ttyName
      << "\nThis means the communication can be eavesdropped." << endl;
  }




  unlockpt(d->masterFd);


  if (d->slaveFd < 0) {
    d->slaveFd = ::open(d->ttyName, 02);
    if (d->slaveFd < 0)
    {
      kdWarning(175) << "Can't open slave pseudo teletype" << endl;
      ::close(d->masterFd);
      d->masterFd = -1;
      return false;
    }
  }
# 327 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
  struct ::termios ttmode;

  ioctl(d->slaveFd, 0x5401, (char *)&ttmode);

  if (!d->xonXoff)
    ttmode.c_iflag &= ~(0010000 | 0002000);
  else
    ttmode.c_iflag |= (0010000 | 0002000);

  ttmode.c_cc[0] = ('C' - '@'&037);
  ttmode.c_cc[1] = ('\\' - '@'&037);
  ttmode.c_cc[2] = 0177;

  ioctl(d->slaveFd, 0x5402, (char *)&ttmode);


  ioctl(d->slaveFd, 0x5414, (char *)&d->winSize);

  fcntl(d->masterFd, 2, 1);
  fcntl(d->slaveFd, 2, 1);

  return true;
}

void KPty::close()
{
   if (d->masterFd < 0)
      return;
   chownpty(false);
   ::close(d->slaveFd);
   ::close(d->masterFd);
   d->masterFd = d->slaveFd = -1;
}

void KPty::setCTty()
{




    setsid();



    ioctl(d->slaveFd, 0x540E, 0);






    int pgrp = getpid();

    tcsetpgrp (d->slaveFd, pgrp);



}

void KPty::login(const char *user, const char *remotehost)
{
# 418 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
    (void)user;;
    (void)remotehost;;

}

void KPty::logout()
{
# 443 "/coolo/prod/kdelibs/kdecore/kpty.cpp"
}

void KPty::setWinSize(int lines, int columns)
{
  d->winSize.ws_row = (unsigned short)lines;
  d->winSize.ws_col = (unsigned short)columns;
  if (d->masterFd >= 0)
    ioctl( d->masterFd, 0x5414, (char *)&d->winSize );
}

void KPty::setXonXoff(bool useXonXoff)
{
  d->xonXoff = useXonXoff;
  if (d->masterFd >= 0) {



    struct ::termios ttmode;

    ioctl(d->masterFd, 0x5401, (char *)&ttmode);

    if (!useXonXoff)
      ttmode.c_iflag &= ~(0010000 | 0002000);
    else
      ttmode.c_iflag |= (0010000 | 0002000);

    ioctl(d->masterFd, 0x5402, (char *)&ttmode);
  }
}

const char *KPty::ttyName() const
{
    return d->ttyName.data();
}

int KPty::masterFd() const
{
    return d->masterFd;
}

int KPty::slaveFd() const
{
    return d->slaveFd;
}


bool KPty::chownpty(bool grant)
{
  if (!d->needGrantPty)
    return true;


  pid_t pid = fork();
  if (pid == 0)
  {

    if (d->masterFd != 3 &&
        dup2(d->masterFd , 3) < 0)
      exit(1);
    QString path = locate("exe", "kgrantpty");
    execle(path.ascii(), "kgrantpty", grant?"--grant":"--revoke", (void *)0,
        __null);
    exit(1);
  }
  else if (pid > 0)
  {
    int w;

retry:
    int rc = waitpid(pid, &w, 0);
    if ((rc == -1) && ((*__errno_location ()) == 4))
      goto retry;

    return (rc != -1 && ((((*(int *) &(w))) & 0x7f) == 0) && ((((*(int *) &(w))) & 0xff00) >> 8) == 0);
  }

  return false;
}
# 17 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kprocess.cpp" 1
# 29 "/coolo/prod/kdelibs/kdecore/kprocess.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 30 "/coolo/prod/kdelibs/kdecore/kprocess.cpp" 2
# 53 "/coolo/prod/kdelibs/kdecore/kprocess.cpp"
# 1 "/usr/include/sys/stropts.h" 1 3 4
# 54 "/coolo/prod/kdelibs/kdecore/kprocess.cpp" 2





# 1 "/usr/include/errno.h" 1 3 4
# 61 "/coolo/prod/kdelibs/kdecore/kprocess.cpp" 2
# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 62 "/coolo/prod/kdelibs/kdecore/kprocess.cpp" 2
# 84 "/coolo/prod/kdelibs/kdecore/kprocess.cpp"
class KProcessPrivate {
public:
   KProcessPrivate() :
     usePty(KProcess::NoCommunication),
     addUtmp(false), useShell(false),
     pty(0), priority(0)
   {
   }

   KProcess::Communication usePty;
   bool addUtmp : 1;
   bool useShell : 1;

   KPty *pty;
   const char *user;

   int priority;

   QMap<QString,QString> env;
   QString wd;
   QCString shell;
   QCString executable;
};





KProcess::KProcess( QObject* parent, const char *name )
  : QObject( parent, name ),
    run_mode(NotifyOnExit),
    runs(false),
    pid_(0),
    status(0),
    keepPrivs(false),
    innot(0),
    outnot(0),
    errnot(0),
    communication(NoCommunication),
    input_data(0),
    input_sent(0),
    input_total(0)
{
  KProcessController::ref();
  KProcessController::theKProcessController->addKProcess(this);

  d = new KProcessPrivate;

  out[0] = out[1] = -1;
  in[0] = in[1] = -1;
  err[0] = err[1] = -1;
}

KProcess::KProcess()
  : QObject(),
    run_mode(NotifyOnExit),
    runs(false),
    pid_(0),
    status(0),
    keepPrivs(false),
    innot(0),
    outnot(0),
    errnot(0),
    communication(NoCommunication),
    input_data(0),
    input_sent(0),
    input_total(0)
{
  KProcessController::ref();
  KProcessController::theKProcessController->addKProcess(this);

  d = new KProcessPrivate;

  out[0] = out[1] = -1;
  in[0] = in[1] = -1;
  err[0] = err[1] = -1;
}

void
KProcess::setEnvironment(const QString &name, const QString &value)
{
   d->env.insert(name, value);
}

void
KProcess::setWorkingDirectory(const QString &dir)
{
   d->wd = dir;
}

void
KProcess::setupEnvironment()
{
   QMap<QString,QString>::Iterator it;
   for(it = d->env.begin(); it != d->env.end(); ++it)
   {
      setenv(QFile::encodeName(it.key()).data(),
             QFile::encodeName(it.data()).data(), 1);
   }
   if (!d->wd.isEmpty())
   {
      chdir(QFile::encodeName(d->wd).data());
   }
}

void
KProcess::setRunPrivileged(bool keepPrivileges)
{
   keepPrivs = keepPrivileges;
}

bool
KProcess::runPrivileged() const
{
   return keepPrivs;
}

bool
KProcess::setPriority(int prio)
{
    if (runs) {
        if (setpriority(PRIO_PROCESS, pid_, prio))
            return false;
    } else {
        if (prio > 19 || prio < (geteuid() ? getpriority(PRIO_PROCESS, 0) : -20))
            return false;
    }
    d->priority = prio;
    return true;
}

KProcess::~KProcess()
{
  if (run_mode != DontCare)
    kill(9);
  detach();

  delete d->pty;
  delete d;

  KProcessController::theKProcessController->removeKProcess(this);
  KProcessController::deref();
}

void KProcess::detach()
{
  if (runs) {
    KProcessController::theKProcessController->addProcess(pid_);
    runs = false;
    pid_ = 0;
    commClose();
  }
}

void KProcess::setBinaryExecutable(const char *filename)
{
   d->executable = filename;
}

bool KProcess::setExecutable(const QString& proc)
{
  if (runs) return false;

  if (proc.isEmpty()) return false;

  if (!arguments.isEmpty())
     arguments.remove(arguments.begin());
  arguments.prepend(QFile::encodeName(proc));

  return true;
}

KProcess &KProcess::operator<<(const QStringList& args)
{
  QStringList::ConstIterator it = args.begin();
  for ( ; it != args.end() ; ++it )
      arguments.append(QFile::encodeName(*it));
  return *this;
}

KProcess &KProcess::operator<<(const QCString& arg)
{
  return operator<< (arg.data());
}

KProcess &KProcess::operator<<(const char* arg)
{
  arguments.append(arg);
  return *this;
}

KProcess &KProcess::operator<<(const QString& arg)
{
  arguments.append(QFile::encodeName(arg));
  return *this;
}

void KProcess::clearArguments()
{
  arguments.clear();
}

bool KProcess::start(RunMode runmode, Communication comm)
{
  if (runs) {
    kdDebug(175) << "Attempted to start an already running process" << endl;
    return false;
  }

  uint n = arguments.count();
  if (n == 0) {
    kdDebug(175) << "Attempted to start a process without arguments" << endl;
    return false;
  }
  char **arglist;
  QCString shellCmd;
  if (d->useShell)
  {
      if (d->shell.isEmpty()) {
        kdDebug(175) << "Invalid shell specified" << endl;
        return false;
      }

      for (uint i = 0; i < n; i++) {
          shellCmd += arguments[i];
          shellCmd += " ";
      }

      arglist = static_cast<char **>(malloc( 4 * sizeof(char *)));
      arglist[0] = d->shell.data();
      arglist[1] = (char *) "-c";
      arglist[2] = shellCmd.data();
      arglist[3] = 0;
  }
  else
  {
      arglist = static_cast<char **>(malloc( (n + 1) * sizeof(char *)));
      for (uint i = 0; i < n; i++)
         arglist[i] = arguments[i].data();
      arglist[n] = 0;
  }

  run_mode = runmode;

  if (!setupCommunication(comm))
  {
      kdDebug(175) << "Could not setup Communication!" << endl;
      free(arglist);
      return false;
  }




  struct passwd *pw = geteuid() ? 0 : getpwuid(getuid());


  int fd[2];
  if (pipe(fd))
     fd[0] = fd[1] = -1;

  QApplication::flushX();




  pid_ = fork();
  if (pid_ == 0) {


        close(fd[0]);

        fcntl(fd[1], 2, 1);


        struct sigaction act;
        sigemptyset(&act.sa_mask);
        act.__sigaction_handler.sa_handler = ((__sighandler_t) 0);
        act.sa_flags = 0;
        for (int sig = 1; sig < 64; sig++)
          sigaction(sig, &act, 0L);

        if (!commSetupDoneC())
          kdDebug(175) << "Could not finish comm setup in child!" << endl;

        if (d->priority)
            setpriority(PRIO_PROCESS, 0, d->priority);

        if (!runPrivileged())
        {
           setgid(getgid());

           if (pw)
              initgroups(pw->pw_name, pw->pw_gid);

           setuid(getuid());
        }

        setupEnvironment();

        if (runmode == DontCare || runmode == OwnGroup)
          setsid();

        const char *executable = arglist[0];
        if (!d->executable.isEmpty())
           executable = d->executable.data();
        execvp(executable, arglist);

        char resultByte = 1;
        write(fd[1], &resultByte, 1);
        _exit(-1);
  } else if (pid_ == -1) {



        pid_ = 0;
        free(arglist);
        return false;
  }

  free(arglist);

  if (!commSetupDoneP())
    kdDebug(175) << "Could not finish comm setup in parent!" << endl;


  close(fd[1]);
  for(;;)
  {
     char resultByte;
     int n = ::read(fd[0], &resultByte, 1);
     if (n == 1)
     {

         close(fd[0]);
         waitpid(pid_, 0, 0);
         pid_ = 0;
         commClose();
         return false;
     }
     if (n == -1)
     {
        if ((*__errno_location ()) == 4)
           continue;
     }
     break;
  }
  close(fd[0]);

  runs = true;
  switch (runmode)
  {
  case Block:
    for (;;)
    {
      commClose();
      if (!runs)
      {

        KProcessController::theKProcessController->unscheduleCheck();
        if (waitpid(pid_, &status, 1) != 0)
        {
          commClose();
          KProcessController::theKProcessController->rescheduleCheck();
          break;
        }
        runs = true;
      }
      else
      {



        waitpid(pid_, &status, 0);
        runs = false;
        break;
      }
    }


    processExited(this);
    break;
  default:
    input_data = 0;
    break;
  }

  return true;
}



bool KProcess::kill(int signo)
{
  if (runs && pid_ > 0 && !::kill(run_mode == OwnGroup ? -pid_ : pid_, signo))
    return true;
  return false;
}



bool KProcess::isRunning() const
{
  return runs;
}



pid_t KProcess::pid() const
{
  return pid_;
}
# 509 "/coolo/prod/kdelibs/kdecore/kprocess.cpp"
bool KProcess::wait(int timeout)
{
  if (!runs)
    return true;




  struct timeval tv, *tvp;
  if (timeout < 0)
    tvp = 0;
  else
  {




    tv.tv_sec = timeout;
    tv.tv_usec = 0;

    tvp = &tv;
  }

  int fd = KProcessController::theKProcessController->notifierFd();
  for(;;)
  {
    fd_set fds;
    memset ((void*)&fds, 0, sizeof (fds));
    FD_SET(fd,&fds);
# 549 "/coolo/prod/kdelibs/kdecore/kprocess.cpp"
    switch( select( fd+1, &fds, 0, 0, tvp ) )
    {
    case -1:
      if( (*__errno_location ()) == 4 )
        break;

    case 0:
      KProcessController::theKProcessController->rescheduleCheck();
      return false;
    default:
      KProcessController::theKProcessController->unscheduleCheck();
      if (waitpid(pid_, &status, 1) != 0)
      {
        processHasExited(status);
        KProcessController::theKProcessController->rescheduleCheck();
        return true;
      }
    }
  }
}



bool KProcess::normalExit() const
{
  return (pid_ != 0) && !runs && ((((*(int *) &(status))) & 0x7f) == 0);
}



int KProcess::exitStatus() const
{
  return ((((*(int *) &(status))) & 0xff00) >> 8);
}



bool KProcess::writeStdin(const char *buffer, int buflen)
{



  if (input_data != 0)
    return false;

  if (communication & Stdin) {
    input_data = buffer;
    input_sent = 0;
    input_total = buflen;
    innot->setEnabled(true);
    if (input_total)
       slotSendData(0);
    return true;
  } else
    return false;
}

void KProcess::suspend()
{
  if (outnot)
     outnot->setEnabled(false);
}

void KProcess::resume()
{
  if (outnot)
     outnot->setEnabled(true);
}

bool KProcess::closeStdin()
{
  if (communication & Stdin) {
    communication = (Communication) (communication & ~Stdin);
    delete innot;
    innot = 0;
    if (!(d->usePty & Stdin))
      close(in[1]);
    in[1] = -1;
    return true;
  } else
    return false;
}

bool KProcess::closeStdout()
{
  if (communication & Stdout) {
    communication = (Communication) (communication & ~Stdout);
    delete outnot;
    outnot = 0;
    if (!(d->usePty & Stdout))
      close(out[0]);
    out[0] = -1;
    return true;
  } else
    return false;
}

bool KProcess::closeStderr()
{
  if (communication & Stderr) {
    communication = (Communication) (communication & ~Stderr);
    delete errnot;
    errnot = 0;
    if (!(d->usePty & Stderr))
      close(err[0]);
    err[0] = -1;
    return true;
  } else
    return false;
}

bool KProcess::closePty()
{
  if (d->pty && d->pty->masterFd() >= 0) {
    if (d->addUtmp)
      d->pty->logout();
    d->pty->close();
    return true;
  } else
    return false;
}

void KProcess::closeAll()
{
  closeStdin();
  closeStdout();
  closeStderr();
  closePty();
}







void KProcess::slotChildOutput(int fdno)
{
  if (!childOutput(fdno))
     closeStdout();
}


void KProcess::slotChildError(int fdno)
{
  if (!childError(fdno))
     closeStderr();
}


void KProcess::slotSendData(int)
{
  if (input_sent == input_total) {
    innot->setEnabled(false);
    input_data = 0;
    wroteStdin(this);
  } else
    input_sent += ::write(in[1], input_data+input_sent, input_total-input_sent);
}

void KProcess::setUseShell(bool useShell, const char *shell)
{
  d->useShell = useShell;
  d->shell = (shell && *shell) ? shell : "/bin/sh";
}

void KProcess::setUsePty(Communication usePty, bool addUtmp)
{
  d->usePty = usePty;
  d->addUtmp = addUtmp;
  if (usePty) {
    if (!d->pty)
      d->pty = new KPty;
  } else {
    delete d->pty;
    d->pty = 0;
  }
}

KPty *KProcess::pty() const
{
  return d->pty;
}

QString KProcess::quote(const QString &arg)
{
    QChar q('\'');
    return QString(arg).replace(q, "'\\''").prepend(q).append(q);
}







void KProcess::processHasExited(int state)
{


    status = state;
    runs = false;

    commClose();

    if (run_mode != DontCare)
      processExited(this);
}



int KProcess::childOutput(int fdno)
{
  if (communication & NoRead) {
     int len = -1;
     receivedStdout(fdno, len);
     (*__errno_location ()) = 0;
     return len;
  }
  else
  {
     char buffer[1025];
     int len;

     len = ::read(fdno, buffer, 1024);

     if (len > 0) {
        buffer[len] = 0;
        receivedStdout(this, buffer, len);
     }
     return len;
  }
}

int KProcess::childError(int fdno)
{
  char buffer[1025];
  int len;

  len = ::read(fdno, buffer, 1024);

  if (len > 0) {
     buffer[len] = 0;
     receivedStderr(this, buffer, len);
  }
  return len;
}


int KProcess::setupCommunication(Communication comm)
{

  if (d->usePty)
  {

    if (!(~(comm & d->usePty) & (Stdout | Stderr))) {
       kdWarning(175) << "Invalid usePty/communication combination (" << d->usePty << "/" << comm << ")" << endl;
       return 0;
    }
    if (!d->pty->open())
       return 0;

    int rcomm = comm & d->usePty;
    int mfd = d->pty->masterFd();
    if (rcomm & Stdin)
      in[1] = mfd;
    if (rcomm & Stdout)
      out[0] = mfd;
    if (rcomm & Stderr)
      err[0] = mfd;


    d->user = getlogin();
    if (!d->user)
      d->user = getenv("LOGNAME");
  }

  communication = comm;

  comm = (Communication) (comm & ~d->usePty);
  if (comm & Stdin) {
    if (socketpair(1, SOCK_STREAM, 0, in))
      goto fail0;
    fcntl(in[0], 2, 1);
    fcntl(in[1], 2, 1);
  }
  if (comm & Stdout) {
    if (socketpair(1, SOCK_STREAM, 0, out))
      goto fail1;
    fcntl(out[0], 2, 1);
    fcntl(out[1], 2, 1);
  }
  if (comm & Stderr) {
    if (socketpair(1, SOCK_STREAM, 0, err))
      goto fail2;
    fcntl(err[0], 2, 1);
    fcntl(err[1], 2, 1);
  }
  return 1;
 fail2:
  if (comm & Stdout)
  {
    close(out[0]);
    close(out[1]);
    out[0] = out[1] = -1;
  }
 fail1:
  if (comm & Stdin)
  {
    close(in[0]);
    close(in[1]);
    in[0] = in[1] = -1;
  }
 fail0:
  communication = NoCommunication;
  return 0;
}



int KProcess::commSetupDoneP()
{
  int rcomm = communication & ~d->usePty;
  if (rcomm & Stdin)
    close(in[0]);
  if (rcomm & Stdout)
    close(out[1]);
  if (rcomm & Stderr)
    close(err[1]);
  in[0] = out[1] = err[1] = -1;


  if (run_mode != NotifyOnExit && run_mode != OwnGroup)
    return 1;

  if (communication & Stdin) {
    innot = new QSocketNotifier(in[1], QSocketNotifier::Write, this);
    (qt_check_pointer((innot)==0,"/coolo/prod/kdelibs/kdecore/kprocess.cpp",886));
    innot->setEnabled(false);
    QObject::connect(innot, "2""activated(int)",
                     this, "1""slotSendData(int)");
  }

  if (communication & Stdout) {
    outnot = new QSocketNotifier(out[0], QSocketNotifier::Read, this);
    (qt_check_pointer((outnot)==0,"/coolo/prod/kdelibs/kdecore/kprocess.cpp",894));
    QObject::connect(outnot, "2""activated(int)",
                     this, "1""slotChildOutput(int)");
    if (communication & NoRead)
        suspend();
  }

  if (communication & Stderr) {
    errnot = new QSocketNotifier(err[0], QSocketNotifier::Read, this );
    (qt_check_pointer((errnot)==0,"/coolo/prod/kdelibs/kdecore/kprocess.cpp",903));
    QObject::connect(errnot, "2""activated(int)",
                     this, "1""slotChildError(int)");
  }

  return 1;
}



int KProcess::commSetupDoneC()
{
  int ok = 1;

  if (d->usePty & Stdin) {
    if (dup2(d->pty->slaveFd(), 0) < 0) ok = 0;
  } else if (communication & Stdin) {
    if (dup2(in[0], 0) < 0) ok = 0;
  } else {
    int null_fd = open( "/dev/null", 00 );
    if (dup2( null_fd, 0 ) < 0) ok = 0;
    close( null_fd );
  }
  struct linger so;
  memset(&so, 0, sizeof(so));
  if (d->usePty & Stdout) {
    if (dup2(d->pty->slaveFd(), 1) < 0) ok = 0;
  } else if (communication & Stdout) {
    if (dup2(out[1], 1) < 0 ||
        setsockopt(out[1], 1, 13, (char *)&so, sizeof(so)))
      ok = 0;
  }
  if (d->usePty & Stderr) {
    if (dup2(d->pty->slaveFd(), 2) < 0) ok = 0;
  } else if (communication & Stderr) {
    if (dup2(err[1], 2) < 0 ||
        setsockopt(err[1], 1, 13, (char *)&so, sizeof(so)))
      ok = 0;
  }




  if (d->usePty) {
    d->pty->setCTty();
    if (d->addUtmp)
      d->pty->login(d->user, getenv("DISPLAY"));
  }

  return ok;
}



void KProcess::commClose()
{
  closeStdin();

  if (pid_) {




    int notfd = KProcessController::theKProcessController->notifierFd();

    while ((communication & (Stdout | Stderr)) || runs) {
      fd_set rfds;
      memset ((void*)&rfds, 0, sizeof(rfds));
      struct timeval timeout, *p_timeout;

      int max_fd = 0;
      if (communication & Stdout) {
        FD_SET(out[0], &rfds);
        max_fd = out[0];
      }
      if (communication & Stderr) {
        FD_SET(err[0], &rfds);
        if (err[0] > max_fd)
          max_fd = err[0];
      }
      if (runs) {
        FD_SET(notfd, &rfds);
        if (notfd > max_fd)
          max_fd = notfd;


        p_timeout = 0;
      } else {


        timeout.tv_sec = timeout.tv_usec = 0;
        p_timeout = &timeout;
      }

      int fds_ready = select(max_fd+1, &rfds, 0, 0, p_timeout);
      if (fds_ready < 0) {
        if ((*__errno_location ()) == 4)
          continue;
        break;
      } else if (!fds_ready)
        break;

      if ((communication & Stdout) && FD_ISSET(out[0], &rfds))
        slotChildOutput(out[0]);

      if ((communication & Stderr) && FD_ISSET(err[0], &rfds))
        slotChildError(err[0]);

      if (runs && FD_ISSET (notfd, &rfds)) {
        runs = false;
        return;
      }
    }
  }

  closeStdout();
  closeStderr();

  closePty();
}


void KProcess::virtual_hook( int, void* )
{ }






KShellProcess::KShellProcess(const char *shellname):
  KProcess()
{
  setUseShell( true, shellname ? shellname : getenv("SHELL") );
}

KShellProcess::~KShellProcess() {
}

QString KShellProcess::quote(const QString &arg)
{
    return KProcess::quote(arg);
}

bool KShellProcess::start(RunMode runmode, Communication comm)
{
  return KProcess::start(runmode, comm);
}

void KShellProcess::virtual_hook( int id, void* data )
{ KProcess::virtual_hook( id, data ); }

# 1 "../kdecore/kprocess.moc" 1
# 11 "../kdecore/kprocess.moc"
# 1 "../../../prod/kdelibs/kdecore/kprocess.h" 1
# 12 "../kdecore/kprocess.moc" 2
# 22 "../kdecore/kprocess.moc"
const char *KProcess::className() const
{
    return "KProcess";
}

QMetaObject *KProcess::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KProcess( "KProcess", &KProcess::staticMetaObject );
# 50 "../kdecore/kprocess.moc"
QMetaObject* KProcess::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { "fdno", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_0 = {"slotChildOutput", 1, param_slot_0 };
    static const QUParameter param_slot_1[] = {
        { "fdno", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_1 = {"slotChildError", 1, param_slot_1 };
    static const QUParameter param_slot_2[] = {
        { "dummy", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_2 = {"slotSendData", 1, param_slot_2 };
    static const QMetaData slot_tbl[] = {
        { "slotChildOutput(int)", &slot_0, QMetaData::Protected },
        { "slotChildError(int)", &slot_1, QMetaData::Protected },
        { "slotSendData(int)", &slot_2, QMetaData::Protected }
    };
    static const QUParameter param_signal_0[] = {
        { "proc", &static_QUType_ptr, "KProcess", QUParameter::In }
    };
    static const QUMethod signal_0 = {"processExited", 1, param_signal_0 };
    static const QUParameter param_signal_1[] = {
        { "proc", &static_QUType_ptr, "KProcess", QUParameter::In },
        { "buffer", &static_QUType_charstar, 0, QUParameter::In },
        { "buflen", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_1 = {"receivedStdout", 3, param_signal_1 };
    static const QUParameter param_signal_2[] = {
        { "fd", &static_QUType_int, 0, QUParameter::In },
        { "len", &static_QUType_int, 0, QUParameter::InOut }
    };
    static const QUMethod signal_2 = {"receivedStdout", 2, param_signal_2 };
    static const QUParameter param_signal_3[] = {
        { "proc", &static_QUType_ptr, "KProcess", QUParameter::In },
        { "buffer", &static_QUType_charstar, 0, QUParameter::In },
        { "buflen", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_3 = {"receivedStderr", 3, param_signal_3 };
    static const QUParameter param_signal_4[] = {
        { "proc", &static_QUType_ptr, "KProcess", QUParameter::In }
    };
    static const QUMethod signal_4 = {"wroteStdin", 1, param_signal_4 };
    static const QMetaData signal_tbl[] = {
        { "processExited(KProcess*)", &signal_0, QMetaData::Public },
        { "receivedStdout(KProcess*,char*,int)", &signal_1, QMetaData::Public },
        { "receivedStdout(int,int&)", &signal_2, QMetaData::Public },
        { "receivedStderr(KProcess*,char*,int)", &signal_3, QMetaData::Public },
        { "wroteStdin(KProcess*)", &signal_4, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KProcess", parentObject,
        slot_tbl, 3,
        signal_tbl, 5,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KProcess.setMetaObject( metaObj );
    return metaObj;
}

void* KProcess::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KProcess" ) )
        return this;
    return QObject::qt_cast( clname );
}





void KProcess::processExited( KProcess* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 0 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}


void KProcess::receivedStdout( KProcess* t0, char* t1, int t2 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 1 );
    if ( !clist )
        return;
    QUObject o[4];
    static_QUType_ptr.set(o+1,t0);
    static_QUType_charstar.set(o+2,t1);
    static_QUType_int.set(o+3,t2);
    activate_signal( clist, o );
}


void KProcess::receivedStdout( int t0, int& t1 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 2 );
    if ( !clist )
        return;
    QUObject o[3];
    static_QUType_int.set(o+1,t0);
    static_QUType_int.set(o+2,t1);
    activate_signal( clist, o );
    t1 = static_QUType_int.get(o+2);
}


void KProcess::receivedStderr( KProcess* t0, char* t1, int t2 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 3 );
    if ( !clist )
        return;
    QUObject o[4];
    static_QUType_ptr.set(o+1,t0);
    static_QUType_charstar.set(o+2,t1);
    static_QUType_int.set(o+3,t2);
    activate_signal( clist, o );
}


void KProcess::wroteStdin( KProcess* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 4 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}

bool KProcess::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotChildOutput((int)static_QUType_int.get(_o+1)); break;
    case 1: slotChildError((int)static_QUType_int.get(_o+1)); break;
    case 2: slotSendData((int)static_QUType_int.get(_o+1)); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KProcess::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: processExited((KProcess*)static_QUType_ptr.get(_o+1)); break;
    case 1: receivedStdout((KProcess*)static_QUType_ptr.get(_o+1),(char*)static_QUType_charstar.get(_o+2),(int)static_QUType_int.get(_o+3)); break;
    case 2: receivedStdout((int)static_QUType_int.get(_o+1),(int&)static_QUType_int.get(_o+2)); break;
    case 3: receivedStderr((KProcess*)static_QUType_ptr.get(_o+1),(char*)static_QUType_charstar.get(_o+2),(int)static_QUType_int.get(_o+3)); break;
    case 4: wroteStdin((KProcess*)static_QUType_ptr.get(_o+1)); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KProcess::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KProcess::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }



const char *KShellProcess::className() const
{
    return "KShellProcess";
}

QMetaObject *KShellProcess::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KShellProcess( "KShellProcess", &KShellProcess::staticMetaObject );
# 262 "../kdecore/kprocess.moc"
QMetaObject* KShellProcess::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KProcess::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KShellProcess", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KShellProcess.setMetaObject( metaObj );
    return metaObj;
}

void* KShellProcess::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KShellProcess" ) )
        return this;
    return KProcess::qt_cast( clname );
}

bool KShellProcess::qt_invoke( int _id, QUObject* _o )
{
    return KProcess::qt_invoke(_id,_o);
}

bool KShellProcess::qt_emit( int _id, QUObject* _o )
{
    return KProcess::qt_emit(_id,_o);
}


bool KShellProcess::qt_property( int id, int f, QVariant* v)
{
    return KProcess::qt_property( id, f, v);
}

bool KShellProcess::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 1056 "/coolo/prod/kdelibs/kdecore/kprocess.cpp" 2
# 18 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kprocctrl.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kprocctrl.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/kprocctrl.cpp" 2





# 1 "/usr/include/errno.h" 1 3 4
# 30 "/coolo/prod/kdelibs/kdecore/kprocctrl.cpp" 2






KProcessController *KProcessController::theKProcessController;
int KProcessController::refCount;

void KProcessController::ref()
{
  if( !refCount )
    theKProcessController = new KProcessController;
  refCount++;
}

void KProcessController::deref()
{
  refCount--;
  if( !refCount ) {
    delete theKProcessController;
    theKProcessController = 0;
  }
}

KProcessController::KProcessController()
  : needcheck( false )
{
  if( pipe( fd ) )
  {
    perror( "pipe" );
    abort();
  }

  fcntl( fd[0], 4, 04000 );
  fcntl( fd[1], 4, 04000 );
  fcntl( fd[0], 2, 1 );
  fcntl( fd[1], 2, 1 );

  notifier = new QSocketNotifier( fd[0], QSocketNotifier::Read );
  notifier->setEnabled( true );
  QObject::connect( notifier, "2""activated(int)",
                    "1""slotDoHousekeeping()");

  setupHandlers();
}

KProcessController::~KProcessController()
{
  resetHandlers();

  delete notifier;

  close( fd[0] );
  close( fd[1] );
}


struct sigaction KProcessController::oldChildHandlerData;
bool KProcessController::handlerSet = false;

void KProcessController::setupHandlers()
{
  if( handlerSet )
      return;
  handlerSet = true;

  struct sigaction act;
  sigemptyset( &act.sa_mask );

  act.__sigaction_handler.sa_handler = ((__sighandler_t) 1);
  act.sa_flags = 0;
  sigaction( 13, &act, 0L );

  act.__sigaction_handler.sa_handler = theSigCHLDHandler;
  act.sa_flags = 1;



  act.sa_flags |= 0x10000000;

  sigaction( 17, &act, &oldChildHandlerData );

  sigaddset( &act.sa_mask, 17 );

  sigprocmask( 1, &act.sa_mask, 0 );
}

void KProcessController::resetHandlers()
{
  if( !handlerSet )
      return;
  handlerSet = false;

  sigaction( 17, &oldChildHandlerData, 0 );

}




void KProcessController::theSigCHLDHandler( int arg )
{
  int saved_errno = (*__errno_location ());

  char dummy = 0;
  ::write( theKProcessController->fd[1], &dummy, 1 );

  if( oldChildHandlerData.__sigaction_handler.sa_handler != ((__sighandler_t) 1) &&
      oldChildHandlerData.__sigaction_handler.sa_handler != ((__sighandler_t) 0) )
     oldChildHandlerData.__sigaction_handler.sa_handler( arg );

  (*__errno_location ()) = saved_errno;
}

int KProcessController::notifierFd() const
{
  return fd[0];
}

void KProcessController::unscheduleCheck()
{
  char dummy[16];
  if( ::read( fd[0], dummy, sizeof(dummy) ) > 0 )
    needcheck = true;
}

void
KProcessController::rescheduleCheck()
{
  if( needcheck )
  {
    needcheck = false;
    char dummy = 0;
    ::write( fd[1], &dummy, 1 );
  }
}

void KProcessController::slotDoHousekeeping()
{
  char dummy[16];
  ::read( fd[0], dummy, sizeof(dummy) );

  int status;
 again:
  QValueListIterator<KProcess*> it( kProcessList.begin() );
  QValueListIterator<KProcess*> eit( kProcessList.end() );
  while( it != eit )
  {
    KProcess *prc = *it;
    if( prc->runs && waitpid( prc->pid_, &status, 1 ) > 0 )
    {
      prc->processHasExited( status );

      if (!theKProcessController)
        return;
      goto again;
    }
    ++it;
  }
  QValueListIterator<int> uit( unixProcessList.begin() );
  QValueListIterator<int> ueit( unixProcessList.end() );
  while( uit != ueit )
  {
    if( waitpid( *uit, 0, 1 ) > 0 )
    {
      uit = unixProcessList.remove( uit );
      deref();
    } else
      ++uit;
  }
}

bool KProcessController::waitForProcessExit( int timeout )
{
  for(;;)
  {
    struct timeval tv, *tvp;
    if (timeout < 0)
      tvp = 0;
    else
    {
      tv.tv_sec = timeout;
      tv.tv_usec = 0;
      tvp = &tv;
    }

    fd_set fds;
    memset ((void*)&fds, 0, sizeof(fds));
    FD_SET(fd[0], &fds);

    switch( select( fd[0]+1, &fds, 0, 0, tvp ) )
    {
    case -1:
      if( (*__errno_location ()) == 4 )
        continue;

    case 0:
      return false;
    default:
      slotDoHousekeeping();
      return true;
    }
  }
}

void KProcessController::addKProcess( KProcess* p )
{
  kProcessList.append( p );
}

void KProcessController::removeKProcess( KProcess* p )
{
  kProcessList.remove( p );
}

void KProcessController::addProcess( int pid )
{
  unixProcessList.append( pid );
  ref();
}

# 1 "../kdecore/kprocctrl.moc" 1
# 11 "../kdecore/kprocctrl.moc"
# 1 "../../../prod/kdelibs/kdecore/kprocctrl.h" 1
# 12 "../kdecore/kprocctrl.moc" 2
# 22 "../kdecore/kprocctrl.moc"
const char *KProcessController::className() const
{
    return "KProcessController";
}

QMetaObject *KProcessController::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KProcessController( "KProcessController", &KProcessController::staticMetaObject );
# 50 "../kdecore/kprocctrl.moc"
QMetaObject* KProcessController::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod slot_0 = {"slotDoHousekeeping", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "slotDoHousekeeping()", &slot_0, QMetaData::Private }
    };
    metaObj = QMetaObject::new_metaobject(
        "KProcessController", parentObject,
        slot_tbl, 1,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KProcessController.setMetaObject( metaObj );
    return metaObj;
}

void* KProcessController::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KProcessController" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KProcessController::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotDoHousekeeping(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KProcessController::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KProcessController::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KProcessController::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 253 "/coolo/prod/kdelibs/kdecore/kprocctrl.cpp" 2
# 19 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/klocale.cpp" 1
# 24 "/coolo/prod/kdelibs/kdecore/klocale.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 25 "/coolo/prod/kdelibs/kdecore/klocale.cpp" 2





# 1 "/coolo/prod/qt-copy/include/qprinter.h" 1
# 39 "/coolo/prod/qt-copy/include/qprinter.h"
# 50 "/coolo/prod/qt-copy/include/qprinter.h"
#undef B0


class QPrinterPrivate;

class QPrinter : public QPaintDevice
{
public:
    enum PrinterMode { ScreenResolution, PrinterResolution, HighResolution, Compatible };

    QPrinter( PrinterMode mode = ScreenResolution );
   ~QPrinter();

    enum Orientation { Portrait, Landscape };

    enum PageSize { A4, B5, Letter, Legal, Executive,
                       A0, A1, A2, A3, A5, A6, A7, A8, A9, B0, B1,
                       B10, B2, B3, B4, B6, B7, B8, B9, C5E, Comm10E,
                       DLE, Folio, Ledger, Tabloid, Custom, NPageSize = Custom };

    enum PageOrder { FirstPageFirst, LastPageFirst };

    enum ColorMode { GrayScale, Color };

    enum PaperSource { OnlyOne, Lower, Middle, Manual, Envelope,
                       EnvelopeManual, Auto, Tractor, SmallFormat,
                       LargeFormat, LargeCapacity, Cassette, FormSource };

    enum PrintRange { AllPages,
                        Selection,
                        PageRange };

    enum PrinterOption { PrintToFile,
                         PrintSelection,
                         PrintPageRange };

    QString printerName() const;
    virtual void setPrinterName( const QString &);
    bool outputToFile() const;
    virtual void setOutputToFile( bool );
    QString outputFileName()const;
    virtual void setOutputFileName( const QString &);

    QString printProgram() const;
    virtual void setPrintProgram( const QString &);

    QString printerSelectionOption() const;
    virtual void setPrinterSelectionOption( const QString & );

    QString docName() const;
    virtual void setDocName( const QString &);
    QString creator() const;
    virtual void setCreator( const QString &);

    Orientation orientation() const;
    virtual void setOrientation( Orientation );
    PageSize pageSize() const;
    virtual void setPageSize( PageSize );
# 116 "/coolo/prod/qt-copy/include/qprinter.h"
    virtual void setPageOrder( PageOrder );
    PageOrder pageOrder() const;

    void setResolution( int );
    int resolution() const;

    virtual void setColorMode( ColorMode );
    ColorMode colorMode() const;

    virtual void setFullPage( bool );
    bool fullPage() const;
    QSize margins() const;
    void setMargins( uint top, uint left, uint bottom, uint right );
    void margins( uint *top, uint *left, uint *bottom, uint *right ) const;

    int fromPage() const;
    int toPage() const;
    virtual void setFromTo( int fromPage, int toPage );
    int minPage() const;
    int maxPage() const;
    virtual void setMinMax( int minPage, int maxPage );
    int numCopies() const;
    virtual void setNumCopies( int );

    bool collateCopiesEnabled() const;
    void setCollateCopiesEnabled(bool );

    bool collateCopies() const;
    void setCollateCopies( bool );

    PrintRange printRange() const;
    void setPrintRange( PrintRange range );

    bool newPage();
    bool abort();
    bool aborted() const;

    bool setup( QWidget *parent = 0 );

    PaperSource paperSource() const;
    virtual void setPaperSource( PaperSource );

    void setOptionEnabled( PrinterOption, bool enable );
    bool isOptionEnabled( PrinterOption );

protected:
    bool cmd( int, QPainter *, QPDevCmdParam * );
    int metric( int ) const;






private:

    QPaintDevice *pdrv;
    int pid;
# 198 "/coolo/prod/qt-copy/include/qprinter.h"
    int state;
    QString printer_name;
    QString option_string;
    QString output_filename;
    bool output_file;
    QString print_prog;
    QString doc_name;
    QString creator_name;

    PageSize page_size;
    PaperSource paper_source;
    PageOrder page_order;
    ColorMode color_mode;
    Orientation orient;
    uint to_edge : 1;
    uint appcolcopies : 1;
    uint usercolcopies : 1;
    uint res_set : 1;
    short from_pg, to_pg;
    short min_pg, max_pg;
    short ncopies;
    int res;
    QPrinterPrivate *d;

private:

    QPrinter( const QPrinter & );
    QPrinter &operator=( const QPrinter & );

};


inline QString QPrinter::printerName() const
{ return printer_name; }

inline bool QPrinter::outputToFile() const
{ return output_file; }

inline QString QPrinter::outputFileName() const
{ return output_filename; }

inline QString QPrinter::printProgram() const
{ return print_prog; }

inline QString QPrinter::docName() const
{ return doc_name; }

inline QString QPrinter::creator() const
{ return creator_name; }

inline QPrinter::PageSize QPrinter::pageSize() const
{ return page_size; }

inline QPrinter::Orientation QPrinter::orientation() const
{ return orient; }

inline int QPrinter::fromPage() const
{ return from_pg; }

inline int QPrinter::toPage() const
{ return to_pg; }

inline int QPrinter::minPage() const
{ return min_pg; }

inline int QPrinter::maxPage() const
{ return max_pg; }

inline int QPrinter::numCopies() const
{ return ncopies; }

inline bool QPrinter::collateCopiesEnabled() const
{ return appcolcopies; }

inline void QPrinter::setCollateCopiesEnabled(bool v)
{ appcolcopies = v; }

inline bool QPrinter::collateCopies() const
{ return usercolcopies; }
# 31 "/coolo/prod/kdelibs/kdecore/klocale.cpp" 2




# 1 "/coolo/prod/kdelibs/kdecore/kcatalogue.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kcatalogue.h"



struct kde_loaded_l10nfile;

class KCataloguePrivate;
# 36 "/coolo/prod/kdelibs/kdecore/kcatalogue.h"
class KCatalogue
{
public:





  explicit KCatalogue(const QString & name = QString::null);




  KCatalogue(const KCatalogue & rhs);




  KCatalogue & operator = ( const KCatalogue & rhs);




  virtual ~KCatalogue();






  QString name() const;







  void setFileName( const QString & fileName );
# 85 "/coolo/prod/kdelibs/kdecore/kcatalogue.h"
  const char * translate( const char * msgid ) const;

private:





  QString fileName() const;




  void doUnload();

private:
  KCataloguePrivate * d;
};
# 36 "/coolo/prod/kdelibs/kdecore/klocale.cpp" 2






# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"




class KLocale;

class KCalendarSystemPrivate;
# 42 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
class KCalendarSystem
{
public:





  KCalendarSystem(const KLocale * locale = 0);




  virtual ~KCalendarSystem();







  virtual int year (const QDate & date) const = 0;
# 72 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString yearString(const QDate & pDate, bool bShort) const;
# 81 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual int yearStringToInteger(const QString & sNum, int & iLength) const;







  virtual int month (const QDate & date) const = 0;
# 98 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString monthString(const QDate & pDate, bool bShort) const;
# 107 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual int monthStringToInteger(const QString & sNum, int & iLength) const;







  virtual int day (const QDate & date) const = 0;
# 124 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString dayString(const QDate & pDate, bool bShort) const;
# 133 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual int dayStringToInteger(const QString & sNum, int & iLength) const;
# 142 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual int dayOfWeek (const QDate & date) const = 0;







  virtual int dayOfYear (const QDate & date) const = 0;
# 162 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual bool setYMD(QDate & date, int y, int m, int d) const = 0;
# 171 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QDate addYears(const QDate & date, int nyears) const = 0;
# 180 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QDate addMonths(const QDate & date, int nmonths) const = 0;
# 189 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QDate addDays(const QDate & date, int ndays) const = 0;







  virtual int monthsInYear (const QDate & date) const = 0;







  virtual int daysInYear (const QDate & date) const = 0;







  virtual int daysInMonth (const QDate & date) const = 0;







  virtual int weeksInYear(int year) const = 0;







  virtual int weekNumber(const QDate& date, int * yearNum = 0) const = 0;
# 238 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString yearLiteral (int year) const = 0;
# 248 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString yearLiteral (const QDate & date) const = 0;
# 259 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString monthName (int month, int year, bool shortName = false) const = 0;
# 268 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString monthName (const QDate & date, bool shortName = false ) const = 0;
# 282 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString monthNamePossessive(int month, int year, bool shortName = false) const = 0;
# 294 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString monthNamePossessive(const QDate & date, bool shortName = false) const = 0;
# 304 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString weekDayName (int weekDay, bool shortName = false) const = 0;
# 313 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.h"
  virtual QString weekDayName (const QDate & date, bool shortName = false) const = 0;







  virtual int minValidYear () const = 0;







  virtual int maxValidYear () const = 0;






  virtual int weekDayOfPray () const = 0;




  virtual QString calendarName() const = 0;






  virtual bool isLunar() const = 0;






  virtual bool isLunisolar() const = 0;






  virtual bool isSolar() const = 0;

protected:
  const KLocale * locale() const;

private:
  KCalendarSystemPrivate * d;
};
# 43 "/coolo/prod/kdelibs/kdecore/klocale.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemfactory.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kcalendarsystemfactory.h"




class KCalendarSystem;
class KLocale;







class KCalendarSystemFactory
{
public:
  KCalendarSystemFactory ();
  ~KCalendarSystemFactory ();
# 52 "/coolo/prod/kdelibs/kdecore/kcalendarsystemfactory.h"
  static KCalendarSystem *create (const QString & calType = QString::fromLatin1("gregorian"),
                                  const KLocale * locale = 0);






  static QStringList calendarSystems();

private:
};
# 44 "/coolo/prod/kdelibs/kdecore/klocale.cpp" 2


static const char * const SYSTEM_MESSAGES = "kdelibs";

static const char *maincatalogue = 0;

class KLocalePrivate
{
public:
  int weekStartDay;
  int plural_form;
  bool nounDeclension;
  bool dateMonthNamePossessive;
  QStringList languageList;
  QValueList<KCatalogue> catalogues;
  QString encoding;
  QTextCodec * codecForEncoding;
  KConfig * config;
  bool formatInited;
  int pageSize;
  KLocale::MeasureSystem measureSystem;
  QStringList langTwoAlpha;
  KConfig *languages;

  QString calendarType;
  KCalendarSystem * calendar;
  QString first_language;
  bool utf8FileEncoding;
};

static KLocale *this_klocale = 0;

KLocale::KLocale( const QString & catalogue, KConfig * config )
{
  d = new KLocalePrivate;
  d->config = config;
  d->languages = 0;
  d->calendar = 0;

  initCatalogue(catalogue);
  initEncoding(0);
  initFileNameEncoding(0);

  KConfig *cfg = d->config;
  this_klocale = this;
  if (!cfg) cfg = KGlobal::instance()->config();
  this_klocale = 0;
  ((cfg) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","cfg","/coolo/prod/kdelibs/kdecore/klocale.cpp",91));

  if (m_language.isEmpty())
     initLanguage(cfg, config == 0);
}

QString KLocale::_initLanguage(KConfigBase *config)
{
  if (this_klocale)
  {

     this_klocale->initLanguage((KConfig *) config, true);
     return this_klocale->language();
  }
  return QString::null;
}

void KLocale::initCatalogue(const QString & catalogue)
{

  QString mainCatalogue = catalogue;
  if (maincatalogue)
    mainCatalogue = QString::fromLatin1(maincatalogue);

  if (mainCatalogue.isEmpty()) {
    kdDebug(173) << "KLocale instance created called without valid "
                 << "catalogue! Give an argument or call setMainCatalogue "
                 << "before init" << endl;
  }
  else
    d->catalogues.append( KCatalogue(mainCatalogue ) );


  d->catalogues.append( KCatalogue( SYSTEM_MESSAGES ) );
  d->catalogues.append( KCatalogue( "kio" ) );
}

void KLocale::initLanguage(KConfig * config, bool useEnv)
{
  KConfigGroupSaver saver(config, "Locale");

  m_country = config->readEntry( "Country" );
  if ( m_country.isEmpty() )
    m_country = defaultCountry();


  QStringList languageList;
  if ( useEnv )
    languageList += QStringList::split
      (':', QFile::decodeName( ::getenv("KDE_LANG") ));

  languageList += config->readListEntry("Language", ':');


  if ( useEnv )
    {

      QStringList langs;

      langs << QFile::decodeName( ::getenv("LC_ALL") );
      langs << QFile::decodeName( ::getenv("LC_MESSAGES") );
      langs << QFile::decodeName( ::getenv("LANG") );
      langs << QFile::decodeName( ::getenv("LC_CTYPE") );

      for ( QStringList::Iterator it = langs.begin();
            it != langs.end();
            ++it )
        {
          QString ln, ct, chrset;
          splitLocale(*it, ln, ct, chrset);

          if (!ct.isEmpty()) {
            langs.insert(it, ln + '_' + ct);
            if (!chrset.isEmpty())
              langs.insert(it, ln + '_' + ct + '.' + chrset);
          }

          langs.insert(it, ln);
        }

      languageList += langs;
    }


  setLanguage( languageList );
}

void KLocale::doBindInit()
{
  for ( QValueList<KCatalogue>::Iterator it = d->catalogues.begin();
        it != d->catalogues.end();
        ++it )
    initCatalogue( *it );

  if ( useDefaultLanguage() )
    d->plural_form = -1;
  else
    {
      QString pf = translate_priv
        ( ("_: Dear translator, please do not translate this string " "in any form, but pick the _right_ value out of " "NoPlural/TwoForms/French... If not sure what to do mail " "thd@kde.org and coolo@kde.org, they will tell you. " "Better leave that out if unsure, the programs will " "crash!!\nDefinition of PluralForm - to be set by the " "translator of kdelibs.po"), 0);






      if ( pf.isEmpty() ) {
        kdWarning(173) << "found no definition of PluralForm for " << m_language << endl;
        d->plural_form = -1;
      } else if ( pf == "NoPlural" )
        d->plural_form = 0;
      else if ( pf == "TwoForms" )
        d->plural_form = 1;
      else if ( pf == "French" )
        d->plural_form = 2;
      else if ( pf == "OneTwoRest" || pf == "Gaeilge" )
        d->plural_form = 3;
      else if ( pf == "Russian" )
        d->plural_form = 4;
      else if ( pf == "Polish" )
        d->plural_form = 5;
      else if ( pf == "Slovenian" )
        d->plural_form = 6;
      else if ( pf == "Lithuanian" )
        d->plural_form = 7;
      else if ( pf == "Czech" )
        d->plural_form = 8;
      else if ( pf == "Slovak" )
        d->plural_form = 9;
      else if ( pf == "Maltese" )
        d->plural_form = 10;
      else if ( pf == "Arabic" )
        d->plural_form = 11;
      else if ( pf == "Balcan" )
        d->plural_form = 12;
      else if ( pf == "Macedonian" )
        d->plural_form = 13;
      else {
        kdWarning(173) << "Definition of PluralForm is none of "
                       << "NoPlural/"
                       << "TwoForms/"
                       << "French/"
                       << "OneTwoRest/"
                       << "Russian/"
                       << "Polish/"
                       << "Slovenian/"
                       << "Lithuanian/"
                       << "Czech/"
                       << "Slovak/"
                       << "Arabic/"
                       << "Balcan/"
                       << "Macedonian/"
                       << "Maltese: " << pf << endl;
        exit(1);
      }
    }

  d->formatInited = false;
}

void KLocale::doFormatInit() const
{
  if ( d->formatInited ) return;

  KLocale * that = const_cast<KLocale *>(this);
  that->initFormat();

  d->formatInited = true;
}

void KLocale::initFormat()
{
  KConfig *config = d->config;
  if (!config) config = KGlobal::instance()->config();
  ((config) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","config","/coolo/prod/kdelibs/kdecore/klocale.cpp",265));

  kdDebug(173) << "KLocale::initFormat" << endl;




  KLocale *lsave = KGlobal::_locale;
  KGlobal::_locale = this;

  KConfigGroupSaver saver(config, "Locale");

  KSimpleConfig entry(locate("locale",
                             QString::fromLatin1("l10n/%1/entry.desktop")
                             .arg(m_country)), true);
  entry.setGroup("KCM Locale");











  m_decimalSymbol = entry.readEntry("DecimalSymbol", QString::fromLatin1(".")); m_decimalSymbol = config->readEntry("DecimalSymbol", m_decimalSymbol);;
  m_thousandsSeparator = entry.readEntry("ThousandsSeparator", QString::fromLatin1(",")); m_thousandsSeparator = config->readEntry("ThousandsSeparator", m_thousandsSeparator);;
  m_thousandsSeparator.replace( QString::fromLatin1("$0"), QString::null );


  m_positiveSign = entry.readEntry("PositiveSign", QString::fromLatin1("")); m_positiveSign = config->readEntry("PositiveSign", m_positiveSign);;
  m_negativeSign = entry.readEntry("NegativeSign", QString::fromLatin1("-")); m_negativeSign = config->readEntry("NegativeSign", m_negativeSign);;


  m_currencySymbol = entry.readEntry("CurrencySymbol", QString::fromLatin1("$")); m_currencySymbol = config->readEntry("CurrencySymbol", m_currencySymbol);;
  m_monetaryDecimalSymbol = entry.readEntry("MonetaryDecimalSymbol", QString::fromLatin1(".")); m_monetaryDecimalSymbol = config->readEntry("MonetaryDecimalSymbol", m_monetaryDecimalSymbol);;
  m_monetaryThousandsSeparator = entry.readEntry("MonetaryThousandsSeparator", QString::fromLatin1(",")); m_monetaryThousandsSeparator = config->readEntry("MonetaryThousandsSeparator", m_monetaryThousandsSeparator);;

  m_monetaryThousandsSeparator.replace(QString::fromLatin1("$0"), QString::null);

  m_fracDigits = (int)entry.readNumEntry("FracDigits", 2); m_fracDigits = (int)config->readNumEntry("FracDigits", m_fracDigits);;
  m_positivePrefixCurrencySymbol = entry.readBoolEntry("PositivePrefixCurrencySymbol", true); m_positivePrefixCurrencySymbol = config->readBoolEntry("PositivePrefixCurrencySymbol", m_positivePrefixCurrencySymbol);;

  m_negativePrefixCurrencySymbol = entry.readBoolEntry("NegativePrefixCurrencySymbol", true); m_negativePrefixCurrencySymbol = config->readBoolEntry("NegativePrefixCurrencySymbol", m_negativePrefixCurrencySymbol);;

  m_positiveMonetarySignPosition = (SignPosition)entry.readNumEntry("PositiveMonetarySignPosition", (int)BeforeQuantityMoney); m_positiveMonetarySignPosition = (SignPosition)config->readNumEntry("PositiveMonetarySignPosition", m_positiveMonetarySignPosition);;

  m_negativeMonetarySignPosition = (SignPosition)entry.readNumEntry("NegativeMonetarySignPosition", (int)ParensAround); m_negativeMonetarySignPosition = (SignPosition)config->readNumEntry("NegativeMonetarySignPosition", m_negativeMonetarySignPosition);;



  d->nounDeclension = entry.readBoolEntry("NounDeclension", false); d->nounDeclension = config->readBoolEntry("NounDeclension", d->nounDeclension);;


  m_timeFormat = entry.readEntry("TimeFormat", QString::fromLatin1("%H:%M:%S")); m_timeFormat = config->readEntry("TimeFormat", m_timeFormat);;
  m_dateFormat = entry.readEntry("DateFormat", QString::fromLatin1("%A %d %B %Y")); m_dateFormat = config->readEntry("DateFormat", m_dateFormat);;
  m_dateFormatShort = entry.readEntry("DateFormatShort", QString::fromLatin1("%Y-%m-%d")); m_dateFormatShort = config->readEntry("DateFormatShort", m_dateFormatShort);;
  d->dateMonthNamePossessive = entry.readBoolEntry("DateMonthNamePossessive", false); d->dateMonthNamePossessive = config->readBoolEntry("DateMonthNamePossessive", d->dateMonthNamePossessive);;

  d->weekStartDay = (int)entry.readNumEntry("WeekStartDay", 1); d->weekStartDay = (int)config->readNumEntry("WeekStartDay", d->weekStartDay);;


  d->pageSize = (int)entry.readNumEntry("PageSize", (int)QPrinter::A4); d->pageSize = (int)config->readNumEntry("PageSize", d->pageSize);;
  d->measureSystem = (MeasureSystem)entry.readNumEntry("MeasureSystem", (int)Metric); d->measureSystem = (MeasureSystem)config->readNumEntry("MeasureSystem", d->measureSystem);;

  d->calendarType = entry.readEntry("CalendarSystem", QString::fromLatin1("gregorian")); d->calendarType = config->readEntry("CalendarSystem", d->calendarType);;
  delete d->calendar;
  d->calendar = 0;


  KGlobal::_locale = lsave;
}

bool KLocale::setCountry(const QString & country)
{

  if ( country.isEmpty() )
    return false;

  m_country = country;

  d->formatInited = false;

  return true;
}

QString KLocale::catalogueFileName(const QString & language,
                                   const KCatalogue & catalogue)
{
  QString path = QString::fromLatin1("%1/LC_MESSAGES/%2.mo")
    .arg( language )
    .arg( catalogue.name() );

  return locate( "locale", path );
}

bool KLocale::isLanguageInstalled(const QString & language) const
{

  if ( language.isEmpty() ) return false;

  bool bRes = true;
  if ( language != defaultLanguage() )
    for ( QValueList<KCatalogue>::ConstIterator it = d->catalogues.begin();
          it != d->catalogues.end() && bRes;
          ++it )
      {
        bRes = !catalogueFileName( language, *it ).isNull();
        if ( !bRes )
          kdDebug(173) << "message catalogue not found: "
                       << (*it).name() << endl;
      }

  return bRes;
}

bool KLocale::setLanguage(const QString & language)
{
  bool bRes = true;

  if (d->first_language.isNull() || language != d->first_language)
    bRes = isLanguageInstalled( language );

  if ( bRes )
    {
      m_language = language;


      if (d->first_language.isNull())
        d->first_language = language;

      doBindInit();
    }

  return bRes;
}

bool KLocale::setLanguage(const QStringList & languages)
{
  QStringList languageList(languages);



  for( QStringList::Iterator it = languageList.fromLast();
         it != languageList.begin();
         --it )
    if ( languageList.contains(*it) > 1 || (*it).isEmpty() )
      it = languageList.remove( it );

  bool bRes = false;
  for ( QStringList::ConstIterator it = languageList.begin();
        it != languageList.end();
        ++it )
    if ( bRes = setLanguage( *it ) )
      break;

  if ( !bRes )
    setLanguage(defaultLanguage());

  d->languageList = languageList;
  d->langTwoAlpha.clear();

  return bRes;
}

void KLocale::splitLocale(const QString & aStr,
                          QString & language,
                          QString & country,
                          QString & chrset)
{
  QString str = aStr;


  int f = str.find(':');
  if (f >= 0)
    str.truncate(f);

  country = QString::null;
  chrset = QString::null;
  language = QString::null;

  f = str.find('.');
  if (f >= 0)
    {
      chrset = str.mid(f + 1);
      str.truncate(f);
    }

  f = str.find('_');
  if (f >= 0)
    {
      country = str.mid(f + 1);
      str.truncate(f);
    }

  language = str;
}

QString KLocale::language() const
{
  return m_language;
}

QString KLocale::country() const
{
  return m_country;
}

QString KLocale::monthName(int i, bool shortName) const
{
  if ( shortName )
    switch ( i )
      {
      case 1: return translate("January", "Jan");
      case 2: return translate("February", "Feb");
      case 3: return translate("March", "Mar");
      case 4: return translate("April", "Apr");
      case 5: return translate("May short", "May");
      case 6: return translate("June", "Jun");
      case 7: return translate("July", "Jul");
      case 8: return translate("August", "Aug");
      case 9: return translate("September", "Sep");
      case 10: return translate("October", "Oct");
      case 11: return translate("November", "Nov");
      case 12: return translate("December", "Dec");
      }
  else
    switch (i)
      {
      case 1: return translate("January");
      case 2: return translate("February");
      case 3: return translate("March");
      case 4: return translate("April");
      case 5: return translate("May long", "May");
      case 6: return translate("June");
      case 7: return translate("July");
      case 8: return translate("August");
      case 9: return translate("September");
      case 10: return translate("October");
      case 11: return translate("November");
      case 12: return translate("December");
      }

  return QString::null;
}

QString KLocale::monthNamePossessive(int i, bool shortName) const
{
  if ( shortName )
    switch ( i )
      {
      case 1: return translate("of January", "of Jan");
      case 2: return translate("of February", "of Feb");
      case 3: return translate("of March", "of Mar");
      case 4: return translate("of April", "of Apr");
      case 5: return translate("of May short", "of May");
      case 6: return translate("of June", "of Jun");
      case 7: return translate("of July", "of Jul");
      case 8: return translate("of August", "of Aug");
      case 9: return translate("of September", "of Sep");
      case 10: return translate("of October", "of Oct");
      case 11: return translate("of November", "of Nov");
      case 12: return translate("of December", "of Dec");
      }
  else
    switch (i)
      {
      case 1: return translate("of January");
      case 2: return translate("of February");
      case 3: return translate("of March");
      case 4: return translate("of April");
      case 5: return translate("of May long", "of May");
      case 6: return translate("of June");
      case 7: return translate("of July");
      case 8: return translate("of August");
      case 9: return translate("of September");
      case 10: return translate("of October");
      case 11: return translate("of November");
      case 12: return translate("of December");
      }

  return QString::null;
}

QString KLocale::weekDayName (int i, bool shortName) const
{
  if ( shortName )
    switch ( i )
      {
      case 1: return translate("Monday", "Mon");
      case 2: return translate("Tuesday", "Tue");
      case 3: return translate("Wednesday", "Wed");
      case 4: return translate("Thursday", "Thu");
      case 5: return translate("Friday", "Fri");
      case 6: return translate("Saturday", "Sat");
      case 7: return translate("Sunday", "Sun");
      }
  else
    switch ( i )
      {
      case 1: return translate("Monday");
      case 2: return translate("Tuesday");
      case 3: return translate("Wednesday");
      case 4: return translate("Thursday");
      case 5: return translate("Friday");
      case 6: return translate("Saturday");
      case 7: return translate("Sunday");
      }

  return QString::null;
}

void KLocale::insertCatalogue( const QString & catalogue )
{
  KCatalogue cat( catalogue );

  initCatalogue( cat );

  d->catalogues.append( cat );
}

void KLocale::removeCatalogue(const QString &catalogue)
{
  for ( QValueList<KCatalogue>::Iterator it = d->catalogues.begin();
        it != d->catalogues.end(); )
    if ((*it).name() == catalogue) {
      it = d->catalogues.remove(it);
      return;
    } else
      ++it;
}

void KLocale::setActiveCatalogue(const QString &catalogue)
{
  for ( QValueList<KCatalogue>::Iterator it = d->catalogues.begin();
        it != d->catalogues.end(); ++it)
    if ((*it).name() == catalogue) {
      KCatalogue save = *it;
      d->catalogues.remove(it);
      d->catalogues.prepend(save);
      return;
    }
}

KLocale::~KLocale()
{
  delete d->calendar;
  delete d->languages;
  delete d;
  d = 0L;
}

QString KLocale::translate_priv(const char *msgid,
                                const char *fallback,
                                const char **translated) const
{
  if (!msgid || !msgid[0])
    {
      kdWarning() << "KLocale: trying to look up \"\" in catalogue. "
                   << "Fix the program" << endl;
      return QString::null;
    }

  if ( useDefaultLanguage() )
    return QString::fromUtf8( fallback );

  for ( QValueList<KCatalogue>::ConstIterator it = d->catalogues.begin();
        it != d->catalogues.end();
        ++it )
    {

      const char * text = (*it).translate( msgid );

      if ( text )
        {

          if (translated)
            *translated = text;
          return QString::fromUtf8( text );
        }
    }


  return QString::fromUtf8( fallback );
}

QString KLocale::translate(const char* msgid) const
{
  return translate_priv(msgid, msgid);
}

QString KLocale::translate( const char *index, const char *fallback) const
{
  if (!index || !index[0] || !fallback || !fallback[0])
    {
      kdDebug(173) << "KLocale: trying to look up \"\" in catalogue. "
                   << "Fix the program" << endl;
      return QString::null;
    }

  if ( useDefaultLanguage() )
    return QString::fromUtf8( fallback );

  char *newstring = new char[strlen(index) + strlen(fallback) + 5];
  sprintf(newstring, "_: %s\n%s", index, fallback);

  QString r = translate_priv(newstring, fallback);
  delete [] newstring;

  return r;
}

static QString put_n_in(const QString &orig, unsigned long n)
{
  QString ret = orig;
  int index = ret.find("%n");
  if (index == -1)
    return ret;
  ret.replace(index, 2, QString::number(n));
  return ret;
}





QString KLocale::translate( const char *singular, const char *plural,
                            unsigned long n ) const
{
  if (!singular || !singular[0] || !plural || !plural[0])
    {
      kdWarning() << "KLocale: trying to look up \"\" in catalogue. "
                   << "Fix the program" << endl;
      return QString::null;
    }

  char *newstring = new char[strlen(singular) + strlen(plural) + 6];
  sprintf(newstring, "_n: %s\n%s", singular, plural);

  QString r = translate_priv(newstring, 0);
  delete [] newstring;

  if ( r.isEmpty() || useDefaultLanguage() || d->plural_form == -1) {
    if ( n == 1 ) {
      return put_n_in( QString::fromUtf8( singular ), n );
        } else {
          QString tmp = QString::fromUtf8( plural );

          if (tmp.find("%n") == -1) {
                          kdWarning() << "the message for i18n should contain a '%n'! " << plural << endl;
          }

      return put_n_in( tmp, n );
        }
  }

  QStringList forms = QStringList::split( "\n", r, false );
  switch ( d->plural_form ) {
  case 0:
    if (forms.count() != 1) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 1 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    return put_n_in( forms[0], n);
  case 1:
    if (forms.count() != 2) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 2 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n == 1 )
      return put_n_in( forms[0], n);
    else
      return put_n_in( forms[1], n);
  case 2:
    if (forms.count() != 2) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 2 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n == 1 || n == 0 )
      return put_n_in( forms[0], n);
    else
      return put_n_in( forms[1], n);
  case 3:
    if (forms.count() != 3) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 3 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n == 1 )
      return put_n_in( forms[0], n);
    else if ( n == 2 )
      return put_n_in( forms[1], n);
    else
      return put_n_in( forms[2], n);
  case 4:
    if (forms.count() != 3) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 3 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n%10 == 1 && n%100 != 11)
      return put_n_in( forms[0], n);
    else if (( n%10 >= 2 && n%10 <=4 ) && (n%100<10 || n%100>20))
      return put_n_in( forms[1], n);
    else
      return put_n_in( forms[2], n);
  case 5:
    if (forms.count() != 3) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 3 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n == 1 )
      return put_n_in( forms[0], n);
    else if ( n%10 >= 2 && n%10 <=4 && (n%100<10 || n%100>=20) )
      return put_n_in( forms[1], n);
    else
      return put_n_in( forms[2], n);
  case 6:
    if (forms.count() != 4) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 4 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n%100 == 1 )
      return put_n_in( forms[1], n);
    else if ( n%100 == 2 )
      return put_n_in( forms[2], n);
    else if ( n%100 == 3 || n%100 == 4 )
      return put_n_in( forms[3], n);
    else
      return put_n_in( forms[0], n);
  case 7:
    if (forms.count() != 3) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 3 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n%10 == 0 || (n%100>=11 && n%100<=19) )
      return put_n_in( forms[2], n);
    else if ( n%10 == 1 )
      return put_n_in( forms[0], n);
    else
      return put_n_in( forms[1], n);
  case 8:
    if (forms.count() != 3) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 3 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n%100 == 1 )
      return put_n_in( forms[0], n);
    else if (( n%100 >= 2 ) && ( n%100 <= 4 ))
      return put_n_in( forms[1], n);
    else
      return put_n_in( forms[2], n);
  case 9:
    if (forms.count() != 3) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 3 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n == 1 )
      return put_n_in( forms[0], n);
    else if (( n >= 2 ) && ( n <= 4 ))
      return put_n_in( forms[1], n);
    else
      return put_n_in( forms[2], n);
  case 10:
    if (forms.count() != 4) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 4 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if ( n == 1 )
      return put_n_in( forms[0], n );
    else if ( ( n == 0 ) || ( n%100 > 0 && n%100 <= 10 ) )
      return put_n_in( forms[1], n );
    else if ( n%100 > 10 && n%100 < 20 )
      return put_n_in( forms[2], n );
    else
      return put_n_in( forms[3], n );
  case 11:
    if (forms.count() != 4) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 4 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
    if (n == 1)
      return put_n_in(forms[0], n);
    else if (n == 2)
      return put_n_in(forms[1], n);
    else if ( n < 11)
      return put_n_in(forms[2], n);
    else
      return put_n_in(forms[3], n);
  case 12:
     if (forms.count() != 3) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 3 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
     if (n != 11 && n % 10 == 1)
        return put_n_in(forms[0], n);
     else if (n / 10 != 1 && n % 10 >= 2 && n % 10 <= 4)
        return put_n_in(forms[1], n);
     else
        return put_n_in(forms[2], n);
  case 13:
     if (forms.count() != 3) { kdError() << "translation of \"" << singular << "\" doesn't contain " << 3 << " different plural forms as expected\n"; return QString( "BROKEN TRANSLATION %1" ).arg( singular ); };
     if (n % 10 == 1)
        return put_n_in(forms[0], n);
     else if (n % 10 == 2)
        return put_n_in(forms[1], n);
     else
        return put_n_in(forms[2], n);
  }
  kdFatal() << "The function should have been returned in another way\n";

  return QString::null;
}

QString KLocale::translateQt( const char *context, const char *source,
                              const char *message) const
{
  if (!source || !source[0]) {
    kdWarning() << "KLocale: trying to look up \"\" in catalogue. "
                << "Fix the program" << endl;
    return QString::null;
  }

  if ( useDefaultLanguage() ) {
    return QString::null;
  }

  char *newstring = 0;
  const char *translation = 0;
  QString r;

  if ( message && message[0]) {
    char *newstring = new char[strlen(source) + strlen(message) + 5];
    sprintf(newstring, "_: %s\n%s", source, message);
    const char *translation = 0;

    r = translate_priv(newstring, source, &translation);
    delete [] newstring;
    if (translation)
      return r;
  }

  if ( context && context[0] && message && message[0]) {
    newstring = new char[strlen(context) + strlen(message) + 5];
    sprintf(newstring, "_: %s\n%s", context, message);

    r = translate_priv(newstring, source, &translation);
    delete [] newstring;
    if (translation)
      return r;
  }

  r = translate_priv(source, source, &translation);
  if (translation)
    return r;
  return QString::null;
}

bool KLocale::nounDeclension() const
{
  doFormatInit();
  return d->nounDeclension;
}

bool KLocale::dateMonthNamePossessive() const
{
  doFormatInit();
  return d->dateMonthNamePossessive;
}

int KLocale::weekStartDay() const
{
  doFormatInit();
  return d->weekStartDay;
}

bool KLocale::weekStartsMonday() const
{
  doFormatInit();
  return (d->weekStartDay==1);
}

QString KLocale::decimalSymbol() const
{
  doFormatInit();
  return m_decimalSymbol;
}

QString KLocale::thousandsSeparator() const
{
  doFormatInit();
  return m_thousandsSeparator;
}

QString KLocale::currencySymbol() const
{
  doFormatInit();
  return m_currencySymbol;
}

QString KLocale::monetaryDecimalSymbol() const
{
  doFormatInit();
  return m_monetaryDecimalSymbol;
}

QString KLocale::monetaryThousandsSeparator() const
{
  doFormatInit();
  return m_monetaryThousandsSeparator;
}

QString KLocale::positiveSign() const
{
  doFormatInit();
  return m_positiveSign;
}

QString KLocale::negativeSign() const
{
  doFormatInit();
  return m_negativeSign;
}

int KLocale::fracDigits() const
{
  doFormatInit();
  return m_fracDigits;
}

bool KLocale::positivePrefixCurrencySymbol() const
{
  doFormatInit();
  return m_positivePrefixCurrencySymbol;
}

bool KLocale::negativePrefixCurrencySymbol() const
{
  doFormatInit();
  return m_negativePrefixCurrencySymbol;
}

KLocale::SignPosition KLocale::positiveMonetarySignPosition() const
{
  doFormatInit();
  return m_positiveMonetarySignPosition;
}

KLocale::SignPosition KLocale::negativeMonetarySignPosition() const
{
  doFormatInit();
  return m_negativeMonetarySignPosition;
}

static inline void put_it_in( QChar *buffer, uint& index, const QString &s )
{
  for ( uint l = 0; l < s.length(); l++ )
    buffer[index++] = s.at( l );
}

static inline void put_it_in( QChar *buffer, uint& index, int number )
{
  buffer[index++] = number / 10 + '0';
  buffer[index++] = number % 10 + '0';
}

QString KLocale::formatMoney(double num,
                             const QString & symbol,
                             int precision) const
{

  QString currency = symbol.isNull()
    ? currencySymbol()
    : symbol;
  if (precision < 0) precision = fracDigits();


  bool neg = num < 0;
  QString res = QString::number(neg?-num:num, 'f', precision);
  int pos = res.find('.');
  if (pos == -1) pos = res.length();
  else res.replace(pos, 1, monetaryDecimalSymbol());

  while (0 < (pos -= 3))
    res.insert(pos, monetaryThousandsSeparator());


  int signpos = neg
    ? negativeMonetarySignPosition()
    : positiveMonetarySignPosition();
  QString sign = neg
    ? negativeSign()
    : positiveSign();

  switch (signpos)
    {
    case ParensAround:
      res.prepend('(');
      res.append (')');
      break;
    case BeforeQuantityMoney:
      res.prepend(sign);
      break;
    case AfterQuantityMoney:
      res.append(sign);
      break;
    case BeforeMoney:
      currency.prepend(sign);
      break;
    case AfterMoney:
      currency.append(sign);
      break;
    }

  if (neg?negativePrefixCurrencySymbol():
      positivePrefixCurrencySymbol())
    {
      res.prepend(' ');
      res.prepend(currency);
    } else {
      res.append (' ');
      res.append (currency);
    }

  return res;
}

QString KLocale::formatMoney(const QString &numStr) const
{
  return formatMoney(numStr.toDouble());
}

QString KLocale::formatNumber(double num, int precision) const
{
  bool neg = num < 0;
  if (precision == -1) precision = 2;
  QString res = QString::number(neg?-num:num, 'f', precision);
  int pos = res.find('.');
  if (pos == -1) pos = res.length();
  else res.replace(pos, 1, decimalSymbol());

  while (0 < (pos -= 3))
    res.insert(pos, thousandsSeparator());


  res.prepend(neg?negativeSign():positiveSign());

  return res;
}

QString KLocale::formatLong(long num) const
{
  return formatNumber((double)num, 0);
}

QString KLocale::formatNumber(const QString &numStr) const
{
  return formatNumber(numStr.toDouble());
}

QString KLocale::formatDate(const QDate &pDate, bool shortFormat) const
{
  const QString rst = shortFormat?dateFormatShort():dateFormat();

  QString buffer;

  bool escape = false;
  int number = 0;

  int year = calendar()->year(pDate);
  int month = calendar()->month(pDate);
  int day = calendar()->day(pDate);

  for ( uint format_index = 0; format_index < rst.length(); ++format_index )
    {
      if ( !escape )
        {
          if ( rst.at( format_index ).unicode() == '%' )
            escape = true;
          else
            buffer.append(rst.at(format_index));
        }
      else
        {
          switch ( rst.at( format_index ).unicode() )
            {
            case '%':
              buffer.append('%');
              break;
            case 'Y':
              buffer.append(calendar()->yearString(pDate, false));
              break;
            case 'y':
              buffer.append(calendar()->yearString(pDate, true));
              break;
            case 'n':
              buffer.append(calendar()->monthString(pDate, true));
              break;
            case 'e':
              buffer.append(calendar()->dayString(pDate, false));
              break;
            case 'm':
              buffer.append(calendar()->monthString(pDate, false));
              break;
            case 'b':
              if (d->nounDeclension && d->dateMonthNamePossessive)
                buffer.append(calendar()->monthNamePossessive(month, year, true));
              else
                buffer.append(calendar()->monthName(month, year, true));
              break;
            case 'B':
              if (d->nounDeclension && d->dateMonthNamePossessive)
                buffer.append(calendar()->monthNamePossessive(month, year, false));
              else
                buffer.append(calendar()->monthName(month, year, false));
              break;
            case 'd':
              buffer.append(calendar()->dayString(pDate, false));
              break;
            case 'a':
              buffer.append(calendar()->weekDayName(pDate, true));
              break;
            case 'A':
              buffer.append(calendar()->weekDayName(pDate, false));
              break;
            default:
              buffer.append(rst.at(format_index));
              break;
            }
          escape = false;
        }
    }
  return buffer;
}

void KLocale::setMainCatalogue(const char *catalogue)
{
  maincatalogue = catalogue;
}

double KLocale::readNumber(const QString &_str, bool * ok) const
{
  QString str = _str.stripWhiteSpace();
  bool neg = str.find(negativeSign()) == 0;
  if (neg)
    str.remove( 0, negativeSign().length() );




  QString exponentialPart;
  int EPos;

  EPos = str.find('E', 0, false);

  if (EPos != -1)
  {
    exponentialPart = str.mid(EPos);
    str = str.left(EPos);
  }

  int pos = str.find(decimalSymbol());
  QString major;
  QString minor;
  if ( pos == -1 )
    major = str;
  else
    {
      major = str.left(pos);
      minor = str.mid(pos + decimalSymbol().length());
    }


  int thlen = thousandsSeparator().length();
  int lastpos = 0;
  while ( ( pos = major.find( thousandsSeparator() ) ) > 0 )
  {

    int fromEnd = major.length() - pos;
    if ( fromEnd % (3+thlen) != 0
        || pos - lastpos > 3
        || pos == 0
        || (lastpos>0 && pos-lastpos!=3))
    {
      if (ok) *ok = false;
      return 0.0;
    }

    lastpos = pos;
    major.remove( pos, thlen );
  }
  if (lastpos>0 && major.length()-lastpos!=3)
  {
    if (ok) *ok = false;
    return 0.0;
  }

  QString tot;
  if (neg) tot = '-';

  tot += major + '.' + minor + exponentialPart;

  return tot.toDouble(ok);
}

double KLocale::readMoney(const QString &_str, bool * ok) const
{
  QString str = _str.stripWhiteSpace();
  bool neg = false;
  bool currencyFound = false;

  int pos = str.find(currencySymbol());
  if ( pos == 0 || pos == (int) str.length()-1 )
    {
      str.remove(pos,currencySymbol().length());
      str = str.stripWhiteSpace();
      currencyFound = true;
    }
  if (str.isEmpty())
    {
      if (ok) *ok = false;
      return 0;
    }


  if (negativeMonetarySignPosition() == ParensAround)
    {
      if (str[0] == '(' && str[str.length()-1] == ')')
        {
          neg = true;
          str.remove(str.length()-1,1);
          str.remove(0,1);
        }
    }
  else
    {
      int i1 = str.find(negativeSign());
      if ( i1 == 0 || i1 == (int) str.length()-1 )
        {
          neg = true;
          str.remove(i1,negativeSign().length());
        }
    }
  if (neg) str = str.stripWhiteSpace();



  if ( !currencyFound )
    {
      pos = str.find(currencySymbol());
      if ( pos == 0 || pos == (int) str.length()-1 )
        {
          str.remove(pos,currencySymbol().length());
          str = str.stripWhiteSpace();
        }
    }


  pos = str.find(monetaryDecimalSymbol());
  QString major;
  QString minior;
  if (pos == -1)
    major = str;
  else
    {
      major = str.left(pos);
      minior = str.mid(pos + monetaryDecimalSymbol().length());
    }


  int thlen = monetaryThousandsSeparator().length();
  int lastpos = 0;
  while ( ( pos = major.find( monetaryThousandsSeparator() ) ) > 0 )
  {

    int fromEnd = major.length() - pos;
    if ( fromEnd % (3+thlen) != 0
        || pos - lastpos > 3
        || pos == 0
        || (lastpos>0 && pos-lastpos!=3))
    {
      if (ok) *ok = false;
      return 0.0;
    }
    lastpos = pos;
    major.remove( pos, thlen );
  }
  if (lastpos>0 && major.length()-lastpos!=3)
  {
    if (ok) *ok = false;
    return 0.0;
  }

  QString tot;
  if (neg) tot = '-';
  tot += major + '.' + minior;
  return tot.toDouble(ok);
}







static int readInt(const QString &str, uint &pos)
{
  if (!str.at(pos).isDigit()) return -1;
  int result = 0;
  for (; str.length() > pos && str.at(pos).isDigit(); pos++)
    {
      result *= 10;
      result += str.at(pos).digitValue();
    }

  return result;
}

QDate KLocale::readDate(const QString &intstr, bool* ok) const
{
  QDate date;
  date = readDate(intstr, ShortFormat, ok);
  if (date.isValid()) return date;
  return readDate(intstr, NormalFormat, ok);
}

QDate KLocale::readDate(const QString &intstr, ReadDateFlags flags, bool* ok) const
{
  QString fmt = ((flags & ShortFormat) ? dateFormatShort() : dateFormat()).simplifyWhiteSpace();
  return readDate( intstr, fmt, ok );
}

QDate KLocale::readDate(const QString &intstr, const QString &fmt, bool* ok) const
{

  QString str = intstr.simplifyWhiteSpace().lower();
  int day = -1, month = -1;

  int year = calendar()->year(QDate::currentDate());
  uint strpos = 0;
  uint fmtpos = 0;

  int iLength;

  bool error = false;

  while (fmt.length() > fmtpos && str.length() > strpos && !error)
  {

    QChar c = fmt.at(fmtpos++);

    if (c != '%') {
      if (c.isSpace() && str.at(strpos).isSpace())
        strpos++;
      else if (c != str.at(strpos++))
        error = true;
    }
    else
    {
      int j;

      if (str.length() > strpos && str.at(strpos).isSpace())
        strpos++;

      c = fmt.at(fmtpos++);
      switch (c)
      {
        case 'a':
        case 'A':

          error = true;
          j = 1;
          while (error && (j < 8)) {
            QString s = weekDayName(j, c == 'a').lower();
            int len = s.length();
            if (str.mid(strpos, len) == s)
            {
              strpos += len;
              error = false;
            }
            j++;
          }
          break;
        case 'b':
        case 'B':

          error = true;
          if (d->nounDeclension && d->dateMonthNamePossessive) {
            j = 1;
            while (error && (j < 13)) {
              QString s = calendar()->monthNamePossessive(j, year, c == 'b').lower();
              int len = s.length();
              if (str.mid(strpos, len) == s) {
                month = j;
                strpos += len;
                error = false;
              }
              j++;
            }
          }
          j = 1;
          while (error && (j < 13)) {
            QString s = calendar()->monthName(j, year, c == 'b').lower();
            int len = s.length();
            if (str.mid(strpos, len) == s) {
              month = j;
              strpos += len;
              error = false;
            }
            j++;
          }
          break;
        case 'd':
        case 'e':
          day = calendar()->dayStringToInteger(str.mid(strpos), iLength);
          strpos += iLength;

          error = iLength <= 0;
          break;

        case 'n':
        case 'm':
          month = calendar()->monthStringToInteger(str.mid(strpos), iLength);
          strpos += iLength;

          error = iLength <= 0;
          break;

        case 'Y':
        case 'y':
          year = calendar()->yearStringToInteger(str.mid(strpos), iLength);
          strpos += iLength;

          error = iLength <= 0;
# 1474 "/coolo/prod/kdelibs/kdecore/klocale.cpp"
          break;
      }
    }
  }



  if ( fmt.length() > fmtpos || str.length() > strpos )
  {
    error = true;
  }


  if ( year != -1 && month != -1 && day != -1 && !error)
  {
    if (ok) *ok = true;

    QDate result;
    calendar()->setYMD(result, year, month, day);

    return result;
  }
  else
  {
    if (ok) *ok = false;
    return QDate();
  }
}

QTime KLocale::readTime(const QString &intstr, bool *ok) const
{
  QTime _time;
  _time = readTime(intstr, WithSeconds, ok);
  if (_time.isValid()) return _time;
  return readTime(intstr, WithoutSeconds, ok);
}

QTime KLocale::readTime(const QString &intstr, ReadTimeFlags flags, bool *ok) const
{
  QString str = intstr.simplifyWhiteSpace().lower();
  QString Format = timeFormat().simplifyWhiteSpace();
  if (flags & WithoutSeconds)
    Format.remove(QRegExp(".%S"));

  int hour = -1, minute = -1;
  int second = ( flags & WithoutSeconds == 0 ) ? -1 : 0;
  bool g_12h = false;
  bool pm = false;
  uint strpos = 0;
  uint Formatpos = 0;

  while (Format.length() > Formatpos || str.length() > strpos)
    {
      if ( !(Format.length() > Formatpos && str.length() > strpos) ) goto error;

      QChar c = Format.at(Formatpos++);

      if (c != '%')
        {
          if (c.isSpace())
            strpos++;
          else if (c != str.at(strpos++))
            goto error;
          continue;
        }


      if (str.length() > strpos && str.at(strpos).isSpace())
        strpos++;

      c = Format.at(Formatpos++);
      switch (c)
        {
        case 'p':
          {
            QString s;
            s = translate("pm").lower();
            int len = s.length();
            if (str.mid(strpos, len) == s)
              {
                pm = true;
                strpos += len;
              }
            else
              {
                s = translate("am").lower();
                len = s.length();
                if (str.mid(strpos, len) == s) {
                  pm = false;
                  strpos += len;
                }
                else
                  goto error;
              }
          }
          break;

        case 'k':
        case 'H':
          g_12h = false;
          hour = readInt(str, strpos);
          if (hour < 0 || hour > 23)
            goto error;

          break;

        case 'l':
        case 'I':
          g_12h = true;
          hour = readInt(str, strpos);
          if (hour < 1 || hour > 12)
            goto error;

          break;

        case 'M':
          minute = readInt(str, strpos);
          if (minute < 0 || minute > 59)
            goto error;

          break;

        case 'S':
          second = readInt(str, strpos);
          if (second < 0 || second > 59)
            goto error;

          break;
        }
    }
  if (g_12h) {
    hour %= 12;
    if (pm) hour += 12;
  }

  if (ok) *ok = true;
  return QTime(hour, minute, second);

 error:
  if (ok) *ok = false;
  return QTime(-1, -1, -1);
}

QString KLocale::formatTime(const QTime &pTime, bool includeSecs) const
{
  const QString rst = timeFormat();



  QChar *buffer = new QChar[rst.length() * 3 / 2 + 30];

  uint index = 0;
  bool escape = false;
  int number = 0;

  for ( uint format_index = 0; format_index < rst.length(); format_index++ )
    {
      if ( !escape )
        {
          if ( rst.at( format_index ).unicode() == '%' )
            escape = true;
          else
            buffer[index++] = rst.at( format_index );
        }
      else
        {
          switch ( rst.at( format_index ).unicode() )
            {
            case '%':
              buffer[index++] = '%';
              break;
            case 'H':
              put_it_in( buffer, index, pTime.hour() );
              break;
            case 'I':
              put_it_in( buffer, index, ( pTime.hour() + 11) % 12 + 1 );
              break;
            case 'M':
              put_it_in( buffer, index, pTime.minute() );
              break;
            case 'S':
              if (includeSecs)
                put_it_in( buffer, index, pTime.second() );
              else if ( index > 0 )
                {


                  --index;
                  break;
                }
              break;
            case 'k':
              number = pTime.hour();
            case 'l':

              if ( rst.at( format_index ).unicode() == 'l' )
                number = (pTime.hour() + 11) % 12 + 1;
              if ( number / 10 )
                buffer[index++] = number / 10 + '0';
              buffer[index++] = number % 10 + '0';
              break;
            case 'p':
              {
                QString s;
                if ( pTime.hour() >= 12 )
                  put_it_in( buffer, index, translate("pm") );
                else
                  put_it_in( buffer, index, translate("am") );
                break;
              }
            default:
              buffer[index++] = rst.at( format_index );
              break;
            }
          escape = false;
        }
    }
  QString ret( buffer, index );
  delete [] buffer;
  return ret;
}

bool KLocale::use12Clock() const
{
  if ((timeFormat().contains(QString::fromLatin1("%I")) > 0) ||
      (timeFormat().contains(QString::fromLatin1("%l")) > 0))
    return true;
  else
    return false;
}

QString KLocale::languages() const
{
  return d->languageList.join( QString::fromLatin1(":") );
}

QStringList KLocale::languageList() const
{
  return d->languageList;
}

QString KLocale::formatDateTime(const QDateTime &pDateTime,
                                bool shortFormat,
                                bool includeSeconds) const
{
  return translate("concatenation of dates and time", "%1 %2")
    .arg( formatDate( pDateTime.date(), shortFormat ) )
    .arg( formatTime( pDateTime.time(), includeSeconds ) );
}

QString i18n(const char* text)
{
  register KLocale *instance = KGlobal::locale();
  if (instance)
    return instance->translate(text);
  return QString::fromUtf8(text);
}

QString i18n(const char* index, const char *text)
{
  register KLocale *instance = KGlobal::locale();
  if (instance)
    return instance->translate(index, text);
  return QString::fromUtf8(text);
}

QString i18n(const char* singular, const char* plural, unsigned long n)
{
  register KLocale *instance = KGlobal::locale();
  if (instance)
    return instance->translate(singular, plural, n);
  if (n == 1)
    return put_n_in(QString::fromUtf8(singular), n);
  else
    return put_n_in(QString::fromUtf8(plural), n);
}

void KLocale::initInstance()
{
  if (KGlobal::_locale)
    return;

  KInstance *app = KGlobal::instance();
  if (app) {
    KGlobal::_locale = new KLocale(QString::fromLatin1(app->instanceName()));


    QTextCodec::setCodecForLocale(KGlobal::_locale->codecForEncoding());
  }
  else
    kdDebug(173) << "no app name available using KLocale - nothing to do\n";
}

QString KLocale::langLookup(const QString &fname, const char *rtype)
{
  QStringList search;


  const QStringList localDoc = KGlobal::dirs()->resourceDirs(rtype);


  for (int id=localDoc.count()-1; id >= 0; --id)
    {
      QStringList langs = KGlobal::locale()->languageList();
      langs.append( "en" );
      langs.remove( defaultLanguage() );
      QStringList::ConstIterator lang;
      for (lang = langs.begin(); lang != langs.end(); ++lang)
        search.append(QString("%1%2/%3").arg(localDoc[id]).arg(*lang).arg(fname));
    }


  QStringList::Iterator it;
  for (it = search.begin(); it != search.end(); ++it)
    {
      kdDebug(173) << "Looking for help in: " << *it << endl;

      QFileInfo info(*it);
      if (info.exists() && info.isFile() && info.isReadable())
        return *it;
    }

  return QString::null;
}

bool KLocale::useDefaultLanguage() const
{
  return language() == defaultLanguage();
}

void KLocale::initEncoding(KConfig *)
{
  const int mibDefault = 4;


  setEncoding( QTextCodec::codecForLocale()->mibEnum() );

  if ( !d->codecForEncoding )
    {
      kdWarning(173) << " Defaulting to ISO 8859-1 encoding." << endl;
      setEncoding(mibDefault);
    }

  ((d->codecForEncoding) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","d->codecForEncoding","/coolo/prod/kdelibs/kdecore/klocale.cpp",1817));
}

void KLocale::initFileNameEncoding(KConfig *)
{


  d->utf8FileEncoding = getenv("KDE_UTF8_FILENAMES") != 0;
  if (d->utf8FileEncoding)
  {
    QFile::setEncodingFunction(KLocale::encodeFileNameUTF8);
    QFile::setDecodingFunction(KLocale::decodeFileNameUTF8);
  }


}

QCString KLocale::encodeFileNameUTF8( const QString & fileName )
{
  return fileName.utf8();
}

QString KLocale::decodeFileNameUTF8( const QCString & localFileName )
{
  return QString::fromUtf8(localFileName);
}

void KLocale::initCatalogue( KCatalogue & catalogue )
{
  catalogue.setFileName( catalogueFileName( language(), catalogue ) );
}

void KLocale::setDateFormat(const QString & format)
{
  doFormatInit();
  m_dateFormat = format.stripWhiteSpace();
}

void KLocale::setDateFormatShort(const QString & format)
{
  doFormatInit();
  m_dateFormatShort = format.stripWhiteSpace();
}

void KLocale::setDateMonthNamePossessive(bool possessive)
{
  doFormatInit();
  d->dateMonthNamePossessive = possessive;
}

void KLocale::setTimeFormat(const QString & format)
{
  doFormatInit();
  m_timeFormat = format.stripWhiteSpace();
}

void KLocale::setWeekStartsMonday(bool start)
{
  doFormatInit();
  if (start)
    d->weekStartDay = 1;
  else
    d->weekStartDay = 7;
}

void KLocale::setWeekStartDay(int day)
{
  doFormatInit();
  if (day>7 || day<1)
    d->weekStartDay = 1;
  else
    d->weekStartDay = day;
}

QString KLocale::dateFormat() const
{
  doFormatInit();
  return m_dateFormat;
}

QString KLocale::dateFormatShort() const
{
  doFormatInit();
  return m_dateFormatShort;
}

QString KLocale::timeFormat() const
{
  doFormatInit();
  return m_timeFormat;
}

void KLocale::setDecimalSymbol(const QString & symbol)
{
  doFormatInit();
  m_decimalSymbol = symbol.stripWhiteSpace();
}

void KLocale::setThousandsSeparator(const QString & separator)
{
  doFormatInit();

  m_thousandsSeparator = separator;
}

void KLocale::setPositiveSign(const QString & sign)
{
  doFormatInit();
  m_positiveSign = sign.stripWhiteSpace();
}

void KLocale::setNegativeSign(const QString & sign)
{
  doFormatInit();
  m_negativeSign = sign.stripWhiteSpace();
}

void KLocale::setPositiveMonetarySignPosition(SignPosition signpos)
{
  doFormatInit();
  m_positiveMonetarySignPosition = signpos;
}

void KLocale::setNegativeMonetarySignPosition(SignPosition signpos)
{
  doFormatInit();
  m_negativeMonetarySignPosition = signpos;
}

void KLocale::setPositivePrefixCurrencySymbol(bool prefix)
{
  doFormatInit();
  m_positivePrefixCurrencySymbol = prefix;
}

void KLocale::setNegativePrefixCurrencySymbol(bool prefix)
{
  doFormatInit();
  m_negativePrefixCurrencySymbol = prefix;
}

void KLocale::setFracDigits(int digits)
{
  doFormatInit();
  m_fracDigits = digits;
}

void KLocale::setMonetaryThousandsSeparator(const QString & separator)
{
  doFormatInit();

  m_monetaryThousandsSeparator = separator;
}

void KLocale::setMonetaryDecimalSymbol(const QString & symbol)
{
  doFormatInit();
  m_monetaryDecimalSymbol = symbol.stripWhiteSpace();
}

void KLocale::setCurrencySymbol(const QString & symbol)
{
  doFormatInit();
  m_currencySymbol = symbol.stripWhiteSpace();
}

int KLocale::pageSize() const
{
  doFormatInit();
  return d->pageSize;
}

void KLocale::setPageSize(int pageSize)
{

  doFormatInit();
  d->pageSize = pageSize;
}

KLocale::MeasureSystem KLocale::measureSystem() const
{
  doFormatInit();
  return d->measureSystem;
}

void KLocale::setMeasureSystem(MeasureSystem value)
{
  doFormatInit();
  d->measureSystem = value;
}

QString KLocale::defaultLanguage()
{
  return QString::fromLatin1("en_US");
}

QString KLocale::defaultCountry()
{
  return QString::fromLatin1("C");
}

const char * KLocale::encoding() const
{
  return codecForEncoding()->name();
}

int KLocale::encodingMib() const
{
  return codecForEncoding()->mibEnum();
}

int KLocale::fileEncodingMib() const
{
  if (d->utf8FileEncoding)
     return 106;
  return codecForEncoding()->mibEnum();
}

QTextCodec * KLocale::codecForEncoding() const
{
  return d->codecForEncoding;
}

bool KLocale::setEncoding(int mibEnum)
{
  QTextCodec * codec = QTextCodec::codecForMib(mibEnum);
  if (codec)
    d->codecForEncoding = codec;

  return codec != 0;
}

QStringList KLocale::languagesTwoAlpha() const
{
  if (d->langTwoAlpha.count())
     return d->langTwoAlpha;

  const QStringList &origList = languageList();

  QStringList result;

  KConfig config(QString::fromLatin1("language.codes"), true, false);
  config.setGroup("TwoLetterCodes");

  for ( QStringList::ConstIterator it = origList.begin();
        it != origList.end();
        ++it )
    {
      QString lang = *it;
      QStringList langLst;
      if (config.hasKey( lang ))
         langLst = config.readListEntry( lang );
      else
      {
         int i = lang.find('_');
         if (i >= 0)
            lang.truncate(i);
         langLst << lang;
      }

      for ( QStringList::ConstIterator langIt = langLst.begin();
            langIt != langLst.end();
            ++langIt )
        {
          if ( !(*langIt).isEmpty() && !result.contains( *langIt ) )
            result += *langIt;
        }
    }
  d->langTwoAlpha = result;
  return result;
}

QStringList KLocale::allLanguagesTwoAlpha() const
{
  if (!d->languages)
    d->languages = new KConfig("all_languages", true, false, "locale");

  return d->languages->groupList();
}

QString KLocale::twoAlphaToLanguageName(const QString &code) const
{
  if (!d->languages)
    d->languages = new KConfig("all_languages", true, false, "locale");

  d->languages->setGroup(code.lower());
  return d->languages->readEntry("Name");
}

QStringList KLocale::allCountriesTwoAlpha() const
{
  QStringList countries;
  QStringList paths = KGlobal::dirs()->findAllResources("locale", "l10n/*/entry.desktop");
  for(QStringList::ConstIterator it = paths.begin();
      it != paths.end(); ++it)
  {
    QString code = (*it).mid((*it).length()-16, 2);
    if (code != "/C")
       countries.append(code);
  }
  return countries;
}

QString KLocale::twoAlphaToCountryName(const QString &code) const
{
  KConfig cfg("l10n/"+code.lower()+"/entry.desktop", true, false, "locale");
  cfg.setGroup("KCM Locale");
  return cfg.readEntry("Name");
}

void KLocale::setCalendar(const QString & calType)
{
  doFormatInit();

  d->calendarType = calType;

  delete d->calendar;
  d->calendar = 0;
}

QString KLocale::calendarType() const
{
  doFormatInit();

  return d->calendarType;
}

const KCalendarSystem * KLocale::calendar() const
{
  doFormatInit();


  if ( !d->calendar )
    d->calendar = KCalendarSystemFactory::create( d->calendarType, this );

  return d->calendar;
}

KLocale::KLocale(const KLocale & rhs)
{
  d = new KLocalePrivate;

  *this = rhs;
}

KLocale & KLocale::operator=(const KLocale & rhs)
{

  m_decimalSymbol = rhs.m_decimalSymbol;
  m_thousandsSeparator = rhs.m_thousandsSeparator;
  m_currencySymbol = rhs.m_currencySymbol;
  m_monetaryDecimalSymbol = rhs.m_monetaryDecimalSymbol;
  m_monetaryThousandsSeparator = rhs.m_monetaryThousandsSeparator;
  m_positiveSign = rhs.m_positiveSign;
  m_negativeSign = rhs.m_negativeSign;
  m_fracDigits = rhs.m_fracDigits;
  m_positivePrefixCurrencySymbol = rhs.m_positivePrefixCurrencySymbol;
  m_negativePrefixCurrencySymbol = rhs.m_negativePrefixCurrencySymbol;
  m_positiveMonetarySignPosition = rhs.m_positiveMonetarySignPosition;
  m_negativeMonetarySignPosition = rhs.m_negativeMonetarySignPosition;


  m_timeFormat = rhs.m_timeFormat;
  m_dateFormat = rhs.m_dateFormat;
  m_dateFormatShort = rhs.m_dateFormatShort;

  m_language = rhs.m_language;
  m_country = rhs.m_country;


  *d = *rhs.d;
  d->languages = 0;
  d->calendar = 0;

  return *this;
}

bool KLocale::setCharset(const QString & ) { return true; }
QString KLocale::charset() const { return QString::fromLatin1("UTF-8"); }
# 20 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/krfcdate.cpp" 1
# 24 "/coolo/prod/kdelibs/kdecore/krfcdate.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 25 "/coolo/prod/kdelibs/kdecore/krfcdate.cpp" 2







# 1 "/coolo/prod/kdelibs/kdecore/krfcdate.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/krfcdate.h"
# 31 "/coolo/prod/kdelibs/kdecore/krfcdate.h"
class KRFCDate
{
public:
# 46 "/coolo/prod/kdelibs/kdecore/krfcdate.h"
   static time_t parseDate(const QString &date);
# 63 "/coolo/prod/kdelibs/kdecore/krfcdate.h"
   static time_t parseDateISO8601(const QString &date);





   static int localUTCOffset();
# 81 "/coolo/prod/kdelibs/kdecore/krfcdate.h"
   static QCString rfc2822DateString(time_t utcTime, int utcOffset);
# 95 "/coolo/prod/kdelibs/kdecore/krfcdate.h"
   static QCString rfc2822DateString(time_t utcTime);

};
# 33 "/coolo/prod/kdelibs/kdecore/krfcdate.cpp" 2

static unsigned int ymdhms_to_seconds(int year, int mon, int day, int hour, int minute, int second)
{
    if (sizeof(time_t) == 4)
    {
       if ((time_t)-1 < 0)
       {
          if (year >= 2038)
          {
             year = 2038;
             mon = 0;
             day = 1;
             hour = 0;
             minute = 0;
             second = 0;
          }
       }
       else
       {
          if (year >= 2115)
          {
             year = 2115;
             mon = 0;
             day = 1;
             hour = 0;
             minute = 0;
             second = 0;
          }
       }
    }

    unsigned int ret = (day - 32075)
            + 1461L * (year + 4800L + (mon - 14) / 12) / 4
            + 367 * (mon - 2 - (mon - 14) / 12 * 12) / 12
            - 3 * ((year + 4900L + (mon - 14) / 12) / 100) / 4
            - 2440588;
    ret = 24*ret + hour;
    ret = 60*ret + minute;
    ret = 60*ret + second;

    return ret;
}

static const char haystack[37]="janfebmaraprmayjunjulaugsepoctnovdec";



static const struct {
    const char *tzName;
    int tzOffset;
} known_zones[] = {
    { "UT", 0 },
    { "GMT", 0 },
    { "EST", -300 },
    { "EDT", -240 },
    { "CST", -360 },
    { "CDT", -300 },
    { "MST", -420 },
    { "MDT", -360 },
    { "PST", -480 },
    { "PDT", -420 },
    { 0, 0 }
};

time_t
KRFCDate::parseDate(const QString &_date)
{
# 111 "/coolo/prod/kdelibs/kdecore/krfcdate.cpp"
     time_t result = 0;
     int offset = 0;
     char *newPosStr;
     const char *dateString = _date.latin1();
     int day = 0;
     char monthStr[4];
     int month = -1;
     int year = 0;
     int hour = 0;
     int minute = 0;
     int second = 0;


     while(*dateString && isspace(*dateString))
        dateString++;


     while(*dateString && !isdigit(*dateString) && !isspace(*dateString))
        dateString++;


     while(*dateString && isspace(*dateString))
        dateString++;

     if (!*dateString)
        return result;

     if (isalpha(*dateString))
     {


        while(*dateString && isspace(*dateString))
           dateString++;

        for(int i=0; i < 3;i++)
        {
           if (!*dateString || (*dateString == '-') || isspace(*dateString))
              return result;
           monthStr[i] = tolower(*dateString++);
        }
        monthStr[3] = '\0';

        newPosStr = (char*)strstr(haystack, monthStr);

        if (!newPosStr)
           return result;

        month = (newPosStr-haystack)/3;

        if ((month < 0) || (month > 11))
           return result;

        while (*dateString && isalpha(*dateString))
           dateString++;
     }



     day = strtol(dateString, &newPosStr, 10);
     dateString = newPosStr;

     if ((day < 1) || (day > 31))
         return result;

     if (!*dateString)
        return result;

     while(*dateString && (isspace(*dateString) || (*dateString == '-')))
        dateString++;

     if (month == -1)
     {
        for(int i=0; i < 3;i++)
        {
           if (!*dateString || (*dateString == '-') || isspace(*dateString))
              return result;
           monthStr[i] = tolower(*dateString++);
        }
        monthStr[3] = '\0';

        newPosStr = (char*)strstr(haystack, monthStr);

        if (!newPosStr)
           return result;

        month = (newPosStr-haystack)/3;

        if ((month < 0) || (month > 11))
           return result;

        while (*dateString && isalpha(*dateString))
           dateString++;

     }


     while(*dateString && (isspace(*dateString) || (*dateString == '-')))
        dateString++;

     if (!*dateString || !isdigit(*dateString))
        return result;


     year = strtol(dateString, &newPosStr, 10);
     dateString = newPosStr;


     if ((year >= 0) && (year < 50))
         year += 2000;

     if ((year >= 50) && (year < 100))
         year += 1900;

     if ((year < 1900) || (year > 2500))
        return result;


     if (*dateString)
     {

        if (!isspace(*dateString++))
           return result;

        hour = strtol(dateString, &newPosStr, 10);
        dateString = newPosStr;

        if ((hour < 0) || (hour > 23))
           return result;

        if (!*dateString)
           return result;


        if (*dateString++ != ':')
           return result;

        minute = strtol(dateString, &newPosStr, 10);
        dateString = newPosStr;

        if ((minute < 0) || (minute > 59))
           return result;

        if (!*dateString)
           return result;


        if (*dateString != ':' && !isspace(*dateString))
           return result;


        if (*dateString ==':') {
           dateString++;

           second = strtol(dateString, &newPosStr, 10);
           dateString = newPosStr;

           if ((second < 0) || (second > 59))
              return result;
        } else {
           dateString++;
        }

        while(*dateString && isspace(*dateString))
           dateString++;
     }



     if (*dateString) {
        if ((strncasecmp(dateString, "gmt", 3) == 0) ||
            (strncasecmp(dateString, "utc", 3) == 0))
        {
           dateString += 3;
           while(*dateString && isspace(*dateString))
              dateString++;
        }

        if ((*dateString == '+') || (*dateString == '-')) {
           offset = strtol(dateString, &newPosStr, 10);
           if (abs(offset) < 30)
           {
              dateString = newPosStr;

              offset = offset * 100;

              if (*dateString && *(dateString+1))
              {
                 dateString++;
                 int minutes = strtol(dateString, &newPosStr, 10);
                 if (offset > 0)
                    offset += minutes;
                 else
                    offset -= minutes;
              }
           }

           if ((offset < -9959) || (offset > 9959))
              return result;

           int sgn = (offset < 0)? -1:1;
           offset = abs(offset);
           offset = ((offset / 100)*60 + (offset % 100))*sgn;
        } else {
           for (int i=0; known_zones[i].tzName != 0; i++) {
              if (0 == strncasecmp(dateString, known_zones[i].tzName, strlen(known_zones[i].tzName))) {
                 offset = known_zones[i].tzOffset;
                 break;
              }
           }
        }
     }

     result = ymdhms_to_seconds(year, month+1, day, hour, minute, second);


     if ((offset > 0) && (offset > result))
        offset = 0;

     result -= offset*60;




     if (result < 1) result = 1;

     return result;
}

time_t
KRFCDate::parseDateISO8601( const QString& input)
{






  unsigned int year = 0;
  unsigned int month = 0;
  unsigned int mday = 0;
  unsigned int hour = 0;
  unsigned int min = 0;
  unsigned int sec = 0;

  int offset = 0;


  int tPos = input.find('T');

  if (-1 == tPos)
    return 0;



  QString dateString = input.left(tPos).stripWhiteSpace();

  QString timeString = input.mid(tPos + 1).stripWhiteSpace();

  QStringList l = QStringList::split('-', dateString);

  year = l[0].toUInt();
  month = l[1].toUInt();
  mday = l[2].toUInt();


  if ('Z' == timeString.at(timeString.length() - 1)) {
    timeString.remove(timeString.length() - 1, 1);
  }



  int plusPos = timeString.findRev('+');

  if (-1 != plusPos) {
    QString offsetString = timeString.mid(plusPos + 1);

    offset = offsetString.left(2).toUInt() * 60 + offsetString.right(2).toUInt();

    timeString = timeString.left(plusPos);
  } else {
    int minusPos = timeString.findRev('-');

    if (-1 != minusPos) {
      QString offsetString = timeString.mid(minusPos + 1);

      offset = - (offsetString.left(2).toUInt() * 60 + offsetString.right(2).toUInt());

      timeString = timeString.left(minusPos);
    }
  }


  int dotPos = timeString.findRev('.');

  if (-1 != dotPos) {
    timeString = timeString.left(dotPos);
  }



  l = QStringList::split(':', timeString);

  hour = l[0].toUInt();
  min = l[1].toUInt();
  sec = l[2].toUInt();

  time_t result = ymdhms_to_seconds(year, month, mday, hour, min, sec);


  if ((offset > 0) && (offset > result))
     offset = 0;

  result -= offset*60;




  if (result < 1) result = 1;

  return result;
}


int KRFCDate::localUTCOffset()
{
  time_t timeNow = time((time_t*) 0);

  tm *tM = gmtime(&timeNow);
  unsigned int timeUTC = ymdhms_to_seconds(tM->tm_year+1900, tM->tm_mon+1, tM->tm_mday,
                                           tM->tm_hour, tM->tm_min, tM->tm_sec);

  tM = localtime(&timeNow);
  unsigned int timeLocal = ymdhms_to_seconds(tM->tm_year+1900, tM->tm_mon+1, tM->tm_mday,
                                             tM->tm_hour, tM->tm_min, tM->tm_sec);

  return ((int)(timeLocal-timeUTC))/60;
}


static const char * const day_names[] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

static const char * const month_names[] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};


QCString KRFCDate::rfc2822DateString(time_t utcTime, int utcOffset)
{
    utcTime += utcOffset * 60;
    tm *tM = gmtime(&utcTime);
    char sgn = (utcOffset < 0) ? '-' : '+';
    int z = (utcOffset < 0) ? -utcOffset : utcOffset;
    QCString dateStr;

    dateStr.sprintf("%s, %02d %s %04d %02d:%02d:%02d %c%02d%02d",
                    day_names[tM->tm_wday], tM->tm_mday,
                    month_names[tM->tm_mon], tM->tm_year+1900,
                    tM->tm_hour, tM->tm_min, tM->tm_sec,
                    sgn, z/60%24, z%60);

    return dateStr;
}


QCString KRFCDate::rfc2822DateString(time_t utcTime)
{
    return rfc2822DateString(utcTime, localUTCOffset());
}
# 21 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kiconeffect.cpp" 1
# 14 "/coolo/prod/kdelibs/kdecore/kiconeffect.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 15 "/coolo/prod/kdelibs/kdecore/kiconeffect.cpp" 2

# 1 "/usr/include/math.h" 1 3 4
# 25 "/usr/include/math.h" 3 4



extern "C" {



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 30 "/usr/include/bits/huge_val.h" 3 4
# 51 "/usr/include/bits/huge_val.h" 3 4
# 34 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/nan.h" 1 3 4
# 29 "/usr/include/bits/nan.h" 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 24 "/usr/include/bits/mathdef.h" 3 4




typedef long double float_t;

typedef long double double_t;





# 41 "/usr/include/math.h" 2 3 4















# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 66 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME
# 78 "/usr/include/math.h" 3 4





# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 89 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME











# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 110 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME




#undef __MATHDECL_1
#undef __MATHDECL
#undef __MATHCALL




extern int signgam;
# 166 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,
    FP_INFINITE,
    FP_ZERO,
    FP_SUBNORMAL,
    FP_NORMAL
  };






# 197 "/usr/include/math.h" 3 4
# 209 "/usr/include/math.h" 3 4














# 237 "/usr/include/math.h" 3 4












typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 275 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();








# 318 "/usr/include/math.h" 3 4













# 375 "/usr/include/math.h" 3 4










































}
# 17 "/coolo/prod/kdelibs/kdecore/kiconeffect.cpp" 2



# 1 "/coolo/prod/qt-copy/include/qbitmap.h" 1
# 39 "/coolo/prod/qt-copy/include/qbitmap.h"






class QBitmap : public QPixmap
{
public:
    QBitmap();
    QBitmap( int w, int h, bool clear = FALSE,
             QPixmap::Optimization = QPixmap::DefaultOptim );
    QBitmap( const QSize &, bool clear = FALSE,
             QPixmap::Optimization = QPixmap::DefaultOptim );
    QBitmap( int w, int h, const uchar *bits, bool isXbitmap=FALSE );
    QBitmap( const QSize &, const uchar *bits, bool isXbitmap=FALSE );
    QBitmap( const QBitmap & );

    QBitmap( const QString &fileName, const char *format=0 );

    QBitmap &operator=( const QBitmap & );
    QBitmap &operator=( const QPixmap & );
    QBitmap &operator=( const QImage & );


    QBitmap xForm( const QWMatrix & ) const;

};
# 21 "/coolo/prod/kdelibs/kdecore/kiconeffect.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qimage.h" 1
# 39 "/coolo/prod/qt-copy/include/qimage.h"







class QImageDataMisc;

class QImageTextKeyLang {
public:
    QImageTextKeyLang(const char* k, const char* l) : key(k), lang(l) { }
    QImageTextKeyLang() { }

    QCString key;
    QCString lang;

    bool operator< (const QImageTextKeyLang& other) const
        { return key < other.key || key==other.key && lang < other.lang; }
    bool operator== (const QImageTextKeyLang& other) const
        { return key==other.key && lang==other.lang; }
};



class QImage
{
public:
    enum Endian { IgnoreEndian, BigEndian, LittleEndian };

    QImage();
    QImage( int width, int height, int depth, int numColors=0,
            Endian bitOrder=IgnoreEndian );
    QImage( const QSize&, int depth, int numColors=0,
            Endian bitOrder=IgnoreEndian );

    QImage( const QString &fileName, const char* format=0 );
    QImage( const char * const xpm[] );
    QImage( const QByteArray &data );

    QImage( uchar* data, int w, int h, int depth,
                QRgb* colortable, int numColors,
                Endian bitOrder );





    QImage( const QImage & );
   ~QImage();

    QImage &operator=( const QImage & );
    QImage &operator=( const QPixmap & );
    bool operator==( const QImage & ) const;
    bool operator!=( const QImage & ) const;
    void detach();
    QImage copy() const;
    QImage copy(int x, int y, int w, int h, int conversion_flags=0) const;
    QImage copy(const QRect&) const;

    static QImage fromMimeSource( const QString& abs_name );

    bool isNull() const { return data->bits == 0; }

    int width() const { return data->w; }
    int height() const { return data->h; }
    QSize size() const { return QSize(data->w,data->h); }
    QRect rect() const { return QRect(0,0,data->w,data->h); }
    int depth() const { return data->d; }
    int numColors() const { return data->ncols; }
    Endian bitOrder() const { return (Endian) data->bitordr; }

    QRgb color( int i ) const;
    void setColor( int i, QRgb c );
    void setNumColors( int );

    bool hasAlphaBuffer() const;
    void setAlphaBuffer( bool );

    bool allGray() const;
    bool isGrayscale() const;

    uchar *bits() const;
    uchar *scanLine( int ) const;
    uchar **jumpTable() const;
    QRgb *colorTable() const;
    int numBytes() const;
    int bytesPerLine() const;





    bool create( int width, int height, int depth, int numColors=0,
                        Endian bitOrder=IgnoreEndian );
    bool create( const QSize&, int depth, int numColors=0,
                        Endian bitOrder=IgnoreEndian );
    void reset();

    void fill( uint pixel );
    void invertPixels( bool invertAlpha = TRUE );

    QImage convertDepth( int ) const;

    QImage convertDepthWithPalette( int, QRgb* p, int pc, int cf=0 ) const;

    QImage convertDepth( int, int conversion_flags ) const;
    QImage convertBitOrder( Endian ) const;

    enum ScaleMode {
        ScaleFree,
        ScaleMin,
        ScaleMax
    };

    QImage smoothScale( int w, int h, ScaleMode mode=ScaleFree ) const;
    QImage smoothScale( const QSize& s, ScaleMode mode=ScaleFree ) const;


    QImage scale( int w, int h, ScaleMode mode=ScaleFree ) const;
    QImage scale( const QSize& s, ScaleMode mode=ScaleFree ) const;
    QImage scaleWidth( int w ) const;
    QImage scaleHeight( int h ) const;
    QImage xForm( const QWMatrix &matrix ) const;



    QImage createAlphaMask( int conversion_flags=0 ) const;


    QImage createHeuristicMask( bool clipTight=TRUE ) const;


    QImage mirror() const;
    QImage mirror(bool horizontally, bool vertically) const;

    QImage swapRGB() const;

    static Endian systemBitOrder();
    static Endian systemByteOrder();


    static const char* imageFormat( const QString &fileName );
    static QStrList inputFormats();
    static QStrList outputFormats();

    static QStringList inputFormatList();
    static QStringList outputFormatList();

    bool load( const QString &fileName, const char* format=0 );
    bool loadFromData( const uchar *buf, uint len,
                              const char *format=0 );
    bool loadFromData( QByteArray data, const char* format=0 );
    bool save( const QString &fileName, const char* format,
                      int quality=-1 ) const;
    bool save( QIODevice * device, const char* format,
                      int quality=-1 ) const;


    bool valid( int x, int y ) const;
    int pixelIndex( int x, int y ) const;
    QRgb pixel( int x, int y ) const;
    void setPixel( int x, int y, uint index_or_rgb );


    int dotsPerMeterX() const;
    int dotsPerMeterY() const;
    void setDotsPerMeterX(int);
    void setDotsPerMeterY(int);
    QPoint offset() const;
    void setOffset(const QPoint&);

    QValueList<QImageTextKeyLang> textList() const;
    QStringList textLanguages() const;
    QStringList textKeys() const;
    QString text(const char* key, const char* lang=0) const;
    QString text(const QImageTextKeyLang&) const;
    void setText(const char* key, const char* lang, const QString&);

private:
    void init();
    void reinit();
    void freeBits();
    static void warningIndexRange( const char *, int );

    struct QImageData : public QShared {
        int w;
        int h;
        int d;
        int ncols;
        int nbytes;
        int bitordr;
        QRgb *ctbl;
        uchar **bits;
        bool alpha;
        int dpmx;
        int dpmy;
        QPoint offset;

        QImageDataMisc* misc;

        bool ctbl_mine;
    } *data;

    QImageDataMisc& misc() const;


    bool doImageIO( QImageIO* io, int quality ) const;

    friend void bitBlt( QImage* dst, int dx, int dy,
                                 const QImage* src, int sx, int sy,
                                 int sw, int sh, int conversion_flags );
};





 QDataStream &operator<<( QDataStream &, const QImage & );
 QDataStream &operator>>( QDataStream &, QImage & );



class QIODevice;
typedef void (*image_io_handler)( QImageIO * );


struct QImageIOData;


class QImageIO
{
public:
    QImageIO();
    QImageIO( QIODevice *ioDevice, const char *format );
    QImageIO( const QString &fileName, const char* format );
   ~QImageIO();


    const QImage &image() const { return im; }
    int status() const { return iostat; }
    const char *format() const { return frmt; }
    QIODevice *ioDevice() const { return iodev; }
    QString fileName() const { return fname; }
    int quality() const;
    QString description() const { return descr; }
    const char *parameters() const;
    float gamma() const;

    void setImage( const QImage & );
    void setStatus( int );
    void setFormat( const char * );
    void setIODevice( QIODevice * );
    void setFileName( const QString & );
    void setQuality( int );
    void setDescription( const QString & );
    void setParameters( const char * );
    void setGamma( float );

    bool read();
    bool write();

    static const char* imageFormat( const QString &fileName );
    static const char *imageFormat( QIODevice * );
    static QStrList inputFormats();
    static QStrList outputFormats();

    static void defineIOHandler( const char *format,
                                 const char *header,
                                 const char *flags,
                                 image_io_handler read_image,
                                 image_io_handler write_image );

private:
    void init();

    QImage im;
    int iostat;
    QCString frmt;
    QIODevice *iodev;
    QString fname;
    char *params;
    QString descr;
    QImageIOData *d;

private:

    QImageIO( const QImageIO & );
    QImageIO &operator=( const QImageIO & );

};



 void bitBlt( QImage* dst, int dx, int dy, const QImage* src,
                      int sx=0, int sy=0, int sw=-1, int sh=-1,
                      int conversion_flags=0 );






inline bool QImage::hasAlphaBuffer() const
{
    return data->alpha;
}

inline uchar *QImage::bits() const
{
    return data->bits ? data->bits[0] : 0;
}

inline uchar **QImage::jumpTable() const
{
    return data->bits;
}

inline QRgb *QImage::colorTable() const
{
    return data->ctbl;
}

inline int QImage::numBytes() const
{
    return data->nbytes;
}

inline int QImage::bytesPerLine() const
{
    return data->h ? data->nbytes/data->h : 0;
}

inline QImage QImage::copy(const QRect& r) const
{
    return copy(r.x(), r.y(), r.width(), r.height());
}

inline QRgb QImage::color( int i ) const
{

    if ( i >= data->ncols )
        warningIndexRange( "color", i );

    return data->ctbl ? data->ctbl[i] : (QRgb)-1;
}

inline void QImage::setColor( int i, QRgb c )
{

    if ( i >= data->ncols )
        warningIndexRange( "setColor", i );

    if ( data->ctbl )
        data->ctbl[i] = c;
}

inline uchar *QImage::scanLine( int i ) const
{

    if ( i >= data->h )
        warningIndexRange( "scanLine", i );

    return data->bits ? data->bits[i] : 0;
}

inline int QImage::dotsPerMeterX() const
{
    return data->dpmx;
}

inline int QImage::dotsPerMeterY() const
{
    return data->dpmy;
}

inline QPoint QImage::offset() const
{
    return data->offset;
}
# 23 "/coolo/prod/kdelibs/kdecore/kiconeffect.cpp" 2


# 1 "/coolo/prod/qt-copy/include/qpainter.h" 1
# 39 "/coolo/prod/qt-copy/include/qpainter.h"
# 49 "/coolo/prod/qt-copy/include/qpainter.h"
# 1 "/coolo/prod/qt-copy/include/qpointarray.h" 1
# 39 "/coolo/prod/qt-copy/include/qpointarray.h"
# 51 "/coolo/prod/qt-copy/include/qpointarray.h"
class QPointArray : public QMemArray<QPoint>
{
public:
    QPointArray() {}
    ~QPointArray() {}
    QPointArray( int size ) : QMemArray<QPoint>( size ) {}
    QPointArray( const QPointArray &a ) : QMemArray<QPoint>( a ) {}
    QPointArray( const QRect &r, bool closed=FALSE );
    QPointArray( int nPoints, const QCOORD *points );

    QPointArray &operator=( const QPointArray &a )
        { return (QPointArray&)assign( a ); }

    QPointArray copy() const
        { QPointArray tmp; return *((QPointArray*)&tmp.duplicate(*this)); }

    void translate( int dx, int dy );
    QRect boundingRect() const;

    void point( uint i, int *x, int *y ) const;
    QPoint point( uint i ) const;
    void setPoint( uint i, int x, int y );
    void setPoint( uint i, const QPoint &p );
    bool setPoints( int nPoints, const QCOORD *points );
    bool setPoints( int nPoints, int firstx, int firsty, ... );
    bool putPoints( int index, int nPoints, const QCOORD *points );
    bool putPoints( int index, int nPoints, int firstx, int firsty, ... );
    bool putPoints( int index, int nPoints,
                       const QPointArray & from, int fromIndex=0 );

    void makeArc( int x, int y, int w, int h, int a1, int a2 );
    void makeEllipse( int x, int y, int w, int h );
    void makeArc( int x, int y, int w, int h, int a1, int a2,
                     const QWMatrix& );
    QPointArray cubicBezier() const;

    void* shortPoints( int index = 0, int nPoints = -1 ) const;
    static void cleanBuffers();

protected:
    static uint splen;
    static void* sp;
};






 QDataStream &operator<<( QDataStream &, const QPointArray & );
 QDataStream &operator>>( QDataStream &, QPointArray & );






inline void QPointArray::setPoint( uint i, const QPoint &p )
{
    setPoint( i, p.x(), p.y() );
}
# 50 "/coolo/prod/qt-copy/include/qpainter.h" 2
# 1 "/coolo/prod/qt-copy/include/qwmatrix.h" 1
# 39 "/coolo/prod/qt-copy/include/qwmatrix.h"
# 51 "/coolo/prod/qt-copy/include/qwmatrix.h"
class QWMatrix
{
public:
    QWMatrix();
    QWMatrix( double m11, double m12, double m21, double m22,
              double dx, double dy );

    void setMatrix( double m11, double m12, double m21, double m22,
                           double dx, double dy );

    double m11() const { return _m11; }
    double m12() const { return _m12; }
    double m21() const { return _m21; }
    double m22() const { return _m22; }
    double dx() const { return _dx; }
    double dy() const { return _dy; }

    void map( int x, int y, int *tx, int *ty ) const;
    void map( double x, double y, double *tx, double *ty ) const;
    QRect mapRect( const QRect & ) const;

    QPoint map( const QPoint &p ) const { return operator *( p ); }
    QRect map( const QRect &r ) const { return mapRect ( r ); }
    QPointArray map( const QPointArray &a ) const { return operator * ( a ); }
    QRegion map( const QRegion &r ) const { return operator *( r ); }
    QRegion mapToRegion( const QRect &r ) const { return operator *( r ); }
    QPointArray mapToPolygon( const QRect &r ) const;

    void reset();
    bool isIdentity() const;

    QWMatrix &translate( double dx, double dy );
    QWMatrix &scale( double sx, double sy );
    QWMatrix &shear( double sh, double sv );
    QWMatrix &rotate( double a );

    bool isInvertible() const { return (_m11*_m22 - _m12*_m21) != 0; }
    double det() const { return _m11*_m22 - _m12*_m21; }

    QWMatrix invert( bool * = 0 ) const;

    bool operator==( const QWMatrix & ) const;
    bool operator!=( const QWMatrix & ) const;
    QWMatrix &operator*=( const QWMatrix & );


    QPoint operator * (const QPoint & ) const;
    QRegion operator * (const QRect & ) const;
    QRegion operator * (const QRegion & ) const;
    QPointArray operator * ( const QPointArray &a ) const;

    enum TransformationMode {
        Points, Areas
    };
    static void setTransformationMode( QWMatrix::TransformationMode m );
    static TransformationMode transformationMode();
private:
    double _m11, _m12;
    double _m21, _m22;
    double _dx, _dy;
};

 QWMatrix operator*( const QWMatrix &, const QWMatrix & );






 QDataStream &operator<<( QDataStream &, const QWMatrix & );
 QDataStream &operator>>( QDataStream &, QWMatrix & );
# 51 "/coolo/prod/qt-copy/include/qpainter.h" 2


class QGfx;
class QTextCodec;
class QTextParag;
class QPaintDevice;
class QTextItem;



class QPainterPrivate;

class QPainter : public Qt
{
public:
    enum CoordinateMode { CoordDevice, CoordPainter };

    QPainter();
    QPainter( const QPaintDevice *, bool unclipped = FALSE );
    QPainter( const QPaintDevice *, const QWidget *, bool unclipped = FALSE );
   ~QPainter();

    bool begin( const QPaintDevice *, bool unclipped = FALSE );
    bool begin( const QPaintDevice *, const QWidget *, bool unclipped = FALSE );
    bool end();
    QPaintDevice *device() const;





    static void redirect( QPaintDevice *pdev, QPaintDevice *replacement );
    static QPaintDevice *redirect( QPaintDevice *pdev );

    bool isActive() const;

    void flush( const QRegion &region, CoordinateMode cm = CoordDevice );
    void flush();
    void save();
    void restore();



    QFontMetrics fontMetrics() const;
    QFontInfo fontInfo() const;

    const QFont &font() const;
    void setFont( const QFont & );
    const QPen &pen() const;
    void setPen( const QPen & );
    void setPen( PenStyle );
    void setPen( const QColor & );
    const QBrush &brush() const;
    void setBrush( const QBrush & );
    void setBrush( BrushStyle );
    void setBrush( const QColor & );
    QPoint pos() const;



    const QColor &backgroundColor() const;
    void setBackgroundColor( const QColor & );
    BGMode backgroundMode() const;
    void setBackgroundMode( BGMode );
    RasterOp rasterOp() const;
    void setRasterOp( RasterOp );
    const QPoint &brushOrigin() const;
    void setBrushOrigin( int x, int y );
    void setBrushOrigin( const QPoint & );






    bool hasViewXForm() const;
    bool hasWorldXForm() const;


    void setViewXForm( bool );
    QRect window() const;
    void setWindow( const QRect & );
    void setWindow( int x, int y, int w, int h );
    QRect viewport() const;
    void setViewport( const QRect & );
    void setViewport( int x, int y, int w, int h );

    void setWorldXForm( bool );
    const QWMatrix &worldMatrix() const;
    void setWorldMatrix( const QWMatrix &, bool combine=FALSE );

    void saveWorldMatrix();
    void restoreWorldMatrix();

    void scale( double sx, double sy );
    void shear( double sh, double sv );
    void rotate( double a );

    void translate( double dx, double dy );
    void resetXForm();
    double translationX() const;
    double translationY() const;

    QPoint xForm( const QPoint & ) const;
    QRect xForm( const QRect & ) const;
    QPointArray xForm( const QPointArray & ) const;
    QPointArray xForm( const QPointArray &, int index, int npoints ) const;
    QPoint xFormDev( const QPoint & ) const;
    QRect xFormDev( const QRect & ) const;
    QPointArray xFormDev( const QPointArray & ) const;
    QPointArray xFormDev( const QPointArray &, int index, int npoints ) const;



    void setClipping( bool );
    bool hasClipping() const;
    QRegion clipRegion( CoordinateMode = CoordDevice ) const;
    void setClipRect( const QRect &, CoordinateMode = CoordDevice );
    void setClipRect( int x, int y, int w, int h, CoordinateMode = CoordDevice );
    void setClipRegion( const QRegion &, CoordinateMode = CoordDevice );



    void drawPoint( int x, int y );
    void drawPoint( const QPoint & );
    void drawPoints( const QPointArray& a,
                            int index=0, int npoints=-1 );
    void moveTo( int x, int y );
    void moveTo( const QPoint & );
    void lineTo( int x, int y );
    void lineTo( const QPoint & );
    void drawLine( int x1, int y1, int x2, int y2 );
    void drawLine( const QPoint &, const QPoint & );
    void drawRect( int x, int y, int w, int h );
    void drawRect( const QRect & );
    void drawWinFocusRect( int x, int y, int w, int h );
    void drawWinFocusRect( int x, int y, int w, int h,
                                  const QColor &bgColor );
    void drawWinFocusRect( const QRect & );
    void drawWinFocusRect( const QRect &,
                                  const QColor &bgColor );
    void drawRoundRect( int x, int y, int w, int h, int = 25, int = 25 );
    void drawRoundRect( const QRect &, int = 25, int = 25 );
    void drawEllipse( int x, int y, int w, int h );
    void drawEllipse( const QRect & );
    void drawArc( int x, int y, int w, int h, int a, int alen );
    void drawArc( const QRect &, int a, int alen );
    void drawPie( int x, int y, int w, int h, int a, int alen );
    void drawPie( const QRect &, int a, int alen );
    void drawChord( int x, int y, int w, int h, int a, int alen );
    void drawChord( const QRect &, int a, int alen );
    void drawLineSegments( const QPointArray &,
                                  int index=0, int nlines=-1 );
    void drawPolyline( const QPointArray &,
                              int index=0, int npoints=-1 );
    void drawPolygon( const QPointArray &, bool winding=FALSE,
                             int index=0, int npoints=-1 );
    void drawConvexPolygon( const QPointArray &,
                             int index=0, int npoints=-1 );

    void drawCubicBezier( const QPointArray &, int index=0 );

    void drawPixmap( int x, int y, const QPixmap &,
                            int sx=0, int sy=0, int sw=-1, int sh=-1 );
    void drawPixmap( const QPoint &, const QPixmap &,
                            const QRect &sr );
    void drawPixmap( const QPoint &, const QPixmap & );
    void drawPixmap( const QRect &, const QPixmap & );
    void drawImage( int x, int y, const QImage &,
                           int sx = 0, int sy = 0, int sw = -1, int sh = -1,
                           int conversionFlags = 0 );
    void drawImage( const QPoint &, const QImage &,
                           const QRect &sr, int conversionFlags = 0 );
    void drawImage( const QPoint &, const QImage &,
                           int conversion_flags = 0 );
    void drawImage( const QRect &, const QImage & );
    void drawTiledPixmap( int x, int y, int w, int h, const QPixmap &,
                                 int sx=0, int sy=0 );
    void drawTiledPixmap( const QRect &, const QPixmap &,
                                 const QPoint & );
    void drawTiledPixmap( const QRect &, const QPixmap & );

    void drawPicture( const QPicture & );
    void drawPicture( int x, int y, const QPicture & );
    void drawPicture( const QPoint &, const QPicture & );


    void fillRect( int x, int y, int w, int h, const QBrush & );
    void fillRect( const QRect &, const QBrush & );
    void eraseRect( int x, int y, int w, int h );
    void eraseRect( const QRect & );



    enum TextDirection {
        Auto,
        RTL,
        LTR
    };

    void drawText( int x, int y, const QString &, int len = -1, TextDirection dir = Auto );
    void drawText( const QPoint &, const QString &, int len = -1, TextDirection dir = Auto );

    void drawText( int x, int y, const QString &, int pos, int len, TextDirection dir = Auto );
    void drawText( const QPoint &p, const QString &, int pos, int len, TextDirection dir = Auto );

    void drawText( int x, int y, int w, int h, int flags,
                          const QString&, int len = -1, QRect *br=0,
                          QTextParag **intern=0 );
    void drawText( const QRect &, int flags,
                          const QString&, int len = -1, QRect *br=0,
                          QTextParag **intern=0 );

    void drawTextItem( int x, int y, const QTextItem &ti, int textflags = 0 );
    void drawTextItem( const QPoint& p, const QTextItem &ti, int textflags = 0 );

    QRect boundingRect( int x, int y, int w, int h, int flags,
                              const QString&, int len = -1, QTextParag **intern=0 );
    QRect boundingRect( const QRect &, int flags,
                              const QString&, int len = -1, QTextParag **intern=0 );

    int tabStops() const;
    void setTabStops( int );
    int *tabArray() const;
    void setTabArray( int * );






    HANDLE handle() const;



    static void initialize();
    static void cleanup();

private:
    void init();
    void destroy();
    void updateFont();
    void updatePen();
    void updateBrush();

    void updateXForm();
    void updateInvXForm();

    void map( int, int, int *rx, int *ry ) const;
    void map( int, int, int, int, int *, int *, int *, int * ) const;
    void mapInv( int, int, int *, int * ) const;
    void mapInv( int, int, int, int, int *, int *, int *, int * ) const;



    void drawPolyInternal( const QPointArray &, bool close=TRUE );

    void drawWinFocusRect( int x, int y, int w, int h, bool xorPaint,
                                  const QColor &penColor );

    enum { IsActive=0x01, ExtDev=0x02, IsStartingUp=0x04, NoCache=0x08,
           VxF=0x10, WxF=0x20, ClipOn=0x40, SafePolygon=0x80, MonoDev=0x100,
           DirtyFont=0x200, DirtyPen=0x400, DirtyBrush=0x800,
           RGBColor=0x1000, FontMet=0x2000, FontInf=0x4000, CtorBegin=0x8000,
           UsePrivateCx = 0x10000, VolatileDC = 0x20000, Qt2Compat = 0x40000 };
    uint flags;
    bool testf( uint b ) const { return (flags&b)!=0; }
    void setf( uint b ) { flags |= b; }
    void setf( uint b, bool v );
    void clearf( uint b ) { flags &= (uint)(~b); }
    void fix_neg_rect( int *x, int *y, int *w, int *h );

    QPainterPrivate *d;
    QPaintDevice *pdev;
    QColor bg_col;
    uchar bg_mode;
    uchar rop;
    uchar pu;
    QPoint bro;
    QFont cfont;
    QFont *pfont;
    QPen cpen;
    QBrush cbrush;
    QRegion crgn;
    int tabstops;
    int *tabarray;
    int tabarraylen;
    bool block_ext;



    QCOORD wx, wy, ww, wh;
    QCOORD vx, vy, vw, vh;
    QWMatrix wxmat;


    QWMatrix xmat;
    QWMatrix ixmat;



    double m11() const { return xmat.m11(); }
    double m12() const { return xmat.m12(); }
    double m21() const { return xmat.m21(); }
    double m22() const { return xmat.m22(); }
    double dx() const { return xmat.dx(); }
    double dy() const { return xmat.dy(); }
    double im11() const { return ixmat.m11(); }
    double im12() const { return ixmat.m12(); }
    double im21() const { return ixmat.m21(); }
    double im22() const { return ixmat.m22(); }
    double idx() const { return ixmat.dx(); }
    double idy() const { return ixmat.dy(); }

    int txop;
    bool txinv;







    void *penRef;
    void *brushRef;
    void *ps_stack;
    void *wm_stack;
    void killPStack();

protected:
# 389 "/coolo/prod/qt-copy/include/qpainter.h"
    friend class QFontEngineXLFD;
    friend class QFontEngineXft;
    friend class QFontEngineBox;
    Display *dpy;
    int scrn;
    Qt::HANDLE hd;
    Qt::HANDLE rendhd;
    GC gc;
    GC gc_brush;
    QPoint curPt;
    uint clip_serial;
# 409 "/coolo/prod/qt-copy/include/qpainter.h"
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QTextLayout;
    friend void qt_format_text( const QFont &, const QRect &r,
                     int tf, const QString& str, int len, QRect *brect,
                     int tabstops, int* tabarray, int tabarraylen,
                     QTextParag **internal, QPainter* painter );
    friend void qt_draw_background( QPainter *p, int x, int y, int w, int h );
    friend void qt_draw_transformed_rect( QPainter *p, int x, int y, int w, int h, bool fill );
    friend class QPrinter;

private:

    QPainter( const QPainter & );
    QPainter &operator=( const QPainter & );


    enum TransformationCodes {
        TxNone = 0,
        TxTranslate = 1,
        TxScale = 2,
        TxRotShear = 3
    };
};






inline QPaintDevice *QPainter::device() const
{
    return pdev;
}

inline bool QPainter::isActive() const
{
    return testf(IsActive);
}

inline const QFont &QPainter::font() const
{
    return cfont;
}

inline const QPen &QPainter::pen() const
{
    return cpen;
}

inline const QBrush &QPainter::brush() const
{
    return cbrush;
}
# 471 "/coolo/prod/qt-copy/include/qpainter.h"
inline const QColor &QPainter::backgroundColor() const
{
    return bg_col;
}

inline Qt::BGMode QPainter::backgroundMode() const
{
    return (BGMode)bg_mode;
}

inline Qt::RasterOp QPainter::rasterOp() const
{
    return (RasterOp)rop;
}

inline const QPoint &QPainter::brushOrigin() const
{
    return bro;
}

inline bool QPainter::hasViewXForm() const
{

    return testf(VxF);



}

inline bool QPainter::hasWorldXForm() const
{

    return testf(WxF);



}

inline double QPainter::translationX() const
{

    return worldMatrix().dx();



}

inline double QPainter::translationY() const
{

    return worldMatrix().dy();



}


inline bool QPainter::hasClipping() const
{
    return testf(ClipOn);
}

inline int QPainter::tabStops() const
{
    return tabstops;
}

inline int *QPainter::tabArray() const
{
    return tabarray;
}







inline Qt::HANDLE QPainter::handle() const
{
    return hd;
}


inline void QPainter::setBrushOrigin( const QPoint &p )
{
    setBrushOrigin( p.x(), p.y() );
}


inline void QPainter::setWindow( const QRect &r )
{
    setWindow( r.x(), r.y(), r.width(), r.height() );
}

inline void QPainter::setViewport( const QRect &r )
{
    setViewport( r.x(), r.y(), r.width(), r.height() );
}


inline void QPainter::setClipRect( int x, int y, int w, int h, CoordinateMode m )
{
    setClipRect( QRect(x,y,w,h), m );
}

inline void QPainter::drawPoint( const QPoint &p )
{
    drawPoint( p.x(), p.y() );
}

inline void QPainter::moveTo( const QPoint &p )
{
    moveTo( p.x(), p.y() );
}

inline void QPainter::lineTo( const QPoint &p )
{
    lineTo( p.x(), p.y() );
}

inline void QPainter::drawLine( const QPoint &p1, const QPoint &p2 )
{
    drawLine( p1.x(), p1.y(), p2.x(), p2.y() );
}

inline void QPainter::drawRect( const QRect &r )
{
    drawRect( r.x(), r.y(), r.width(), r.height() );
}

inline void QPainter::drawWinFocusRect( const QRect &r )
{
    drawWinFocusRect( r.x(), r.y(), r.width(), r.height() );
}

inline void QPainter::drawWinFocusRect( const QRect &r,const QColor &penColor )
{
    drawWinFocusRect( r.x(), r.y(), r.width(), r.height(), penColor );
}

inline void QPainter::drawRoundRect( const QRect &r, int xRnd, int yRnd )
{
    drawRoundRect( r.x(), r.y(), r.width(), r.height(), xRnd, yRnd );
}

inline void QPainter::drawEllipse( const QRect &r )
{
    drawEllipse( r.x(), r.y(), r.width(), r.height() );
}

inline void QPainter::drawArc( const QRect &r, int a, int alen )
{
    drawArc( r.x(), r.y(), r.width(), r.height(), a, alen );
}

inline void QPainter::drawPie( const QRect &r, int a, int alen )
{
    drawPie( r.x(), r.y(), r.width(), r.height(), a, alen );
}

inline void QPainter::drawChord( const QRect &r, int a, int alen )
{
    drawChord( r.x(), r.y(), r.width(), r.height(), a, alen );
}

inline void QPainter::drawPixmap( const QPoint &p, const QPixmap &pm,
                                  const QRect &sr )
{
    drawPixmap( p.x(), p.y(), pm, sr.x(), sr.y(), sr.width(), sr.height() );
}

inline void QPainter::drawImage( const QPoint &p, const QImage &pm,
                                 const QRect &sr, int conversionFlags )
{
    drawImage( p.x(), p.y(), pm,
               sr.x(), sr.y(), sr.width(), sr.height(), conversionFlags );
}

inline void QPainter::drawTiledPixmap( const QRect &r, const QPixmap &pm,
                                       const QPoint &sp )
{
    drawTiledPixmap( r.x(), r.y(), r.width(), r.height(), pm, sp.x(), sp.y() );
}

inline void QPainter::drawTiledPixmap( const QRect &r, const QPixmap &pm )
{
    drawTiledPixmap( r.x(), r.y(), r.width(), r.height(), pm, 0, 0 );
}

inline void QPainter::fillRect( const QRect &r, const QBrush &brush )
{
    fillRect( r.x(), r.y(), r.width(), r.height(), brush );
}

inline void QPainter::eraseRect( int x, int y, int w, int h )
{
    fillRect( x, y, w, h, backgroundColor() );
}

inline void QPainter::eraseRect( const QRect &r )
{
    fillRect( r.x(), r.y(), r.width(), r.height(), backgroundColor() );
}

inline void QPainter::drawText( const QPoint &p, const QString &s, int len, TextDirection dir )
{
    drawText( p.x(), p.y(), s, 0, len, dir );
}

inline void QPainter::drawText( const QPoint &p, const QString &s, int pos, int len, TextDirection dir )
{
    drawText( p.x(), p.y(), s, pos, len, dir );
}

inline void QPainter::drawText( int x, int y, int w, int h, int tf,
                                const QString& str, int len, QRect *br, QTextParag **i )
{
    QRect r(x, y, w, h);
    drawText( r, tf, str, len, br, i );
}

inline void QPainter::drawTextItem( const QPoint& p, const QTextItem &ti, int textflags )
{
    drawTextItem( p.x(), p.y(), ti, textflags );
}

inline QRect QPainter::boundingRect( int x, int y, int w, int h, int tf,
                                     const QString& str, int len, QTextParag **i )
{
    QRect r(x, y, w, h);
    return boundingRect( r, tf, str, len, i );
}
# 26 "/coolo/prod/kdelibs/kdecore/kiconeffect.cpp" 2







# 1 "/coolo/prod/kdelibs/kdecore/kiconeffect.h" 1
# 16 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"






class QWidget;

class KIconEffectPrivate;
# 35 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
class KIconEffect
{
public:



    KIconEffect();
    ~KIconEffect();
# 55 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
    enum Effects { NoEffect, ToGray, Colorize, ToGamma, DeSaturate, LastEffect };




    void init();
# 71 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
    bool hasEffect(int group, int state) const;
# 81 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
     QString fingerprint(int group, int state) const;
# 91 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
    QImage apply(QImage src, int group, int state) const;
# 103 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
    QImage apply(QImage src, int effect, float value, const QColor rgb, bool trans) const;
# 112 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
    QPixmap apply(QPixmap src, int group, int state) const;
# 123 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
    QPixmap apply(QPixmap src, int effect, float value, const QColor rgb, bool trans) const;






    QImage doublePixels(QImage src) const;
# 144 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
    static void visualActivate(QWidget *widget, QRect rect);







    static void toGray(QImage &image, float value);
# 161 "/coolo/prod/kdelibs/kdecore/kiconeffect.h"
    static void colorize(QImage &image, const QColor &col, float value);







    static void deSaturate(QImage &image, float value);







    static void toGamma(QImage &image, float value);






    static void semiTransparent(QImage &image);






    static void semiTransparent(QPixmap &pixmap);







    static void overlay(QImage &src, QImage &overlay);

private:
    int mEffect[6][3];
    float mValue[6][3];
    QColor mColor[6][3];
    bool mTrans[6][3];
    KIconEffectPrivate *d;
};
# 34 "/coolo/prod/kdelibs/kdecore/kiconeffect.cpp" 2

extern bool qt_use_xrender;
extern bool qt_has_xft;

class KIconEffectPrivate
{
public:
        QString mKey[6][3];
};

KIconEffect::KIconEffect()
{
    d = new KIconEffectPrivate;
    init();
}

KIconEffect::~KIconEffect()
{
    delete d;
    d = 0L;
}

void KIconEffect::init()
{
    KConfig *config = KGlobal::config();

    int i, j, effect=-1;
    QStringList groups;
    groups += "Desktop";
    groups += "Toolbar";
    groups += "MainToolbar";
    groups += "Small";
    groups += "Panel";

    QStringList states;
    states += "Default";
    states += "Active";
    states += "Disabled";

    QStringList::ConstIterator it, it2;
    QString _togray("togray");
    QString _colorize("colorize");
    QString _desaturate("desaturate");
    QString _togamma("togamma");
    QString _none("none");

    KConfigGroupSaver cs(config, "default");

    for (it=groups.begin(), i=0; it!=groups.end(); it++, i++)
    {

        mEffect[i][0] = NoEffect;
        mEffect[i][1] = ((i==0)||(i==4)) ? ToGamma : NoEffect;
        mEffect[i][2] = ToGray;

        mTrans[i][0] = false;
        mTrans[i][1] = false;
        mTrans[i][2] = true;
        mValue[i][0] = 1.0;
        mValue[i][1] = ((i==0)||(i==4)) ? 0.7 : 1.0;
        mValue[i][2] = 1.0;
        mColor[i][0] = QColor(144,128,248);
        mColor[i][1] = QColor(169,156,255);
        mColor[i][2] = QColor(34,202,0);

        config->setGroup(*it + "Icons");
        for (it2=states.begin(), j=0; it2!=states.end(); it2++, j++)
        {
            QString tmp = config->readEntry(*it2 + "Effect");
            if (tmp == _togray)
                effect = ToGray;
            else if (tmp == _colorize)
                effect = Colorize;
            else if (tmp == _desaturate)
                effect = DeSaturate;
            else if (tmp == _togamma)
                effect = ToGamma;
            else if (tmp == _none)
                effect = NoEffect;
            else
                continue;
            if(effect != -1)
                mEffect[i][j] = effect;
            mValue[i][j] = config->readDoubleNumEntry(*it2 + "Value");
            mColor[i][j] = config->readColorEntry(*it2 + "Color");
            mTrans[i][j] = config->readBoolEntry(*it2 + "SemiTransparent");

        }
    }
}

bool KIconEffect::hasEffect(int group, int state) const
{
    return mEffect[group][state] != NoEffect;
}

QString KIconEffect::fingerprint(int group, int state) const
{
    if ( group >= KIcon::LastGroup ) return "";
    QString cached = d->mKey[group][state];
    if (cached.isEmpty())
    {
        QString tmp;
        cached = tmp.setNum(mEffect[group][state]);
        cached += ':';
        cached += tmp.setNum(mValue[group][state]);
        cached += ':';
        cached += mTrans[group][state] ? QString::fromLatin1("trans")
            : QString::fromLatin1("notrans");
        if (mEffect[group][state] == Colorize)
        {
            cached += ':';
            cached += mColor[group][state].name();
        }

        d->mKey[group][state] = cached;
    }

    return cached;
}

QImage KIconEffect::apply(QImage image, int group, int state) const
{
    if (state >= KIcon::LastState)
    {
        kdDebug(265) << "Illegal icon state: " << state << "\n";
        return image;
    }
    if (group >= KIcon::LastGroup)
    {
        kdDebug(265) << "Illegal icon group: " << group << "\n";
        return image;
    }
    return apply(image, mEffect[group][state], mValue[group][state],
            mColor[group][state], mTrans[group][state]);
}

QImage KIconEffect::apply(QImage image, int effect, float value, const QColor col, bool trans) const
{
    if (effect >= LastEffect )
    {
        kdDebug(265) << "Illegal icon effect: " << effect << "\n";
        return image;
    }
    if (value > 1.0)
        value = 1.0;
    else if (value < 0.0)
        value = 0.0;
    switch (effect)
    {
    case ToGray:
        toGray(image, value);
        break;
    case DeSaturate:
        deSaturate(image, value);
        break;
    case Colorize:
        colorize(image, col, value);
        break;
    case ToGamma:
        toGamma(image, value);
        break;
    }
    if (trans == true)
    {
        semiTransparent(image);
    }
    return image;
}

QPixmap KIconEffect::apply(QPixmap pixmap, int group, int state) const
{
    if (state >= KIcon::LastState)
    {
        kdDebug(265) << "Illegal icon state: " << state << "\n";
        return pixmap;
    }
    if (group >= KIcon::LastGroup)
    {
        kdDebug(265) << "Illegal icon group: " << group << "\n";
        return pixmap;
    }
    return apply(pixmap, mEffect[group][state], mValue[group][state],
            mColor[group][state], mTrans[group][state]);
}

QPixmap KIconEffect::apply(QPixmap pixmap, int effect, float value,
        const QColor col, bool trans) const
{
    QPixmap result;

    if (effect >= LastEffect )
    {
        kdDebug(265) << "Illegal icon effect: " << effect << "\n";
        return result;
    }

    if ((trans == true) && (effect == NoEffect))
    {
        result = pixmap;
        semiTransparent(result);
    }
    else if ( effect != NoEffect )
    {
        QImage tmpImg = pixmap.convertToImage();
        tmpImg = apply(tmpImg, effect, value, col, trans);
        result.convertFromImage(tmpImg);
    }
    else
        result = pixmap;

    return result;
}




void KIconEffect::toGray(QImage &img, float value)
{
    int pixels = (img.depth() > 8) ? img.width()*img.height()
            : img.numColors();
    unsigned int *data = img.depth() > 8 ? (unsigned int *) img.bits()
            : (unsigned int *) img.colorTable();
    int rval, gval, bval, val, alpha, i;
    for (i=0; i<pixels; i++)
    {
        val = qGray(data[i]);
        alpha = qAlpha(data[i]);
        if (value < 1.0)
        {
            rval = static_cast<int>(value*val+(1.0-value)*qRed(data[i]));
            gval = static_cast<int>(value*val+(1.0-value)*qGreen(data[i]));
            bval = static_cast<int>(value*val+(1.0-value)*qBlue(data[i]));
            data[i] = qRgba(rval, gval, bval, alpha);
        } else
            data[i] = qRgba(val, val, val, alpha);
    }
}

void KIconEffect::colorize(QImage &img, const QColor &col, float value)
{
    int pixels = (img.depth() > 8) ? img.width()*img.height()
            : img.numColors();
    unsigned int *data = img.depth() > 8 ? (unsigned int *) img.bits()
            : (unsigned int *) img.colorTable();
    int rval, gval, bval, val, alpha, i;
    float rcol = col.red(), gcol = col.green(), bcol = col.blue();
    for (i=0; i<pixels; i++)
    {
        val = qGray(data[i]);
        if (val < 128)
        {
             rval = static_cast<int>(rcol/128*val);
             gval = static_cast<int>(gcol/128*val);
             bval = static_cast<int>(bcol/128*val);
        }
        else if (val > 128)
        {
             rval = static_cast<int>((val-128)*(2-rcol/128)+rcol-1);
             gval = static_cast<int>((val-128)*(2-gcol/128)+gcol-1);
             bval = static_cast<int>((val-128)*(2-bcol/128)+bcol-1);
        }
        else
        {
             rval = static_cast<int>(rcol);
             gval = static_cast<int>(gcol);
             bval = static_cast<int>(bcol);
        }
        if (value < 1.0)
        {
            rval = static_cast<int>(value*rval+(1.0 - value)*qRed(data[i]));
            gval = static_cast<int>(value*gval+(1.0 - value)*qGreen(data[i]));
            bval = static_cast<int>(value*bval+(1.0 - value)*qBlue(data[i]));
        }

        alpha = qAlpha(data[i]);
        data[i] = qRgba(rval, gval, bval, alpha);
    }
}

void KIconEffect::deSaturate(QImage &img, float value)
{
    int pixels = (img.depth() > 8) ? img.width()*img.height()
            : img.numColors();
    unsigned int *data = (img.depth() > 8) ? (unsigned int *) img.bits()
            : (unsigned int *) img.colorTable();
    QColor color;
    int h, s, v, i;
    for (i=0; i<pixels; i++)
    {
        color.setRgb(data[i]);
        color.hsv(&h, &s, &v);
        color.setHsv(h, (int) (s * (1.0 - value) + 0.5), v);
        data[i] = qRgba(color.red(), color.green(), color.blue(),
                qAlpha(data[i]));
    }
}

void KIconEffect::toGamma(QImage &img, float value)
{
    int pixels = (img.depth() > 8) ? img.width()*img.height()
            : img.numColors();
    unsigned int *data = (img.depth() > 8) ? (unsigned int *) img.bits()
            : (unsigned int *) img.colorTable();
    QColor color;
    int i, rval, gval, bval;
    float gamma;
    gamma = 1/(2*value+0.5);

    for (i=0; i<pixels; i++)
    {
        color.setRgb(data[i]);
        color.rgb(&rval, &gval, &bval);
        rval = static_cast<int>(pow(static_cast<float>(rval)/255 , gamma)*255);
        gval = static_cast<int>(pow(static_cast<float>(gval)/255 , gamma)*255);
        bval = static_cast<int>(pow(static_cast<float>(bval)/255 , gamma)*255);
        data[i] = qRgba(rval, gval, bval, qAlpha(data[i]));
    }
}

void KIconEffect::semiTransparent(QImage &img)
{
    img.setAlphaBuffer(true);

    int x, y;
    if (img.depth() == 32)
    {
        int width = img.width();
        int height = img.height();

        if (qt_use_xrender && qt_has_xft )
          for (y=0; y<height; y++)
          {



            uchar *line = (uchar*) img.scanLine(y) + 3;

            for (x=0; x<width; x++)
            {
                *line >>= 1;
                line += 4;
            }
          }
        else
          for (y=0; y<height; y++)
          {
            QRgb *line = (QRgb *) img.scanLine(y);
            for (x=(y%2); x<width; x+=2)
                line[x] &= 0x00ffffff;
          }

    } else
    {

        int transColor = -1;


        for (x=0; x<img.numColors(); x++)
        {

            if (qAlpha(img.color(x)) < 127)
            {
                transColor = x;
                break;
            }
        }



        if(transColor < 0 || transColor >= img.numColors())
            return;

        img.setColor(transColor, 0);
        if(img.depth() == 8)
        {
            for (y=0; y<img.height(); y++)
            {
                unsigned char *line = img.scanLine(y);
                for (x=(y%2); x<img.width(); x+=2)
                    line[x] = transColor;
            }
        }
        else
        {


            for (y=0; y<img.height(); y++)
                for (x=(y%2); x<img.width(); x+=2)
                    img.setPixel(x, y, transColor);
        }
    }
}

void KIconEffect::semiTransparent(QPixmap &pix)
{
    if ( qt_use_xrender && qt_has_xft )
    {
        QImage img=pix.convertToImage();
        semiTransparent(img);
        pix.convertFromImage(img);
        return;
    }

    QImage img;
    if (pix.mask() != 0L)
        img = pix.mask()->convertToImage();
    else
    {
        img.create(pix.size(), 1, 2, QImage::BigEndian);
        img.fill(1);
    }

    for (int y=0; y<img.height(); y++)
    {
        QRgb *line = (QRgb *) img.scanLine(y);
        QRgb pattern = (y % 2) ? 0x55555555 : 0xaaaaaaaa;
        for (int x=0; x<(img.width()+31)/32; x++)
            line[x] &= pattern;
    }
    QBitmap mask;
    mask.convertFromImage(img);
    pix.setMask(mask);
}

QImage KIconEffect::doublePixels(QImage src) const
{
    QImage dst;
    if (src.depth() == 1)
    {
        kdDebug(265) << "image depth 1 not supported\n";
        return dst;
    }

    int w = src.width();
    int h = src.height();
    dst.create(w*2, h*2, src.depth());
    dst.setAlphaBuffer(src.hasAlphaBuffer());

    int x, y;
    if (src.depth() == 32)
    {
        QRgb *l1, *l2;
        for (y=0; y<h; y++)
        {
            l1 = (QRgb *) src.scanLine(y);
            l2 = (QRgb *) dst.scanLine(y*2);
            for (x=0; x<w; x++)
            {
                l2[x*2] = l2[x*2+1] = l1[x];
            }
            memcpy(dst.scanLine(y*2+1), l2, dst.bytesPerLine());
        }
    } else
    {
        for (x=0; x<src.numColors(); x++)
            dst.setColor(x, src.color(x));

        unsigned char *l1, *l2;
        for (y=0; y<h; y++)
        {
            l1 = src.scanLine(y);
            l2 = dst.scanLine(y*2);
            for (x=0; x<w; x++)
            {
                l2[x*2] = l1[x];
                l2[x*2+1] = l1[x];
            }
            memcpy(dst.scanLine(y*2+1), l2, dst.bytesPerLine());
        }
    }
    return dst;
}

void KIconEffect::overlay(QImage &src, QImage &overlay)
{
    if (src.depth() != overlay.depth())
    {
        kdDebug(265) << "Image depth src != overlay!\n";
        return;
    }
    if (src.size() != overlay.size())
    {
        kdDebug(265) << "Image size src != overlay\n";
        return;
    }
    if (!overlay.hasAlphaBuffer())
    {
        kdDebug(265) << "Overlay doesn't have alpha buffer!\n";
        return;
    }

    int i, j;



    if (src.depth() == 1)
    {
        kdDebug(265) << "1bpp not supported!\n";
        return;
    }



    if (src.depth() == 8)
    {
        if (src.numColors() + overlay.numColors() > 255)
        {
            kdDebug(265) << "Too many colors in src + overlay!\n";
            return;
        }


        int trans;
        for (trans=0; trans<overlay.numColors(); trans++)
        {
            if (qAlpha(overlay.color(trans)) == 0)
            {
                kdDebug(265) << "transparent pixel found at " << trans << "\n";
                break;
            }
        }
        if (trans == overlay.numColors())
        {
            kdDebug(265) << "transparent pixel not found!\n";
            return;
        }


        int nc = src.numColors();
        src.setNumColors(nc + overlay.numColors());
        for (i=0; i<overlay.numColors(); i++)
        {
            src.setColor(nc+i, overlay.color(i));
        }


        unsigned char *oline, *sline;
        for (i=0; i<src.height(); i++)
        {
            oline = overlay.scanLine(i);
            sline = src.scanLine(i);
            for (j=0; j<src.width(); j++)
            {
                if (oline[j] != trans)
                    sline[j] = oline[j]+nc;
            }
        }
    }



    if (src.depth() == 32)
    {
        QRgb *oline, *sline;
        int r1, g1, b1, a1;
        int r2, g2, b2, a2;

        for (i=0; i<src.height(); i++)
        {
            oline = (QRgb *) overlay.scanLine(i);
            sline = (QRgb *) src.scanLine(i);

            for (j=0; j<src.width(); j++)
            {
                r1 = qRed(oline[j]);
                g1 = qGreen(oline[j]);
                b1 = qBlue(oline[j]);
                a1 = qAlpha(oline[j]);

                r2 = qRed(sline[j]);
                g2 = qGreen(sline[j]);
                b2 = qBlue(sline[j]);
                a2 = qAlpha(sline[j]);

                r2 = (a1 * r1 + (0xff - a1) * r2) >> 8;
                g2 = (a1 * g1 + (0xff - a1) * g2) >> 8;
                b2 = (a1 * b1 + (0xff - a1) * b2) >> 8;
                a2 = ((a2) < (a1) ? (a1) : (a2));

                sline[j] = qRgba(r2, g2, b2, a2);
            }
        }
    }

    return;
}

    void
KIconEffect::visualActivate(QWidget * widget, QRect rect)
{
    if (!KGlobalSettings::visualActivate())
        return;

    uint actSpeed = KGlobalSettings::visualActivateSpeed();

    uint actCount = ((rect.width()) < (rect.height()) ? (rect.width()) : (rect.height())) / 2;



    if (actCount < 1)
        actCount = 1;

    else if (actCount > 10)
        actCount = 10;



    if (actSpeed < 1)
        actSpeed = 1;

    else if (actSpeed > 100)
        actSpeed = 100;






    unsigned int actDelay = (1000 * (100 - actSpeed)) / actCount;



    QPoint c = rect.center();

    QPainter p(widget);


    p.setPen(QPen(Qt::black, 2, Qt::DotLine));
    p.setRasterOp(Qt::NotROP);







    unsigned int deltaX = rect.width() / actCount;
    unsigned int deltaY = rect.height() / actCount;

    for (unsigned int i = 1; i < actCount; i++) {

        int w = i * deltaX;
        int h = i * deltaY;

        rect.setRect(c.x() - w / 2, c.y() - h / 2, w, h);

        p.drawRect(rect);
        p.flush();

        usleep(actDelay);

        p.drawRect(rect);
    }
}
# 22 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kicontheme.cpp" 1
# 19 "/coolo/prod/kdelibs/kdecore/kicontheme.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 20 "/coolo/prod/kdelibs/kdecore/kicontheme.cpp" 2
# 40 "/coolo/prod/kdelibs/kdecore/kicontheme.cpp"
class KIconThemePrivate
{
public:
    QString example, screenshot;
    QString linkOverlay, lockOverlay, zipOverlay, shareOverlay;
    bool hidden;
};




class KIconThemeDir
{
public:
    KIconThemeDir(const QString& dir, const KConfigBase *config);

    bool isValid() const { return mbValid; }
    QString iconPath(const QString& name) const;
    QStringList iconList() const;
    QString dir() const { return mDir; }

    KIcon::Context context() const { return mContext; }
    KIcon::Type type() const { return mType; }
    int size() const { return mSize; }
    int minSize() const { return mMinSize; }
    int maxSize() const { return mMaxSize; }
    int threshold() const { return mThreshold; }

private:
    bool mbValid;
    KIcon::Type mType;
    KIcon::Context mContext;
    int mSize, mMinSize, mMaxSize;
    int mThreshold;

    QString mDir;
};




KIconTheme::KIconTheme(const QString& name, const QString& appName)
{
    d = new KIconThemePrivate;

    QStringList icnlibs;
    QStringList::ConstIterator it, itDir;
    QStringList themeDirs;
    QString cDir;





    if (!appName.isEmpty() &&
       ( name == "crystalsvg" || name== "hicolor" || name == "locolor" ) )
    {
        icnlibs = KGlobal::dirs()->resourceDirs("data");
        for (it=icnlibs.begin(); it!=icnlibs.end(); it++)
        {
            cDir = *it + appName + "/icons/" + name;
            if (QFile::exists( cDir ))
                themeDirs += cDir + "/";
        }
    }


    icnlibs = KGlobal::dirs()->resourceDirs("icon");
    for (it=icnlibs.begin(); it!=icnlibs.end(); it++)
    {
        cDir = *it + name + "/";
        if (KStandardDirs::exists(cDir))
        {
            themeDirs += cDir;
            if (mDir.isEmpty()
                    && (KStandardDirs::exists( cDir + "index.desktop") || KStandardDirs::exists( cDir + "index.theme")))
                mDir = cDir;
        }
    }

    if (mDir.isEmpty())
    {
        kdDebug(264) << "Icon theme " << name << " not found.\n";
        return;
    }

    QString fileName, mainSection;
    if(QFile::exists(mDir + "index.desktop")) {
        fileName = mDir + "index.desktop";
        mainSection="KDE Icon Theme";
    } else {
        fileName = mDir + "index.theme";
        mainSection="Icon Theme";
    }
    KSimpleConfig cfg(fileName);
    cfg.setGroup(mainSection);
    mName = cfg.readEntry("Name");
    mDesc = cfg.readEntry("Comment");
    mDepth = cfg.readNumEntry("DisplayDepth", 32);
    mInherits = cfg.readListEntry("Inherits");
    if ( name != "crystalsvg" )
      for ( QStringList::Iterator it = mInherits.begin(); it != mInherits.end(); ++it )
         if ( *it == "default" || *it == "hicolor" ) *it="crystalsvg";

    d->hidden = cfg.readBoolEntry("Hidden", false);
    d->example = cfg.readPathEntry("Example");
    d->screenshot = cfg.readPathEntry("ScreenShot");
    d->linkOverlay = cfg.readEntry("LinkOverlay", "link");
    d->lockOverlay = cfg.readEntry("LockOverlay", "lock");
    d->zipOverlay = cfg.readEntry("ZipOverlay", "zip");
    d->shareOverlay = cfg.readEntry("ShareOverlay","share");

    QStringList dirs = cfg.readPathListEntry("Directories");
    mDirs.setAutoDelete(true);
    for (it=dirs.begin(); it!=dirs.end(); it++)
    {
        cfg.setGroup(*it);
        for (itDir=themeDirs.begin(); itDir!=themeDirs.end(); itDir++)
        {
            if (KStandardDirs::exists(*itDir + *it + "/"))
            {
                KIconThemeDir *dir = new KIconThemeDir(*itDir + *it, &cfg);
                if (!dir->isValid())
                {
                    kdWarning(264) << "Icon directory " << *itDir << " group " << *it << " not valid.\n";
                    delete dir;
                }
                else
                    mDirs.append(dir);
            }
        }
    }


    int i;
    QMap<int,QValueList<int> > scIcons;
    for (KIconThemeDir *dir=mDirs.first(); dir!=0L; dir=mDirs.next())
    {
        if ((dir->type() == KIcon::Scalable) && !scIcons.contains(dir->size()))
        {
            QValueList<int> lst;
            for (i=dir->minSize(); i<=dir->maxSize(); i++)
                lst += i;
            scIcons[dir->size()] = lst;
        }
    }

    QStringList groups;
    groups += "Desktop";
    groups += "Toolbar";
    groups += "MainToolbar";
    groups += "Small";
    groups += "Panel";
    const int defDefSizes[] = { 32, 22, 22, 16, 32 };
    cfg.setGroup(mainSection);
    for (it=groups.begin(), i=0; it!=groups.end(); it++, i++)
    {
        mDefSize[i] = cfg.readNumEntry(*it + "Default", defDefSizes[i]);
        QValueList<int> lst = cfg.readIntListEntry(*it + "Sizes"), exp;
        QValueList<int>::ConstIterator it2;
        for (it2=lst.begin(); it2!=lst.end(); it2++)
        {
            if (scIcons.contains(*it2))
                exp += scIcons[*it2];
            else
                exp += *it2;
        }
        mSizes[i] = exp;
    }

}

KIconTheme::~KIconTheme()
{
    delete d;
}

bool KIconTheme::isValid() const
{
    return !mDirs.isEmpty();
}

bool KIconTheme::isHidden() const
{
    return d->hidden;
}

QString KIconTheme::example() const { return d->example; }
QString KIconTheme::screenshot() const { return d->screenshot; }
QString KIconTheme::linkOverlay() const { return d->linkOverlay; }
QString KIconTheme::lockOverlay() const { return d->lockOverlay; }
QString KIconTheme::zipOverlay() const { return d->zipOverlay; }
QString KIconTheme::shareOverlay() const { return d->shareOverlay; }

int KIconTheme::defaultSize(KIcon::Group group) const
{
    if ((group < 0) || (group >= KIcon::LastGroup))
    {
        kdDebug(264) << "Illegal icon group: " << group << "\n";
        return -1;
    }
    return mDefSize[group];
}

QValueList<int> KIconTheme::querySizes(KIcon::Group group) const
{
    QValueList<int> empty;
    if ((group < 0) || (group >= KIcon::LastGroup))
    {
        kdDebug(264) << "Illegal icon group: " << group << "\n";
        return empty;
    }
    return mSizes[group];
}

QStringList KIconTheme::queryIcons(int size, KIcon::Context context) const
{
    int delta = 1000, dw;

    QPtrListIterator<KIconThemeDir> dirs(mDirs);
    KIconThemeDir *dir;


    QStringList result;
    for ( ; dirs.current(); ++dirs)
    {
        dir = dirs.current();
        if ((context != KIcon::Any) && (context != dir->context()))
            continue;
        if ((dir->type() == KIcon::Fixed) && (dir->size() == size))
        {
            result += dir->iconList();
            continue;
        }
        if ((dir->type() == KIcon::Scalable) &&
            (size >= dir->minSize()) && (size <= dir->maxSize()))
        {
            result += dir->iconList();
            continue;
        }
        if ((dir->type() == KIcon::Threshold) &&
            (abs(size-dir->size())<dir->threshold()))
            result+=dir->iconList();
    }

    return result;

    dirs.toFirst();


    KIconThemeDir *best = 0L;
    for ( ; dirs.current(); ++dirs)
    {
        dir = dirs.current();
        if ((context != KIcon::Any) && (context != dir->context()))
            continue;
        dw = dir->size() - size;
        if ((dw > 6) || (abs(dw) >= abs(delta)))
            continue;
        delta = dw;
        best = dir;
    }
    if (best == 0L)
        return QStringList();

    return best->iconList();
}

QStringList KIconTheme::queryIconsByContext(int size, KIcon::Context context) const
{
    QPtrListIterator<KIconThemeDir> dirs(mDirs);
    int dw;
    KIconThemeDir *dir;




    QStringList iconlist[128];




    for ( ; dirs.current(); ++dirs)
    {
        dir = dirs.current();
        if ((context != KIcon::Any) && (context != dir->context()))
            continue;
        dw = abs(dir->size() - size);
        iconlist[(dw<127)?dw:127]+=dir->iconList();
    }

    QStringList iconlistResult;
    for (int i=0; i<128; i++) iconlistResult+=iconlist[i];

    return iconlistResult;
}

KIcon KIconTheme::iconPath(const QString& name, int size, KIcon::MatchType match) const
{
    KIcon icon;
    QString path;
    int delta = 1000, dw;
    KIconThemeDir *dir;

    dw = 1000;
    QPtrListIterator<KIconThemeDir> dirs(mDirs);
    for ( ; dirs.current(); ++dirs)
    {
        dir = dirs.current();

        if (match == KIcon::MatchExact)
        {
            if ((dir->type() == KIcon::Fixed) && (dir->size() != size))
                continue;
            if ((dir->type() == KIcon::Scalable) &&
                ((size < dir->minSize()) || (size > dir->maxSize())))
              continue;
            if ((dir->type() == KIcon::Threshold) &&
                (abs(dir->size()-size) > dir->threshold()))
                continue;
        } else
        {
            dw = dir->size() - size;
            if (dir->type() != KIcon::Threshold &&
               ((dw > 7) || (abs(dw) >= abs(delta))))
                continue;
        }

        path = dir->iconPath(name);
        if (path.isEmpty())
            continue;
        icon.path = path;
        icon.size = dir->size();
        icon.type = dir->type();
        icon.threshold = dir->threshold();
        icon.context = dir->context();


        if (match == KIcon::MatchExact)
            return icon;
        else
        {
            delta = dw;
            if (delta==0) return icon;
        }
    }
    return icon;
}


QString *KIconTheme::_theme = 0L;


QStringList *KIconTheme::_theme_list = 0L;


QString KIconTheme::current()
{

    if (_theme != 0L)
        return *_theme;

    _theme = new QString();
    KConfig *config = KGlobal::config();
    KConfigGroupSaver saver(config, "Icons");
    *_theme = config->readEntry("Theme",defaultThemeName());
    if ( *_theme == QString::fromLatin1("hicolor") ) *_theme = defaultThemeName();







    return *_theme;
}


QStringList KIconTheme::list()
{

    if (_theme_list != 0L)
        return *_theme_list;

    _theme_list = new QStringList();
    QStringList icnlibs = KGlobal::dirs()->resourceDirs("icon");
    QStringList::ConstIterator it;
    for (it=icnlibs.begin(); it!=icnlibs.end(); it++)
    {
        QDir dir(*it);
        if (!dir.exists())
            continue;
        QStringList lst = dir.entryList(QDir::Dirs);
        QStringList::ConstIterator it2;
        for (it2=lst.begin(); it2!=lst.end(); it2++)
        {
            if ((*it2 == ".") || (*it2 == "..") || (*it2).startsWith("default.") )
                continue;
            if (!KStandardDirs::exists(*it + *it2 + "/index.desktop") && !KStandardDirs::exists(*it + *it2 + "/index.theme"))
                continue;
            if (!_theme_list->contains(*it2))
                _theme_list->append(*it2);
        }
    }
    return *_theme_list;
}


void KIconTheme::reconfigure()
{
    delete _theme;
    _theme=0L;
    delete _theme_list;
    _theme_list=0L;
}


QString KIconTheme::defaultThemeName()
{
    return QString::fromLatin1("crystalsvg");
}



KIconThemeDir::KIconThemeDir(const QString& dir, const KConfigBase *config)
{
    mbValid = false;
    mDir = dir;
    mSize = config->readNumEntry("Size");
    mMinSize = 1;
    mMaxSize = 50;
    mType = KIcon::Fixed;

    if (mSize == 0)
        return;

    QString tmp = config->readEntry("Context");
    if (tmp == "Devices")
        mContext = KIcon::Device;
    else if (tmp == "MimeTypes")
        mContext = KIcon::MimeType;
    else if (tmp == "FileSystems")
        mContext = KIcon::FileSystem;
    else if (tmp == "Applications")
        mContext = KIcon::Application;
    else if (tmp == "Actions")
        mContext = KIcon::Action;
    else {
        kdDebug(264) << "Invalid Context= line for icon theme: " << mDir << "\n";
        return;
    }
    tmp = config->readEntry("Type");
    if (tmp == "Fixed")
        mType = KIcon::Fixed;
    else if (tmp == "Scalable")
        mType = KIcon::Scalable;
    else if (tmp == "Threshold")
        mType = KIcon::Threshold;
    else {
        kdDebug(264) << "Invalid Type= line for icon theme: " << mDir << "\n";
        return;
    }
    if (mType == KIcon::Scalable)
    {
        mMinSize = config->readNumEntry("MinSize", mSize);
        mMaxSize = config->readNumEntry("MaxSize", mSize);
    } else if (mType == KIcon::Threshold)
        mThreshold = config->readNumEntry("Threshold", 2);
    mbValid = true;
}

QString KIconThemeDir::iconPath(const QString& name) const
{
    if (!mbValid)
        return QString::null;
    QString file = mDir + "/" + name;

    if (access(QFile::encodeName(file), 4) == 0)
        return file;

    return QString::null;
}

QStringList KIconThemeDir::iconList() const
{
    QDir dir(mDir);

    QStringList lst = dir.entryList("*.png;*.svg;*.svgz;*.xpm", QDir::Files);



    QStringList result;
    QStringList::ConstIterator it;
    for (it=lst.begin(); it!=lst.end(); it++)
        result += mDir + "/" + *it;
    return result;
}
# 23 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kiconloader.cpp" 1
# 44 "/coolo/prod/kdelibs/kdecore/kiconloader.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 45 "/coolo/prod/kdelibs/kdecore/kiconloader.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/svgicons/ksvgiconengine.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/svgicons/ksvgiconengine.h"



class KSVGIconPainter;

class KSVGIconEngine
{
public:
        KSVGIconEngine();
        ~KSVGIconEngine();

        bool load(int width, int height, const QString &path);

        KSVGIconPainter *painter();
        QImage *image();

        double width();
        double height();

private:
        struct Private;
        Private *d;
};
# 48 "/coolo/prod/kdelibs/kdecore/kiconloader.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/svgicons/ksvgiconpainter.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/svgicons/ksvgiconpainter.h"

# 1 "/usr/include/libart-2.0/libart_lgpl/art_render.h" 1
# 24 "/usr/include/libart-2.0/libart_lgpl/art_render.h"




# 1 "/usr/include/libart-2.0/libart_lgpl/art_alphagamma.h" 1
# 21 "/usr/include/libart-2.0/libart_lgpl/art_alphagamma.h"






# 1 "/usr/include/libart-2.0/libart_lgpl/art_misc.h" 1
# 24 "/usr/include/libart-2.0/libart_lgpl/art_misc.h"
# 34 "/usr/include/libart-2.0/libart_lgpl/art_misc.h"
# 1 "/usr/include/libart-2.0/libart_lgpl/art_config.h" 1



typedef unsigned char art_u8;
typedef unsigned short art_u16;
typedef unsigned int art_u32;
# 35 "/usr/include/libart-2.0/libart_lgpl/art_misc.h" 2











typedef int art_boolean;
# 68 "/usr/include/libart-2.0/libart_lgpl/art_misc.h"








extern "C" {


void __attribute__((noreturn))
art_die (const char *fmt, ...) __attribute__((format (printf, 1, 2)));

void
art_warn (const char *fmt, ...) __attribute__((format (printf, 1, 2)));

void
art_dprint (const char *fmt, ...) __attribute__((format (printf, 1, 2)));


}


# 29 "/usr/include/libart-2.0/libart_lgpl/art_alphagamma.h" 2



extern "C" {


typedef struct _ArtAlphaGamma ArtAlphaGamma;

struct _ArtAlphaGamma {

  double gamma;
  int invtable_size;
  int table[256];
  art_u8 invtable[1];
};

ArtAlphaGamma *
art_alphagamma_new (double gamma);

void
art_alphagamma_free (ArtAlphaGamma *alphagamma);


}
# 30 "/usr/include/libart-2.0/libart_lgpl/art_render.h" 2



extern "C" {








typedef art_u16 ArtPixMaxDepth;
# 56 "/usr/include/libart-2.0/libart_lgpl/art_render.h"

typedef struct _ArtRender ArtRender;
typedef struct _ArtRenderCallback ArtRenderCallback;
typedef struct _ArtRenderMaskRun ArtRenderMaskRun;
typedef struct _ArtImageSource ArtImageSource;
typedef struct _ArtMaskSource ArtMaskSource;

typedef enum {
  ART_ALPHA_NONE = 0,
  ART_ALPHA_SEPARATE = 1,
  ART_ALPHA_PREMUL = 2
} ArtAlphaType;

typedef enum {
  ART_COMPOSITE_NORMAL,
  ART_COMPOSITE_MULTIPLY,

  ART_COMPOSITE_CUSTOM
} ArtCompositingMode;

typedef enum {
  ART_IMAGE_SOURCE_CAN_CLEAR = 1,
  ART_IMAGE_SOURCE_CAN_COMPOSITE = 2
} ArtImageSourceFlags;

struct _ArtRenderMaskRun {
  int x;
  int alpha;
};

struct _ArtRenderCallback {
  void (*render) (ArtRenderCallback *self, ArtRender *render,
                  art_u8 *dest, int y);
  void (*done) (ArtRenderCallback *self, ArtRender *render);
};

struct _ArtImageSource {
  ArtRenderCallback super;
  void (*negotiate) (ArtImageSource *self, ArtRender *render,
                     ArtImageSourceFlags *p_flags,
                     int *p_buf_depth, ArtAlphaType *p_alpha_type);
};

struct _ArtMaskSource {
  ArtRenderCallback super;
  int (*can_drive) (ArtMaskSource *self, ArtRender *render);


  void (*invoke_driver) (ArtMaskSource *self, ArtRender *render);
  void (*prepare) (ArtMaskSource *self, ArtRender *render, art_boolean first);
};

struct _ArtRender {

  int x0, y0;
  int x1, y1;
  art_u8 *pixels;
  int rowstride;
  int n_chan;
  int depth;
  ArtAlphaType alpha_type;

  art_boolean clear;
  ArtPixMaxDepth clear_color[16 + 1];
  art_u32 opacity;

  ArtCompositingMode compositing_mode;

  ArtAlphaGamma *alphagamma;

  art_u8 *alpha_buf;


  int buf_depth;
  ArtAlphaType buf_alpha;
  art_u8 *image_buf;



  int n_run;
  ArtRenderMaskRun *run;


  int n_span;
  int *span_x;

  art_boolean need_span;
};

ArtRender *
art_render_new (int x0, int y0, int x1, int y1,
                art_u8 *pixels, int rowstride,
                int n_chan, int depth, ArtAlphaType alpha_type,
                ArtAlphaGamma *alphagamma);

void
art_render_invoke (ArtRender *render);

void
art_render_clear (ArtRender *render, const ArtPixMaxDepth *clear_color);

void
art_render_clear_rgb (ArtRender *render, art_u32 clear_rgb);

void
art_render_mask_solid (ArtRender *render, int opacity);

void
art_render_image_solid (ArtRender *render, ArtPixMaxDepth *color);


void
art_render_add_mask_source (ArtRender *render, ArtMaskSource *mask_source);

void
art_render_invoke_callbacks (ArtRender *render, art_u8 *dest, int y);


void
art_render_add_image_source (ArtRender *render, ArtImageSource *image_source);


}
# 25 "/coolo/prod/kdelibs/kdecore/svgicons/ksvgiconpainter.h" 2
# 1 "/usr/include/libart-2.0/libart_lgpl/art_render_gradient.h" 1
# 27 "/usr/include/libart-2.0/libart_lgpl/art_render_gradient.h"





# 1 "/usr/include/libart-2.0/libart_lgpl/art_filterlevel.h" 1
# 21 "/usr/include/libart-2.0/libart_lgpl/art_filterlevel.h"


extern "C" {


typedef enum {
  ART_FILTER_NEAREST,
  ART_FILTER_TILES,
  ART_FILTER_BILINEAR,
  ART_FILTER_HYPER
} ArtFilterLevel;
# 65 "/usr/include/libart-2.0/libart_lgpl/art_filterlevel.h"
}
# 34 "/usr/include/libart-2.0/libart_lgpl/art_render_gradient.h" 2




extern "C" {


typedef struct _ArtGradientLinear ArtGradientLinear;
typedef struct _ArtGradientRadial ArtGradientRadial;
typedef struct _ArtGradientStop ArtGradientStop;

typedef enum {
  ART_GRADIENT_PAD,
  ART_GRADIENT_REFLECT,
  ART_GRADIENT_REPEAT
} ArtGradientSpread;

struct _ArtGradientLinear {
  double a;
  double b;
  double c;
  ArtGradientSpread spread;
  int n_stops;
  ArtGradientStop *stops;
};

struct _ArtGradientRadial {
  double affine[6];
  double fx, fy;
  int n_stops;
  ArtGradientStop *stops;
};

struct _ArtGradientStop {
  double offset;
  ArtPixMaxDepth color[16 + 1];
};

void
art_render_gradient_linear (ArtRender *render,
                            const ArtGradientLinear *gradient,
                            ArtFilterLevel level);

void
art_render_gradient_radial (ArtRender *render,
                            const ArtGradientRadial *gradient,
                            ArtFilterLevel level);


}
# 26 "/coolo/prod/kdelibs/kdecore/svgicons/ksvgiconpainter.h" 2

class QImage;
class QColor;
class QWMatrix;
class QDomElement;
class QPointArray;

class KSVGIconPainter
{
public:
        KSVGIconPainter(int width, int height, int dwidth, int dheight);
        ~KSVGIconPainter();

        QImage *image();

        QWMatrix *worldMatrix();

        void finish();

        void setUseFill(bool fill);
        void setUseStroke(bool stroke);

        void setStrokeWidth(double width);
        void setStrokeMiterLimit(const QString &miter);
        void setCapStyle(const QString &cap);
        void setJoinStyle(const QString &join);
        void setStrokeColor(const QString &stroke);
        void setFillColor(const QString &fill);
        void setFillRule(const QString &fillRule);
        void setOpacity(const QString &opacity);
        void setFillOpacity(const QString &fillOpacity);
        void setStrokeOpacity(const QString &strokeOpacity);
        void setStrokeDashOffset(const QString &dashOffset);
        void setStrokeDashArray(const QString &dashes);

        void setWorldMatrix(QWMatrix *worldMatrix);
        void setClippingRect(int x, int y, int w, int h);

        void drawRectangle(double x, double y, double w, double h, double rx, double ry);
        void drawEllipse(double cx, double cy, double rx, double ry);
        void drawLine(double x1, double y1, double x2, double y2);
        void drawPolyline(QPointArray polyArray, int points = -1);
        void drawPolygon(QPointArray polyArray);
        void drawPath(const QString &data, bool fill);
        void drawImage(double x, double y, QImage &image);

        QColor parseColor(const QString &param);
        Q_UINT32 toArtColor(QColor color);
        Q_UINT32 parseOpacity(QString data);

        double toPixel(const QString &s, bool hmode);
        double dpi();

        ArtGradientLinear *linearGradient(const QString &id);
        void addLinearGradient(const QString &id, ArtGradientLinear *gradient);

        QDomElement linearGradientElement(ArtGradientLinear *linear);
        void addLinearGradientElement(ArtGradientLinear *gradient, QDomElement element);

        ArtGradientRadial *radialGradient(const QString &id);
        void addRadialGradient(const QString &id, ArtGradientRadial *gradient);

        QDomElement radialGradientElement(ArtGradientRadial *radial);
        void addRadialGradientElement(ArtGradientRadial *gradient, QDomElement element);

        QWMatrix parseTransform(const QString &transform);

private:
        struct Private;
        Private *d;
};
# 49 "/coolo/prod/kdelibs/kdecore/kiconloader.cpp" 2




class KIconThemeNode
{
public:

    KIconThemeNode(KIconTheme *_theme);
    ~KIconThemeNode();

    void queryIcons(QStringList *lst, int size, KIcon::Context context) const;
    void queryIconsByContext(QStringList *lst, int size, KIcon::Context context) const;
    KIcon findIcon(const QString& name, int size, KIcon::MatchType match) const;
    void printTree(QString& dbgString) const;

    KIconTheme *theme;
};

KIconThemeNode::KIconThemeNode(KIconTheme *_theme)
{
    theme = _theme;
}

KIconThemeNode::~KIconThemeNode()
{
    delete theme;
}

void KIconThemeNode::printTree(QString& dbgString) const
{


    dbgString += "(";
    dbgString += theme->name();
    dbgString += ")";
}

void KIconThemeNode::queryIcons(QStringList *result,
                                int size, KIcon::Context context) const
{

    *result += theme->queryIcons(size, context);
}

void KIconThemeNode::queryIconsByContext(QStringList *result,
                                int size, KIcon::Context context) const
{

    *result += theme->queryIconsByContext(size, context);
}

KIcon KIconThemeNode::findIcon(const QString& name, int size,
                               KIcon::MatchType match) const
{
    return theme->iconPath(name, size, match);
}




struct KIconGroup
{
    int size;
    bool dblPixels;
    bool alphaBlending;
};




struct KIconLoaderPrivate
{
    QStringList mThemeList;
    QStringList mThemesInTree;
    KIconGroup *mpGroups;
    KIconThemeNode *mpThemeRoot;
    KStandardDirs *mpDirs;
    KIconEffect mpEffect;
    QDict<QImage> imgDict;
    QImage lastImage;
    QString lastImageKey;
    int lastIconType;
    int lastIconThreshold;
    QPtrList<KIconThemeNode> links;
    bool extraDesktopIconsLoaded :1;
    bool delayedLoading :1;
};



KIconLoader::KIconLoader(const QString& _appname, KStandardDirs *_dirs)
{
    init( _appname, _dirs );
}

void KIconLoader::reconfigure( const QString& _appname, KStandardDirs *_dirs )
{
    delete d;
    init( _appname, _dirs );
}

void KIconLoader::init( const QString& _appname, KStandardDirs *_dirs )
{
    d = new KIconLoaderPrivate;
    d->imgDict.setAutoDelete( true );
    d->links.setAutoDelete(true);
    d->extraDesktopIconsLoaded=false;
    d->delayedLoading=false;

    if (_dirs)
        d->mpDirs = _dirs;
    else
        d->mpDirs = KGlobal::dirs();



    d->mpThemeRoot = 0L;


    d->mThemeList = KIconTheme::list();
    if (!d->mThemeList.contains(KIconTheme::defaultThemeName()))
    {
        kdError(264) << "Error: standard icon theme"
                     << " \"" << KIconTheme::defaultThemeName() << "\" "
                     << " not found!" << endl;
        d->mpGroups=0L;

        return;
    }

    QString appname = _appname;
    if (appname.isEmpty())
        appname = KGlobal::instance()->instanceName();


    KIconTheme *def = new KIconTheme(KIconTheme::current(), appname);
    if (!def->isValid())
    {
        delete def;
        def = new KIconTheme(KIconTheme::defaultThemeName(), appname);
    }
    d->mpThemeRoot = new KIconThemeNode(def);
    d->links.append(d->mpThemeRoot);
    d->mThemesInTree += KIconTheme::current();
    addBaseThemes(d->mpThemeRoot, appname);


    static const char * const groups[] = { "Desktop", "Toolbar", "MainToolbar", "Small", "Panel", 0L };
    KConfig *config = KGlobal::config();
    KConfigGroupSaver cs(config, "dummy");


    d->mpGroups = new KIconGroup[(int) KIcon::LastGroup];
    for (KIcon::Group i=KIcon::FirstGroup; i<KIcon::LastGroup; i++)
    {
        if (groups[i] == 0L)
            break;
        config->setGroup(QString::fromLatin1(groups[i]) + "Icons");
        d->mpGroups[i].size = config->readNumEntry("Size", 0);
        d->mpGroups[i].dblPixels = config->readBoolEntry("DoublePixels", false);
        if (QPixmap::defaultDepth()>8)
            d->mpGroups[i].alphaBlending = config->readBoolEntry("AlphaBlending", true);
        else
            d->mpGroups[i].alphaBlending = false;

        if (!d->mpGroups[i].size)
            d->mpGroups[i].size = d->mpThemeRoot->theme->defaultSize(i);
    }


    d->mpDirs->addResourceType("appicon", KStandardDirs::kde_default("data") +
                appname + "/pics/");
    d->mpDirs->addResourceType("appicon", KStandardDirs::kde_default("data") +
                appname + "/toolbar/");


    QStringList dirs;
    dirs += d->mpDirs->resourceDirs("icon");
    dirs += d->mpDirs->resourceDirs("pixmap");
    for (QStringList::ConstIterator it = dirs.begin(); it != dirs.end(); it++)
        d->mpDirs->addResourceDir("appicon", *it);


    QString dbgString = "Theme tree: ";
    d->mpThemeRoot->printTree(dbgString);
    kdDebug(264) << dbgString << endl;

}

KIconLoader::~KIconLoader()
{


    d->mpThemeRoot=0;
    delete[] d->mpGroups;
    delete d;
}

void KIconLoader::enableDelayedIconSetLoading( bool enable )
{
    d->delayedLoading = enable;
}

bool KIconLoader::isDelayedIconSetLoadingEnabled() const
{
    return d->delayedLoading;
}

void KIconLoader::addAppDir(const QString& appname)
{
    d->mpDirs->addResourceType("appicon", KStandardDirs::kde_default("data") +
                appname + "/pics/");
    d->mpDirs->addResourceType("appicon", KStandardDirs::kde_default("data") +
                appname + "/toolbar/");
    addAppThemes(appname);
}

void KIconLoader::addAppThemes(const QString& appname)
{
    if ( KIconTheme::current() != KIconTheme::defaultThemeName() )
    {
        KIconTheme *def = new KIconTheme(KIconTheme::current(), appname);
        if (def->isValid())
        {
            KIconThemeNode* node = new KIconThemeNode(def);
            d->links.append(node);
            addBaseThemes(node, appname);
        }
        else
            delete def;
    }

    KIconTheme *def = new KIconTheme(KIconTheme::defaultThemeName(), appname);
    KIconThemeNode* node = new KIconThemeNode(def);
    d->links.append(node);
    addBaseThemes(node, appname);
}

void KIconLoader::addBaseThemes(KIconThemeNode *node, const QString &appname)
{
    QStringList lst = node->theme->inherits();
    QStringList::ConstIterator it;

    for (it=lst.begin(); it!=lst.end(); it++)
    {
        if (!d->mThemeList.contains(*it) ||
            ( d->mThemesInTree.contains(*it) && (*it) != "hicolor"))
            continue;
        KIconTheme *theme = new KIconTheme(*it,appname);
        if (!theme->isValid()) {
            delete theme;
            continue;
        }
        KIconThemeNode *n = new KIconThemeNode(theme);
        d->mThemesInTree.append(*it);
        addBaseThemes(n, appname);
        d->links.append(n);
    }
}

void KIconLoader::addExtraDesktopThemes()
{
    if ( d->extraDesktopIconsLoaded ) return;

    QStringList list;
    QStringList icnlibs = KGlobal::dirs()->resourceDirs("icon");
    QStringList::ConstIterator it;
    char buf[1000];
    int r;
    for (it=icnlibs.begin(); it!=icnlibs.end(); it++)
    {
        QDir dir(*it);
        if (!dir.exists())
            continue;
        QStringList lst = dir.entryList("default.*", QDir::Dirs);
        QStringList::ConstIterator it2;
        for (it2=lst.begin(); it2!=lst.end(); it2++)
        {
            if (!KStandardDirs::exists(*it + *it2 + "/index.desktop")
                && !KStandardDirs::exists(*it + *it2 + "/index.theme"))
                continue;
            r=readlink( QFile::encodeName(*it + *it2) , buf, sizeof(buf)-1);
            if ( r>0 )
            {
              buf[r]=0;
              QDir dir2( buf );
              QString themeName=dir2.dirName();

              if (!list.contains(themeName))
                list.append(themeName);
            }
        }
    }

    for (it=list.begin(); it!=list.end(); it++)
    {
        if ( d->mThemesInTree.contains(*it) )
                continue;
        if ( *it == QString("default.kde") ) continue;

        KIconTheme *def = new KIconTheme( *it, "" );
        KIconThemeNode* node = new KIconThemeNode(def);
        d->mThemesInTree.append(*it);
        d->links.append(node);
        addBaseThemes(node, "" );
    }

    d->extraDesktopIconsLoaded=true;

}

bool KIconLoader::extraDesktopThemesAdded() const
{
    return d->extraDesktopIconsLoaded;
}

QString KIconLoader::removeIconExtension(const QString &name) const
{
    int extensionLength=0;

    QString ext = name.right(4);

    static const QString &png_ext = KGlobal::staticQString(".png");
    static const QString &xpm_ext = KGlobal::staticQString(".xpm");
    if (ext == png_ext || ext == xpm_ext)
      extensionLength=4;

    else
    {
        static const QString &svgz_ext = KGlobal::staticQString(".svgz");
        static const QString &svg_ext = KGlobal::staticQString(".svg");

        if (name.right(5) == svgz_ext)
            extensionLength=5;
        else if (ext == svg_ext)
            extensionLength=4;
    }


    if ( extensionLength > 0 )
    {

        kdDebug(264) << "Application " << KGlobal::instance()->instanceName()
                     << " loads icon " << name << " with extension.\n";


        return name.left(name.length() - extensionLength);
    }
    return name;
}


KIcon KIconLoader::findMatchingIcon(const QString& name, int size) const
{
    KIcon icon;

    const QString *ext[4];
    int count=0;
    static const QString &png_ext = KGlobal::staticQString(".png");
    ext[count++]=&png_ext;

    static const QString &svgz_ext = KGlobal::staticQString(".svgz");
    ext[count++]=&svgz_ext;
    static const QString &svg_ext = KGlobal::staticQString(".svg");
    ext[count++]=&svg_ext;

    static const QString &xpm_ext = KGlobal::staticQString(".xpm");
    ext[count++]=&xpm_ext;
# 433 "/coolo/prod/kdelibs/kdecore/kiconloader.cpp"
    for ( KIconThemeNode *themeNode = d->links.first() ; themeNode ;
        themeNode = d->links.next() )
    {
        for (int i = 0 ; i < count ; i++)
        {
            icon = themeNode->theme->iconPath(name + *ext[i], size, KIcon::MatchExact);
            if (icon.isValid())
                return icon;
        }

    }

    for ( KIconThemeNode *themeNode = d->links.first() ; themeNode ;
        themeNode = d->links.next() )
    {
        for (int i = 0 ; i < count ; i++)
        {
            icon = themeNode->theme->iconPath(name + *ext[i], size, KIcon::MatchBest);
            if (icon.isValid())
                return icon;
        }

    }

    return icon;
}

inline QString KIconLoader::unknownIconPath( int size ) const
{
    static const QString &str_unknown = KGlobal::staticQString("unknown");

    KIcon icon = findMatchingIcon(str_unknown, size);
    if (!icon.isValid())
    {
        kdDebug(264) << "Warning: could not find \"Unknown\" icon for size = "
                     << size << "\n";
        return QString::null;
    }
    return icon.path;
}



QString KIconLoader::iconPath(const QString& _name, int group_or_size,
                              bool canReturnNull) const
{
    if (d->mpThemeRoot == 0L)
        return QString::null;

    if (_name.at(0) == '/')
        return _name;

    QString name = removeIconExtension( _name );

    QString path;
    if (group_or_size == KIcon::User)
    {
        static const QString &png_ext = KGlobal::staticQString(".png");
        static const QString &xpm_ext = KGlobal::staticQString(".xpm");
        path = d->mpDirs->findResource("appicon", name + png_ext);


        static const QString &svgz_ext = KGlobal::staticQString(".svgz");
        static const QString &svg_ext = KGlobal::staticQString(".svg");
        if (path.isEmpty())
            path = d->mpDirs->findResource("appicon", name + svgz_ext);
        if (path.isEmpty())
           path = d->mpDirs->findResource("appicon", name + svg_ext);

        if (path.isEmpty())
             path = d->mpDirs->findResource("appicon", name + xpm_ext);
        return path;
    }

    if (group_or_size >= KIcon::LastGroup)
    {
        kdDebug(264) << "Illegal icon group: " << group_or_size << "\n";
        return path;
    }

    int size;
    if (group_or_size >= 0)
        size = d->mpGroups[group_or_size].size;
    else
        size = -group_or_size;

    if (_name.isEmpty()) {
        if (canReturnNull)
            return QString::null;
        else
            return unknownIconPath(size);
    }

    KIcon icon = findMatchingIcon(name, size);

    if (!icon.isValid())
    {

        path = iconPath(name, KIcon::User, true);
        if (!path.isEmpty() || canReturnNull)
            return path;

        if (canReturnNull)
            return QString::null;
        else
            return unknownIconPath(size);
    }
    return icon.path;
}

QPixmap KIconLoader::loadIcon(const QString& _name, KIcon::Group group, int size,
                              int state, QString *path_store, bool canReturnNull) const
{
    QString name = _name;
    QPixmap pix;
    QString key;
    bool absolutePath=false, favIconOverlay=false;

    if (d->mpThemeRoot == 0L)
        return pix;


    if (name.startsWith("favicons/"))
    {
       favIconOverlay = true;
       name = locateLocal("cache", name+".png");
    }
    if (name.at(0) == '/') absolutePath=true;

    static const QString &str_unknown = KGlobal::staticQString("unknown");


    if (group == KIcon::User)
    {
        key = "$kicou_";
        key += QString::number(size); key += '_';
        key += name;
        bool inCache = QPixmapCache::find(key, pix);
        if (inCache && (path_store == 0L))
            return pix;

        QString path = (absolutePath) ? name :
                        iconPath(name, KIcon::User, canReturnNull);
        if (path.isEmpty())
        {
            if (canReturnNull)
                return pix;

            path = iconPath(str_unknown, KIcon::Small, true);
            if (path.isEmpty())
            {
                kdDebug(264) << "Warning: Cannot find \"unknown\" icon.\n";
                return pix;
            }
        }

        if (path_store != 0L)
            *path_store = path;
        if (inCache)
            return pix;
        QImage img(path);
        if (size != 0)
            img=img.smoothScale(size,size);

        pix.convertFromImage(img);
        QPixmapCache::insert(key, pix);
        return pix;
    }



    if ((group < -1) || (group >= KIcon::LastGroup))
    {
        kdDebug(264) << "Illegal icon group: " << group << "\n";
        group = KIcon::Desktop;
    }

    int overlay = (state & KIcon::OverlayMask);
    state &= ~KIcon::OverlayMask;
    if ((state < 0) || (state >= KIcon::LastState))
    {
        kdDebug(264) << "Illegal icon state: " << state << "\n";
        state = KIcon::DefaultState;
    }

    if ((size == 0) && (group < 0))
    {
        kdDebug(264) << "Neither size nor group specified!\n";
        group = KIcon::Desktop;
    }

    if (!absolutePath)
    {
        if (!canReturnNull && name.isEmpty())
            name = str_unknown;
        else
            name = removeIconExtension(name);
    }


    if (size == 0)
    {
        size = d->mpGroups[group].size;
    }
    favIconOverlay = favIconOverlay && (size > 22);



    key = "$kico_";
    key += name; key += '_';
    key += QString::number(size); key += '_';

    QString overlayStr = QString::number( overlay );

    QString noEffectKey = key + '_' + overlayStr;

    if (group >= 0)
    {
        key += d->mpEffect.fingerprint(group, state);
        if (d->mpGroups[group].dblPixels)
            key += QString::fromLatin1(":dblsize");
    } else
        key += QString::fromLatin1("noeffect");
    key += '_';
    key += overlayStr;


    bool inCache = QPixmapCache::find(key, pix);
    if (inCache && (path_store == 0L))
        return pix;

    QImage *img = 0;
    int iconType;
    int iconThreshold;

    if ( ( path_store != 0L ) ||
         noEffectKey != d->lastImageKey )
    {

        KIcon icon;
        if (absolutePath && !favIconOverlay)
        {
            icon.context=KIcon::Any;
            icon.type=KIcon::Scalable;
            icon.path=name;
        }
        else
        {
            if (!name.isEmpty())
                icon = findMatchingIcon(favIconOverlay ? QString("www") : name, size);

            if (!icon.isValid())
            {

                if (!name.isEmpty())
                    pix = loadIcon(name, KIcon::User, size, state, path_store, true);
                if (!pix.isNull() || canReturnNull)
                    return pix;

                icon = findMatchingIcon(str_unknown, size);
                if (!icon.isValid())
                {
                    kdDebug(264)
                        << "Warning: could not find \"Unknown\" icon for size = "
                        << size << "\n";
                    return pix;
                }
            }
        }

        if (path_store != 0L)
            *path_store = icon.path;
        if (inCache)
            return pix;


        QString ext = icon.path.right(3).upper();
        if(ext != "SVG" && ext != "VGZ")
        {
            img = new QImage(icon.path, ext.latin1());
            if (img->isNull()) {
                delete img;
                return pix;
            }
        }

        else
        {

            KSVGIconEngine *svgEngine = new KSVGIconEngine();

            if(svgEngine->load(size, size, icon.path))
                img = svgEngine->painter()->image();
            else
                img = new QImage();

            delete svgEngine;
        }


        iconType = icon.type;
        iconThreshold = icon.threshold;

        d->lastImage = img->copy();
        d->lastImageKey = noEffectKey;
        d->lastIconType = iconType;
        d->lastIconThreshold = iconThreshold;
    }
    else
    {
        img = new QImage( d->lastImage.copy() );
        iconType = d->lastIconType;
        iconThreshold = d->lastIconThreshold;
    }


    if (overlay)
    {
        QImage *ovl;
        KIconTheme *theme = d->mpThemeRoot->theme;
        if ((overlay & KIcon::LockOverlay) &&
                ((ovl = loadOverlay(theme->lockOverlay(), size)) != 0L))
            KIconEffect::overlay(*img, *ovl);
        if ((overlay & KIcon::LinkOverlay) &&
                ((ovl = loadOverlay(theme->linkOverlay(), size)) != 0L))
            KIconEffect::overlay(*img, *ovl);
        if ((overlay & KIcon::ZipOverlay) &&
                ((ovl = loadOverlay(theme->zipOverlay(), size)) != 0L))
            KIconEffect::overlay(*img, *ovl);
        if ((overlay & KIcon::ShareOverlay) &&
            ((ovl = loadOverlay(theme->shareOverlay(), size)) != 0L))
          KIconEffect::overlay(*img, *ovl);
        if (overlay & KIcon::HiddenOverlay)
            for (int y = 0; y < img->height(); y++)
            {
                Q_UINT32 *line = reinterpret_cast<Q_UINT32 *>(img->scanLine(y));
                for (int x = 0; x < img->width(); x++)
                    line[x] = (line[x] & 0x00ffffff) | (((0x80) < (qAlpha(line[x])) ? (0x80) : (qAlpha(line[x]))) << 24);
            }
    }


    if ((iconType == KIcon::Scalable) && (size != img->width()))
    {
        *img = img->smoothScale(size, size);
    }
    if ((iconType == KIcon::Threshold) && (size != img->width()))
    {
        if ( abs(size-img->width())>iconThreshold )
            *img = img->smoothScale(size, size);
    }
    if ((group >= 0) && d->mpGroups[group].dblPixels)
    {
        *img = d->mpEffect.doublePixels(*img);
    }
    if (group >= 0)
    {
        *img = d->mpEffect.apply(*img, group, state);
    }

    pix.convertFromImage(*img);

    delete img;

    if (favIconOverlay)
    {
        QPixmap favIcon(name, "PNG");
        int x = pix.width() - favIcon.width() - 1,
            y = pix.height() - favIcon.height() - 1;
        if (pix.mask())
        {
            QBitmap mask = *pix.mask();
            QBitmap fmask;
            if (favIcon.mask())
                fmask = *favIcon.mask();
            else {

                fmask = favIcon.createHeuristicMask();
            }

            bitBlt(&mask, x, y, &fmask,
                   0, 0, favIcon.width(), favIcon.height(),
                   favIcon.mask() ? Qt::OrROP : Qt::SetROP);
            pix.setMask(mask);
        }
        bitBlt(&pix, x, y, &favIcon);
    }

    QPixmapCache::insert(key, pix);
    return pix;
}

QImage *KIconLoader::loadOverlay(const QString &name, int size) const
{
    QString key = name + '_' + QString::number(size);
    QImage *image = d->imgDict.find(key);
    if (image != 0L)
        return image;

    KIcon icon = findMatchingIcon(name, size);
    if (!icon.isValid())
    {
        kdDebug(264) << "Overlay " << name << "not found.\n";
        return 0L;
    }
    image = new QImage(icon.path);
    d->imgDict.insert(key, image);
    return image;
}



QMovie KIconLoader::loadMovie(const QString& name, KIcon::Group group, int size) const
{
    QString file = moviePath( name, group, size );
    if (file.isEmpty())
        return QMovie();
    int dirLen = file.findRev('/');
    QString icon = iconPath(name, size ? -size : group, true);
    if (!icon.isEmpty() && file.left(dirLen) != icon.left(dirLen))
        return QMovie();
    return QMovie(file);
}

QString KIconLoader::moviePath(const QString& name, KIcon::Group group, int size) const
{
    if (!d->mpGroups) return QString::null;

    if ( ((group < -1) || (group >= KIcon::LastGroup)) && (group != KIcon::User) )
    {
        kdDebug(264) << "Illegal icon group: " << group << "\n";
        group = KIcon::Desktop;
    }
    if ((size == 0) && (group < 0))
    {
        kdDebug(264) << "Neither size nor group specified!\n";
        group = KIcon::Desktop;
    }

    QString file = name + ".mng";
    if (group == KIcon::User)
    {
        file = d->mpDirs->findResource("appicon", file);
    }
    else
    {
        if (size == 0)
            size = d->mpGroups[group].size;

        KIcon icon;
        icon = d->mpThemeRoot->findIcon(file, size, KIcon::MatchExact);
        if (!icon.isValid())
        {
           icon = d->mpThemeRoot->findIcon(file, size, KIcon::MatchBest);
        }
        file = icon.isValid() ? icon.path : QString::null;

    }
    return file;
}


QStringList KIconLoader::loadAnimated(const QString& name, KIcon::Group group, int size) const
{
    QStringList lst;

    if (!d->mpGroups) return lst;

    if ((group < -1) || (group >= KIcon::LastGroup))
    {
        kdDebug(264) << "Illegal icon group: " << group << "\n";
        group = KIcon::Desktop;
    }
    if ((size == 0) && (group < 0))
    {
        kdDebug(264) << "Neither size nor group specified!\n";
        group = KIcon::Desktop;
    }

    QString file = name + "/0001";
    if (group == KIcon::User)
    {
        file = d->mpDirs->findResource("appicon", file + ".png");
    } else
    {
        if (size == 0)
            size = d->mpGroups[group].size;
        KIcon icon = findMatchingIcon(file, size);
        file = icon.isValid() ? icon.path : QString::null;

    }
    if (file.isEmpty())
        return lst;

    QString path = file.left(file.length()-8);
    DIR* dp = opendir( QFile::encodeName(path) );
    if(!dp)
        return lst;

    struct dirent* ep;
    while( ( ep = readdir( dp ) ) != 0L )
    {
        QString fn(QFile::decodeName(ep->d_name));
        if(!(fn.left(4)).toUInt())
            continue;

        lst += path + fn;
    }
    closedir ( dp );
    lst.sort();
    return lst;
}

KIconTheme *KIconLoader::theme() const
{
    if (d->mpThemeRoot) return d->mpThemeRoot->theme;
    return 0L;
}

int KIconLoader::currentSize(KIcon::Group group) const
{
    if (!d->mpGroups) return -1;

    if ((group < 0) || (group >= KIcon::LastGroup))
    {
        kdDebug(264) << "Illegal icon group: " << group << "\n";
        return -1;
    }
    return d->mpGroups[group].size;
}

QStringList KIconLoader::queryIconsByDir( const QString& iconsDir ) const
{
  QDir dir(iconsDir);
  QStringList lst = dir.entryList("*.png;*.xpm", QDir::Files);
  QStringList result;
  QStringList::ConstIterator it;
  for (it=lst.begin(); it!=lst.end(); it++)
    result += iconsDir + "/" + *it;
  return result;
}

QStringList KIconLoader::queryIconsByContext(int group_or_size,
                                            KIcon::Context context) const
{
    QStringList result;
    if (group_or_size >= KIcon::LastGroup)
    {
        kdDebug(264) << "Illegal icon group: " << group_or_size << "\n";
        return result;
    }
    int size;
    if (group_or_size >= 0)
        size = d->mpGroups[group_or_size].size;
    else
        size = -group_or_size;

    for ( KIconThemeNode *themeNode = d->links.first() ; themeNode ;
            themeNode = d->links.next() )
       themeNode->queryIconsByContext(&result, size, context);


    QString name;
    QStringList res2, entries;
    QStringList::ConstIterator it;
    for (it=result.begin(); it!=result.end(); it++)
    {
        int n = (*it).findRev('/');
        if (n == -1)
            name = *it;
        else
            name = (*it).mid(n+1);
        if (!entries.contains(name))
        {
            entries += name;
            res2 += *it;
        }
    }
    return res2;

}

QStringList KIconLoader::queryIcons(int group_or_size, KIcon::Context context) const
{
    QStringList result;
    if (group_or_size >= KIcon::LastGroup)
    {
        kdDebug(264) << "Illegal icon group: " << group_or_size << "\n";
        return result;
    }
    int size;
    if (group_or_size >= 0)
        size = d->mpGroups[group_or_size].size;
    else
        size = -group_or_size;

    for ( KIconThemeNode *themeNode = d->links.first() ; themeNode ;
            themeNode = d->links.next() )
       themeNode->queryIcons(&result, size, context);


    QString name;
    QStringList res2, entries;
    QStringList::ConstIterator it;
    for (it=result.begin(); it!=result.end(); it++)
    {
        int n = (*it).findRev('/');
        if (n == -1)
            name = *it;
        else
            name = (*it).mid(n+1);
        if (!entries.contains(name))
        {
            entries += name;
            res2 += *it;
        }
    }
    return res2;
}

KIconEffect * KIconLoader::iconEffect() const
{
    return &d->mpEffect;
}

bool KIconLoader::alphaBlending(KIcon::Group group) const
{
    if (!d->mpGroups) return -1;

    if ((group < 0) || (group >= KIcon::LastGroup))
    {
        kdDebug(264) << "Illegal icon group: " << group << "\n";
        return -1;
    }
    return d->mpGroups[group].alphaBlending;
}

QIconSet KIconLoader::loadIconSet(const QString& name, KIcon::Group group, int size)
{
    return loadIconSet( name, group, size, false );
}



class KIconFactory
    : public QIconFactory
    {
    public:
        KIconFactory( const QString& iconName_P, KIcon::Group group_P,
            int size_P, KIconLoader* loader_P );
        virtual QPixmap* createPixmap( const QIconSet&, QIconSet::Size, QIconSet::Mode, QIconSet::State );
    private:
        QString iconName;
        KIcon::Group group;
        int size;
        KIconLoader* loader;
    };


QIconSet KIconLoader::loadIconSet( const QString& name, KIcon::Group group, int size,
    bool canReturnNull)
{
    if ( !d->delayedLoading )
        return loadIconSetNonDelayed( name, group, size, canReturnNull );

    if(canReturnNull)
    {
        QPixmap pm = loadIcon( name, group, size, KIcon::DefaultState, __null, true );
        if( pm.isNull())
            return QIconSet();

        QIconSet ret( pm );
        ret.installIconFactory( new KIconFactory( name, group, size, this ));
        return ret;
    }

    QIconSet ret;
    ret.installIconFactory( new KIconFactory( name, group, size, this ));
    return ret;
}

QIconSet KIconLoader::loadIconSetNonDelayed( const QString& name,
                                             KIcon::Group group,
                                             int size, bool canReturnNull )
{
    QIconSet iconset;
    QPixmap tmp = loadIcon(name, group, size, KIcon::ActiveState, __null, canReturnNull);
    iconset.setPixmap( tmp, QIconSet::Small, QIconSet::Active );

    iconset.setPixmap( tmp, QIconSet::Large, QIconSet::Active );
    tmp = loadIcon(name, group, size, KIcon::DisabledState, __null, canReturnNull);
    iconset.setPixmap( tmp, QIconSet::Small, QIconSet::Disabled );
    iconset.setPixmap( tmp, QIconSet::Large, QIconSet::Disabled );
    tmp = loadIcon(name, group, size, KIcon::DefaultState, __null, canReturnNull);
    iconset.setPixmap( tmp, QIconSet::Small, QIconSet::Normal );
    iconset.setPixmap( tmp, QIconSet::Large, QIconSet::Normal );
    return iconset;
}

KIconFactory::KIconFactory( const QString& iconName_P, KIcon::Group group_P,
    int size_P, KIconLoader* loader_P )
    : iconName( iconName_P ), group( group_P ), size( size_P ), loader( loader_P )
{
    setAutoDelete( true );
}

QPixmap* KIconFactory::createPixmap( const QIconSet&, QIconSet::Size, QIconSet::Mode mode_P, QIconSet::State )
    {

    static const KIcon::States tbl[] = { KIcon::DefaultState, KIcon::DisabledState, KIcon::ActiveState };
    int state = KIcon::DefaultState;
    if( mode_P <= QIconSet::Active )
        state = tbl[ mode_P ];
    if( group >= 0 && state == KIcon::ActiveState )
    {
        if( loader->iconEffect()->fingerprint(group, KIcon::ActiveState )
            == loader->iconEffect()->fingerprint(group, KIcon::DefaultState ))
            return __null;
    }


    QPixmap pm = loader->loadIcon( iconName, group, size, state );
    return new QPixmap( pm );
    }



QPixmap DesktopIcon(const QString& name, int force_size, int state,
        KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIcon(name, KIcon::Desktop, force_size, state);
}

QPixmap DesktopIcon(const QString& name, KInstance *instance)
{
    return DesktopIcon(name, 0, KIcon::DefaultState, instance);
}

QIconSet DesktopIconSet(const QString& name, int force_size, KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIconSet( name, KIcon::Desktop, force_size );
}

QPixmap BarIcon(const QString& name, int force_size, int state,
        KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIcon(name, KIcon::Toolbar, force_size, state);
}

QPixmap BarIcon(const QString& name, KInstance *instance)
{
    return BarIcon(name, 0, KIcon::DefaultState, instance);
}

QIconSet BarIconSet(const QString& name, int force_size, KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIconSet( name, KIcon::Toolbar, force_size );
}

QPixmap SmallIcon(const QString& name, int force_size, int state,
        KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIcon(name, KIcon::Small, force_size, state);
}

QPixmap SmallIcon(const QString& name, KInstance *instance)
{
    return SmallIcon(name, 0, KIcon::DefaultState, instance);
}

QIconSet SmallIconSet(const QString& name, int force_size, KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIconSet( name, KIcon::Small, force_size );
}

QPixmap MainBarIcon(const QString& name, int force_size, int state,
        KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIcon(name, KIcon::MainToolbar, force_size, state);
}

QPixmap MainBarIcon(const QString& name, KInstance *instance)
{
    return MainBarIcon(name, 0, KIcon::DefaultState, instance);
}

QIconSet MainBarIconSet(const QString& name, int force_size, KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIconSet( name, KIcon::MainToolbar, force_size );
}

QPixmap UserIcon(const QString& name, int state, KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIcon(name, KIcon::User, 0, state);
}

QPixmap UserIcon(const QString& name, KInstance *instance)
{
    return UserIcon(name, KIcon::DefaultState, instance);
}

QIconSet UserIconSet(const QString& name, KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->loadIconSet( name, KIcon::User );
}

int IconSize(KIcon::Group group, KInstance *instance)
{
    KIconLoader *loader = instance->iconLoader();
    return loader->currentSize(group);
}

QPixmap KIconLoader::unknown()
{
    QPixmap pix;
    if ( QPixmapCache::find("unknown", pix) )
            return pix;

    QString path = KGlobal::iconLoader()->iconPath("unknown", KIcon::Small, true);
    if (path.isEmpty())
    {
        kdDebug(264) << "Warning: Cannot find \"unknown\" icon.\n";
        pix.resize(32,32);
    } else
    {
        pix.load(path);
        QPixmapCache::insert("unknown", pix);
    }

    return pix;
}
# 24 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kwin.cpp" 1
# 32 "/coolo/prod/kdelibs/kdecore/kwin.cpp"
# 1 "/coolo/prod/qt-copy/include/qwhatsthis.h" 1
# 37 "/coolo/prod/qt-copy/include/qwhatsthis.h"







# 1 "/coolo/prod/qt-copy/include/qcursor.h" 1
# 39 "/coolo/prod/qt-copy/include/qcursor.h"
# 65 "/coolo/prod/qt-copy/include/qcursor.h"
struct QCursorData;


class QCursor : public Qt
{
public:
    QCursor();
    QCursor( int shape );
    QCursor( const QBitmap &bitmap, const QBitmap &mask,
             int hotX=-1, int hotY=-1 );
    QCursor( const QPixmap &pixmap,
             int hotX=-1, int hotY=-1 );
    QCursor( const QCursor & );
   ~QCursor();
    QCursor &operator=( const QCursor & );

    int shape() const;
    void setShape( int );

    const QBitmap *bitmap() const;
    const QBitmap *mask() const;
    QPoint hotSpot() const;





    HANDLE handle() const;






    static QPoint pos();
    static void setPos( int x, int y );
    static void setPos( const QPoint & );

    static void initialize();
    static void cleanup();


    static int x11Screen();

private:
    void setBitmap( const QBitmap &bitmap, const QBitmap &mask,
                                 int hotX, int hotY );
    void update() const;
    QCursorData *data;
    QCursor *find_cur(int);



};
# 138 "/coolo/prod/qt-copy/include/qcursor.h"
 QDataStream &operator<<( QDataStream &, const QCursor & );
 QDataStream &operator>>( QDataStream &, QCursor & );




inline void QCursor::setPos( const QPoint &p )
{
    setPos( p.x(), p.y() );
}
# 46 "/coolo/prod/qt-copy/include/qwhatsthis.h" 2

class QToolButton;
class QPopupMenu;
class QStyleSheet;

class QWhatsThis: public Qt
{
public:
    QWhatsThis( QWidget *);
    virtual ~QWhatsThis();

    virtual QString text( const QPoint & );
    virtual bool clicked( const QString& href );


    static void setFont( const QFont &font );

    static void add( QWidget *, const QString &);
    static void remove( QWidget * );
    static QString textFor( QWidget *, const QPoint & pos = QPoint(), bool includeParents = FALSE );

    static QToolButton * whatsThisButton( QWidget * parent );

    static void enterWhatsThisMode();
    static bool inWhatsThisMode();
    static void leaveWhatsThisMode( const QString& = QString::null, const QPoint& pos = QCursor::pos(), QWidget* w = 0 );

    static void display( const QString& text, const QPoint& pos = QCursor::pos(), QWidget* w = 0 );
};
# 33 "/coolo/prod/kdelibs/kdecore/kwin.cpp" 2


# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 36 "/coolo/prod/kdelibs/kdecore/kwin.cpp" 2
# 57 "/coolo/prod/kdelibs/kdecore/kwin.cpp"
static bool atoms_created = FALSE;
extern Atom qt_wm_protocols;
extern Time qt_x_last_input_time;

static Atom net_wm_context_help;
static Atom kde_wm_change_state;
static void kwin_net_create_atoms() {
    if (!atoms_created){
        const int max = 20;
        Atom* atoms[max];
        const char* names[max];
        Atom atoms_return[max];
        int n = 0;

        atoms[n] = &net_wm_context_help;
        names[n++] = "_NET_WM_CONTEXT_HELP";

        atoms[n] = &kde_wm_change_state;
        names[n++] = "_KDE_WM_CHANGE_STATE";


        XInternAtoms( qt_xdisplay(), const_cast<char**>(names), n, FALSE, atoms_return );
        for (int i = 0; i < n; i++ )
            *atoms[i] = atoms_return[i];

        atoms_created = 1;
    }
}





static void sendClientMessageToRoot(Window w, Atom a, long x, long y = 0, long z = 0 ){

  XEvent ev;
  long mask;

  memset(&ev, 0, sizeof(ev));
  ev.xclient.type = 33;
  ev.xclient.window = w;
  ev.xclient.message_type = a;
  ev.xclient.format = 32;
  ev.xclient.data.l[0] = x;
  ev.xclient.data.l[1] = y;
  ev.xclient.data.l[2] = z;
  mask = (1L<<20);
  XSendEvent(qt_xdisplay(), qt_xrootwin(), 0, mask, &ev);

}




static void sendClientMessage(Window w, Atom a, long x){

  XEvent ev;
  long mask;

  memset(&ev, 0, sizeof(ev));
  ev.xclient.type = 33;
  ev.xclient.window = w;
  ev.xclient.message_type = a;
  ev.xclient.format = 32;
  ev.xclient.data.l[0] = x;
  ev.xclient.data.l[1] = 0L;
  mask = 0L;
  if (w == qt_xrootwin())
    mask = (1L<<20);
  XSendEvent(qt_xdisplay(), w, 0, mask, &ev);

}

namespace
{
class ContextWidget : public QWidget
{
public:
    ContextWidget();
    virtual bool x11Event( XEvent * ev);
};

ContextWidget::ContextWidget()
        : QWidget(0,0)
    {

        kwin_net_create_atoms();
        KApplication::kApplication()->installX11EventFilter( this );
        QWhatsThis::enterWhatsThisMode();
        QCursor c = *QApplication::overrideCursor();
        QWhatsThis::leaveWhatsThisMode();
        XGrabPointer( qt_xdisplay(), qt_xrootwin(), TRUE,
                      (uint)( (1L<<2) | (1L<<3) |
                              (1L<<6) | (1L<<4) |
                              (1L<<5) ),
                      1, 1,
                      None, c.handle(), 0L );
        qApp->enter_loop();

    }


bool ContextWidget::x11Event( XEvent * ev)
    {

        if ( ev->type == 4 && ev->xbutton.button == 1 ) {
            XUngrabPointer( qt_xdisplay(), ev->xbutton.time );
            Window root;
            Window child = qt_xrootwin();
            int root_x, root_y, lx, ly;
            uint state;
            Window w;
            do {
                w = child;
                XQueryPointer( qt_xdisplay(), w, &root, &child,
                               &root_x, &root_y, &lx, &ly, &state );
            } while ( child != None && child != w );

            ::sendClientMessage(w, qt_wm_protocols, net_wm_context_help);
            XEvent e = *ev;
            e.xbutton.window = w;
            e.xbutton.subwindow = w;
            e.xbutton.x = lx;
            e.xbutton.y = ly;
            XSendEvent( qt_xdisplay(), w, TRUE, (1L<<2), &e );
            qApp->exit_loop();
            return TRUE;
        }
        return FALSE;

    }
}

void KWin::invokeContextHelp()
{
    ContextWidget w;
}

void KWin::setSystemTrayWindowFor( WId trayWin, WId forWin )
{

    NETWinInfo info( qt_xdisplay(), trayWin, qt_xrootwin(), 0 );
    if ( !forWin )
        forWin = qt_xrootwin();
    info.setKDESystemTrayWinFor( forWin );

}

void KWin::activateWindow( WId win, long time )
{

    NETRootInfo info( qt_xdisplay(), 0 );
    if( time == 0 )
        time = qt_x_last_input_time;
    info.setActiveWindow( win, NET::FromApplication, time );

}

void KWin::setActiveWindow( WId win, long time )
{

    NETRootInfo info( qt_xdisplay(), 0 );
        time = qt_x_last_input_time;
    info.setActiveWindow( win, NET::FromTool, time );

}

void KWin::setActiveWindow( WId win )
{
    setActiveWindow( win, 0 );
}

void KWin::demandAttention( WId win, bool set )
{

    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), 0 );
    info.setState( set ? NET::DemandsAttention : 0, NET::DemandsAttention );

}

void KWin::setUserTime( WId win, long time )
{

    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), 0 );
    info.setUserTime( time );

}

KWin::WindowInfo KWin::windowInfo( WId win, unsigned long properties, unsigned long properties2 )
{
    return WindowInfo( win, properties, properties2 );
}


WId KWin::transientFor( WId win )
{

    KXErrorHandler handler;
    Window transient_for = None;
    if( XGetTransientForHint( qt_xdisplay(), win, &transient_for ))
        return transient_for;

    return None;



}

WId KWin::groupLeader( WId win )
{

    KXErrorHandler handler;
    XWMHints *hints = XGetWMHints( qt_xdisplay(), win );
    Window window_group = None;
    if ( hints )
    {
        if( hints->flags & (1L << 6) )
            window_group = hints->window_group;
        XFree( reinterpret_cast< char* >( hints ));
    }

    return window_group;



}


KWin::Info KWin::info( WId win )
{
    Info w;

    NETWinInfo inf( qt_xdisplay(), win, qt_xrootwin(),
                    NET::WMState |
                    NET::WMStrut |
                    NET::WMWindowType |
                    NET::WMName |
                    NET::WMVisibleName |
                    NET::WMDesktop |
                    NET::WMPid |
                    NET::WMKDEFrameStrut |
                    NET::XAWMState
                    );

    w.win = win;
    w.state = inf.state();
    w.mappingState = inf.mappingState();
    w.strut = inf.strut();
    w.windowType = inf.windowType();
    if ( inf.name() ) {
        w.name = QString::fromUtf8( inf.name() );
    } else {
        char* c = 0;
        if ( XFetchName( qt_xdisplay(), win, &c ) != 0 ) {
            w.name = QString::fromLocal8Bit( c );
            XFree( c );
        }
    }
    if ( inf.visibleName() )
        w.visibleName = QString::fromUtf8( inf.visibleName() );
    else
        w.visibleName = w.name;

    w.desktop = inf.desktop();
    w.onAllDesktops = inf.desktop() == NETWinInfo::OnAllDesktops;
    w.pid = inf.pid();
    NETRect frame, geom;
    inf.kdeGeometry( frame, geom );
    w.geometry.setRect( geom.pos.x, geom.pos.y, geom.size.width, geom.size.height );
    w.frameGeometry.setRect( frame.pos.x, frame.pos.y, frame.size.width, frame.size.height );

    return w;
}

QPixmap KWin::icon( WId win, int width, int height, bool scale )
{
    return icon( win, width, height, scale, NETWM | WMHints | ClassHint | XApp );
}


QPixmap KWin::icon( WId win, int width, int height, bool scale, int flags )
{

    KXErrorHandler handler;

    QPixmap result;

    if( flags & NETWM ) {
        NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), NET::WMIcon );
        NETIcon ni = info.icon( width, height );
        if ( ni.data && ni.size.width > 0 && ni.size.height > 0 ) {
            QImage img( (uchar*) ni.data, (int) ni.size.width, (int) ni.size.height, 32, 0, 0, QImage::IgnoreEndian );
            img.setAlphaBuffer( TRUE );
            if ( scale && width > 0 && height > 0 &&img.size() != QSize( width, height ) && !img.isNull() )
                img = img.smoothScale( width, height );
            if ( !img.isNull() )
                result.convertFromImage( img );
            return result;
        }
    }

    if( flags & WMHints ) {
        Pixmap p = None;
        Pixmap p_mask = None;

        XWMHints *hints = XGetWMHints(qt_xdisplay(), win );
        if (hints && (hints->flags & (1L << 2))){
            p = hints->icon_pixmap;
        }
        if (hints && (hints->flags & (1L << 5))){
            p_mask = hints->icon_mask;
        }
        if (hints)
            XFree((char*)hints);

        if (p != None){
            Window root;
            int x, y;
            unsigned int w = 0;
            unsigned int h = 0;
            unsigned int border_w, depth;
            XGetGeometry(qt_xdisplay(), p, &root,
                         &x, &y, &w, &h, &border_w, &depth);
            if (w > 0 && h > 0){
                QPixmap pm(w, h, depth);

                pm.detach();
                XCopyArea(qt_xdisplay(), p, pm.handle(),
                          qt_xget_temp_gc(qt_xscreen(), depth==1),
                          0, 0, w, h, 0, 0);
                if (p_mask != None){
                    QBitmap bm(w, h);
                    XCopyArea(qt_xdisplay(), p_mask, bm.handle(),
                              qt_xget_temp_gc(qt_xscreen(), true),
                              0, 0, w, h, 0, 0);
                    pm.setMask(bm);
                }
                if ( scale && width > 0 && height > 0 && !pm.isNull() &&
                     ( (int) w != width || (int) h != height) ){
                    result.convertFromImage( pm.convertToImage().smoothScale( width, height ) );
                } else {
                    result = pm;
                }
            }
        }
    }




    int iconWidth;
    if( width < 24 )
        iconWidth = 16;
    else if( width < 40 )
        iconWidth = 32;
    else
        iconWidth = 48;

    if( flags & ClassHint ) {


        if( result.isNull() ) {

            XClassHint hint;
            if( XGetClassHint( qt_xdisplay(), win, &hint ) ) {
                QString className = hint.res_class;

                QPixmap pm = KGlobal::instance()->iconLoader()->loadIcon( className.lower(), KIcon::Small, iconWidth,
                                                                          KIcon::DefaultState, 0, true );
                if( scale && !pm.isNull() )
                    result.convertFromImage( pm.convertToImage().smoothScale( width, height ) );
                else
                    result = pm;

                XFree( hint.res_name );
                XFree( hint.res_class );
            }
        }
    }

    if( flags & XApp ) {


        if ( result.isNull() ) {
            QPixmap pm = KGlobal::instance()->iconLoader()->loadIcon( "xapp", KIcon::Small, iconWidth,
                                                                       KIcon::DefaultState, 0, true );
            if( scale && !pm.isNull() )
                result.convertFromImage( pm.convertToImage().smoothScale( width, height ) );
            else
                result = pm;
        }
    }

    return result;
}

void KWin::setIcons( WId win, const QPixmap& icon, const QPixmap& miniIcon )
{

    if ( icon.isNull() )
        return;
    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), 0 );
    QImage img = icon.convertToImage().convertDepth( 32 );
    NETIcon ni;
    ni.size.width = img.size().width();
    ni.size.height = img.size().height();
    ni.data = (unsigned char *) img.bits();
    info.setIcon( ni, true );
    if ( miniIcon.isNull() )
        return;
    img = miniIcon.convertToImage().convertDepth( 32 );
    ni.size.width = img.size().width();
    ni.size.height = img.size().height();
    ni.data = (unsigned char *) img.bits();
    info.setIcon( ni, false );

}

void KWin::setType( WId win, NET::WindowType windowType )
{

    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), 0 );
    info.setWindowType( windowType );

}

void KWin::setState( WId win, unsigned long state )
{

    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), NET::WMState );
    info.setState( state, state );

}

void KWin::clearState( WId win, unsigned long state )
{

    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), NET::WMState );
    info.setState( 0, state );

}

void KWin::setOnAllDesktops( WId win, bool b )
{

    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), NET::WMDesktop );
    if ( b )
        info.setDesktop( NETWinInfo::OnAllDesktops );
    else if ( info.desktop() == NETWinInfo::OnAllDesktops ) {
        NETRootInfo rinfo( qt_xdisplay(), NET::CurrentDesktop );
        info.setDesktop( rinfo.currentDesktop() );
    }

}

void KWin::setOnDesktop( WId win, int desktop )
{

    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), NET::WMDesktop );
    info.setDesktop( desktop );

}

void KWin::setStrut( WId win, int left, int right, int top, int bottom )
{

    NETWinInfo info( qt_xdisplay(), win, qt_xrootwin(), 0 );
    NETStrut strut;
    strut.left = left;
    strut.right = right;
    strut.top = top;
    strut.bottom = bottom;
    info.setStrut( strut );

}

int KWin::currentDesktop()
{

    if (!qt_xdisplay())

      return 1;

    NETRootInfo info( qt_xdisplay(), NET::CurrentDesktop );
    return info.currentDesktop();

}

int KWin::numberOfDesktops()
{

    if (!qt_xdisplay())

      return 0;

    NETRootInfo info( qt_xdisplay(), NET::NumberOfDesktops );
    return info.numberOfDesktops();

}

void KWin::setCurrentDesktop( int desktop )
{

    NETRootInfo info( qt_xdisplay(), NET::CurrentDesktop );
    info.setCurrentDesktop( desktop );

}


void KWin::iconifyWindow( WId win, bool animation)
{

    if ( !animation )
    {
        kwin_net_create_atoms();
        sendClientMessageToRoot( win, kde_wm_change_state, 3, 1 );
    }
    XIconifyWindow( qt_xdisplay(), win, qt_xscreen() );

}


void KWin::deIconifyWindow( WId win, bool animation )
{

    if ( !animation )
    {
        kwin_net_create_atoms();
        sendClientMessageToRoot( win, kde_wm_change_state, 1, 1 );
    }
    XMapWindow( qt_xdisplay(), win );

}

void KWin::appStarted()
{

    KStartupInfo::appStarted();

}

class KWin::WindowInfoPrivate
{
    public:
        WindowInfoPrivate()

        : info( __null )

        {}

        ~WindowInfoPrivate() { delete info; }
        NETWinInfo* info;

        WId win_;
        QString name_;
        QString iconic_name_;
        QRect geometry_;
        QRect frame_geometry_;
        int ref;
        bool valid;
    private:
        WindowInfoPrivate( const WindowInfoPrivate& );
        void operator=( const WindowInfoPrivate& );
};


KWin::WindowInfo::WindowInfo( WId win, unsigned long properties, unsigned long properties2 )
{

    KXErrorHandler handler;
    d = new WindowInfoPrivate;
    d->ref = 1;
    if( properties == 0 )
        properties = NET::WMState |
                     NET::WMStrut |
                     NET::WMWindowType |
                     NET::WMName |
                     NET::WMVisibleName |
                     NET::WMIconName |
                     NET::WMVisibleIconName |
                     NET::WMDesktop |
                     NET::WMPid |
                     NET::WMKDEFrameStrut |
                     NET::XAWMState |
                     NET::WMGeometry;
    if( properties & NET::WMVisibleIconName )
        properties |= NET::WMIconName | NET::WMVisibleName;
    if( properties & NET::WMVisibleName )
        properties |= NET::WMName;
    properties |= NET::XAWMState;
    unsigned long props[ 2 ] = { properties, properties2 };
    d->info = new NETWinInfo( qt_xdisplay(), win, qt_xrootwin(), props, 2 );
    d->win_ = win;
    if( properties & NET::WMName ) {
        if( d->info->name())
            d->name_ = QString::fromUtf8( d->info->name() );
        else
            d->name_ = readNameProperty( win, ((Atom) 39) );
    }
    if( properties & NET::WMIconName ) {
        if( d->info->iconName())
            d->iconic_name_ = QString::fromUtf8( d->info->iconName());
        else
            d->iconic_name_ = readNameProperty( win, ((Atom) 37) );
    }
    if( properties & ( NET::WMGeometry | NET::WMKDEFrameStrut )) {
        NETRect frame, geom;
        d->info->kdeGeometry( frame, geom );
        d->geometry_.setRect( geom.pos.x, geom.pos.y, geom.size.width, geom.size.height );
        d->frame_geometry_.setRect( frame.pos.x, frame.pos.y, frame.size.width, frame.size.height );
    }
    d->valid = !handler.error( false );

}


KWin::WindowInfo::WindowInfo()
    : d( __null )
{
}

KWin::WindowInfo::~WindowInfo()
{
    if( d != __null ) {
        if( --d->ref == 0 ) {
            delete d;
        }
    }
}

KWin::WindowInfo::WindowInfo( const WindowInfo& wininfo )
    : d( wininfo.d )
{
    if( d != __null )
        ++d->ref;
}

KWin::WindowInfo& KWin::WindowInfo::operator=( const WindowInfo& wininfo )
{
    if( d != wininfo.d ) {
        if( d != __null )
            if( --d->ref == 0 )
                delete d;
        d = wininfo.d;
        if( d != __null )
            ++d->ref;
    }
    return *this;
}

bool KWin::WindowInfo::valid( bool withdrawn_is_valid ) const
{
    if( !d->valid )
        return false;
    if( !withdrawn_is_valid && mappingState() == NET::Withdrawn )
        return false;
    return true;
}

WId KWin::WindowInfo::win() const
{
    return d->win_;
}

unsigned long KWin::WindowInfo::state() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMState ) == 0, 176 )
        << "Pass NET::WMState to KWin::windowInfo()" << endl;
    return d->info->state();



}

NET::MappingState KWin::WindowInfo::mappingState() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::XAWMState ) == 0, 176 )
        << "Pass NET::XAWMState to KWin::windowInfo()" << endl;
    return d->info->mappingState();



}

NETStrut KWin::WindowInfo::strut() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMStrut ) == 0, 176 )
        << "Pass NET::WMStrut to KWin::windowInfo()" << endl;
    return d->info->strut();




}

NET::WindowType KWin::WindowInfo::windowType( int supported_types ) const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMWindowType ) == 0, 176 )
        << "Pass NET::WMWindowType to KWin::windowInfo()" << endl;
    return d->info->windowType( supported_types );



}

QString KWin::WindowInfo::visibleNameMatchingState() const
{
    if( mappingState() == NET::Iconic )
        return visibleIconName();
    else
        return visibleName();
}

QString KWin::WindowInfo::visibleNameWithState() const
{
    QString s = visibleName();
    if ( isMinimized() ) {
        s.prepend('(');
        s.append(')');
    }
    return s;
}

QString KWin::Info::visibleNameWithState() const
{
    QString s = visibleName;
    if ( isMinimized() ) {
        s.prepend('(');
        s.append(')');
    }
    return s;
}

QString KWin::WindowInfo::visibleName() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMVisibleName ) == 0, 176 )
        << "Pass NET::WMVisibleName to KWin::windowInfo()" << endl;
    return d->info->visibleName() ? QString::fromUtf8(d->info->visibleName()) : name();



}

QString KWin::WindowInfo::name() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMName ) == 0, 176 )
        << "Pass NET::WMName to KWin::windowInfo()" << endl;
    return d->name_;



}

QString KWin::WindowInfo::visibleIconName() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMVisibleIconName ) == 0, 176 )
        << "Pass NET::WMVisibleIconName to KWin::windowInfo()" << endl;
    if( d->info->visibleIconName())
        return QString::fromUtf8( d->info->visibleIconName());
    if( d->info->iconName())
        return QString::fromUtf8( d->info->iconName());
    if( !d->iconic_name_.isEmpty())
        return d->iconic_name_;

    return visibleName();
}

QString KWin::WindowInfo::iconName() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMIconName ) == 0, 176 )
        << "Pass NET::WMIconName to KWin::windowInfo()" << endl;
    if( d->info->iconName())
        return QString::fromUtf8( d->info->iconName());
    if( !d->iconic_name_.isEmpty())
        return d->iconic_name_;

    return name();
}

bool KWin::WindowInfo::isOnCurrentDesktop() const
{

    return isOnDesktop( KWin::currentDesktop());



}

bool KWin::WindowInfo::isOnDesktop( int desktop ) const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMDesktop ) == 0, 176 )
        << "Pass NET::WMDesktop to KWin::windowInfo()" << endl;
    return d->info->desktop() == desktop || d->info->desktop() == NET::OnAllDesktops;



}

bool KWin::WindowInfo::onAllDesktops() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMDesktop ) == 0, 176 )
        << "Pass NET::WMDesktop to KWin::windowInfo()" << endl;
    return d->info->desktop() == NET::OnAllDesktops;



}

int KWin::WindowInfo::desktop() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMDesktop ) == 0, 176 )
        << "Pass NET::WMDesktop to KWin::windowInfo()" << endl;
    return d->info->desktop();



}

QRect KWin::WindowInfo::geometry() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMGeometry ) == 0, 176 )
        << "Pass NET::WMGeometry to KWin::windowInfo()" << endl;
    return d->geometry_;



}

QRect KWin::WindowInfo::frameGeometry() const
{
    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS ] & NET::WMKDEFrameStrut ) == 0, 176 )
        << "Pass NET::WMKDEFrameStrut to KWin::windowInfo()" << endl;
    return d->frame_geometry_;
}

WId KWin::WindowInfo::transientFor() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS2 ] & NET::WM2TransientFor ) == 0, 176 )
        << "Pass NET::WM2TransientFor to KWin::windowInfo()" << endl;
    return d->info->transientFor();



}

WId KWin::WindowInfo::groupLeader() const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS2 ] & NET::WM2GroupLeader ) == 0, 176 )
        << "Pass NET::WM2GroupLeader to KWin::windowInfo()" << endl;
    return d->info->groupLeader();



}

bool KWin::WindowInfo::actionSupported( NET::Action action ) const
{

    kdWarning(( d->info->passedProperties()[ NETWinInfo::PROTOCOLS2 ] & NET::WM2AllowedActions ) == 0, 176 )
        << "Pass NET::WM2AllowedActions to KWin::windowInfo()" << endl;
    if( allowedActionsSupported())
        return d->info->allowedActions() & action;
    else

        return true;
}


bool KWin::WindowInfo::isMinimized() const
{

    if( mappingState() != NET::Iconic )
        return false;

    if(( state() & NET::Hidden ) != 0
        && ( state() & NET::Shaded ) == 0 )
        return true;


    return icccmCompliantMappingState() ? false : true;



}

bool KWin::Info::isMinimized() const
{

    if( mappingState != NET::Iconic )
        return false;

    if(( state & NET::Hidden ) != 0
        && ( state & NET::Shaded ) == 0 )
        return true;


    return icccmCompliantMappingState() ? false : true;



}

bool KWin::Info::isIconified() const
{
    return isMinimized();
}

bool KWin::icccmCompliantMappingState()
{

    static enum { noidea, yes, no } wm_is_1_2_compliant = noidea;
    if( wm_is_1_2_compliant == noidea ) {
        NETRootInfo info( qt_xdisplay(), NET::Supported );
        wm_is_1_2_compliant = info.isSupported( NET::Hidden ) ? yes : no;
    }
    return wm_is_1_2_compliant == yes;



}

bool KWin::allowedActionsSupported()
{

    static enum { noidea, yes, no } wm_supports_allowed_actions = noidea;
    if( wm_supports_allowed_actions == noidea ) {
        NETRootInfo info( qt_xdisplay(), NET::Supported );
        wm_supports_allowed_actions = info.isSupported( NET::WM2AllowedActions ) ? yes : no;
    }
    return wm_supports_allowed_actions == yes;



}

QString KWin::readNameProperty( WId win, unsigned long atom )
{

    XTextProperty tp;
    char **text = __null;
    int count;

    QString result;

    if ( XGetTextProperty( qt_xdisplay(), win, &tp, atom ) != 0 && tp.value != __null ) {
        if ( tp.encoding == ((Atom) 31) )
            result = QString::fromLocal8Bit( (const char*) tp.value );
        else if ( XmbTextPropertyToTextList( qt_xdisplay(), &tp, &text, &count) == Success &&
                  text != __null && count > 0 ) {
            result = QString::fromLocal8Bit( text[0] );
        }
        if( text != __null )
            XFreeStringList( text );
        XFree( tp.value );
    }

    return result;
}
# 25 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kwinmodule.cpp" 1
# 26 "/coolo/prod/kdelibs/kdecore/kwinmodule.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kwinmodule.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kwinmodule.h"





class KWinModulePrivate;
# 51 "/coolo/prod/kdelibs/kdecore/kwinmodule.h"
class KWinModule : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:






    KWinModule( QObject* parent = 0 );




    ~KWinModule();
# 87 "/coolo/prod/kdelibs/kdecore/kwinmodule.h"
    const QValueList<WId>& windows() const;







    const QValueList<WId>& stackingOrder() const;






    bool hasWId(WId id) const;





    const QValueList<WId>& systemTrayWindows() const;





    int currentDesktop() const;





    int numberOfDesktops() const;






    WId activeWindow() const;
# 136 "/coolo/prod/kdelibs/kdecore/kwinmodule.h"
    QRect workArea( int desktop = - 1 ) const;
# 149 "/coolo/prod/kdelibs/kdecore/kwinmodule.h"
    QRect workArea( const QValueList<WId> &excludes, int desktop = -1) const;






    QString desktopName( int desktop ) const;






    void setDesktopName( int desktop, const QString& name );
# 174 "/coolo/prod/kdelibs/kdecore/kwinmodule.h"
    void doNotManage( const QString& title );


protected:





    void currentDesktopChanged( int desktop);





    void windowAdded(WId id);





    void windowRemoved(WId id);





    void activeWindowChanged(WId id);




    void desktopNamesChanged();





    void numberOfDesktopsChanged(int num);





    void systemTrayWindowAdded(WId id);





    void systemTrayWindowRemoved(WId id);




    void workAreaChanged();






    void strutChanged();





    void stackingOrderChanged();
# 255 "/coolo/prod/kdelibs/kdecore/kwinmodule.h"
    void windowChanged(WId id, const unsigned long* properties );
# 266 "/coolo/prod/kdelibs/kdecore/kwinmodule.h"
    void windowChanged(WId id, unsigned int properties) ;





    void windowChanged(WId id);

protected:
    virtual void connectNotify( const char* signal );

private:
    KWinModulePrivate* d;

    friend class KWinModulePrivate;
};
# 27 "/coolo/prod/kdelibs/kdecore/kwinmodule.cpp" 2
# 37 "/coolo/prod/kdelibs/kdecore/kwinmodule.cpp"
static KWinModulePrivate* static_d = 0;

class KWinModulePrivate : public QWidget, public NETRootInfo
{
public:
    KWinModulePrivate()
        : QWidget(0,0), NETRootInfo( qt_xdisplay(),
                                     ClientList |
                                     ClientListStacking |
                                     NumberOfDesktops |
                                     DesktopGeometry |
                                     CurrentDesktop |
                                     DesktopNames |
                                     ActiveWindow |
                                     WorkArea |
                                     KDESystemTrayWindows,
                                     -1, false
                                     ),
          strutSignalConnected( false )
    {
        KApplication::kApplication()->installX11EventFilter( this );
        (void ) KApplication::kApplication()->desktop();
        activate();
        updateStackingOrder();
    }
    ~KWinModulePrivate()
    {
    }




    QPtrList<KWinModule> modules;

    QValueList<WId> windows;
    QValueList<WId> stackingOrder;
    QValueList<WId> systemTrayWindows;

    struct StrutData
    {
        StrutData( WId window_, const NETStrut& strut_, int desktop_ )
            : window( window_ ), strut( strut_ ), desktop( desktop_ ) {};
        StrutData() {};
        WId window;
        NETStrut strut;
        int desktop;
    };
    QValueList<StrutData> strutWindows;
    QValueList<WId> possibleStrutWindows;
    bool strutSignalConnected;

    void addClient(Window);
    void removeClient(Window);
    void addSystemTrayWin(Window);
    void removeSystemTrayWin(Window);

    bool x11Event( XEvent * ev );

    void updateStackingOrder();
    bool removeStrutWindow( WId );
};


KWinModule::KWinModule( QObject* parent )
    : QObject( parent, "kwin_module" )
{
    if ( !static_d )
        static_d = new KWinModulePrivate;
    d = static_d;
    d->modules.append( this );
}

KWinModule::~KWinModule()
{
    d->modules.removeRef( this );
    if ( d->modules.isEmpty() ) {
        delete d;
        static_d = 0;
    }
}

const QValueList<WId>& KWinModule::windows() const
{
    return d->windows;
}

const QValueList<WId>& KWinModule::stackingOrder() const
{
    return d->stackingOrder;
}


bool KWinModule::hasWId(WId w) const
{
    return d->windows.contains( w );
}

const QValueList<WId>& KWinModule::systemTrayWindows() const
{
    return d->systemTrayWindows;
}

bool KWinModulePrivate::x11Event( XEvent * ev )
{
    if ( ev->xany.window == qt_xrootwin() ) {
        int m = NETRootInfo::event( ev );

        if ( m & CurrentDesktop )
            for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit )
                (*mit)->currentDesktopChanged( currentDesktop() );
        if ( m & ActiveWindow )
            for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit )
                (*mit)->activeWindowChanged( activeWindow() );
        if ( m & DesktopNames )
            for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit )
                (*mit)->desktopNamesChanged();
        if ( m & NumberOfDesktops )
            for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit )
                (*mit)->numberOfDesktopsChanged( numberOfDesktops() );
        if ( m & WorkArea )
            for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit )
                (*mit)->workAreaChanged();
        if ( m & ClientListStacking ) {
            updateStackingOrder();
            for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit )
                (*mit)->stackingOrderChanged();
        }
    } else if ( windows.contains( ev->xany.window ) ){
        NETWinInfo ni( qt_xdisplay(), ev->xany.window, qt_xrootwin(), 0 );
        unsigned long dirty[ 2 ];
        ni.event( ev, dirty, 2 );
        if ( !dirty[ 0 ] && !dirty[ 1 ] && ev->type ==28 && ev->xproperty.atom == ((Atom) 35) )
            dirty[ NETWinInfo::PROTOCOLS ] |= NET::WMIcon;
        if ( (dirty[ NETWinInfo::PROTOCOLS ] & NET::WMStrut) != 0 ) {
            removeStrutWindow( ev->xany.window );
            if ( !possibleStrutWindows.contains( ev->xany.window ) )
                possibleStrutWindows.append( ev->xany.window );
        }
        if ( dirty[ NETWinInfo::PROTOCOLS ] || dirty[ NETWinInfo::PROTOCOLS2 ] ) {
            for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit ) {
                (*mit)->windowChanged( ev->xany.window );
                (*mit)->windowChanged( ev->xany.window, dirty );
                (*mit)->windowChanged( ev->xany.window, dirty[ NETWinInfo::PROTOCOLS ] );
                if ( (dirty[ NETWinInfo::PROTOCOLS ] & NET::WMStrut) != 0 )
                    (*mit)->strutChanged();
            }
        }
    }

    return FALSE;
}

bool KWinModulePrivate::removeStrutWindow( WId w )
{
    for( QValueList< StrutData >::Iterator it = strutWindows.begin();
         it != strutWindows.end();
         ++it )
        if( (*it).window == w ) {
            strutWindows.remove( it );
            return true;
        }
    return false;
}

void KWinModulePrivate::updateStackingOrder()
{
    stackingOrder.clear();
    for ( int i = 0; i < clientListStackingCount(); i++ )
        stackingOrder.append( clientListStacking()[i] );
}

void KWinModulePrivate::addClient(Window w)
{
    if ( !QWidget::find( w ) )
        XSelectInput( qt_xdisplay(), w, (1L<<22) | (1L<<17) );
    bool emit_strutChanged = FALSE;
    if( strutSignalConnected && modules.count() > 0 ) {
        NETWinInfo info( qt_xdisplay(), w, qt_xrootwin(), NET::WMStrut | NET::WMDesktop );
        NETStrut strut = info.strut();
        if ( strut.left || strut.top || strut.right || strut.bottom ) {
            strutWindows.append( StrutData( w, strut, info.desktop()));
            emit_strutChanged = TRUE;
        }
    } else
        possibleStrutWindows.append( w );
    windows.append( w );
    for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit ) {
        (*mit)->windowAdded( w );
        if ( emit_strutChanged )
            (*mit)->strutChanged();
    }
}

void KWinModulePrivate::removeClient(Window w)
{
    bool emit_strutChanged = removeStrutWindow( w );
    if( strutSignalConnected && possibleStrutWindows.contains( w ) && modules.count() > 0 ) {
        NETWinInfo info( qt_xdisplay(), w, qt_xrootwin(), NET::WMStrut );
        NETStrut strut = info.strut();
        if ( strut.left || strut.top || strut.right || strut.bottom ) {
            emit_strutChanged = TRUE;
        }
    }
    possibleStrutWindows.remove( w );
    windows.remove( w );
    for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit ) {
        (*mit)->windowRemoved( w );
        if ( emit_strutChanged )
            (*mit)->strutChanged();
    }
}

void KWinModulePrivate::addSystemTrayWin(Window w)
{
    systemTrayWindows.append( w );
    for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit )
        (*mit)->systemTrayWindowAdded( w );
}

void KWinModulePrivate::removeSystemTrayWin(Window w)
{
    systemTrayWindows.remove( w );
    for ( QPtrListIterator<KWinModule> mit( modules ); mit.current(); ++mit )
        (*mit)->systemTrayWindowRemoved( w );
}

int KWinModule::currentDesktop() const
{
    return d->currentDesktop();
}

int KWinModule::numberOfDesktops() const
{
    return d->numberOfDesktops();
}

WId KWinModule::activeWindow() const
{
    return d->activeWindow();
}

QRect KWinModule::workArea( int desktop ) const
{
    int desk = (desktop > 0 && desktop <= (int) d->numberOfDesktops() ) ? desktop : currentDesktop();
    if ( desk <= 0 )
        return QApplication::desktop()->geometry();
    NETRect r = d->workArea( desk );
    return QRect( r.pos.x, r.pos.y, r.size.width, r.size.height );
}

QRect KWinModule::workArea( const QValueList<WId>& exclude, int desktop ) const
{
    QRect all = QApplication::desktop()->geometry();
    QRect a = all;

    if (desktop == -1)
        desktop = d->currentDesktop();

    QValueList<WId>::ConstIterator it1;
    for( it1 = d->windows.begin(); it1 != d->windows.end(); ++it1 ) {

        if(exclude.contains(*it1) > 0) continue;




        NETStrut strut;
        QValueList< KWinModulePrivate::StrutData >::Iterator it2 = d->strutWindows.begin();
        for( ;
             it2 != d->strutWindows.end();
             ++it2 )
            if( (*it2).window == *it1 )
                break;
        if( it2 != d->strutWindows.end()) {
            if(!((*it2).desktop == desktop || (*it2).desktop == NETWinInfo::OnAllDesktops ))
                continue;
            strut = (*it2).strut;
        } else if( d->possibleStrutWindows.contains( *it1 )) {
            NETWinInfo info( qt_xdisplay(), (*it1), qt_xrootwin(), NET::WMStrut | NET::WMDesktop);
            strut = info.strut();
            d->possibleStrutWindows.remove( *it1 );
            d->strutWindows.append( KWinModulePrivate::StrutData( *it1, info.strut(), info.desktop()));
            if(!(info.desktop() == desktop || info.desktop() == NETWinInfo::OnAllDesktops))
                continue;
        } else
            continue;

        QRect r = all;
        if ( strut.left > 0 )
            r.setLeft( r.left() + (int) strut.left );
        if ( strut.top > 0 )
            r.setTop( r.top() + (int) strut.top );
        if ( strut.right > 0 )
            r.setRight( r.right() - (int) strut.right );
        if ( strut.bottom > 0 )
            r.setBottom( r.bottom() - (int) strut.bottom );

        a = a.intersect(r);
    }
    return a;
}

void KWinModule::connectNotify( const char* signal )
{
    if( !d->strutSignalConnected && qstrcmp( signal, "2""strutChanged()") == 0 )
        d->strutSignalConnected = true;
    QObject::connectNotify( signal );
}

QString KWinModule::desktopName( int desktop ) const
{
    const char* name = d->desktopName( (desktop > 0 && desktop <= (int) d->numberOfDesktops() ) ? desktop : currentDesktop() );
    if ( name && name[0] )
        return QString::fromUtf8( name );
    return i18n("Desktop %1").arg( desktop );
}

void KWinModule::setDesktopName( int desktop, const QString& name )
{
    if (desktop <= 0 || desktop > (int) d->numberOfDesktops() )
        desktop = currentDesktop();
    d->setDesktopName( desktop, name.utf8().data() );
}


void KWinModule::doNotManage( const QString& title )
{
    if ( !KApplication::kApplication()->dcopClient()->isAttached() )
        KApplication::kApplication()->dcopClient()->attach();
    QByteArray data, replyData;
    QCString replyType;
    QDataStream arg(data, 0x0002);
    arg << title;
    KApplication::kApplication()->dcopClient()->call("kwin", "", "doNotManage(QString)",
                             data, replyType, replyData);
}

# 1 "../kdecore/kwinmodule.moc" 1
# 11 "../kdecore/kwinmodule.moc"
# 1 "../../../prod/kdelibs/kdecore/kwinmodule.h" 1
# 12 "../kdecore/kwinmodule.moc" 2
# 22 "../kdecore/kwinmodule.moc"
const char *KWinModule::className() const
{
    return "KWinModule";
}

QMetaObject *KWinModule::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KWinModule( "KWinModule", &KWinModule::staticMetaObject );
# 50 "../kdecore/kwinmodule.moc"
QMetaObject* KWinModule::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_signal_0[] = {
        { "desktop", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_0 = {"currentDesktopChanged", 1, param_signal_0 };
    static const QUParameter param_signal_1[] = {
        { "id", &static_QUType_ptr, "WId", QUParameter::In }
    };
    static const QUMethod signal_1 = {"windowAdded", 1, param_signal_1 };
    static const QUParameter param_signal_2[] = {
        { "id", &static_QUType_ptr, "WId", QUParameter::In }
    };
    static const QUMethod signal_2 = {"windowRemoved", 1, param_signal_2 };
    static const QUParameter param_signal_3[] = {
        { "id", &static_QUType_ptr, "WId", QUParameter::In }
    };
    static const QUMethod signal_3 = {"activeWindowChanged", 1, param_signal_3 };
    static const QUMethod signal_4 = {"desktopNamesChanged", 0, 0 };
    static const QUParameter param_signal_5[] = {
        { "num", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_5 = {"numberOfDesktopsChanged", 1, param_signal_5 };
    static const QUParameter param_signal_6[] = {
        { "id", &static_QUType_ptr, "WId", QUParameter::In }
    };
    static const QUMethod signal_6 = {"systemTrayWindowAdded", 1, param_signal_6 };
    static const QUParameter param_signal_7[] = {
        { "id", &static_QUType_ptr, "WId", QUParameter::In }
    };
    static const QUMethod signal_7 = {"systemTrayWindowRemoved", 1, param_signal_7 };
    static const QUMethod signal_8 = {"workAreaChanged", 0, 0 };
    static const QUMethod signal_9 = {"strutChanged", 0, 0 };
    static const QUMethod signal_10 = {"stackingOrderChanged", 0, 0 };
    static const QUParameter param_signal_11[] = {
        { "id", &static_QUType_ptr, "WId", QUParameter::In },
        { "properties", &static_QUType_ptr, "unsigned long", QUParameter::In }
    };
    static const QUMethod signal_11 = {"windowChanged", 2, param_signal_11 };
    static const QUParameter param_signal_12[] = {
        { "id", &static_QUType_ptr, "WId", QUParameter::In },
        { "properties", &static_QUType_ptr, "unsigned int", QUParameter::In }
    };
    static const QUMethod signal_12 = {"windowChanged", 2, param_signal_12 };
    static const QUParameter param_signal_13[] = {
        { "id", &static_QUType_ptr, "WId", QUParameter::In }
    };
    static const QUMethod signal_13 = {"windowChanged", 1, param_signal_13 };
    static const QMetaData signal_tbl[] = {
        { "currentDesktopChanged(int)", &signal_0, QMetaData::Public },
        { "windowAdded(WId)", &signal_1, QMetaData::Public },
        { "windowRemoved(WId)", &signal_2, QMetaData::Public },
        { "activeWindowChanged(WId)", &signal_3, QMetaData::Public },
        { "desktopNamesChanged()", &signal_4, QMetaData::Public },
        { "numberOfDesktopsChanged(int)", &signal_5, QMetaData::Public },
        { "systemTrayWindowAdded(WId)", &signal_6, QMetaData::Public },
        { "systemTrayWindowRemoved(WId)", &signal_7, QMetaData::Public },
        { "workAreaChanged()", &signal_8, QMetaData::Public },
        { "strutChanged()", &signal_9, QMetaData::Public },
        { "stackingOrderChanged()", &signal_10, QMetaData::Public },
        { "windowChanged(WId,const unsigned long*)", &signal_11, QMetaData::Public },
        { "windowChanged(WId,unsigned int)", &signal_12, QMetaData::Public },
        { "windowChanged(WId)", &signal_13, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KWinModule", parentObject,
        0, 0,
        signal_tbl, 14,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KWinModule.setMetaObject( metaObj );
    return metaObj;
}

void* KWinModule::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KWinModule" ) )
        return this;
    return QObject::qt_cast( clname );
}


void KWinModule::currentDesktopChanged( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 0, t0 );
}





void KWinModule::windowAdded( WId t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 1 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,&t0);
    activate_signal( clist, o );
}


void KWinModule::windowRemoved( WId t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 2 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,&t0);
    activate_signal( clist, o );
}


void KWinModule::activeWindowChanged( WId t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 3 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,&t0);
    activate_signal( clist, o );
}


void KWinModule::desktopNamesChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 4 );
}


void KWinModule::numberOfDesktopsChanged( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 5, t0 );
}


void KWinModule::systemTrayWindowAdded( WId t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 6 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,&t0);
    activate_signal( clist, o );
}


void KWinModule::systemTrayWindowRemoved( WId t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 7 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,&t0);
    activate_signal( clist, o );
}


void KWinModule::workAreaChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 8 );
}


void KWinModule::strutChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 9 );
}


void KWinModule::stackingOrderChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 10 );
}


void KWinModule::windowChanged( WId t0, const unsigned long* t1 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 11 );
    if ( !clist )
        return;
    QUObject o[3];
    static_QUType_ptr.set(o+1,&t0);
    static_QUType_ptr.set(o+2,t1);
    activate_signal( clist, o );
}


void KWinModule::windowChanged( WId t0, unsigned int t1 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 12 );
    if ( !clist )
        return;
    QUObject o[3];
    static_QUType_ptr.set(o+1,&t0);
    static_QUType_ptr.set(o+2,&t1);
    activate_signal( clist, o );
}


void KWinModule::windowChanged( WId t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 13 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,&t0);
    activate_signal( clist, o );
}

bool KWinModule::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KWinModule::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: currentDesktopChanged((int)static_QUType_int.get(_o+1)); break;
    case 1: windowAdded((WId)(*((WId*)static_QUType_ptr.get(_o+1)))); break;
    case 2: windowRemoved((WId)(*((WId*)static_QUType_ptr.get(_o+1)))); break;
    case 3: activeWindowChanged((WId)(*((WId*)static_QUType_ptr.get(_o+1)))); break;
    case 4: desktopNamesChanged(); break;
    case 5: numberOfDesktopsChanged((int)static_QUType_int.get(_o+1)); break;
    case 6: systemTrayWindowAdded((WId)(*((WId*)static_QUType_ptr.get(_o+1)))); break;
    case 7: systemTrayWindowRemoved((WId)(*((WId*)static_QUType_ptr.get(_o+1)))); break;
    case 8: workAreaChanged(); break;
    case 9: strutChanged(); break;
    case 10: stackingOrderChanged(); break;
    case 11: windowChanged((WId)(*((WId*)static_QUType_ptr.get(_o+1))),(const unsigned long*)static_QUType_ptr.get(_o+2)); break;
    case 12: windowChanged((WId)(*((WId*)static_QUType_ptr.get(_o+1))),(unsigned int)(*((unsigned int*)static_QUType_ptr.get(_o+2)))); break;
    case 13: windowChanged((WId)(*((WId*)static_QUType_ptr.get(_o+1)))); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KWinModule::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KWinModule::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 375 "/coolo/prod/kdelibs/kdecore/kwinmodule.cpp" 2
# 26 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/krootprop.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/krootprop.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 23 "/coolo/prod/kdelibs/kdecore/krootprop.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/krootprop.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/krootprop.h"

typedef unsigned long Atom;






class KRootPropPrivate;
# 45 "/coolo/prod/kdelibs/kdecore/krootprop.h"
class KRootProp
{
private:
  Atom atom;
  QMap<QString,QString> propDict;
  QString property_;
  bool dirty;
  KRootPropPrivate *d;

public:






   KRootProp( const QString& rProp = QString::null );





  ~KRootProp();





   void setProp(const QString& rProp=QString());




   QString prop() const;







   void destroy();
# 96 "/coolo/prod/kdelibs/kdecore/krootprop.h"
 QString readEntry( const QString& rKey,
                    const QString& pDefault = QString::null ) const ;
# 109 "/coolo/prod/kdelibs/kdecore/krootprop.h"
 int readNumEntry( const QString& rKey, int nDefault = 0 ) const;
# 121 "/coolo/prod/kdelibs/kdecore/krootprop.h"
 QFont readFontEntry( const QString& rKey,
                      const QFont* pDefault = 0 ) const;
# 135 "/coolo/prod/kdelibs/kdecore/krootprop.h"
 QColor readColorEntry( const QString& rKey,
                        const QColor* pDefault = 0 ) const;
# 151 "/coolo/prod/kdelibs/kdecore/krootprop.h"
 QString writeEntry( const QString& rKey, const QString& rValue );
# 161 "/coolo/prod/kdelibs/kdecore/krootprop.h"
 QString writeEntry( const QString& rKey, int nValue );
# 171 "/coolo/prod/kdelibs/kdecore/krootprop.h"
  QString writeEntry( const QString& rKey, const QFont& rFont );
# 181 "/coolo/prod/kdelibs/kdecore/krootprop.h"
  QString writeEntry( const QString& rKey, const QColor& rColor );







  QString removeEntry(const QString& rKey);





  QStringList listEntries() const;






  void sync();
};
# 26 "/coolo/prod/kdelibs/kdecore/krootprop.cpp" 2
# 35 "/coolo/prod/kdelibs/kdecore/krootprop.cpp"
KRootProp::KRootProp(const QString& rProp )
{
  atom = 0;
  dirty = FALSE;
  setProp( rProp );
}

KRootProp::~KRootProp()
{
  sync();
  propDict.clear();
}

void KRootProp::sync()
{
  if ( !dirty )
      return;

  QString propString;
  if ( !propDict.isEmpty() )
  {
    QMap<QString,QString>::Iterator it = propDict.begin();
    QString keyvalue;

    while ( it != propDict.end() )
    {
      keyvalue = QString( "%1=%2\n").arg(it.key()).arg(it.data());
      propString += keyvalue;
      ++it;
    }
  }

  XChangeProperty( qt_xdisplay(), qt_xrootwin(), atom,
                  ((Atom) 31), 8, 0,
                  (const unsigned char *)propString.utf8().data(),
                  propString.length());
  XFlush( qt_xdisplay() );
}

void KRootProp::setProp( const QString& rProp )
{
  Atom type;
  int format;
  unsigned long nitems;
  unsigned long bytes_after;
  long offset;
  char *buf;




  if( atom )
    sync();

  property_ = rProp;
  if( rProp.isEmpty() )
    return;

  atom = XInternAtom( qt_xdisplay(), rProp.utf8(), 0);

  QString s;
  offset = 0; bytes_after = 1;
  while (bytes_after != 0)
  {
    XGetWindowProperty( qt_xdisplay(), qt_xrootwin(), atom, offset, 256,
                        0, ((Atom) 31), &type, &format, &nitems, &bytes_after,
                        (unsigned char **)&buf);
    s += QString::fromUtf8(buf);
    offset += nitems/4;
    if (buf)
      XFree(buf);
  }




  QString keypair;
  int i=0;
  QString key;
  QString value;

  while(s.length() >0 )
  {


    i = s.find("\n");
    if(i == -1)
      i = s.length();



    keypair = s.left(i);
    s.remove(0,i+1);



    keypair.simplifyWhiteSpace();

    i = keypair.find( "=" );
    if( i != -1 )
    {
      key = keypair.left( i );
      value = keypair.mid( i+1 );
      propDict.insert( key, value );
    }
  }
}


QString KRootProp::prop() const
{
    return property_;
}

void KRootProp::destroy()
{
    dirty = FALSE;
    propDict.clear();
    if( atom ) {
        XDeleteProperty( qt_xdisplay(), qt_xrootwin(), atom );
        atom = 0;
    }
}

QString KRootProp::readEntry( const QString& rKey,
                            const QString& pDefault ) const
{
  if( propDict.contains( rKey ) )
      return propDict[ rKey ];
  else
      return pDefault;
}

int KRootProp::readNumEntry( const QString& rKey, int nDefault ) const
{

  QString aValue = readEntry( rKey );
  if( !aValue.isNull() )
  {
    bool ok;

    int rc = aValue.toInt( &ok );
    if (ok)
      return rc;
  }
  return nDefault;
}


QFont KRootProp::readFontEntry( const QString& rKey,
                                const QFont* pDefault ) const
{
  QFont aRetFont;
  QFont aDefFont;

  if (pDefault)
    aDefFont = *pDefault;

  QString aValue = readEntry( rKey );
  if( aValue.isNull() )
    return aDefFont;

  if ( !aRetFont.fromString( aValue ) && pDefault )
    aRetFont = aDefFont;

  return aRetFont;
}


QColor KRootProp::readColorEntry( const QString& rKey,
                                                                const QColor* pDefault ) const
{
  QColor aRetColor;
  int nRed = 0, nGreen = 0, nBlue = 0;

  if( pDefault )
    aRetColor = *pDefault;

  QString aValue = readEntry( rKey );
  if( aValue.isNull() )
    return aRetColor;



  if( aValue.find("#") == 0 ) {
    aRetColor.setNamedColor( aValue );
    return aRetColor;
  }



  int nIndex1 = aValue.find( ',' );
  if( nIndex1 == -1 )
    return aRetColor;

  int nIndex2 = aValue.find( ',', nIndex1+1 );
  if( nIndex2 == -1 )
    return aRetColor;

  bool bOK;
  nRed = aValue.left( nIndex1 ).toInt( &bOK );
  nGreen = aValue.mid( nIndex1+1,
                       nIndex2-nIndex1-1 ).toInt( &bOK );
  nBlue = aValue.mid( nIndex2+1 ).toInt( &bOK );

  aRetColor.setRgb( nRed, nGreen, nBlue );

  return aRetColor;
}

QString KRootProp::writeEntry( const QString& rKey, const QString& rValue )
{
    dirty = TRUE;
    if ( propDict.contains( rKey ) ) {
        QString aValue = propDict[ rKey ];
        propDict.replace( rKey, rValue );
        return aValue;
    }
    else {
        propDict.insert( rKey, rValue );
        return QString::null;
    }
}

QString KRootProp::writeEntry( const QString& rKey, int nValue )
{
  QString aValue;

  aValue.setNum( nValue );

  return writeEntry( rKey, aValue );
}

QString KRootProp::writeEntry( const QString& rKey, const QFont& rFont )
{
  return writeEntry( rKey, rFont.toString() );
}

QString KRootProp::writeEntry( const QString& rKey, const QColor& rColor )
{
  QString aValue = QString( "%1,%2,%3").arg(rColor.red()).arg(rColor.green()).arg(rColor.blue() );

  return writeEntry( rKey, aValue );
}

QString KRootProp::removeEntry(const QString& rKey)
{
    if (propDict.contains(rKey)) {
        dirty = TRUE;
        QString aValue = propDict[rKey];
        propDict.remove(rKey);
        return aValue;
    } else
        return QString::null;
}

QStringList KRootProp::listEntries() const
{
    QMap<QString,QString>::ConstIterator it;
    QStringList list;

    for (it=propDict.begin(); it!=propDict.end(); it++)
        list += it.key();

    return list;
}
# 27 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcharsets.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/kcharsets.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kentities.c" 1
# 31 "/coolo/prod/kdelibs/kdecore/kentities.c"
struct entity {
    const char *name;
    int code;
};




__inline





static unsigned int
hash (register const char *str, register unsigned int len)
{
  static const unsigned short asso_values[] =
    {
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 5,
        15, 10, 0, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 115, 0, 40, 50, 90,
      1887, 0, 0, 45, 1887, 5, 25, 0, 20, 225,
        10, 0, 30, 60, 10, 20, 1887, 1887, 20, 30,
        55, 1887, 1887, 1887, 1887, 1887, 1887, 0, 285, 5,
        75, 25, 55, 390, 335, 10, 5, 0, 30, 120,
       205, 40, 430, 110, 0, 580, 320, 5, 100, 0,
         5, 75, 15, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
      1887, 1887, 1887, 1887, 1887, 1887
    };
  register int hval = len;

  switch (hval)
    {
      default:
      case 8:
        hval += asso_values[(unsigned char)str[7]];
      case 7:
        hval += asso_values[(unsigned char)str[6]];
      case 6:
        hval += asso_values[(unsigned char)str[5]];
      case 5:
        hval += asso_values[(unsigned char)str[4]];
      case 4:
        hval += asso_values[(unsigned char)str[3]];
      case 3:
        hval += asso_values[(unsigned char)str[2]];
      case 2:
        hval += asso_values[(unsigned char)str[1]];
      case 1:
        hval += asso_values[(unsigned char)str[0]];
        break;
    }
  return hval;
}

static const struct entity wordlist[] =
  {
    {"rarr", 0x2192},
    {"Mu", 0x039c},
    {"uarr", 0x2191},
    {"crarr", 0x21b5},
    {"GT", 62},
    {"xi", 0x03be},
    {"Tau", 0x03a4},
    {"Pi", 0x03a0},
    {"zwj", 0x200d},
    {"circ", 0x02c6},
    {"acirc", 0x00e2},
    {"Nu", 0x039d},
    {"ucirc", 0x00fb},
    {"Xi", 0x039e},
    {"larr", 0x2190},
    {"icirc", 0x00ee},
    {"LT", 60},
    {"or", 0x22a6},
    {"Ucirc", 0x00db},
    {"ecirc", 0x00ea},
    {"le", 0x2264},
    {"real", 0x211c},
    {"ocirc", 0x00f4},
    {"Icirc", 0x00ce},
    {"frac14", 0x00bc},
    {"euro", 0x20ac},
    {"rceil", 0x2309},
    {"frac34", 0x00be},
    {"darr", 0x2193},
    {"iexcl", 0x00a1},
    {"frac12", 0x00bd},
    {"loz", 0x25ca},
    {"radic", 0x221a},
    {"ETH", 0x00d0},
    {"lceil", 0x2308},
    {"Ecirc", 0x00ca},
    {"rArr", 0x21d2},
    {"uArr", 0x21d1},
    {"mu", 0x03bc},
    {"AMP", 38},
    {"macr", 0x00af},
    {"Acirc", 0x00c2},
    {"lArr", 0x21d0},
    {"cedil", 0x00b8},
    {"lrm", 0x200e},
    {"rlm", 0x200f},
    {"ccedil", 0x00e7},
    {"uml", 0x00a8},
    {"auml", 0x00e4},
    {"raquo", 0x00bb},
    {"forall", 0x2200},
    {"uuml", 0x00fc},
    {"iuml", 0x00ef},
    {"Prime", 0x2033},
    {"rfloor", 0x230b},
    {"ordf", 0x00aa},
    {"Uuml", 0x00dc},
    {"micro", 0x00b5},
    {"euml", 0x00eb},
    {"Yuml", 0x0178},
    {"laquo", 0x00ab},
    {"Ccedil", 0x00c7},
    {"dArr", 0x21d3},
    {"ouml", 0x00f6},
    {"lfloor", 0x230a},
    {"Iuml", 0x00cf},
    {"nu", 0x03bd},
    {"ni", 0x220b},
    {"zwnj", 0x200c},
    {"ne", 0x2260},
    {"yuml", 0x00ff},
    {"rdquo", 0x201d},
    {"ordm", 0x00ba},
    {"Gamma", 0x0393},
    {"curren", 0x00a4},
    {"Euml", 0x00cb},
    {"Ocirc", 0x00d4},
    {"equiv", 0x2261},
    {"rcaron", 0x0159},
    {"QUOT", 34},
    {"ccaron", 0x010d},
    {"ldquo", 0x201c},
    {"Tcaron", 0x0164},
    {"zcaron", 0x017e},
    {"Auml", 0x00c4},
    {"Ncaron", 0x0147},
    {"ecaron", 0x011b},
    {"and", 0x22a5},
    {"Rcaron", 0x0158},
    {"THORN", 0x00de},
    {"Ccaron", 0x010c},
    {"divide", 0x00f7},
    {"Dcaron", 0x010e},
    {"yen", 0x00a5},
    {"Zcaron", 0x017d},
    {"oline", 0x203e},
    {"Scaron", 0x0160},
    {"tau", 0x03c4},
    {"dcaron", 0x10f},
    {"harr", 0x2194},
    {"Ecaron", 0x011a},
    {"eta", 0x03b7},
    {"Beta", 0x0392},
    {"lt", 60},
    {"chi", 0x03c7},
    {"bull", 0x2022},
    {"Phi", 0x03a6},
    {"fnof", 0x0192},
    {"acute", 0x00b4},
    {"aacute", 0x00e1},
    {"zeta", 0x03b6},
    {"uacute", 0x00fa},
    {"iacute", 0x00ed},
    {"iota", 0x03b9},
    {"rho", 0x03c1},
    {"Uacute", 0x00da},
    {"Ouml", 0x00d6},
    {"eacute", 0x00e9},
    {"Chi", 0x03a7},
    {"Yacute", 0x00dd},
    {"oacute", 0x00f3},
    {"Zeta", 0x0396},
    {"Iacute", 0x00cd},
    {"Rho", 0x03a1},
    {"Iota", 0x0399},
    {"Eta", 0x0397},
    {"ge", 0x2265},
    {"reg", 0x00ae},
    {"trade", 0x2122},
    {"omicron", 0x03bf},
    {"Delta", 0x0394},
    {"para", 0x00b6},
    {"yacute", 0x00fd},
    {"cap", 0x2229},
    {"pi", 0x03c0},
    {"cup", 0x222a},
    {"Eacute", 0x00c9},
    {"hArr", 0x21d4},
    {"delta", 0x03b4},
    {"aelig", 0x00e6},
    {"ncaron", 0x0148},
    {"tilde", 0x02dc},
    {"atilde", 0x00e3},
    {"Aacute", 0x00c1},
    {"quot", 34},
    {"Ntilde", 0x00d1},
    {"infin", 0x221e},
    {"deg", 0x00b0},
    {"weierp", 0x2118},
    {"oelig", 0x0153},
    {"otilde", 0x00f5},
    {"Lambda", 0x039b},
    {"lambda", 0x03bb},
    {"bdquo", 0x201e},
    {"agrave", 0x00e0},
    {"nabla", 0x2207},
    {"ugrave", 0x00f9},
    {"igrave", 0x00ec},
    {"int", 0x222b},
    {"Ugrave", 0x00d9},
    {"piv", 0x03d6},
    {"egrave", 0x00e8},
    {"prod", 0x220f},
    {"image", 0x2111},
    {"amp", 38},
    {"copy", 0x00a9},
    {"cent", 0x00a2},
    {"ograve", 0x00f2},
    {"Igrave", 0x00cc},
    {"not", 0x00ac},
    {"tcaron", 0x0165},
    {"omega", 0x03c9},
    {"Atilde", 0x00c3},
    {"Sigma", 0x03a3},
    {"Oacute", 0x00d3},
    {"prime", 0x2032},
    {"ang", 0x2220},
    {"rang", 0x232a},
    {"Psi", 0x03a8},
    {"aring", 0x00e5},
    {"Egrave", 0x00c8},
    {"Omicron", 0x039f},
    {"uring", 0x016f},
    {"permil", 0x2030},
    {"lang", 0x2329},
    {"Uring", 0x016e},
    {"beta", 0x03b2},
    {"gamma", 0x03b3},
    {"Agrave", 0x00c0},
    {"AElig", 0x00c6},
    {"cong", 0x2245},
    {"middot", 0x00b7},
    {"frasl", 0x2044},
    {"ntilde", 0x00f1},
    {"brvbar", 0x00a6},
    {"eth", 0x00f0},
    {"Otilde", 0x00d5},
    {"Theta", 0x0398},
    {"sum", 0x2211},
    {"there4", 0x2234},
    {"gt", 62},
    {"sim", 0x223c},
    {"Aring", 0x00c5},
    {"rsquo", 0x2019},
    {"rsaquo", 0x203a},
    {"Ograve", 0x00d2},
    {"OElig", 0x0152},
    {"part", 0x2202},
    {"pound", 0x00a3},
    {"Omega", 0x03a9},
    {"lsquo", 0x2018},
    {"lsaquo", 0x2039},
    {"phi", 0x03c6},
    {"notin", 0x2209},
    {"diams", 0x2666},
    {"alpha", 0x03b1},
    {"isin", 0x2208},
    {"scaron", 0x0161},
    {"Dagger", 0x2021},
    {"kappa", 0x03ba},
    {"hellip", 0x2026},
    {"Kappa", 0x039a},
    {"sub", 0x2282},
    {"dagger", 0x2020},
    {"perp", 0x22a5},
    {"alefsym", 0x2135},
    {"sube", 0x2286},
    {"prop", 0x221d},
    {"thorn", 0x00fe},
    {"clubs", 0x2663},
    {"Alpha", 0x0391},
    {"minus", 0x2212},
    {"sect", 0x00a7},
    {"exist", 0x2203},
    {"empty", 0x2205},
    {"lowast", 0x2217},
    {"percnt", 0x0025},
    {"shy", 0x00ad},
    {"theta", 0x03b8},
    {"sup", 0x2283},
    {"sdot", 0x22c5},
    {"psi", 0x03c8},
    {"sup1", 0x00b9},
    {"sbquo", 0x201a},
    {"sup3", 0x00b3},
    {"szlig", 0x00df},
    {"sup2", 0x00b2},
    {"supe", 0x2287},
    {"apos", 0x0027},
    {"iquest", 0x00bf},
    {"times", 0x00d7},
    {"nsub", 0x2284},
    {"oplus", 0x2295},
    {"otimes", 0x2297},
    {"sigma", 0x03c3},
    {"mdash", 0x2014},
    {"emdash", 0x2014},
    {"emsp", 0x2003},
    {"sigmaf", 0x03c2},
    {"ndash", 0x2013},
    {"asymp", 0x2248},
    {"endash", 0x2013},
    {"ensp", 0x2002},
    {"hearts", 0x2665},
    {"upsilon", 0x03c5},
    {"Upsilon", 0x03a5},
    {"epsilon", 0x03b5},
    {"upsih", 0x03d2},
    {"plusmn", 0x00b1},
    {"Epsilon", 0x0395},
    {"nbsp", 0x00a0},
    {"oslash", 0x00f8},
    {"spades", 0x2660},
    {"Oslash", 0x00d8},
    {"thetasym", 0x03d1},
    {"thinsp", 0x2009}
  };

static const short lookup[] =
  {
      -1, -1, -1, -1, 0, -1, -1, 1,
      -1, 2, 3, -1, 4, -1, -1, -1,
      -1, 5, 6, -1, -1, -1, 7, 8,
       9, 10, -1, 11, -1, -1, 12, -1,
      13, -1, 14, 15, -1, 16, -1, -1,
      -1, -1, 17, -1, -1, 18, -1, -1,
      -1, -1, 19, -1, -1, -1, -1, -1,
      -1, 20, -1, 21, -1, -1, -1, -1,
      -1, 22, -1, -1, -1, -1, 23, 24,
      -1, -1, 25, 26, 27, -1, -1, 28,
      29, -1, -1, -1, -1, -1, 30, -1,
      31, -1, -1, -1, -1, -1, -1, 32,
      -1, -1, -1, -1, -1, -1, -1, 33,
      -1, 34, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, 35, -1, -1, -1, 36,
      -1, -1, -1, -1, 37, -1, -1, 38,
      39, 40, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, 41, -1, -1, -1,
      -1, -1, -1, -1, -1, 42, 43, -1,
      -1, -431, -232, -2, 46, -1, 47, 48,
      49, 50, -1, -1, 51, -1, -1, -1,
      -1, 52, 53, 54, -1, -1, 55, -1,
      -1, -1, -1, 56, 57, -1, -1, -1,
      58, -1, -1, -1, -1, 59, 60, 61,
      -1, -1, 62, -1, -1, -1, -1, 63,
      -1, 64, -1, -1, 65, -1, -1, -1,
      -1, -1, -1, -1, 66, -1, -1, -1,
      -1, 67, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, 68, -1, -1,
      69, -1, 70, 71, -1, -1, -1, 72,
      -1, -1, -1, -1, -1, 73, 74, -1,
      -1, 75, 76, -1, -1, -1, -1, 77,
      78, -1, -1, 79, -1, 80, -1, -1,
      -1, 81, 82, -1, -1, -1, -1, 83,
      -1, -1, 84, -1, 85, -1, -1, -1,
      -1, 86, -1, 87, -1, -1, 88, -1,
      -1, -1, 89, -1, -1, -1, -1, -1,
      90, -1, -1, -1, -1, 91, -1, -1,
      -1, -1, 92, -1, 93, -1, -1, 94,
      -1, -1, -1, 95, 96, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      97, -1, -1, 98, -1, -1, -1, -1,
      -1, -1, -1, 99, -1, -1, -1, -1,
      -1, -1, 100, -1, 101, 102, -1, -1,
     103, 104, 105, -1, -1, -1, 106, 107,
     108, 109, -1, -1, 110, -1, 111, -1,
      -1, -1, -1, 112, -1, -1, 113, -1,
      -1, -1, 114, -1, -1, 115, -1, -1,
     116, -1, 117, -1, 118, -1, -1, 119,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, 120, -1, -1, 121, -1, 122, -1,
     123, 124, -1, -1, -1, 125, -1, -1,
      -1, 126, 127, -1, -1, -1, -1, -1,
      -1, 128, -1, 129, -1, -1, 130, -1,
      -1, -1, 131, -1, 132, -1, 133, -1,
      -1, -1, 134, 135, -1, -1, -1, -1,
      -1, -1, -1, 136, -1, -1, 137, 138,
      -1, -1, -1, -1, 139, 140, -1, -1,
      -1, 141, 142, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, 143, -1, -1, 144,
      -1, -1, -1, -1, -1, -1, 145, -1,
      -1, -1, 146, -1, -1, 147, -1, -1,
     148, -1, -1, -1, 149, -1, -1, -1,
      -1, -1, 150, -1, -1, -1, -1, 151,
      -1, -1, -1, -1, 152, -1, -1, -1,
     153, 154, -1, -1, -1, 155, 156, -1,
      -1, -1, -1, 157, -1, -1, -1, -1,
      -1, -1, 158, -1, -1, 159, -1, 160,
      -1, -1, 161, -1, -1, 162, 163, -1,
      -1, 164, 165, -1, -1, -1, -1, 166,
      -1, 167, -1, -1, -1, -1, 168, -1,
     169, -1, -1, -1, -1, -1, -1, -1,
     170, -1, -1, -1, 171, 172, -1, -1,
      -1, 173, 174, -1, -1, -1, 175, -1,
      -1, -1, -1, -1, -1, -1, 176, 177,
      -1, -1, -1, 178, -1, -1, -1, -1,
      -1, -1, 179, 180, 181, -1, -1, 182,
      -1, -1, -1, -1, -1, 183, -1, -1,
      -1, -1, -1, -1, -1, 184, 185, -1,
      -1, -1, 186, 187, 188, -1, -1, -1,
     189, -1, -1, -1, 190, -1, 191, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, 192, 193,
      -1, -1, -1, -1, 194, -1, -1, -1,
      -1, -1, -1, 195, -1, -1, -1, -1,
      -1, -1, -1, 196, -1, -1, -1, 197,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, 198, -1, -1, 199,
     200, 201, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, 202, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, 203, 204, -1, -1,
      -1, -1, 205, -1, -1, -1, 206, -1,
      -1, -1, 207, -1, -1, -1, -1, -1,
     208, -1, -1, -1, -1, 209, -1, -1,
      -1, -1, 210, 211, -1, -1, -1, -1,
      -1, -1, 212, -1, -1, -1, -1, -1,
      -1, 213, -1, -1, -1, -1, 214, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
     215, -1, -1, -1, -1, -1, -1, -1,
      -1, 216, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, 217, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, 218, -1, -1,
      -1, 219, 220, -1, -1, -1, 221, -1,
      -1, 222, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, 223, -1,
      -1, 224, -1, -1, 225, -1, -1, -1,
      -1, -1, -1, 226, -1, -1, -1, -1,
     227, 228, -1, -1, -1, -1, 229, -1,
      -1, -1, -1, 230, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, 231, -1, -1,
      -1, -1, -1, -1, -1, -1, 232, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, 233, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, 234,
     235, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, 236,
      -1, 237, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, 238, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, 239, 240, -1, -1, -1, 241,
     242, 243, -1, -1, -1, 244, 245, -1,
      -1, -1, 246, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, 247, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, 248, -1,
     249, -1, -1, -1, 250, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, 251,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, 252, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, 253, -1, -1,
      -1, 254, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, 255, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, 256, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, 257,
      -1, 258, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
     259, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, 260, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, 261, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, 262, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, 263, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, 264, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, 265, -1, -1, -1, -1, 266,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, 267, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
     268, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
     269, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
     270, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, 271, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
     272, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, 273, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, 274,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, 275
  };


__inline

const struct entity *
kde_findEntity (register const char *str, register unsigned int len)
{
  if (len <= 8 && len >= 2)
    {
      register int key = hash (str, len);

      if (key <= 1886 && key >= 0)
        {
          register int index = lookup[key];

          if (index >= 0)
            {
              register const char *s = wordlist[index].name;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
                return &wordlist[index];
            }
          else if (index < -276)
            {
              register int offset = - 1 - 276 - index;
              register const struct entity *wordptr = &wordlist[276 + lookup[offset]];
              register const struct entity *wordendptr = wordptr + -lookup[offset + 1];

              while (wordptr < wordendptr)
                {
                  register const char *s = wordptr->name;

                  if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
                    return wordptr;
                  wordptr++;
                }
            }
        }
    }
  return 0;
}
# 23 "/coolo/prod/kdelibs/kdecore/kcharsets.cpp" 2
# 31 "/coolo/prod/kdelibs/kdecore/kcharsets.cpp"
# 1 "/coolo/prod/qt-copy/include/qfontdatabase.h" 1
# 39 "/coolo/prod/qt-copy/include/qfontdatabase.h"
# 52 "/coolo/prod/qt-copy/include/qfontdatabase.h"
class QFontStylePrivate;
struct QtFontStyle;
struct QtFontFamily;
struct QtFontFoundry;
struct QFontDef;
class QFontEngine;




class QFontDatabasePrivate;

class QFontDatabase
{
public:
    static QValueList<int> standardSizes();

    QFontDatabase();

    QStringList families() const;
    QStringList families( QFont::Script ) const;
    QStringList styles( const QString & ) const;
    QValueList<int> pointSizes( const QString &, const QString & = QString::null);
    QValueList<int> smoothSizes( const QString &, const QString &);
    QString styleString( const QFont &);

    QFont font( const QString &, const QString &, int);

    bool isBitmapScalable( const QString &, const QString & = QString::null) const;
    bool isSmoothlyScalable( const QString &, const QString & = QString::null) const;
    bool isScalable( const QString &, const QString & = QString::null) const;
    bool isFixedPitch( const QString &, const QString & = QString::null) const;

    bool italic( const QString &, const QString &) const;
    bool bold( const QString &, const QString &) const;
    int weight( const QString &, const QString &) const;

    static QString scriptName(QFont::Script);
    static QString scriptSample(QFont::Script);
# 99 "/coolo/prod/qt-copy/include/qfontdatabase.h"
    QStringList families(bool) const;
    QStringList styles( const QString &, const QString & ) const;
    QValueList<int> pointSizes( const QString &, const QString &, const QString & );
    QValueList<int> smoothSizes( const QString &, const QString &, const QString & );

    QFont font( const QString &, const QString &, int, const QString &);

    bool isBitmapScalable( const QString &, const QString &, const QString & ) const;
    bool isSmoothlyScalable( const QString &, const QString &, const QString & ) const;
    bool isScalable( const QString &, const QString &, const QString & ) const;
    bool isFixedPitch( const QString &, const QString &, const QString & ) const;

    bool italic( const QString &, const QString &, const QString & ) const;
    bool bold( const QString &, const QString &, const QString & ) const;
    int weight( const QString &, const QString &, const QString & ) const;



private:

    static QFontEngine *findFont( QFont::Script script, const QFontPrivate *fp,
                                  const QFontDef &request, int force_encoding_id = -1 );


    static void createDatabase();

    static void parseFontName(const QString &name, QString &foundry, QString &family);

    friend struct QFontDef;
    friend class QFontPrivate;
    friend class QFontDialog;
    friend class QFontEngineLatinXLFD;

    QFontDatabasePrivate *d;
};




inline QStringList QFontDatabase::families( bool ) const
{
    return families();
}

inline QStringList QFontDatabase::styles( const QString &family,
                                          const QString & ) const
{
    return styles(family);
}

inline QValueList<int> QFontDatabase::pointSizes( const QString &family,
                                                  const QString &style ,
                                                  const QString & )
{
    return pointSizes(family, style);
}

inline QValueList<int> QFontDatabase::smoothSizes( const QString &family,
                                                   const QString &style,
                                                   const QString & )
{
    return smoothSizes(family, style);
}

inline QFont QFontDatabase::font( const QString &familyName,
                                  const QString &style,
                                  int pointSize,
                                  const QString &)
{
    return font(familyName, style, pointSize);
}

inline bool QFontDatabase::isBitmapScalable( const QString &family,
                                             const QString &style,
                                             const QString & ) const
{
    return isBitmapScalable(family, style);
}

inline bool QFontDatabase::isSmoothlyScalable( const QString &family,
                                               const QString &style,
                                               const QString & ) const
{
    return isSmoothlyScalable(family, style);
}

inline bool QFontDatabase::isScalable( const QString &family,
                                       const QString &style,
                                       const QString & ) const
{
    return isScalable(family, style);
}

inline bool QFontDatabase::isFixedPitch( const QString &family,
                                         const QString &style,
                                         const QString & ) const
{
    return isFixedPitch(family, style);
}

inline bool QFontDatabase::italic( const QString &family,
                                   const QString &style,
                                   const QString & ) const
{
    return italic(family, style);
}

inline bool QFontDatabase::bold( const QString &family,
                                 const QString &style,
                                 const QString & ) const
{
    return bold(family, style);
}

inline int QFontDatabase::weight( const QString &family,
                                  const QString &style,
                                  const QString & ) const
{
    return weight(family, style);
}
# 32 "/coolo/prod/kdelibs/kdecore/kcharsets.cpp" 2






# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 39 "/coolo/prod/kdelibs/kdecore/kcharsets.cpp" 2


static const char * const language_names[] = {
        ("Other"),
        ("Arabic"),
        ("Baltic"),
        ("Central European"),
        ("Chinese Simplified"),
        ("Chinese Traditional"),
        ("Cyrillic"),
        ("Greek"),
        ("Hebrew"),
        ("Japanese"),
        ("Korean"),
        ("Thai"),
        ("Turkish"),
        ("Western European"),
        ("Tamil"),
        ("Unicode"),
        ("Northern Saami")
};
# 70 "/coolo/prod/kdelibs/kdecore/kcharsets.cpp"
static const char* const charsets_for_encoding[] = {
    "koi8-r", "koi8-r","cp 1251","koi8-u","iso-8859-5", 0,
    "koi8-u", "koi8-u","cp 1251","iso-8859-5","koi8-r", 0,
    "iso 8859-1", "iso8859-1","iso8859-15", 0,
    "iso 8859-2", "iso8859-2","unicode","iso8859-1", 0,
    "iso 8859-3", "iso8859-3","unicode","iso8859-1", 0,
    "iso 8859-4", "iso8859-4","unicode","iso8859-13", "iso8859-1", 0,
    "iso 8859-5", "iso8859-5","koi8-u","koi8-r", 0,
    "iso 8859-6", "unicode","iso8859-6", 0,
    "iso 8859-7", "iso8859-7", 0,
    "iso 8859-8", "iso8859-8", 0,
    "iso 8859-8-i", "iso8859-8", 0,
    "iso 8859-9", "iso8859-9","unicode","iso8859-1", 0,
    "iso 8859-11", "iso8859-11", 0,
    "iso 8859-13", "iso8859-13","unicode","iso8859-4", "iso8859-1", 0,
    "iso 8859-15", "iso8859-15","unicode","iso8859-1", 0,
    "utf8", "unicode","iso8859-1", 0,
    "utf16", "unicode","iso8859-1", 0,
    "iso-10646-ucs-2", "unicode","iso8859-1", 0,
    "cp 1250", "iso8859-2", 0,
    "cp 1251", "cp 1251","koi8-u","koi8-r","iso8859-5", 0,
    "cp 1252", "iso8859-1", 0,
    "cp 1253", "iso8859-7", 0,
    "cp 1254", "iso8859-9", 0,
    "cp 1255", "iso8859-8", 0,
    "cp 1256", "unicode","iso8859-6", 0,
    "cp 1257", "iso8859-13", "iso8859-4", 0,
    "ibm852", "unicode","iso-8859-2", 0,
    "tis620", "iso8859-11", 0,
    "eucjp", "eucjp","unicode","iso8859-1", 0,
    "sjis", "eucjp","unicode","iso8859-1", 0,
    "jis7", "eucjp","unicode","iso8859-1", 0,
    "big5", "big5","unicode","iso8859-1", 0,
    "gbk", "gb2312.1980-0","gbk-0","unicode","iso8859-1", 0,
    "gb18030", "gb18030.2000-1", "gb18030.2000-0", "unicode", "gbk-0", "gb2313.1980-0", "iso8859-1", 0,
    "gb2312", "gb2312.1980-0","unicode","iso8859-1", 0,
    "euckr", "euckr","unicode","iso8859-1", 0,
    "tscii", "tscii", 0,
    "pt 154", "pt 154","cp 1251","koi8-u","koi8-r","iso8859-5", 0,
    "winsami2", "winsami2", "cp1252", "unicode", 0,
    0 };
# 129 "/coolo/prod/kdelibs/kdecore/kcharsets.cpp"
static struct LanguageForEncoding
    {
    const char* index;
    int data;
    } const language_for_encoding[] = {
    { "iso 8859-1", 13 },
    { "iso 8859-15", 13 },
    { "cp 1252", 13 },
    { "iso 8859-2", 3 },
    { "iso 8859-3", 3 },
    { "iso 8859-4", 2 },
    { "iso 8859-13", 2 },
    { "cp 1250", 3 },
    { "cp 1254", 12 },
    { "cp 1257", 2 },
    { "ibm852", 3 },
    { "koi8-r", 6 },
    { "iso 8859-5", 6 },
    { "cp 1251", 6 },
    { "koi8-u", 6 },
    { "pt 154", 6 },
    { "big5", 5 },
    { "gb18030", 4 },
    { "gbk", 4 },
    { "gb2312", 4 },
    { "euckr", 10 },
    { "sjis", 9 },
    { "jis7", 9 },
    { "eucjp", 9 },
    { "iso 8859-7", 7 },
    { "cp 1253", 7 },
    { "iso 8859-6", 1 },
    { "cp 1256", 1 },
    { "iso 8859-8", 8 },
    { "iso 8859-8-i", 8 },
    { "cp 1255", 8 },
    { "iso 8859-9", 12 },
    { "tis620", 11 },
    { "iso 8859-11", 11 },
    { "utf8", 15 },
    { "utf16", 15 },
    { "utf7", 15 },
    { "ucs2", 15 },
    { "iso-10646-ucs-2", 15 },
    { "winsami2", 16},
    { 0, 0 } };


static struct Builtin
    {
    const char* index;
    const char* data;
    } const builtin[] = {
    { "iso-ir-111", "koi8-r" },
    { "koi8-ru", "koi8-u" },
    { "koi8r", "koi8-r" },
    { "koi8u", "koi8-u" },
    { "koi unified", "koi8-r" },
    { "us-ascii", "iso 8859-1" },
    { "usascii", "iso 8859-1" },
    { "x-utf-8", "utf-8" },
    { "x-utf-7", "utf-7" },
    { "unicode-1-1-utf-7", "utf-7" },
    { "ucs2", "iso-10646-ucs-2" },
    { "iso10646-1", "iso-10646-ucs-2" },
    { "gb18030.2000-1", "gb18030" },
    { "gb18030.2000-0", "gb18030" },
    { "gbk-0", "gbk" },
    { "gb2312", "gbk" },
    { "gb2312.1980-0", "gbk" },
    { "big5-0", "big5" },
    { "euc-kr", "euckr" },
    { "x-euc-kr", "euckr" },
    { "euc-jp", "eucjp" },
    { "x-euc-jp", "eucjp" },
    { "jisx0201.1976-0", "eucjp" },
    { "jisx0208.1983-0", "eucjp" },
    { "jisx0208.1990-0", "eucjp" },
    { "jisx0208.1997-0", "eucjp" },
    { "jisx0212.1990-0", "eucjp" },
    { "jisx0213.2000-1", "eucjp" },
    { "jisx0213.2000-2", "eucjp" },
    { "shift_jis", "sjis" },
    { "shift-jis", "sjis" },
    { "x-sjis", "sjis" },
    { "iso-2022-jp", "jis7" },
    { "windows1250", "cp 1250" },
    { "windows1251", "cp 1251" },
    { "windows1252", "cp 1252" },
    { "windows1253", "cp 1253" },
    { "windows1254", "cp 1254" },
    { "windows1255", "cp 1255" },
    { "windows1256", "cp 1256" },
    { "windows1257", "cp 1257" },
    { "windows-1250", "cp 1250" },
    { "windows-1251", "cp 1251" },
    { "windows-1252", "cp 1252" },
    { "windows-1253", "cp 1253" },
    { "windows-1254", "cp 1254" },
    { "windows-1255", "cp 1255" },
    { "windows-1256", "cp 1256" },
    { "windows-1257", "cp 1257" },
    { "x-windows-1250", "cp 1250" },
    { "x-windows-1251", "cp 1251" },
    { "x-windows-1252", "cp 1252" },
    { "x-windows-1253", "cp 1253" },
    { "x-windows-1254", "cp 1254" },
    { "x-windows-1255", "cp 1255" },
    { "x-windows-1256", "cp 1256" },
    { "x-windows-1257", "cp 1257" },
    { "cp-1250", "cp 1250" },
    { "cp-1251", "cp 1251" },
    { "cp-1252", "cp 1252" },
    { "cp-1253", "cp 1253" },
    { "cp-1254", "cp 1254" },
    { "cp-1255", "cp 1255" },
    { "cp-1256", "cp 1256" },
    { "cp-1257", "cp 1257" },
    { "x-cp-1250", "cp 1250" },
    { "x-cp-1251", "cp 1251" },
    { "x-cp-1252", "cp 1252" },
    { "x-cp-1253", "cp 1253" },
    { "x-cp-1254", "cp 1254" },
    { "x-cp-1255", "cp 1255" },
    { "x-cp-1256", "cp 1256" },
    { "x-cp-1257", "cp 1257" },
    { "tis620", "iso 8859-11" },
    { "tis-620", "iso 8859-11" },
    { "thai-tis620", "iso 8859-11" },
    { "windows-874", "iso 8859-11" },
    { "windows874", "iso 8859-11" },
    { "x-windows-874", "iso 8859-11" },
    { "cp874", "iso 8859-11" },
    { "cp-874", "iso 8859-11" },
    { "x-cp-874", "iso 8859-11" },
    { "ksc5601.1987-0", "euckr" },
    { "ks_c_5601-1987", "euckr" },
    { "iso-8859-1", "iso 8859-1" },
    { "iso-8859-2", "iso 8859-2" },
    { "iso-8859-3", "iso 8859-3" },
    { "iso-8859-4", "iso 8859-4" },
    { "iso-8859-5", "iso 8859-5" },
    { "iso-8859-6", "iso 8859-6" },
    { "iso-8859-7", "iso 8859-7" },
    { "iso-8859-8", "iso 8859-8" },
    { "iso-8859-9", "iso 8859-9" },
    { "iso-8859-10", "iso 8859-10" },
    { "iso-8859-11", "iso 8859-11" },
    { "iso-8859-12", "iso 8859-12" },
    { "iso-8859-13", "iso 8859-13" },
    { "iso-8859-14", "iso 8859-14" },
    { "iso-8859-15", "iso 8859-15" },
    { "tscii", "tscii" },
    { "paratype-154", "pt 154" },
    { "pt-154", "pt 154" },
    { "x-winsami2", "winsami2" },
    { 0, 0 }};



static struct Aliases
    {
    const char* index;
    const char* data;
    } const aliases[] = {
    { "cp852", "ibm852" },
    { 0, 0 }};




static struct ConversionHints
    {
    const char* index;
    const char* data;
    } const conversion_hints[] = {
    { "cp1250", "iso-8859-2" },
    { "koi8-r", "iso-8859-5" },
    { "koi8-u", "koi8-r" },
    { "utf16", "iso-10646-ucs-2" },
    { 0, 0 }};




template< typename T, typename Data >
static Data kcharsets_array_search( const T* start, const char* entry )
{
    for( const T* pos = start;
         pos->index != 0;
         ++pos )
        if( qstrcmp( pos->index, entry ) == 0 )
            return pos->data;
    return 0;
}


class KCharsetsPrivate
{
public:
    KCharsetsPrivate(KCharsets* _kc)
        : codecForNameDict(43, false)
    {
        db = 0;
        kc = _kc;
    }
    ~KCharsetsPrivate()
    {
        delete db;
    }
    QFontDatabase *db;
    QAsciiDict<QTextCodec> codecForNameDict;
    KCharsets* kc;
};



KCharsets::KCharsets()
{
    d = new KCharsetsPrivate(this);
}

KCharsets::~KCharsets()
{
    delete d;
}

QChar KCharsets::fromEntity(const QString &str)
{
    QChar res = QChar::null;

    int pos = 0;
    if(str[pos] == '&') pos++;


    if (str[pos] == '#' && str.length()-pos > 1) {
        bool ok;
        pos++;
        if (str[pos] == 'x' || str[pos] == 'X') {
            pos++;

            QString tmp(str.unicode()+pos, str.length()-pos);
            res = tmp.toInt(&ok, 16);
        } else {

            QString tmp(str.unicode()+pos, str.length()-pos);
            res = tmp.toInt(&ok, 10);
        }
        return res;
    }

    const entity *e = kde_findEntity(str.ascii(), str.length());

    if(!e)
    {

        return QChar::null;
    }


    return QChar(e->code);
}

QChar KCharsets::fromEntity(const QString &str, int &len)
{


    len = 8;
    while(len > 0)
    {
        QString tmp = str.left(len);
        QChar res = fromEntity(tmp);
        if( res != QChar::null ) return res;
        len--;
    }
    return QChar::null;
}


QString KCharsets::toEntity(const QChar &ch)
{
    QString ent;
    ent.sprintf("&#0x%x;", ch.unicode());
    return ent;
}

QString KCharsets::resolveEntities( const QString &input )
{
    QString text = input;
    const QChar *p = text.unicode();
    const QChar *end = p + text.length();
    const QChar *ampersand = 0;
    bool scanForSemicolon = false;

    for ( ; p < end; ++p ) {
        const QChar ch = *p;

        if ( ch == '&' ) {
            ampersand = p;
            scanForSemicolon = true;
            continue;
        }

        if ( ch != ';' || scanForSemicolon == false )
            continue;

        (static_cast<void> ((ampersand) ? 0 : (__assert_fail ("ampersand", "/coolo/prod/kdelibs/kdecore/kcharsets.cpp", 435, __PRETTY_FUNCTION__), 0)));

        scanForSemicolon = false;

        const QChar *entityBegin = ampersand + 1;

        const uint entityLength = p - entityBegin;
        if ( entityLength == 0 )
            continue;

        const QChar entityValue = KCharsets::fromEntity( QConstString( entityBegin, entityLength ).string() );
        if ( entityValue.isNull() )
            continue;

        const uint ampersandPos = ampersand - text.unicode();

        text[ ampersandPos ] = entityValue;
        text.remove( ampersandPos + 1, entityLength + 1 );
        p = text.unicode() + ampersandPos;
        end = text.unicode() + text.length();
        ampersand = 0;
    }

    return text;
}

QStringList KCharsets::availableEncodingNames()
{
    QStringList available;

    const char* const* pos = charsets_for_encoding;
    while( *pos != 0 ) {




        for( const char* const* charsets = pos + 1;
             *charsets != 0;
             ++charsets ) {




            if( true ) {

                available.append( QString::fromLatin1( *pos ));
                break;
            }
        }
        while( *pos != 0 )
            ++pos;
        ++pos;
    }
    return available;
}

QString KCharsets::languageForEncoding( const QString &encoding )
{
    int lang = kcharsets_array_search< LanguageForEncoding, int >
        ( language_for_encoding, encoding.latin1());
    return i18n( language_names[lang] );
}

QString KCharsets::encodingForName( const QString &descriptiveName )
{
    const int left = descriptiveName.find( '(' );

    if (left<0)
        return descriptiveName;

    QString name(descriptiveName.mid(left+2));

    const int right = name.find( ')' );

    if (right<0)
        return name;

    return name.left(right-1);
}

QStringList KCharsets::descriptiveEncodingNames()
{
  QStringList encodings = availableEncodingNames();
  QStringList::Iterator it;
  for( it = encodings.begin(); it != encodings.end(); ++it ) {
      QString lang = KGlobal::charsets()->languageForEncoding( *it );
      *it = i18n("Descriptive Encoding Name", "%1 ( %2 )") .arg(lang) .arg(*it);
  }
  encodings.sort();
  return encodings;
}

QTextCodec *KCharsets::codecForName(const QString &n) const
{
    bool b;
    return codecForName( n, b );
}

QTextCodec *KCharsets::codecForName(const QString &n, bool &ok) const
{
    ok = true;

    QTextCodec* codec = 0;

    if((codec = d->codecForNameDict[n.isEmpty() ? "->locale<-" : n.latin1()]))
        return codec;

    if (n.isEmpty()) {
        codec = KGlobal::locale()->codecForEncoding();
        d->codecForNameDict.replace("->locale<-", codec);
        return codec;
    }

    QCString name = n.lower().latin1();
    QCString key = name;
    if (name.right(8) == "_charset")
       name.truncate(name.length()-8);

    if (name.isEmpty()) {
      ok = false;
      return QTextCodec::codecForName("iso8859-1");
    }

    codec = QTextCodec::codecForName(name);

    if(codec) {
        d->codecForNameDict.replace(key, codec);
        return codec;
    }



    QCString cname = kcharsets_array_search< Builtin, const char* >( builtin, name.data());

    if(!cname.isEmpty())
        codec = QTextCodec::codecForName(cname);

    if(codec)
    {
        d->codecForNameDict.replace(key, codec);
        return codec;
    }

    QString dir;
    {
    KConfigGroupSaver cfgsav( KGlobal::config(), "i18n" );
    dir = KGlobal::config()->readPathEntry("i18ndir", QString::fromLatin1("/usr/share/i18n/charmaps"));
    dir += "/";
    }



    cname = kcharsets_array_search< Aliases, const char* >( aliases, name.data());

    if(cname.isEmpty())
        cname = name;
    cname = cname.upper();

    codec = QTextCodec::loadCharmapFile((QString)(dir + cname.data()));

    if(codec) {
        d->codecForNameDict.replace(key, codec);
        return codec;
    }



    cname = cname.lower();
    cname = kcharsets_array_search< ConversionHints, const char* >( conversion_hints, (const char*)cname );

    if(!cname.isEmpty())
        codec = QTextCodec::codecForName(cname);

    if(codec) {
        d->codecForNameDict.replace(key, codec);
        return codec;
    }


    ok = false;
    return QTextCodec::codecForName("iso8859-1");
}
# 28 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kckey.cpp" 1




# 1 "/coolo/prod/kdelibs/kdecore/kckey.h" 1




typedef struct {
        const char *name;
        int code;
} KKeys;

extern const KKeys kde_KKEYS[278];
# 6 "/coolo/prod/kdelibs/kdecore/kckey.cpp" 2

const KKeys kde_KKEYS[278] = {
        { "Escape", 0x1000 },
        { "Tab", 0x1001 },
        { "Backtab", 0x1002 },
        { "Backspace", 0x1003 },
        { "Return", 0x1004 },
        { "Enter", 0x1005 },
        { "Insert", 0x1006 },
        { "Delete", 0x1007 },
        { "Pause", 0x1008 },
        { "Print", 0x1009 },
        { "SysReq", 0x100a },
        { "Clear", 0x100b },
        { "Home", 0x1010 },
        { "End", 0x1011 },
        { "Left", 0x1012 },
        { "Up", 0x1013 },
        { "Right", 0x1014 },
        { "Down", 0x1015 },
        { "Prior", 0x1016 },
        { "Next", 0x1017 },
        { "Shift", 0x1020 },
        { "Control", 0x1021 },
        { "Meta", 0x1022 },
        { "Alt", 0x1023 },
        { "CapsLock", 0x1024 },
        { "NumLock", 0x1025 },
        { "ScrollLock", 0x1026 },
        { "F1", 0x1030 },
        { "F2", 0x1031 },
        { "F3", 0x1032 },
        { "F4", 0x1033 },
        { "F5", 0x1034 },
        { "F6", 0x1035 },
        { "F7", 0x1036 },
        { "F8", 0x1037 },
        { "F9", 0x1038 },
        { "F10", 0x1039 },
        { "F11", 0x103a },
        { "F12", 0x103b },
        { "F13", 0x103c },
        { "F14", 0x103d },
        { "F15", 0x103e },
        { "F16", 0x103f },
        { "F17", 0x1040 },
        { "F18", 0x1041 },
        { "F19", 0x1042 },
        { "F20", 0x1043 },
        { "F21", 0x1044 },
        { "F22", 0x1045 },
        { "F23", 0x1046 },
        { "F24", 0x1047 },
        { "F25", 0x1048 },
        { "F26", 0x1049 },
        { "F27", 0x104a },
        { "F28", 0x104b },
        { "F29", 0x104c },
        { "F30", 0x104d },
        { "F31", 0x104e },
        { "F32", 0x104f },
        { "F33", 0x1050 },
        { "F34", 0x1051 },
        { "F35", 0x1052 },
        { "Super_L", 0x1053 },
        { "Super_R", 0x1054 },
        { "Menu", 0x1055 },
        { "Hyper_L", 0x1056 },
        { "Hyper_R", 0x1057 },
        { "Help", 0x1058 },
        { "Direction_L", 0x1059 },
        { "Direction_R", 0x1060 },
        { "Space", 0x20 },
        { "Any", Qt::Key_Space },
        { "Exclam", 0x21 },
        { "QuoteDbl", 0x22 },
        { "NumberSign", 0x23 },
        { "Dollar", 0x24 },
        { "Percent", 0x25 },
        { "Ampersand", 0x26 },
        { "Apostrophe", 0x27 },
        { "ParenLeft", 0x28 },
        { "ParenRight", 0x29 },
        { "Asterisk", 0x2a },
        { "Plus", 0x2b },
        { "Comma", 0x2c },
        { "Minus", 0x2d },
        { "Period", 0x2e },
        { "Slash", 0x2f },
        { "0", 0x30 },
        { "1", 0x31 },
        { "2", 0x32 },
        { "3", 0x33 },
        { "4", 0x34 },
        { "5", 0x35 },
        { "6", 0x36 },
        { "7", 0x37 },
        { "8", 0x38 },
        { "9", 0x39 },
        { "Colon", 0x3a },
        { "Semicolon", 0x3b },
        { "Less", 0x3c },
        { "Equal", 0x3d },
        { "Greater", 0x3e },
        { "Question", 0x3f },
        { "At", 0x40 },
        { "A", 0x41 },
        { "B", 0x42 },
        { "C", 0x43 },
        { "D", 0x44 },
        { "E", 0x45 },
        { "F", 0x46 },
        { "G", 0x47 },
        { "H", 0x48 },
        { "I", 0x49 },
        { "J", 0x4a },
        { "K", 0x4b },
        { "L", 0x4c },
        { "M", 0x4d },
        { "N", 0x4e },
        { "O", 0x4f },
        { "P", 0x50 },
        { "Q", 0x51 },
        { "R", 0x52 },
        { "S", 0x53 },
        { "T", 0x54 },
        { "U", 0x55 },
        { "V", 0x56 },
        { "W", 0x57 },
        { "X", 0x58 },
        { "Y", 0x59 },
        { "Z", 0x5a },
        { "BracketLeft", 0x5b },
        { "Backslash", 0x5c },
        { "BracketRight", 0x5d },
        { "AsciiCircum", 0x5e },
        { "Underscore", 0x5f },
        { "QuoteLeft", 0x60 },
        { "BraceLeft", 0x7b },
        { "Bar", 0x7c },
        { "BraceRight", 0x7d },
        { "AsciiTilde", 0x7e },
        { "nobreakspace", 0x0a0 },
        { "exclamdown", 0x0a1 },
        { "cent", 0x0a2 },
        { "sterling", 0x0a3 },
        { "currency", 0x0a4 },
        { "yen", 0x0a5 },
        { "brokenbar", 0x0a6 },
        { "section", 0x0a7 },
        { "diaeresis", 0x0a8 },
        { "copyright", 0x0a9 },
        { "ordfeminine", 0x0aa },
        { "guillemotleft", 0x0ab },
        { "notsign", 0x0ac },
        { "hyphen", 0x0ad },
        { "registered", 0x0ae },
        { "macron", 0x0af },
        { "degree", 0x0b0 },
        { "plusminus", 0x0b1 },
        { "twosuperior", 0x0b2 },
        { "threesuperior", 0x0b3 },
        { "acute", 0x0b4 },
        { "mu", 0x0b5 },
        { "paragraph", 0x0b6 },
        { "periodcentered", 0x0b7 },
        { "cedilla", 0x0b8 },
        { "onesuperior", 0x0b9 },
        { "masculine", 0x0ba },
        { "guillemotright", 0x0bb },
        { "onequarter", 0x0bc },
        { "onehalf", 0x0bd },
        { "threequarters", 0x0be },
        { "questiondown", 0x0bf },
        { "Agrave", 0x0c0 },
        { "Aacute", 0x0c1 },
        { "Acircumflex", 0x0c2 },
        { "Atilde", 0x0c3 },
        { "Adiaeresis", 0x0c4 },
        { "Aring", 0x0c5 },
        { "AE", 0x0c6 },
        { "Ccedilla", 0x0c7 },
        { "Egrave", 0x0c8 },
        { "Eacute", 0x0c9 },
        { "Ecircumflex", 0x0ca },
        { "Ediaeresis", 0x0cb },
        { "Igrave", 0x0cc },
        { "Iacute", 0x0cd },
        { "Icircumflex", 0x0ce },
        { "Idiaeresis", 0x0cf },
        { "ETH", 0x0d0 },
        { "Ntilde", 0x0d1 },
        { "Ograve", 0x0d2 },
        { "Oacute", 0x0d3 },
        { "Ocircumflex", 0x0d4 },
        { "Otilde", 0x0d5 },
        { "Odiaeresis", 0x0d6 },
        { "multiply", 0x0d7 },
        { "Ooblique", 0x0d8 },
        { "Ugrave", 0x0d9 },
        { "Uacute", 0x0da },
        { "Ucircumflex", 0x0db },
        { "Udiaeresis", 0x0dc },
        { "Yacute", 0x0dd },
        { "THORN", 0x0de },
        { "ssharp", 0x0df },
        { "agrave", 0x0e0 },
        { "aacute", 0x0e1 },
        { "acircumflex", 0x0e2 },
        { "atilde", 0x0e3 },
        { "adiaeresis", 0x0e4 },
        { "aring", 0x0e5 },
        { "ae", 0x0e6 },
        { "ccedilla", 0x0e7 },
        { "egrave", 0x0e8 },
        { "eacute", 0x0e9 },
        { "ecircumflex", 0x0ea },
        { "ediaeresis", 0x0eb },
        { "igrave", 0x0ec },
        { "iacute", 0x0ed },
        { "icircumflex", 0x0ee },
        { "idiaeresis", 0x0ef },
        { "eth", 0x0f0 },
        { "ntilde", 0x0f1 },
        { "ograve", 0x0f2 },
        { "oacute", 0x0f3 },
        { "ocircumflex", 0x0f4 },
        { "otilde", 0x0f5 },
        { "odiaeresis", 0x0f6 },
        { "division", 0x0f7 },
        { "oslash", 0x0f8 },
        { "ugrave", 0x0f9 },
        { "uacute", 0x0fa },
        { "ucircumflex", 0x0fb },
        { "udiaeresis", 0x0fc },
        { "yacute", 0x0fd },
        { "thorn", 0x0fe },
        { "ydiaeresis", 0x0ff },
        { "Back ", 0x1061 },
        { "Forward ", 0x1062 },
        { "Stop ", 0x1063 },
        { "Refresh ", 0x1064 },
        { "VolumeDown", 0x1070 },
        { "VolumeMute ", 0x1071 },
        { "VolumeUp", 0x1072 },
        { "BassBoost", 0x1073 },
        { "BassUp", 0x1074 },
        { "BassDown", 0x1075 },
        { "TrebleUp", 0x1076 },
        { "TrebleDown", 0x1077 },
        { "MediaPlay ", 0x1080 },
        { "MediaStop ", 0x1081 },
        { "MediaPrev ", 0x1082 },
        { "MediaNext ", 0x1083 },
        { "MediaRecord", 0x1084 },
        { "HomePage ", 0x1090 },
        { "Favorites ", 0x1091 },
        { "Search ", 0x1092 },
        { "Standby", 0x1093 },
        { "OpenUrl", 0x1094 },
        { "LaunchMail ", 0x10a0 },
        { "LaunchMedia", 0x10a1 },
        { "Launch0 ", 0x10a2 },
        { "Launch1 ", 0x10a3 },
        { "Launch2 ", 0x10a4 },
        { "Launch3 ", 0x10a5 },
        { "Launch4 ", 0x10a6 },
        { "Launch5 ", 0x10a7 },
        { "Launch6 ", 0x10a8 },
        { "Launch7 ", 0x10a9 },
        { "Launch8 ", 0x10aa },
        { "Launch9 ", 0x10ab },
        { "LaunchA ", 0x10ac },
        { "LaunchB ", 0x10ad },
        { "LaunchC ", 0x10ae },
        { "LaunchD ", 0x10af },
        { "LaunchE ", 0x10b0 },
        { "LaunchF ", 0x10b1 },
        { "MediaLast", 0x1fff },
        { "unknown", 0xffff }
};
# 29 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kshortcut.cpp" 1
# 21 "/coolo/prod/kdelibs/kdecore/kshortcut.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kkeynative.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kkeynative.h"




typedef union _XEvent XEvent;


class KKeyNativePrivate;




class KKeyNative
{
 public:






        KKeyNative();






        KKeyNative( const XEvent* xevent );






        KKeyNative( const KKey& key );




        KKeyNative( const KKeyNative& );




        KKeyNative( uint code, uint mod, uint sym );
        ~KKeyNative();





        void clear();







        bool init( const XEvent* xevent );






        bool init( const KKey& key );






        bool init( const KKeyNative& key );






        KKeyNative& operator =( const KKeyNative& key )
                { init( key ); return *this; }







        int keyCodeQt() const;





        KKey key() const;






        operator KKey() const { return key(); }





        uint code() const;





        uint mod() const;





        uint sym() const;
# 152 "/coolo/prod/kdelibs/kdecore/kkeynative.h"
        bool isNull() const;
# 165 "/coolo/prod/kdelibs/kdecore/kkeynative.h"
        int compare( const KKeyNative& key ) const;





        bool operator == ( const KKeyNative& key ) const
                { return compare( key ) == 0; }





        bool operator != ( const KKeyNative& key ) const
                { return compare( key ) != 0; }





        bool operator < ( const KKeyNative& key ) const
                { return compare( key ) < 0; }







        static KKeyNative& null();






        static bool keyboardHasWinKey();






        static uint modX( KKey::ModFlag modFlag );






        static uint accelModMaskX();






        static uint modXNumLock();






        static uint modXLock();






        static uint modXScrollLock();

 private:
        uint m_code, m_mod, m_sym;
        KKeyNativePrivate* d;
};
# 22 "/coolo/prod/kdelibs/kdecore/kshortcut.cpp" 2

# 1 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h" 1

# 12 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
namespace KKeyServer
{




        enum ExtraModFlag { MODE_SWITCH = 0x2000 };






        struct Sym
        {
         public:

                uint m_sym;


                Sym()
                        { m_sym = 0; }




                Sym( uint sym )
                        { m_sym = sym; }





                Sym( const QString& s )
                        { init( s ); }







                bool initQt( int keyQt );







                bool init( const QString &s );





                int qt() const;




                QString toStringInternal() const;





                QString toString() const;
# 88 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
                uint getModsRequired() const;




                uint getSymVariation() const;




                operator uint() const { return m_sym; }




                Sym& operator =( uint sym ) { m_sym = sym; return *this; }

         private:
                QString toString( bool bUserSpace ) const;

                static void capitalizeKeyname( QString& );
        };





        struct Key
        {

                enum { CODE_FOR_QT = 256 };


                uint m_code;


                uint m_mod;


                uint m_sym;
# 137 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
                bool init( const KKey& key, bool bQt );
# 146 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
                bool isNative() const { return m_code != CODE_FOR_QT; }





                uint code() const { return m_code; }





                uint mod() const { return m_mod; }





                uint sym() const { return m_sym; }





                int keyCodeQt() const { return (int) m_sym; }





                void setKeycodeQt( int keyQt )
                        { m_code = CODE_FOR_QT; m_sym = keyQt; }





                Key& operator =( const KKeyNative& key );
# 196 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
                int compare( const Key& key ) const;





                bool operator ==( const Key& b ) const
                        { return compare( b ) == 0; }





                bool operator <( const Key& b ) const
                        { return compare( b ) < 0; }





                KKey key() const;
        };




        struct Variations
        {
                enum { MAX_VARIATIONS = 4 };

                Key m_rgkey[MAX_VARIATIONS];
                uint m_nVariations;

                Variations() { m_nVariations = 0; }

                void init( const KKey&, bool bQt );

                uint count() const { return m_nVariations; }
                const Key& key( uint i ) const { return m_rgkey[i]; }
        };


        bool initializeMods();






        uint modX( KKey::ModFlag modFlag );







        bool keyboardHasWinKey();






        uint modXShift();






        uint modXLock();






        uint modXCtrl();






        uint modXAlt();






        uint modXNumLock();







        uint modXWin();






        uint modXScrollLock();
# 316 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        uint accelModMaskX();
# 327 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        bool keyQtToSym( int keyQt, uint& sym );
# 337 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        bool keyQtToMod( int keyQt, uint& mod );
# 347 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        bool symToKeyQt( uint sym, int& keyQt );
# 359 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        bool modToModQt( uint mod, int& modQt );
# 370 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        bool modToModX( uint mod, uint& modX );
# 381 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        bool modXToModQt( uint modX, int& modQt );
# 392 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        bool modXToMod( uint modX, uint& mod );
# 405 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.h"
        bool codeXToSym( uchar codeX, uint modX, uint& symX );




        QString modToStringInternal( uint mod );







        QString modToStringUser( uint mod );





        bool stringToSymMod( const QString&, uint& sym, uint& mod );





        void keyQtToKeyX( uint keyCombQt, unsigned char *pKeyCodeX, uint *pKeySymX, uint *pKeyModX );
}
# 24 "/coolo/prod/kdelibs/kdecore/kshortcut.cpp" 2
# 36 "/coolo/prod/kdelibs/kdecore/kshortcut.cpp"
static KKey* g_pspec = 0;
static KKeySequence* g_pseq = 0;
static KShortcut* g_pcut = 0;





KKey::KKey() { clear(); }
KKey::KKey( uint key, uint modFlags ) { init( key, modFlags ); }
KKey::KKey( int keyQt ) { init( keyQt ); }
KKey::KKey( const QKeySequence& seq ) { init( seq ); }
KKey::KKey( const QKeyEvent* pEvent ) { init( pEvent ); }
KKey::KKey( const KKey& key ) { init( key ); }
KKey::KKey( const QString& sKey ) { init( sKey ); }

KKey::~KKey()
{
}

void KKey::clear()
{
        m_sym = 0;
        m_mod = 0;
}

bool KKey::init( uint key, uint modFlags )
{
        m_sym = key;
        m_mod = modFlags;
        return true;
}

bool KKey::init( int keyQt )
{



        if( KKeyServer::keyQtToSym( keyQt, m_sym )
            && KKeyServer::keyQtToMod( keyQt, m_mod ) )
                return true;
        else {
                m_sym = 0;
                m_mod = 0;
                return false;
        }
}

bool KKey::init( const QKeySequence& key )
{

        return init( (int) key );
}

bool KKey::init( const QKeyEvent* pEvent )
{
        int keyQt = pEvent->key();
        if( pEvent->state() & Qt::ShiftButton ) keyQt |= Qt::SHIFT;
        if( pEvent->state() & Qt::ControlButton ) keyQt |= Qt::CTRL;
        if( pEvent->state() & Qt::AltButton ) keyQt |= Qt::ALT;
        return init( keyQt );
}

bool KKey::init( const KKey& key )
{
        m_sym = key.m_sym;
        m_mod = key.m_mod;
        return true;
}

bool KKey::init( const QString& sSpec )
{
        clear();

        QString sKey = sSpec.stripWhiteSpace();
        if( sKey.startsWith( "default(" ) && sKey.endsWith( ")" ) )
                sKey = sKey.mid( 8, sKey.length() - 9 );

        if( sKey.endsWith( "++" ) )
                sKey = sKey.left( sKey.length() - 1 ) + "plus";
        QStringList rgs = QStringList::split( '+', sKey, true );

        uint i;

        for( i = 0; i < rgs.size(); i++ ) {
                QString s = rgs[i].lower();
                if( s == "shift" ) m_mod |= KKey::SHIFT;
                else if( s == "ctrl" ) m_mod |= KKey::CTRL;
                else if( s == "alt" ) m_mod |= KKey::ALT;
                else if( s == "win" ) m_mod |= KKey::WIN;
                else if( s == "meta" ) m_mod |= KKey::WIN;
                else break;
        }

        if( (i == rgs.size() - 1 && !rgs[i].isEmpty()) ) {
                KKeyServer::Sym sym( rgs[i] );
                m_sym = sym.m_sym;
        }

        if( m_sym == 0 )
                m_mod = 0;

        kdDebug(125) << "KKey::init( \"" << sSpec << "\" ):"
                << " m_sym = " << QString::number(m_sym, 16)
                << ", m_mod = " << QString::number(m_mod, 16) << endl;

        return m_sym != 0;
}

bool KKey::isNull() const { return m_sym == 0; }
uint KKey::sym() const { return m_sym; }
uint KKey::modFlags() const { return m_mod; }

int KKey::compare( const KKey& spec ) const
{
        if( m_sym != spec.m_sym )
                return m_sym - spec.m_sym;
        if( m_mod != spec.m_mod )
                return m_mod - spec.m_mod;
        return 0;
}

int KKey::keyCodeQt() const
{
        return KKeyNative( *this ).keyCodeQt();
}

QString KKey::toString() const
{
        QString s;

        s = KKeyServer::modToStringUser( m_mod );
        if( !s.isEmpty() )
                s += '+';
        s += KKeyServer::Sym(m_sym).toString();

        return s;
}

QString KKey::toStringInternal() const
{



        QString s;

        s = KKeyServer::modToStringInternal( m_mod );
        if( !s.isEmpty() )
                s += '+';
        s += KKeyServer::Sym(m_sym).toStringInternal();
        return s;
}

KKey& KKey::null()
{
        if( !g_pspec )
                g_pspec = new KKey;
        if( !g_pspec->isNull() )
                g_pspec->clear();
        return *g_pspec;
}

QString KKey::modFlagLabel( ModFlag modFlag )
{
        return KKeyServer::modToStringUser( modFlag );
}





KKeySequence::KKeySequence() { clear(); }
KKeySequence::KKeySequence( const QKeySequence& seq ) { init( seq ); }
KKeySequence::KKeySequence( const KKey& key ) { init( key ); }
KKeySequence::KKeySequence( const KKeySequence& seq ) { init( seq ); }
KKeySequence::KKeySequence( const QString& s ) { init( s ); }

KKeySequence::~KKeySequence()
{
}

void KKeySequence::clear()
{
        m_nKeys = 0;
        m_bTriggerOnRelease = false;
}

bool KKeySequence::init( const QKeySequence& seq )
{
        clear();

        if( !seq.isEmpty() ) {
                for( uint i = 0; i < seq.count(); i++ ) {
                        m_rgvar[i].init( seq[i] );
                        if( m_rgvar[i].isNull() )
                                return false;
                }
                m_nKeys = seq.count();
                m_bTriggerOnRelease = false;
        }
# 245 "/coolo/prod/kdelibs/kdecore/kshortcut.cpp"
        return true;
}

bool KKeySequence::init( const KKey& key )
{
        if( !key.isNull() ) {
                m_nKeys = 1;
                m_rgvar[0].init( key );
                m_bTriggerOnRelease = false;
        } else
                clear();
        return true;
}

bool KKeySequence::init( const KKeySequence& seq )
{
        m_bTriggerOnRelease = false;
        m_nKeys = seq.m_nKeys;
        for( uint i = 0; i < m_nKeys; i++ ) {
                if( seq.m_rgvar[i].isNull() ) {
                        kdWarning(125) << "KKeySequence::init( seq ): key[" << i << "] is null." << endl;
                        m_nKeys = 0;
                        return false;
                }
                m_rgvar[i] = seq.m_rgvar[i];
        }
        return true;
}

bool KKeySequence::init( const QString& s )
{
        m_bTriggerOnRelease = false;

        QStringList rgs = QStringList::split( ',', s );
        if( s == "none" || rgs.size() == 0 ) {
                clear();
                return true;
        } else if( rgs.size() <= MAX_KEYS ) {
                m_nKeys = rgs.size();
                for( uint i = 0; i < m_nKeys; i++ ) {
                        m_rgvar[i].init( KKey(rgs[i]) );

                }
                return true;
        } else {
                clear();
                return false;
        }
}

uint KKeySequence::count() const
{
        return m_nKeys;
}

const KKey& KKeySequence::key( uint i ) const
{
        if( i < m_nKeys )
                return m_rgvar[i];
        else
                return KKey::null();
}

bool KKeySequence::isTriggerOnRelease() const
        { return m_bTriggerOnRelease; }

bool KKeySequence::setKey( uint iKey, const KKey& key )
{
        if( iKey <= m_nKeys && iKey < MAX_KEYS ) {
                m_rgvar[iKey].init( key );
                if( iKey == m_nKeys )
                        m_nKeys++;
                return true;
        } else
                return false;
}

bool KKeySequence::isNull() const
{
        return m_nKeys == 0;
}

bool KKeySequence::startsWith( const KKeySequence& seq ) const
{
        if( m_nKeys < seq.m_nKeys )
                return false;

        for( uint i = 0; i < seq.m_nKeys; i++ ) {
                if( m_rgvar[i] != seq.m_rgvar[i] )
                        return false;
        }

        return true;
}

int KKeySequence::compare( const KKeySequence& seq ) const
{
        for( uint i = 0; i < m_nKeys && i < seq.m_nKeys; i++ ) {
                int ret = m_rgvar[i].compare( seq.m_rgvar[i] );
                if( ret != 0 )
                        return ret;
        }
        if( m_nKeys != seq.m_nKeys )
                return m_nKeys - seq.m_nKeys;
        else
                return 0;
}

QKeySequence KKeySequence::qt() const
{
        int k[4] = { 0, 0, 0, 0 };

        for( uint i = 0; i < count(); i++ )
                k[i] = KKeyNative(key(i)).keyCodeQt();

        QKeySequence seq( k[0], k[1], k[2], k[3] );





        return seq;
}

int KKeySequence::keyCodeQt() const
{
        return (count() == 1) ? KKeyNative(key(0)).keyCodeQt() : 0;
}

QString KKeySequence::toString() const
{
        if( m_nKeys < 1 ) return QString::null;

        QString s;
        s = m_rgvar[0].toString();
        for( uint i = 1; i < m_nKeys; i++ ) {
                s += ",";
                s += m_rgvar[i].toString();
        }

        return s;
}

QString KKeySequence::toStringInternal() const
{
        if( m_nKeys < 1 ) return QString::null;

        QString s;
        s = m_rgvar[0].toStringInternal();
        for( uint i = 1; i < m_nKeys; i++ ) {
                s += ",";
                s += m_rgvar[i].toStringInternal();
        }

        return s;
}

KKeySequence& KKeySequence::null()
{
        if( !g_pseq )
                g_pseq = new KKeySequence;
        if( !g_pseq->isNull() )
                g_pseq->clear();
        return *g_pseq;
}





KShortcut::KShortcut() { clear(); }
KShortcut::KShortcut( int keyQt ) { init( keyQt ); }
KShortcut::KShortcut( const QKeySequence& key ) { init( key ); }
KShortcut::KShortcut( const KKey& key ) { init( key ); }
KShortcut::KShortcut( const KKeySequence& seq ) { init( seq ); }
KShortcut::KShortcut( const KShortcut& cut ) { init( cut ); }
KShortcut::KShortcut( const char* ps ) { init( QString(ps) ); }
KShortcut::KShortcut( const QString& s ) { init( s ); }

KShortcut::~KShortcut()
{
}

void KShortcut::clear()
{
        m_nSeqs = 0;
}

bool KShortcut::init( int keyQt )
{
        if( keyQt ) {
                m_nSeqs = 1;
                m_rgseq[0].init( QKeySequence(keyQt) );
        } else
                clear();
        return true;
}

bool KShortcut::init( const QKeySequence& key )
{
        m_nSeqs = 1;
        m_rgseq[0].init( key );
        return true;
}

bool KShortcut::init( const KKey& spec )
{
        m_nSeqs = 1;
        m_rgseq[0].init( spec );
        return true;
}

bool KShortcut::init( const KKeySequence& seq )
{
        m_nSeqs = 1;
        m_rgseq[0] = seq;
        return true;
}

bool KShortcut::init( const KShortcut& cut )
{
        m_nSeqs = cut.m_nSeqs;
        for( uint i = 0; i < m_nSeqs; i++ )
                m_rgseq[i] = cut.m_rgseq[i];
        return true;
}

bool KShortcut::init( const QString& s )
{
        bool bRet = true;
        QStringList rgs = QStringList::split( ';', s );

        if( s == "none" || rgs.size() == 0 )
                clear();
        else if( rgs.size() <= MAX_SEQUENCES ) {
                m_nSeqs = rgs.size();
                for( uint i = 0; i < m_nSeqs; i++ ) {
                        QString& sSeq = rgs[i];
                        if( sSeq.startsWith( "default(" ) )
                                sSeq = sSeq.mid( 8, sSeq.length() - 9 );
                        m_rgseq[i].init( sSeq );

                }
        } else {
                clear();
                bRet = false;
        }

        if( !s.isEmpty() ) {
                QString sDebug;
                QTextStream os( &sDebug, 0x0002 );
                os << "KShortcut::init( \"" << s << "\" ): ";
                for( uint i = 0; i < m_nSeqs; i++ ) {
                        os << " m_rgseq[" << i << "]: ";
                        KKeyServer::Variations vars;
                        vars.init( m_rgseq[i].key(0), true );
                        for( uint j = 0; j < vars.count(); j++ )
                                os << QString::number(vars.m_rgkey[j].keyCodeQt(),16) << ',';
                }
                kdDebug(125) << sDebug << endl;
        }

        return bRet;
}

uint KShortcut::count() const
{
        return m_nSeqs;
}

const KKeySequence& KShortcut::seq( uint i ) const
{
        return (i < m_nSeqs) ? m_rgseq[i] : KKeySequence::null();
}

int KShortcut::keyCodeQt() const
{
        if( m_nSeqs >= 1 )
                return m_rgseq[0].keyCodeQt();
        return QKeySequence();
}

bool KShortcut::isNull() const
{
        return m_nSeqs == 0;
}

int KShortcut::compare( const KShortcut& cut ) const
{
        for( uint i = 0; i < m_nSeqs && i < cut.m_nSeqs; i++ ) {
                int ret = m_rgseq[i].compare( cut.m_rgseq[i] );
                if( ret != 0 )
                        return ret;
        }
        return m_nSeqs - cut.m_nSeqs;
}

bool KShortcut::contains( const KKey& key ) const
{
        return contains( KKeySequence(key) );
}

bool KShortcut::contains( const KKeyNative& keyNative ) const
{
        KKey key = keyNative.key();
        key.simplify();

        for( uint i = 0; i < count(); i++ ) {
                if( !m_rgseq[i].isNull()
                    && m_rgseq[i].count() == 1
                    && m_rgseq[i].key(0) == key )
                        return true;
        }
        return false;
}

bool KShortcut::contains( const KKeySequence& seq ) const
{
        for( uint i = 0; i < count(); i++ ) {
                if( !m_rgseq[i].isNull() && m_rgseq[i] == seq )
                        return true;
        }
        return false;
}

bool KShortcut::setSeq( uint iSeq, const KKeySequence& seq )
{

        if( iSeq <= m_nSeqs && iSeq < MAX_SEQUENCES ) {
                m_rgseq[iSeq] = seq;
                if( iSeq == m_nSeqs )
                        m_nSeqs++;
                return true;
        } else
                return false;
}

bool KShortcut::append( const KKeySequence& seq )
{
        if( m_nSeqs < MAX_SEQUENCES ) {
                if( !seq.isNull() ) {
                        m_rgseq[m_nSeqs] = seq;
                        m_nSeqs++;
                }
                return true;
        } else
                return false;
}

bool KShortcut::append( const KKey& spec )
{
        if( m_nSeqs < MAX_SEQUENCES ) {
                m_rgseq[m_nSeqs].init( spec );
                m_nSeqs++;
                return true;
        } else
                return false;
}

bool KShortcut::append( const KShortcut& cut )
{
        uint seqs = m_nSeqs, co = cut.count();
        for( uint i=0; i<co; i++ ) {
            if (!contains(cut.seq(i))) seqs++;
        }
        if( seqs > MAX_SEQUENCES ) return false;

        for( uint i=0; i<co; i++ ) {
                const KKeySequence& seq = cut.seq(i);
                if(!contains(seq)) {
                        m_rgseq[m_nSeqs] = seq;
                        m_nSeqs++;
                }
        }
        return true;
}

KShortcut::operator QKeySequence () const
{
        if( count() >= 1 )
                return m_rgseq[0].qt();
        else
                return QKeySequence();
}

QString KShortcut::toString() const
{
        QString s;

        for( uint i = 0; i < count(); i++ ) {
                s += m_rgseq[i].toString();
                if( i < count() - 1 )
                        s += ';';
        }

        return s;
}

QString KShortcut::toStringInternal( const KShortcut* pcutDefault ) const
{
        QString s;

        for( uint i = 0; i < count(); i++ ) {
                const KKeySequence& seq = m_rgseq[i];
                if( pcutDefault && i < pcutDefault->count() && seq == (*pcutDefault).seq(i) ) {
                        s += "default(";
                        s += seq.toStringInternal();
                        s += ")";
                } else
                        s += seq.toStringInternal();
                if( i < count() - 1 )
                        s += ';';
        }

        return s;
}

KShortcut& KShortcut::null()
{
        if( !g_pcut )
                g_pcut = new KShortcut;
        if( !g_pcut->isNull() )
                g_pcut->clear();
        return *g_pcut;
}
# 30 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kkeynative_x11.cpp" 1
# 34 "/coolo/prod/kdelibs/kdecore/kkeynative_x11.cpp"



# 1 "/usr/X11R6/include/X11/keysymdef.h" 1
# 52 "/usr/X11R6/include/X11/keysymdef.h"
# 61 "/usr/X11R6/include/X11/keysymdef.h"





















# 189 "/usr/X11R6/include/X11/keysymdef.h"




# 275 "/usr/X11R6/include/X11/keysymdef.h"






# 40 "/coolo/prod/kdelibs/kdecore/kkeynative_x11.cpp" 2




static KKeyNative* gx_pkey = 0;





KKeyNative::KKeyNative() { clear(); }
KKeyNative::KKeyNative( const KKey& key ) { init( key ); }
KKeyNative::KKeyNative( const KKeyNative& key ) { init( key ); }
KKeyNative::KKeyNative( const XEvent* pEvent ) { init( pEvent ); }

KKeyNative::KKeyNative( uint code, uint mod, uint sym )
{
        m_code = code;
        m_mod = mod;
        m_sym = sym;
}

KKeyNative::~KKeyNative()
        { }

void KKeyNative::clear()
{
        m_code = 0;
        m_mod = 0;
        m_sym = 0;
}

bool KKeyNative::init( const XEvent* pEvent )
{
        m_code = pEvent->xkey.keycode;
        m_mod = pEvent->xkey.state;
        XLookupString( (XKeyEvent*) pEvent, 0, 0, (KeySym*) &m_sym, 0 );
        return true;
}

bool KKeyNative::init( const KKey& key )
{


        m_sym = key.sym();
        uint modExtra = KKeyServer::Sym(m_sym).getModsRequired();

        if( !m_sym || !KKeyServer::modToModX( key.modFlags() | modExtra, m_mod ) ) {
                m_sym = m_mod = 0;
                m_code = 0;
                return false;
        }




        if( m_sym == 0xFF61 && !(m_mod & (1<<3)) )
                m_code = 111;
        else if( m_sym == 0xFF6B || (m_sym == 0xFF13 && (m_mod & (1<<2))) )
                m_code = 114;
        else
                m_code = XKeysymToKeycode( qt_xdisplay(), m_sym );

        if( !m_code && m_sym )
                kdDebug(125) << "Couldn't get code for sym" << endl;


        if( key.modFlags() )
                KKeyServer::codeXToSym( m_code, m_mod, m_sym );

        return true;
}

bool KKeyNative::init( const KKeyNative& key )
{
        m_code = key.m_code;
        m_mod = key.m_mod;
        m_sym = key.m_sym;
        return true;
}

uint KKeyNative::code() const { return m_code; }
uint KKeyNative::mod() const { return m_mod; }
uint KKeyNative::sym() const { return m_sym; }

bool KKeyNative::isNull() const
{
        return m_sym == 0;
}

int KKeyNative::compare( const KKeyNative& key ) const
{
        if( m_sym != key.m_sym ) return m_sym - key.m_sym;
        if( m_mod != key.m_mod ) return m_mod - key.m_mod;
        if( m_code != key.m_code ) return m_code - key.m_code;
        return 0;
}

KKeyNative& KKeyNative::null()
{
        if( !gx_pkey )
                gx_pkey = new KKeyNative;
        if( !gx_pkey->isNull() )
                gx_pkey->clear();
        return *gx_pkey;
}

KKey KKeyNative::key() const
{
        uint modSpec;
        if( KKeyServer::modXToMod( m_mod, modSpec ) )
                return KKey( m_sym, modSpec );
        else
                return KKey();
}

int KKeyNative::keyCodeQt() const
{
        int keyQt = KKeyServer::Sym(m_sym).qt(), modQt;

        if( keyQt != Qt::Key_unknown && KKeyServer::modXToModQt( m_mod, modQt ) )
                return keyQt | modQt;

        return 0;
}

uint KKeyNative::modX( KKey::ModFlag modFlag ) { return KKeyServer::modX( modFlag ); }
bool KKeyNative::keyboardHasWinKey() { return KKeyServer::keyboardHasWinKey(); }
uint KKeyNative::accelModMaskX() { return KKeyServer::accelModMaskX(); }
uint KKeyNative::modXNumLock() { return KKeyServer::modXNumLock(); }
uint KKeyNative::modXLock() { return KKeyServer::modXLock(); }
uint KKeyNative::modXScrollLock() { return KKeyServer::modXScrollLock(); }
# 31 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.cpp" 1
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 2 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.cpp" 2
# 17 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.cpp"



# 1 "/usr/X11R6/include/X11/keysymdef.h" 1
# 52 "/usr/X11R6/include/X11/keysymdef.h"
# 61 "/usr/X11R6/include/X11/keysymdef.h"





















# 189 "/usr/X11R6/include/X11/keysymdef.h"




# 275 "/usr/X11R6/include/X11/keysymdef.h"






# 23 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.cpp" 2

namespace KKeyServer
{





struct Mod
{
        int m_mod;
};





struct ModInfo
{
        KKey::ModFlag mod;
        int modQt;
        uint modX;
        const char* psName;
        QString sLabel;
};

struct SymVariation
{
        uint sym, symVariation;
        bool bActive;
};

struct SymName
{
        uint sym;
        const char* psName;
};

struct TransKey {
        int keySymQt;
        uint keySymX;
};





static ModInfo g_rgModInfo[KKey::MOD_FLAG_COUNT] =
{
        { KKey::SHIFT, Qt::SHIFT, (1<<0), ("Shift"), QString() },
        { KKey::CTRL, Qt::CTRL, (1<<2), ("Ctrl"), QString() },
        { KKey::ALT, Qt::ALT, (1<<3), ("Alt"), QString() },
        { KKey::WIN, KKey::QtWIN, (1<<6), ("Win"), QString() }
};

static SymVariation g_rgSymVariation[] =
{
        { '/', 0xFFAF, false },
        { '*', 0xFFAA, false },
        { '-', 0xFFAD, false },
        { '+', 0xFFAB, false },
        { 0xFF0D, 0xFF8D, false },
        { 0, 0, false }
};


static const SymName g_rgSymNames[] = {
        { 0xFE20, "Backtab" },
        { 0xFF08, ("Backspace") },
        { 0xFF15, ("SysReq") },
        { 0xFFE5, ("CapsLock") },
        { 0xFF7F, ("NumLock") },
        { 0xFF14, ("ScrollLock") },
        { 0xFF55, ("PageUp") },
        { 0xFF56, ("PageDown") },
# 111 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.cpp"
        { 0, 0 }
};




static const TransKey g_rgQtToSymX[] =
{
        { Qt::Key_Escape, 0xFF1B },
        { Qt::Key_Tab, 0xFF09 },
        { Qt::Key_Backtab, 0xFE20 },
        { Qt::Key_Backspace, 0xFF08 },
        { Qt::Key_Return, 0xFF0D },
        { Qt::Key_Enter, 0xFF8D },
        { Qt::Key_Insert, 0xFF63 },
        { Qt::Key_Delete, 0xFFFF },
        { Qt::Key_Pause, 0xFF13 },



        { Qt::Key_Print, 0xFF61 },

        { Qt::Key_SysReq, 0xFF15 },
        { Qt::Key_Home, 0xFF50 },
        { Qt::Key_End, 0xFF57 },
        { Qt::Key_Left, 0xFF51 },
        { Qt::Key_Up, 0xFF52 },
        { Qt::Key_Right, 0xFF53 },
        { Qt::Key_Down, 0xFF54 },
        { Qt::Key_Prior, 0xFF55 },
        { Qt::Key_Next, 0xFF56 },




        { Qt::Key_CapsLock, 0xFFE5 },
        { Qt::Key_NumLock, 0xFF7F },
        { Qt::Key_ScrollLock, 0xFF14 },
        { Qt::Key_F1, 0xFFBE },
        { Qt::Key_F2, 0xFFBF },
        { Qt::Key_F3, 0xFFC0 },
        { Qt::Key_F4, 0xFFC1 },
        { Qt::Key_F5, 0xFFC2 },
        { Qt::Key_F6, 0xFFC3 },
        { Qt::Key_F7, 0xFFC4 },
        { Qt::Key_F8, 0xFFC5 },
        { Qt::Key_F9, 0xFFC6 },
        { Qt::Key_F10, 0xFFC7 },
        { Qt::Key_F11, 0xFFC8 },
        { Qt::Key_F12, 0xFFC9 },
        { Qt::Key_F13, 0xFFCA },
        { Qt::Key_F14, 0xFFCB },
        { Qt::Key_F15, 0xFFCC },
        { Qt::Key_F16, 0xFFCD },
        { Qt::Key_F17, 0xFFCE },
        { Qt::Key_F18, 0xFFCF },
        { Qt::Key_F19, 0xFFD0 },
        { Qt::Key_F20, 0xFFD1 },
        { Qt::Key_F21, 0xFFD2 },
        { Qt::Key_F22, 0xFFD3 },
        { Qt::Key_F23, 0xFFD4 },
        { Qt::Key_F24, 0xFFD5 },
        { Qt::Key_F25, 0xFFD6 },
        { Qt::Key_F26, 0xFFD7 },
        { Qt::Key_F27, 0xFFD8 },
        { Qt::Key_F28, 0xFFD9 },
        { Qt::Key_F29, 0xFFDA },
        { Qt::Key_F30, 0xFFDB },
        { Qt::Key_F31, 0xFFDC },
        { Qt::Key_F32, 0xFFDD },
        { Qt::Key_F33, 0xFFDE },
        { Qt::Key_F34, 0xFFDF },
        { Qt::Key_F35, 0xFFE0 },
        { Qt::Key_Super_L, 0xFFEB },
        { Qt::Key_Super_R, 0xFFEC },
        { Qt::Key_Menu, 0xFF67 },
        { Qt::Key_Hyper_L, 0xFFED },
        { Qt::Key_Hyper_R, 0xFFEE },
        { Qt::Key_Help, 0xFF6A },



        { '/', 0xFFAF },
        { '*', 0xFFAA },
        { '-', 0xFFAD },
        { '+', 0xFFAB },
        { Qt::Key_Return, 0xFF8D }





        ,
        { Qt::Key_Standby, 0x1008FF10 },
        { Qt::Key_VolumeDown, 0x1008FF11 },
        { Qt::Key_VolumeMute, 0x1008FF12 },
        { Qt::Key_VolumeUp, 0x1008FF13 },
        { Qt::Key_MediaPlay, 0x1008FF14 },
        { Qt::Key_MediaStop, 0x1008FF15 },
        { Qt::Key_MediaPrev, 0x1008FF16 },
        { Qt::Key_MediaNext, 0x1008FF17 },
        { Qt::Key_HomePage, 0x1008FF18 },
        { Qt::Key_LaunchMail, 0x1008FF19 },
        { Qt::Key_Search, 0x1008FF1B },
        { Qt::Key_MediaRecord, 0x1008FF1C },
        { Qt::Key_LaunchMedia, 0x1008FF32 },
        { Qt::Key_Launch1, 0x1008FF1D },
        { Qt::Key_Back, 0x1008FF26 },
        { Qt::Key_Forward, 0x1008FF27 },
        { Qt::Key_Stop, 0x1008FF28 },
        { Qt::Key_Refresh, 0x1008FF29 },
        { Qt::Key_Favorites, 0x1008FF30 },
        { Qt::Key_Launch0, 0x1008FF33 },
        { Qt::Key_OpenUrl, 0x1008FF38 },
        { Qt::Key_Launch2, 0x1008FF40 },
        { Qt::Key_Launch3, 0x1008FF41 },
        { Qt::Key_Launch4, 0x1008FF42 },
        { Qt::Key_Launch5, 0x1008FF43 },
        { Qt::Key_Launch6, 0x1008FF44 },
        { Qt::Key_Launch7, 0x1008FF45 },
        { Qt::Key_Launch8, 0x1008FF46 },
        { Qt::Key_Launch9, 0x1008FF47 },
        { Qt::Key_LaunchA, 0x1008FF48 },
        { Qt::Key_LaunchB, 0x1008FF49 },
        { Qt::Key_LaunchC, 0x1008FF4A },
        { Qt::Key_LaunchD, 0x1008FF4B },
        { Qt::Key_LaunchE, 0x1008FF4C },
        { Qt::Key_LaunchF, 0x1008FF4D },

};




static bool g_bInitializedMods, g_bInitializedVariations, g_bInitializedKKeyLabels;
static bool g_bMacLabels;
static uint g_modXNumLock, g_modXScrollLock;

bool initializeMods()
{
        XModifierKeymap* xmk = XGetModifierMapping( qt_xdisplay() );

        g_rgModInfo[3].modX = g_modXNumLock = g_modXScrollLock = 0;


        for( int i = 4; i < 8; i++ ) {
                uint mask = (1 << i);
                uint keySymX = XKeycodeToKeysym( qt_xdisplay(), xmk->modifiermap[xmk->max_keypermod * i], 0 );
                switch( keySymX ) {
                        case 0xFF7F: g_modXNumLock = mask; break;
                        case 0xFFEB:
                        case 0xFFEC: g_rgModInfo[3].modX = mask; break;
                        case 0xFFE7:
                        case 0xFFE8: if( !g_rgModInfo[3].modX ) g_rgModInfo[3].modX = mask; break;
                        case 0xFF14: g_modXScrollLock = mask; break;
                }
        }

        XFreeModifiermap( xmk );




        g_bInitializedMods = true;

        kdDebug(125) << "KKeyServer::initializeMods(): Win Mod = 0x" << QString::number(g_rgModInfo[3].modX, 16) << endl;
        return true;
}

static void initializeVariations()
{
        for( int i = 0; g_rgSymVariation[i].sym != 0; i++ )
                g_rgSymVariation[i].bActive = (XKeysymToKeycode( qt_xdisplay(), g_rgSymVariation[i].symVariation ) != 0);
        g_bInitializedVariations = true;
}

static void intializeKKeyLabels()
{
        KConfigGroupSaver cgs( KGlobal::config(), "Keyboard" );
        g_rgModInfo[0].sLabel = KGlobal::config()->readEntry( "Label Shift", i18n(g_rgModInfo[0].psName) );
        g_rgModInfo[1].sLabel = KGlobal::config()->readEntry( "Label Ctrl", i18n(g_rgModInfo[1].psName) );
        g_rgModInfo[2].sLabel = KGlobal::config()->readEntry( "Label Alt", i18n(g_rgModInfo[2].psName) );
        g_rgModInfo[3].sLabel = KGlobal::config()->readEntry( "Label Win", i18n(g_rgModInfo[3].psName) );
        g_bMacLabels = (g_rgModInfo[2].sLabel == "Command");
        g_bInitializedKKeyLabels = true;
}
# 350 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.cpp"
bool Sym::initQt( int keyQt )
{
        int symQt = keyQt & 0xffff;

        if( (keyQt & Qt::UNICODE_ACCEL) || symQt < 0x1000 ) {
                m_sym = QChar(symQt).lower().unicode();
                return true;
        }

        for( uint i = 0; i < sizeof(g_rgQtToSymX)/sizeof(TransKey); i++ ) {
                if( g_rgQtToSymX[i].keySymQt == symQt ) {
                        m_sym = g_rgQtToSymX[i].keySymX;
                        return true;
                }
        }

        m_sym = 0;
        if( symQt != Qt::Key_Shift && symQt != Qt::Key_Control && symQt != Qt::Key_Alt &&
            symQt != Qt::Key_Meta && symQt != Qt::Key_Direction_L && symQt != Qt::Key_Direction_R )
                kdDebug(125) << "Sym::initQt( " << QString::number(keyQt,16) << " ): failed to convert key." << endl;
        return false;
}

bool Sym::init( const QString& s )
{

        if( s.length() == 1 ) {
                m_sym = s[0].lower().unicode();
                return true;
        }


        for( int i = 0; g_rgSymNames[i].sym != 0; i++ ) {
                if( qstricmp( s.latin1(), g_rgSymNames[i].psName ) == 0 ) {
                        m_sym = g_rgSymNames[i].sym;
                        return true;
                }
        }


        m_sym = XStringToKeysym( s.latin1() );
        if( !m_sym ) {
                m_sym = XStringToKeysym( s.lower().latin1() );
                if( !m_sym ) {
                        QString s2 = s;
                        s2[0] = s2[0].upper();
                        m_sym = XStringToKeysym( s2.latin1() );
                }
        }

        return m_sym != 0;
}

int Sym::qt() const
{
        if( m_sym < 0x1000 ) {
                if( m_sym >= 'a' && m_sym <= 'z' )
                        return QChar(m_sym).upper();
                return m_sym;
        }
        if( m_sym < 0x3000 )
                return m_sym | Qt::UNICODE_ACCEL;

        for( uint i = 0; i < sizeof(g_rgQtToSymX)/sizeof(TransKey); i++ )
                if( g_rgQtToSymX[i].keySymX == m_sym )
                        return g_rgQtToSymX[i].keySymQt;
        return Qt::Key_unknown;
}

QString Sym::toString( bool bUserSpace ) const
{
        if( m_sym == 0 )
                return QString::null;


        else if( m_sym < 0x3000 ) {
                QChar c = QChar(m_sym).upper();


                if( (c.latin1() && c.isLetterOrNumber())
                    || (bUserSpace && !c.isSpace()) )
                                return c;
        }


        for( int i = 0; g_rgSymNames[i].sym != 0; i++ ) {
                if( m_sym == g_rgSymNames[i].sym )
                        return bUserSpace ? i18n(g_rgSymNames[i].psName) : QString(g_rgSymNames[i].psName);
        }


        QString s = XKeysymToString( m_sym );
        capitalizeKeyname( s );
        return bUserSpace ? i18n("QAccel", s.latin1()) : s;
}

QString Sym::toStringInternal() const { return toString( false ); }
QString Sym::toString() const { return toString( true ); }

uint Sym::getModsRequired() const
{
        uint mod = 0;


        if( m_sym == 0xFF15 ) return KKey::ALT;
        if( m_sym == 0xFF6B ) return KKey::CTRL;

        if( m_sym < 0x3000 ) {
                QChar c(m_sym);
                if( c.isLetter() && c.lower() != c.upper() && m_sym == c.upper().unicode() )
                        return KKey::SHIFT;
        }

        uchar code = XKeysymToKeycode( qt_xdisplay(), m_sym );
        if( code ) {



                if( m_sym == XKeycodeToKeysym( qt_xdisplay(), code, 0 ) )
                        ;
                else if( m_sym == XKeycodeToKeysym( qt_xdisplay(), code, 1 ) )
                        mod = KKey::SHIFT;
                else if( m_sym == XKeycodeToKeysym( qt_xdisplay(), code, 2 ) )
                        mod = KKeyServer::MODE_SWITCH;
                else if( m_sym == XKeycodeToKeysym( qt_xdisplay(), code, 3 ) )
                        mod = KKey::SHIFT | KKeyServer::MODE_SWITCH;
        }

        return mod;
}

uint Sym::getSymVariation() const
{
        if( !g_bInitializedVariations )
                initializeVariations();

        for( int i = 0; g_rgSymVariation[i].sym != 0; i++ )
                if( g_rgSymVariation[i].sym == m_sym && g_rgSymVariation[i].bActive )
                        return g_rgSymVariation[i].symVariation;
        return 0;
}

void Sym::capitalizeKeyname( QString& s )
{
        s[0] = s[0].upper();
        int len = s.length();
        if( s.endsWith( "left" ) ) s[len-4] = 'L';
        else if( s.endsWith( "right" ) ) s[len-5] = 'R';
        else if( s == "Sysreq" ) s[len-3] = 'R';
}





uint modX( KKey::ModFlag mod )
{
        if( mod == KKey::WIN && !g_bInitializedMods )
                initializeMods();

        for( uint i = 0; i < KKey::MOD_FLAG_COUNT; i++ ) {
                if( g_rgModInfo[i].mod == mod )
                        return g_rgModInfo[i].modX;
        }
        return 0;
}

bool keyboardHasWinKey() { if( !g_bInitializedMods ) { initializeMods(); } return g_rgModInfo[3].modX != 0; }
uint modXShift() { return (1<<0); }
uint modXLock() { return (1<<1); }
uint modXCtrl() { return (1<<2); }
uint modXAlt() { return (1<<3); }
uint modXNumLock() { if( !g_bInitializedMods ) { initializeMods(); } return g_modXNumLock; }
uint modXWin() { if( !g_bInitializedMods ) { initializeMods(); } return g_rgModInfo[3].modX; }
uint modXScrollLock() { if( !g_bInitializedMods ) { initializeMods(); } return g_modXScrollLock; }

uint accelModMaskX()
{
        if( !g_bInitializedMods )
                initializeMods();
        return (1<<0) | (1<<2) | (1<<3) | g_rgModInfo[3].modX;
}

bool keyQtToSym( int keyQt, uint& keySym )
{
        Sym sym;
        if( sym.initQt( keyQt ) ) {
                keySym = sym.m_sym;
                return true;
        } else
                return false;
}

bool keyQtToMod( int keyQt, uint& mod )
{
        mod = 0;

        if( keyQt & Qt::SHIFT ) mod |= KKey::SHIFT;
        if( keyQt & Qt::CTRL ) mod |= KKey::CTRL;
        if( keyQt & Qt::ALT ) mod |= KKey::ALT;
        if( keyQt & (Qt::ALT<<1) ) mod |= KKey::WIN;

        return true;
}

bool symToKeyQt( uint keySym, int& keyQt )
{
        Sym sym( keySym );
        keyQt = sym.qt();
        return (keyQt != Qt::Key_unknown);
}

bool modToModQt( uint mod, int& modQt )
{
        modQt = 0;
        for( int i = 0; i < KKey::MOD_FLAG_COUNT; i++ ) {
                if( mod & g_rgModInfo[i].mod ) {
                        if( !g_rgModInfo[i].modQt ) {
                                modQt = 0;
                                return false;
                        }
                        modQt |= g_rgModInfo[i].modQt;
                }
        }
        return true;
}

bool modToModX( uint mod, uint& modX )
{
        if( !g_bInitializedMods )
                initializeMods();

        modX = 0;
        for( int i = 0; i < KKey::MOD_FLAG_COUNT; i++ ) {
                if( mod & g_rgModInfo[i].mod ) {
                        if( !g_rgModInfo[i].modX ) {
                                kdDebug(125) << "Invalid modifier flag." << endl;
                                modX = 0;
                                return false;
                        }
                        modX |= g_rgModInfo[i].modX;
                }
        }

        if( mod & 0x2000 )
          modX |= 0x2000;
        return true;
}

bool modXToModQt( uint modX, int& modQt )
{
        if( !g_bInitializedMods )
                initializeMods();

        modQt = 0;
        for( int i = 0; i < KKey::MOD_FLAG_COUNT; i++ ) {
                if( modX & g_rgModInfo[i].modX ) {
                        if( !g_rgModInfo[i].modQt ) {
                                modQt = 0;
                                return false;
                        }
                        modQt |= g_rgModInfo[i].modQt;
                }
        }
        return true;
}

bool modXToMod( uint modX, uint& mod )
{
        if( !g_bInitializedMods )
                initializeMods();

        mod = 0;
        for( int i = 0; i < KKey::MOD_FLAG_COUNT; i++ ) {
                if( modX & g_rgModInfo[i].modX )
                        mod |= g_rgModInfo[i].mod;
        }
        return true;
}

bool codeXToSym( uchar codeX, uint modX, uint& sym )
{
        XKeyPressedEvent event;

        event.type = KeyPress;
        event.display = qt_xdisplay();
        event.state = modX;
        event.keycode = codeX;

        XLookupString( &event, 0, 0, (KeySym*) &sym, 0 );
        return true;
}

static QString modToString( uint mod, bool bUserSpace )
{
        if( bUserSpace && !g_bInitializedKKeyLabels )
                intializeKKeyLabels();

        QString s;
        for( int i = KKey::MOD_FLAG_COUNT-1; i >= 0; i-- ) {
                if( mod & g_rgModInfo[i].mod ) {
                        if( !s.isEmpty() )
                                s += '+';
                        s += (bUserSpace)
                                  ? g_rgModInfo[i].sLabel
                                  : QString(g_rgModInfo[i].psName);
                }
        }
        return s;
}

QString modToStringInternal( uint mod ) { return modToString( mod, false ); }
QString modToStringUser( uint mod ) { return modToString( mod, true ); }
# 780 "/coolo/prod/kdelibs/kdecore/kkeyserver_x11.cpp"
bool Key::init( const KKey& key, bool bQt )
{
        if( bQt ) {
                m_code = CODE_FOR_QT;
                m_sym = key.keyCodeQt();
        } else {
                KKeyNative keyNative( key );
                *this = keyNative;
        }
        return true;
}

KKey Key::key() const
{
        if( m_code == CODE_FOR_QT )
                return KKey( keyCodeQt() );
        else {
                uint mod;
                modXToMod( m_mod, mod );
                return KKey( m_sym, mod );
        }
}

Key& Key::operator =( const KKeyNative& key )
{
        m_code = key.code(); m_mod = key.mod(); m_sym = key.sym();
        return *this;
}

int Key::compare( const Key& b ) const
{
        if( m_code == CODE_FOR_QT )
                return m_sym - b.m_sym;
        if( m_sym != b.m_sym ) return m_sym - b.m_sym;
        if( m_mod != b.m_mod ) return m_mod - b.m_mod;
        return m_code - b.m_code;
}






void Variations::init( const KKey& key, bool bQt )
{
        if( key.isNull() ) {
                m_nVariations = 0;
                return;
        }

        m_nVariations = 1;
        m_rgkey[0] = KKeyNative(key);
        uint symVar = Sym(key.sym()).getSymVariation();
        if( symVar ) {
                uint modReq = Sym(m_rgkey[0].sym()).getModsRequired();
                uint modReqVar = Sym(symVar).getModsRequired();


                if( (key.modFlags() & modReq) == (key.modFlags() & modReqVar) ) {
                        m_rgkey[1] = KKeyNative(KKey(symVar, key.modFlags()));
                        m_nVariations = 2;
                }
        }

        if( bQt ) {
                uint nVariations = 0;
                for( uint i = 0; i < m_nVariations; i++ ) {
                        int keyQt = KKeyNative( m_rgkey[i].code(), m_rgkey[i].mod(), m_rgkey[i].sym() ).keyCodeQt();
                        if( keyQt )
                                m_rgkey[nVariations++].setKeycodeQt( keyQt );
                }
                m_nVariations = nVariations;



                for( uint i = 1; i < m_nVariations; i++ ) {
                        for( uint j = 0; j < i; j++ ) {

                                if( m_rgkey[i].keyCodeQt() == m_rgkey[j].keyCodeQt() ) {
                                        for( uint k = i; k < m_nVariations - 1; k++ )
                                                m_rgkey[k].setKeycodeQt( m_rgkey[k+1].keyCodeQt() );
                                        m_nVariations--;
                                        i--;
                                        break;
                                }
                        }
                }
        }
}

}







void KKey::simplify()
{
        if( m_sym == 0xFF15 ) {
                m_sym = 0xFF61;
                m_mod |= ALT;
        } else if( m_sym == 0xFE20 ) {
                m_sym = 0xFF09;
                m_mod |= SHIFT;
        } else {

                m_sym = KKeyNative(*this).sym();
        }


        if( m_sym < 0x3000 && QChar(m_sym).isLetter() )
                m_sym = QChar(m_sym).lower().unicode();



        m_mod &= ~KKeyServer::Sym(m_sym).getModsRequired();
}
# 32 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaccelaction.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kaccelaction.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kaccelaction.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"




# 1 "/coolo/prod/qt-copy/include/qvaluevector.h" 1
# 37 "/coolo/prod/qt-copy/include/qvaluevector.h"
# 49 "/coolo/prod/qt-copy/include/qvaluevector.h"
template <class T>
class QValueVectorPrivate : public QShared
{
public:
    typedef T value_type;
    typedef T* pointer;

    QValueVectorPrivate()
        : start( 0 ), finish( 0 ), end( 0 )
    {
    }

    QValueVectorPrivate( const QValueVectorPrivate<T>& x );
    QValueVectorPrivate( size_t size );

    void derefAndDelete()
    {
        if ( deref() )
            delete this;
    }





    ~QValueVectorPrivate()
    {
        delete[] start;
    }

    size_t size() const
    {
        return finish - start;
    }

    bool empty() const
    {
        return start == finish;
    }

    size_t capacity() const
    {
        return end - start;
    }

    void insert( pointer pos, const T& x );
    void insert( pointer pos, size_t n, const T& x );
    void reserve( size_t n );

    void clear()
    {
        delete[] start;
        start = 0;
        finish = 0;
        end = 0;
    }


    pointer start;
    pointer finish;
    pointer end;

private:
    pointer growAndCopy( size_t n, pointer s, pointer f );

    QValueVectorPrivate<T>& operator=( const QValueVectorPrivate<T>& x );

};

template <class T>
 QValueVectorPrivate<T>::QValueVectorPrivate( const QValueVectorPrivate<T>& x )
    : QShared()
{
    int i = x.size();
    if ( i > 0 ) {
        start = new T[ i ];
        finish = start + i;
        end = start + i;



        qCopy( x.start, x.finish, start );

    } else {
        start = 0;
        finish = 0;
        end = 0;
    }
}

template <class T>
 QValueVectorPrivate<T>::QValueVectorPrivate( size_t size )
{
    if ( size > 0 ) {
        start = new T[size];
        finish = start + size;
        end = start + size;
    } else {
        start = 0;
        finish = 0;
        end = 0;
    }
}

template <class T>
 void QValueVectorPrivate<T>::insert( pointer pos, const T& x )
{
    const size_t lastSize = size();
    const size_t n = lastSize !=0 ? 2*lastSize : 1;
    const size_t offset = pos - start;
    pointer newStart = new T[n];
    pointer newFinish = newStart + offset;
    qCopy( start, pos, newStart );
    *newFinish = x;
    qCopy( pos, finish, ++newFinish );
    delete[] start;
    start = newStart;
    finish = newStart + lastSize + 1;
    end = newStart + n;
}

template <class T>
 void QValueVectorPrivate<T>::insert( pointer pos, size_t n, const T& x )
{
    if ( size_t( end - finish ) >= n ) {

        const size_t elems_after = finish - pos;
        pointer old_finish = finish;
        if ( elems_after > n ) {
            qCopy( finish - n, finish, finish );
            finish += n;
            qCopyBackward( pos, old_finish - n, old_finish );
            qFill( pos, pos + n, x );
        } else {
            pointer filler = finish;
            size_t i = n - elems_after;
            for ( ; i > 0; --i, ++filler )
                *filler = x;
            finish += n - elems_after;
            qCopy( pos, old_finish, finish );
            finish += elems_after;
            qFill( pos, old_finish, x );
        }
    } else {

        const size_t lastSize = size();
        const size_t len = lastSize + ((n) < (lastSize) ? (lastSize) : (n));
        pointer newStart = new T[len];
        pointer newFinish = qCopy( start, pos, newStart );

        size_t i = n;
        for ( ; i > 0; --i, ++newFinish )
            *newFinish = x;
        newFinish = qCopy( pos, finish, newFinish );
        delete[] start;
        start = newStart;
        finish = newFinish;
        end = newStart + len;
    }
}

template <class T>
 void QValueVectorPrivate<T>::reserve( size_t n )
{
    const size_t lastSize = size();
    pointer tmp = growAndCopy( n, start, finish );
    start = tmp;
    finish = tmp + lastSize;
    end = start + n;
}

template <class T>
 typename QValueVectorPrivate<T>::pointer QValueVectorPrivate<T>::growAndCopy( size_t n, pointer s, pointer f )
{
    pointer newStart = new T[n];
    qCopy( s, f, newStart );
    delete[] start;
    return newStart;
}

template <class T> class QDeepCopy;

template <class T>
class QValueVector
{
public:
    typedef T value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef size_t size_type;



    typedef int difference_type;


    QValueVector()
    {
        sh = new QValueVectorPrivate<T>;
    }

    QValueVector( const QValueVector<T>& v )
    {
        sh = v.sh;
        sh->ref();
    }

    QValueVector( size_type n, const T& val = T() );
# 276 "/coolo/prod/qt-copy/include/qvaluevector.h"
    ~QValueVector()
    {
        sh->derefAndDelete();
    }

    QValueVector<T>& operator= ( const QValueVector<T>& v )
    {
        v.sh->ref();
        sh->derefAndDelete();
        sh = v.sh;
        return *this;
    }
# 299 "/coolo/prod/qt-copy/include/qvaluevector.h"
    size_type size() const { return sh->size(); }

    bool empty() const { return sh->empty(); }

    size_type capacity() const
    {
        return size_type( sh->capacity() );
    }

    iterator begin()
    {
        detach();
        return sh->start;
    }

    const_iterator begin() const
    {
        return sh->start;
    }

    const_iterator constBegin() const
    {
        return sh->start;
    }

    iterator end()
    {
        detach();
        return sh->finish;
    }

    const_iterator end() const
    {
        return sh->finish;
    }

    const_iterator constEnd() const
    {
        return sh->finish;
    }

    reference at( size_type i, bool* ok = 0 )
    {
        detach();
        if ( ok )
            *ok = ( i < size() );
        return *( begin() + i );
    }

    const_reference at( size_type i, bool* ok = 0 ) const
    {
        if ( ok )
            *ok = ( i < size() );
        return *( begin() + i );
    }

    reference operator[]( size_type i )
    {
        detach();
        return *( begin() + i );
    }

    const_reference operator[]( size_type i ) const
    {
        return *( begin() + i );
    }

    reference front()
    {
        ((!empty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!empty()","/coolo/prod/qt-copy/include/qvaluevector.h",368));
        detach();
        return *begin();
    }

    const_reference front() const
    {
        ((!empty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!empty()","/coolo/prod/qt-copy/include/qvaluevector.h",375));
        return *begin();
    }

    reference back()
    {
        ((!empty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!empty()","/coolo/prod/qt-copy/include/qvaluevector.h",381));
        detach();
        return *( end() - 1 );
    }

    const_reference back() const
    {
        ((!empty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!empty()","/coolo/prod/qt-copy/include/qvaluevector.h",388));
        return *( end() - 1 );
    }

    void push_back( const T& x )
    {
        detach();
        if ( sh->finish == sh->end ) {
            sh->reserve( size()+size()/2+1 );
        }
        *sh->finish = x;
        ++sh->finish;
    }

    void pop_back()
    {
        detach();
        if ( empty() )
            return;
        --sh->finish;
    }

    iterator insert( iterator pos, const T& x );
    iterator insert( iterator pos, size_type n, const T& x );

    void reserve( size_type n )
    {
        if ( capacity() < n ) {
            detach();
            sh->reserve( n );
        }
    }

    void resize( size_type n, const T& val = T() )
    {
        if ( n < size() )
            erase( begin() + n, end() );
        else
            insert( end(), n - size(), val );
    }

    void clear()
    {
        detach();
        sh->clear();
    }

    iterator erase( iterator pos )
    {
        detach();
        if ( pos + 1 != end() )
            qCopy( pos + 1, sh->finish, pos );
        --sh->finish;
        return pos;
    }

    iterator erase( iterator first, iterator last )
    {
        detach();
        qCopy( last, sh->finish, first );
        sh->finish = sh->finish - ( last - first );
        return first;
    }


    bool operator==( const QValueVector<T>& x )
    {
        return size()==x.size() ? qEqual( constBegin(), constEnd(), x.begin()) : FALSE;
    }

    bool operator==( const QValueVector<T>& x ) const
    {
        return size()==x.size() ? qEqual( begin(), end(), x.begin() ) : FALSE;
    }

    typedef T ValueType;
    typedef ValueType *Iterator;
    typedef const ValueType *ConstIterator;

    size_type count() const { return size(); }
    bool isEmpty() const { return empty(); }

    reference first() { return front(); }
    const_reference first() const { return front(); }
    reference last() { return back(); }
    const_reference last() const { return back(); }
    void append( const T& x ) { push_back( x ); }

protected:
    void detach()
    {
        if ( sh->count > 1 ) { detachInternal(); }
    }
    void detachInternal();
    QValueVectorPrivate<T>* sh;

private:
    friend class QDeepCopy< QValueVector<T> >;
};

template <class T>
 QValueVector<T>::QValueVector( size_type n, const T& val )
{
    sh = new QValueVectorPrivate<T>( n );
    qFill( begin(), end(), val );
}

template <class T>
 void QValueVector<T>::detachInternal()
{
    sh->deref();
    sh = new QValueVectorPrivate<T>( *sh );
}

template <class T>
 typename QValueVector<T>::iterator QValueVector<T>::insert( iterator pos, const T& x )
{
    size_type offset = pos - sh->start;
    detach();
    if ( pos == end() ) {
        if ( sh->finish == sh->end )
            push_back( x );
        else {
            *sh->finish = x;
            ++sh->finish;
        }
    } else {
        if ( sh->finish == sh->end ) {
            sh->insert( pos, x );
        } else {
            *sh->finish = *(sh->finish - 1);
            ++sh->finish;
            qCopyBackward( pos, sh->finish - 2, sh->finish - 1 );
            *pos = x;
        }
    }
    return begin() + offset;
}

template <class T>
 typename QValueVector<T>::iterator QValueVector<T>::insert( iterator pos, size_type n, const T& x )
{
    if ( n != 0 ) {
        size_type offset = pos - sh->start;
        detach();
        pos = begin() + offset;
        sh->insert( pos, n, x );
    }
    return pos;
}



template<class T>
 QDataStream& operator>>( QDataStream& s, QValueVector<T>& v )
{
    v.clear();
    Q_UINT32 c;
    s >> c;
    v.resize( c );
    for( Q_UINT32 i = 0; i < c; ++i )
    {
        T t;
        s >> t;
        v[i] = t;
    }
    return s;
}

template<class T>
 QDataStream& operator<<( QDataStream& s, const QValueVector<T>& v )
{
    s << (Q_UINT32)v.size();


    const T* it = v.begin();
    for( ; it != v.end(); ++it )
        s << *it;
    return s;
}


# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 572 "/coolo/prod/qt-copy/include/qvaluevector.h" 2
# 27 "/coolo/prod/kdelibs/kdecore/kaccelaction.h" 2



class KAccelBase;

class QObject;
class KConfig;
class KConfigBase;
# 72 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
class KAccelAction
{
 public:




        KAccelAction();




        KAccelAction( const KAccelAction& );
# 100 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        KAccelAction( const QString& sName, const QString& sLabel, const QString& sWhatsThis,
                        const KShortcut& cutDef3, const KShortcut& cutDef4,
                        const QObject* pObjSlot, const char* psMethodSlot,
                        bool bConfigurable, bool bEnabled );
        ~KAccelAction();




        void clear();
# 126 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        bool init( const QString& sName, const QString& sLabel, const QString& sWhatsThis,
                        const KShortcut& cutDef3, const KShortcut& cutDef4,
                        const QObject* pObjSlot, const char* psMethodSlot,
                        bool bConfigurable, bool bEnabled );




        KAccelAction& operator=( const KAccelAction& );






        const QString& name() const { return m_sName; }






        const QString& label() const { return m_sLabel; }






        const QString& whatsThis() const { return m_sWhatsThis; }






        const KShortcut& shortcut() const { return m_cut; }
# 171 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        const KShortcut& shortcutDefault() const;
# 181 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        const KShortcut& shortcutDefault3() const { return m_cutDefault3; }
# 191 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        const KShortcut& shortcutDefault4() const { return m_cutDefault4; }





        const QObject* objSlotPtr() const { return m_pObjSlot; }





        const char* methodSlotPtr() const { return m_psMethodSlot; }





        bool isConfigurable() const { return m_bConfigurable; }





        bool isEnabled() const { return m_bEnabled; }





        void setName( const QString& name );





        void setLabel( const QString& label );





        void setWhatsThis( const QString& whatsThis );






        bool setShortcut( const KShortcut& rgCuts );






        void setSlot( const QObject* pObjSlot, const char* psMethodSlot );





        void setConfigurable( bool configurable );





        void setEnabled( bool enable );





        int getID() const { return m_nIDAccel; }
# 274 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        void setID( int n ) { m_nIDAccel = n; }





        bool isConnected() const;
# 289 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        bool setKeySequence( uint i, const KKeySequence &keySeq );






        void clearShortcut();







        bool contains( const KKeySequence &keySeq );






        QString toString() const;




        QString toStringInternal() const;





        static bool useFourModifierKeys();






        static void useFourModifierKeys( bool use );

 protected:
        QString m_sName,
                m_sLabel,
                m_sWhatsThis;
        KShortcut m_cut;
        KShortcut m_cutDefault3, m_cutDefault4;
        const QObject* m_pObjSlot;
        const char* m_psMethodSlot;
        bool m_bConfigurable,
             m_bEnabled;
        int m_nIDAccel;
        uint m_nConnections;

        void incConnections();
        void decConnections();

 private:
        static int g_bUseFourModifierKeys;
        class KAccelActionPrivate* d;

        friend class KAccelActions;
        friend class KAccelBase;
};
# 366 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
class KAccelActions
{
 public:



        KAccelActions();




        KAccelActions( const KAccelActions& );
        virtual ~KAccelActions();




        void clear();







        bool init( const KAccelActions &actions );
# 400 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        bool init( KConfigBase& config, const QString& sGroup );







        void updateShortcuts( KAccelActions &shortcuts );






        int actionIndex( const QString& sAction ) const;
# 424 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        KAccelAction* actionPtr( uint index );
# 433 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        const KAccelAction* actionPtr( uint index ) const;







        KAccelAction* actionPtr( const QString& sAction );







        const KAccelAction* actionPtr( const QString& sAction ) const;







        KAccelAction* actionPtr( KKeySequence cut );
# 467 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        KAccelAction& operator []( uint index );
# 477 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        const KAccelAction& operator []( uint index ) const;
# 494 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        KAccelAction* insert( const QString& sAction, const QString& sLabel, const QString& sWhatsThis,
                        const KShortcut& rgCutDefaults3, const KShortcut& rgCutDefaults4,
                        const QObject* pObjSlot = 0, const char* psMethodSlot = 0,
                        bool bConfigurable = true, bool bEnabled = true );







        KAccelAction* insert( const QString& sName, const QString& sLabel );






        bool remove( const QString& sAction );
# 521 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        bool readActions( const QString& sConfigGroup = "Shortcuts", KConfigBase* pConfig = 0 );
# 532 "/coolo/prod/kdelibs/kdecore/kaccelaction.h"
        bool writeActions( const QString& sConfigGroup = "Shortcuts", KConfigBase* pConfig = 0,
                        bool bWriteAll = false, bool bGlobal = false ) const;




        void emitKeycodeChanged();





        uint count() const;

 protected:
        KAccelBase* m_pKAccelBase;
        KAccelAction** m_prgActions;
        uint m_nSizeAllocated, m_nSize;

        void resize( uint );
        void insertPtr( KAccelAction* );

 private:
        class KAccelActionsPrivate* d;

        KAccelActions( KAccelBase* );
        void initPrivate( KAccelBase* );
        KAccelActions& operator =( KAccelActions& );

        friend class KAccelBase;
};
# 24 "/coolo/prod/kdelibs/kdecore/kaccelaction.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaccelbase.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kaccelbase.h"
# 32 "/coolo/prod/kdelibs/kdecore/kaccelbase.h"
class QPopupMenu;
class QWidget;
# 122 "/coolo/prod/kdelibs/kdecore/kaccelbase.h"
class KAccelBase
{
 public:
        enum Init { QT_KEYS = 0x00, NATIVE_KEYS = 0x01 };
        enum Signal { KEYCODE_CHANGED };

        KAccelBase( int fInitCode );
        virtual ~KAccelBase();

        uint actionCount() const;
        KAccelActions& actions();
        bool isEnabled() const;

        KAccelAction* actionPtr( const QString& sAction );
        const KAccelAction* actionPtr( const QString& sAction ) const;
        KAccelAction* actionPtr( const KKey& key );
        KAccelAction* actionPtr( const KKeyServer::Key& key );

        const QString& configGroup() const { return m_sConfigGroup; }
        void setConfigGroup( const QString& group );
        void setConfigGlobal( bool global );
        virtual void setEnabled( bool bEnabled ) = 0;
        bool getAutoUpdate() { return m_bAutoUpdate; }

        bool setAutoUpdate( bool bAuto );




        KAccelAction* insert( const QString& sName, const QString& sDesc );
        KAccelAction* insert(
                         const QString& sAction, const QString& sDesc, const QString& sHelp,
                         const KShortcut& rgCutDefaults3, const KShortcut& rgCutDefaults4,
                         const QObject* pObjSlot, const char* psMethodSlot,
                         bool bConfigurable = true, bool bEnabled = true );
        bool remove( const QString& sAction );
        bool setActionSlot( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot );

        bool updateConnections();

        bool setShortcut( const QString& sAction, const KShortcut& cut );


        bool setActionEnabled( const QString& sAction, bool bEnable );
# 175 "/coolo/prod/kdelibs/kdecore/kaccelbase.h"
        void readSettings( KConfigBase* pConfig = 0 );






        void writeSettings( KConfigBase* pConfig = 0 ) const;

        QPopupMenu* createPopupMenu( QWidget* pParent, const KKeySequence& );


 protected:
        void slotRemoveAction( KAccelAction* );

        struct X;
        void createKeyList( QValueVector<struct X>& rgKeys );
        bool insertConnection( KAccelAction* );
        bool removeConnection( KAccelAction* );

        virtual bool emitSignal( Signal ) = 0;
        virtual bool connectKey( KAccelAction&, const KKeyServer::Key& ) = 0;
        virtual bool connectKey( const KKeyServer::Key& ) = 0;
        virtual bool disconnectKey( KAccelAction&, const KKeyServer::Key& ) = 0;
        virtual bool disconnectKey( const KKeyServer::Key& ) = 0;

 protected:
        struct ActionInfo
        {
                KAccelAction* pAction;
                uint iSeq, iVariation;


                ActionInfo() { pAction = 0; iSeq = 0xffff; iVariation = 0xffff; }
                ActionInfo( KAccelAction* _pAction, uint _iSeq, uint _iVariation )
                        { pAction = _pAction; iSeq = _iSeq; iVariation = _iVariation; }
        };
        typedef QMap<KKeyServer::Key, ActionInfo> KKeyToActionMap;

        KAccelActions m_rgActions;
        KKeyToActionMap m_mapKeyToAction;
        QValueList<KAccelAction*> m_rgActionsNonUnique;
        bool m_bNativeKeys;
        bool m_bEnabled;
        bool m_bConfigIsGlobal;
        QString m_sConfigGroup;
        bool m_bAutoUpdate;
        KAccelAction* mtemp_pActionRemoving;

 private:
        KAccelBase& operator =( const KAccelBase& );

        friend class KAccelActions;
};
# 25 "/coolo/prod/kdelibs/kdecore/kaccelaction.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qkeycode.h" 1
# 39 "/coolo/prod/qt-copy/include/qkeycode.h"
# 27 "/coolo/prod/kdelibs/kdecore/kaccelaction.cpp" 2







# 1 "/coolo/prod/kdelibs/kdecore/kshortcutlist.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kshortcutlist.h"

# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 24 "/coolo/prod/kdelibs/kdecore/kshortcutlist.h" 2


class QVariant;
class KConfigBase;
class KInstance;
class KKeySequence;
class KShortcut;
# 47 "/coolo/prod/kdelibs/kdecore/kshortcutlist.h"
class KShortcutList
{
 public:



        KShortcutList();
        virtual ~KShortcutList();





        virtual uint count() const = 0;






        virtual QString name( uint index ) const = 0;






        virtual QString label( uint index ) const = 0;






        virtual QString whatsThis( uint index ) const = 0;







        virtual const KShortcut& shortcut( uint index ) const = 0;







        virtual const KShortcut& shortcutDefault( uint index ) const = 0;






        virtual bool isConfigurable( uint index ) const = 0;






        virtual bool setShortcut( uint index, const KShortcut &shortcut ) = 0;







        virtual bool isGlobal( uint index ) const;






        virtual int index( const QString& sName ) const;






        virtual int index( const KKeySequence& keySeq ) const;





        virtual const KInstance* instance() const;


        enum Other { };

        virtual QVariant getOther( Other, uint index ) const = 0;

        virtual bool setOther( Other, uint index, QVariant ) = 0;





        virtual bool save() const = 0;
# 161 "/coolo/prod/kdelibs/kdecore/kshortcutlist.h"
        virtual bool readSettings( const QString& sConfigGroup = QString::null, KConfigBase* pConfig = 0 );
# 172 "/coolo/prod/kdelibs/kdecore/kshortcutlist.h"
        virtual bool writeSettings( const QString& sConfigGroup = QString::null, KConfigBase* pConfig = 0,
                        bool bWriteAll = false, bool bGlobal = false ) const;

 protected:

        virtual void virtual_hook( int id, void* data );
 private:
        class KShortcutListPrivate* d;
};





class KAccel;
class KAccelActions;
class KGlobalAccel;





class KAccelShortcutList : public KShortcutList
{
 public:




        KAccelShortcutList( KAccel* accel );






        KAccelShortcutList( KGlobalAccel* accel );
# 218 "/coolo/prod/kdelibs/kdecore/kshortcutlist.h"
        KAccelShortcutList( KAccelActions &actions, bool bGlobal );
        virtual ~KAccelShortcutList();

        virtual uint count() const;
        virtual QString name( uint index ) const;
        virtual QString label( uint index ) const;
        virtual QString whatsThis( uint index ) const;
        virtual const KShortcut& shortcut( uint index ) const;
        virtual const KShortcut& shortcutDefault( uint index ) const;
        virtual bool isConfigurable( uint index ) const;
        virtual bool setShortcut( uint index , const KShortcut& shortcut );
        virtual bool isGlobal( uint index ) const;


        virtual QVariant getOther( Other, uint index ) const;

        virtual bool setOther( Other, uint index, QVariant );

        virtual bool save() const;

 protected:
        KAccelActions& m_actions;
        bool m_bGlobal;

 protected:
        virtual void virtual_hook( int id, void* data );
 private:
        class KAccelShortcutListPrivate* d;
};

namespace KStdAccel {
# 257 "/coolo/prod/kdelibs/kdecore/kshortcutlist.h"
class ShortcutList : public KShortcutList
{
 public:



        ShortcutList();
        virtual ~ShortcutList();

        virtual uint count() const;
        virtual QString name( uint index ) const;
        virtual QString label( uint index ) const;
        virtual QString whatsThis( uint index ) const;
        virtual const KShortcut& shortcut( uint index ) const;
        virtual const KShortcut& shortcutDefault( uint index ) const;
        virtual bool isConfigurable( uint index ) const;
        virtual bool setShortcut( uint index , const KShortcut& shortcut );


        virtual QVariant getOther( Other, uint index ) const;

        virtual bool setOther( Other, uint index, QVariant );

        virtual bool save() const;

 protected:
        virtual void virtual_hook( int id, void* data );
 private:
        class ShortcutListPrivate* d;
};
}
# 35 "/coolo/prod/kdelibs/kdecore/kaccelaction.cpp" 2





class KAccelActionPrivate
{
 public:
        uint m_nConnections;
};

KAccelAction::KAccelAction()
{

        d = new KAccelActionPrivate;
        m_pObjSlot = 0;
        m_psMethodSlot = 0;
        m_bConfigurable = true;
        m_bEnabled = true;
        m_nIDAccel = 0;
        d->m_nConnections = 0;
}

KAccelAction::KAccelAction( const KAccelAction& action )
{

        d = new KAccelActionPrivate;
        *this = action;
}

KAccelAction::KAccelAction( const QString& sName, const QString& sLabel, const QString& sWhatsThis,
                        const KShortcut& cutDef3, const KShortcut& cutDef4,
                        const QObject* pObjSlot, const char* psMethodSlot,
                        bool bConfigurable, bool bEnabled )
{

        d = new KAccelActionPrivate;
        init( sName, sLabel, sWhatsThis,
                cutDef3, cutDef4,
                pObjSlot, psMethodSlot,
                bConfigurable, bEnabled );
}

KAccelAction::~KAccelAction()
{

        delete d;
}

void KAccelAction::clear()
{
        m_cut.clear();
        m_pObjSlot = 0;
        m_psMethodSlot = 0;
        m_bConfigurable = true;
        m_bEnabled = true;
        m_nIDAccel = 0;
        d->m_nConnections = 0;
}

bool KAccelAction::init( const QString& sName, const QString& sLabel, const QString& sWhatsThis,
                        const KShortcut& rgCutDefaults3, const KShortcut& rgCutDefaults4,
                        const QObject* pObjSlot, const char* psMethodSlot,
                        bool bConfigurable, bool bEnabled )
{
        m_sName = sName;
        m_sLabel = sLabel;
        m_sWhatsThis = sWhatsThis;
        m_cutDefault3 = rgCutDefaults3;
        m_cutDefault4 = rgCutDefaults4;
        m_pObjSlot = pObjSlot;
        m_psMethodSlot = psMethodSlot;
        m_bConfigurable = bConfigurable;
        m_bEnabled = bEnabled;
        m_nIDAccel = 0;
        m_cut = shortcutDefault();
        d->m_nConnections = 0;
        if( !m_bEnabled )
                kdDebug(125) << "KAccelAction::init( \"" << sName << "\" ): created with enabled = false" << endl;
        return true;
}

KAccelAction& KAccelAction::operator =( const KAccelAction& action )
{
        m_sName = action.m_sName;
        m_sLabel = action.m_sLabel;
        m_sWhatsThis = action.m_sWhatsThis;
        m_cutDefault3 = action.m_cutDefault3;
        m_cutDefault4 = action.m_cutDefault4;
        m_pObjSlot = action.m_pObjSlot;
        m_psMethodSlot = action.m_psMethodSlot;
        m_bConfigurable = action.m_bConfigurable;
        m_bEnabled = action.m_bEnabled;
        m_nIDAccel = action.m_nIDAccel;
        m_cut = action.m_cut;
        d->m_nConnections = action.d->m_nConnections;

        return *this;
}

void KAccelAction::setName( const QString& s )
        { m_sName = s; }
void KAccelAction::setLabel( const QString& s )
        { m_sLabel = s; }
void KAccelAction::setWhatsThis( const QString& s )
        { m_sWhatsThis = s; }

bool KAccelAction::setShortcut( const KShortcut& cut )
{
        m_cut = cut;
        return true;
}

void KAccelAction::setSlot( const QObject* pObjSlot, const char* psMethodSlot )
{
        m_pObjSlot = pObjSlot;
        m_psMethodSlot = psMethodSlot;
}

void KAccelAction::setConfigurable( bool b )
        { m_bConfigurable = b; }
void KAccelAction::setEnabled( bool b )
        { m_bEnabled = b; }

QString KAccelAction::toString() const
        { return m_cut.toString(); }

QString KAccelAction::toStringInternal() const
        { return m_cut.toStringInternal( &shortcutDefault() ); }

bool KAccelAction::setKeySequence( uint i, const KKeySequence& seq )
{
        if( i < m_cut.count() ) {
                m_cut.setSeq( i, seq );
                return true;
        } else if( i == m_cut.count() )
                return m_cut.append( seq );
        return false;
}

void KAccelAction::clearShortcut()
{
        m_cut.clear();
}

bool KAccelAction::contains( const KKeySequence& seq )
{
        return m_cut.contains( seq );
        for( uint i = 0; i < m_cut.count(); i++ ) {
                if( m_cut.seq(i) == seq )
                        return true;
        }
        return false;
}

const KShortcut& KAccelAction::shortcutDefault() const
        { return (useFourModifierKeys()) ? m_cutDefault4 : m_cutDefault3; }
bool KAccelAction::isConnected() const
        { return d->m_nConnections; }
void KAccelAction::incConnections()
        { d->m_nConnections++; }
void KAccelAction::decConnections()
        { if( d->m_nConnections > 0 ) d->m_nConnections--; }


int KAccelAction::g_bUseFourModifierKeys = -1;

bool KAccelAction::useFourModifierKeys()
{
        if( KAccelAction::g_bUseFourModifierKeys == -1 ) {

                KConfigGroupSaver cgs( KGlobal::config(), "Keyboard" );
                bool b = KGlobal::config()->readBoolEntry( "Use Four Modifier Keys", false );
                KAccelAction::g_bUseFourModifierKeys = b && KKeyNative::keyboardHasWinKey();
        }
        return KAccelAction::g_bUseFourModifierKeys == 1;
}

void KAccelAction::useFourModifierKeys( bool b )
{
        if( KAccelAction::g_bUseFourModifierKeys != (int)b ) {
                KAccelAction::g_bUseFourModifierKeys = b && KKeyNative::keyboardHasWinKey();


                if( b && !KKeyNative::keyboardHasWinKey() )
                        kdDebug(125) << "Tried to use four modifier keys on a keyboard layout without a Meta key.\n";
        }
        KConfigGroupSaver cgs( KGlobal::config(), "Keyboard" );
        KGlobal::config()->writeEntry( "Use Four Modifier Keys", KAccelAction::g_bUseFourModifierKeys, true, true);

        kdDebug(125) << "bUseFourModifierKeys = " << KAccelAction::g_bUseFourModifierKeys << endl;
}





class KAccelActionsPrivate
{
 public:
};

KAccelActions::KAccelActions()
{
        kdDebug(125) << "KAccelActions(): this = " << this << endl;
        initPrivate( 0 );
}

KAccelActions::KAccelActions( const KAccelActions& actions )
{
        kdDebug(125) << "KAccelActions( actions = " << &actions << " ): this = " << this << endl;
        initPrivate( 0 );
        init( actions );
}

KAccelActions::KAccelActions( KAccelBase* pKAccelBase )
{
        kdDebug(125) << "KAccelActions( KAccelBase = " << pKAccelBase << " ): this = " << this << endl;
        initPrivate( pKAccelBase );
}

KAccelActions::~KAccelActions()
{

        clear();

}

void KAccelActions::initPrivate( KAccelBase* pKAccelBase )
{
        m_pKAccelBase = pKAccelBase;
        m_nSizeAllocated = m_nSize = 0;
        m_prgActions = 0;

}

void KAccelActions::clear()
{
        kdDebug(125) << "\tKAccelActions::clear()" << endl;
        for( uint i = 0; i < m_nSize; i++ )
                delete m_prgActions[i];
        delete[] m_prgActions;

        m_nSizeAllocated = m_nSize = 0;
        m_prgActions = 0;
}

bool KAccelActions::init( const KAccelActions& actions )
{
        clear();
        resize( actions.count() );
        for( uint i = 0; i < m_nSize; i++ ) {
                KAccelAction* pAction = actions.m_prgActions[i];
                if( pAction )
                        m_prgActions[i] = new KAccelAction( *pAction );
                else
                        m_prgActions[i] = 0;
        }

        return true;
}

bool KAccelActions::init( KConfigBase& config, const QString& sGroup )
{
        kdDebug(125) << "KAccelActions::init( " << sGroup << " )" << endl;
        QMap<QString, QString> mapEntry = config.entryMap( sGroup );
        resize( mapEntry.count() );

        QMap<QString, QString>::Iterator it( mapEntry.begin() );
        for( uint i = 0; it != mapEntry.end(); ++it, i++ ) {
                QString sShortcuts = *it;
                KShortcut cuts;

                kdDebug(125) << it.key() << " = " << sShortcuts << endl;
                if( !sShortcuts.isEmpty() && sShortcuts != "none" )
                        cuts.init( sShortcuts );

                m_prgActions[i] = new KAccelAction( it.key(), it.key(), it.key(),
                        cuts, cuts,
                        0, 0,
                        true, false );
        }

        return true;
}

void KAccelActions::resize( uint nSize )
{
        if( nSize > m_nSizeAllocated ) {
                uint nSizeAllocated = ((nSize/10) + 1) * 10;
                KAccelAction** prgActions = new KAccelAction* [nSizeAllocated];


                for( uint i = 0; i < m_nSizeAllocated; i++ )
                        prgActions[i] = m_prgActions[i];


                for( uint i = m_nSizeAllocated; i < nSizeAllocated; i++ )
                        prgActions[i] = 0;

                delete[] m_prgActions;
                m_prgActions = prgActions;
                m_nSizeAllocated = nSizeAllocated;
        }

        m_nSize = nSize;
}

void KAccelActions::insertPtr( KAccelAction* pAction )
{
        resize( m_nSize + 1 );
        m_prgActions[m_nSize-1] = pAction;
}

void KAccelActions::updateShortcuts( KAccelActions& actions2 )
{
        kdDebug(125) << "KAccelActions::updateShortcuts()" << endl;
        bool bChanged = false;

        for( uint i = 0; i < m_nSize; i++ ) {
                KAccelAction* pAction = m_prgActions[i];
                if( pAction && pAction->m_bConfigurable ) {
                        KAccelAction* pAction2 = actions2.actionPtr( pAction->m_sName );
                        if( pAction2 ) {
                                QString sOld = pAction->m_cut.toStringInternal();
                                pAction->m_cut = pAction2->m_cut;
                                kdDebug(125) << "\t" << pAction->m_sName
                                        << " found: " << sOld
                                        << " => " << pAction2->m_cut.toStringInternal()
                                        << " = " << pAction->m_cut.toStringInternal() << endl;
                                bChanged = true;
                        }
                }
        }

        if( bChanged )
                emitKeycodeChanged();
}

int KAccelActions::actionIndex( const QString& sAction ) const
{
        for( uint i = 0; i < m_nSize; i++ ) {
                if( m_prgActions[i] == 0 )
                        kdWarning(125) << "KAccelActions::actionPtr( " << sAction << " ): encountered null pointer at m_prgActions[" << i << "]" << endl;
                else if( m_prgActions[i]->m_sName == sAction )
                        return (int) i;
        }
        return -1;
}

KAccelAction* KAccelActions::actionPtr( uint i )
{
        return m_prgActions[i];
}

const KAccelAction* KAccelActions::actionPtr( uint i ) const
{
        return m_prgActions[i];
}

KAccelAction* KAccelActions::actionPtr( const QString& sAction )
{
        int i = actionIndex( sAction );
        return (i >= 0) ? m_prgActions[i] : 0;
}

const KAccelAction* KAccelActions::actionPtr( const QString& sAction ) const
{
        int i = actionIndex( sAction );
        return (i >= 0) ? m_prgActions[i] : 0;
}

KAccelAction* KAccelActions::actionPtr( KKeySequence cut )
{
        for( uint i = 0; i < m_nSize; i++ ) {
                if( m_prgActions[i] == 0 )
                        kdWarning(125) << "KAccelActions::actionPtr( " << cut.toStringInternal() << " ): encountered null pointer at m_prgActions[" << i << "]" << endl;
                else if( m_prgActions[i]->contains( cut ) )
                        return m_prgActions[i];
        }
        return 0;
}

KAccelAction& KAccelActions::operator []( uint i )
{
        return *actionPtr( i );
}

const KAccelAction& KAccelActions::operator []( uint i ) const
{
        return *actionPtr( i );
}

KAccelAction* KAccelActions::insert( const QString& sName, const QString& sLabel )
{
        if( actionPtr( sName ) ) {
                kdWarning(125) << "KAccelActions::insertLabel( " << sName << ", " << sLabel << " ): action with same name already present." << endl;
                return 0;
        }

        KAccelAction* pAction = new KAccelAction;
        pAction->m_sName = sName;
        pAction->m_sLabel = sLabel;
        pAction->m_bConfigurable = false;
        pAction->m_bEnabled = false;

        insertPtr( pAction );
        return pAction;
}

KAccelAction* KAccelActions::insert( const QString& sAction, const QString& sLabel, const QString& sWhatsThis,
                        const KShortcut& rgCutDefaults3, const KShortcut& rgCutDefaults4,
                        const QObject* pObjSlot, const char* psMethodSlot,
                        bool bConfigurable, bool bEnabled )
{

        if( actionPtr( sAction ) ) {
                kdWarning(125) << "KAccelActions::insert( " << sAction << " ): action with same name already present." << endl;
                return 0;
        }

        KAccelAction* pAction = new KAccelAction(
                sAction, sLabel, sWhatsThis,
                rgCutDefaults3, rgCutDefaults4,
                pObjSlot, psMethodSlot,
                bConfigurable, bEnabled );
        insertPtr( pAction );


        return pAction;
}

bool KAccelActions::remove( const QString& sAction )
{
        kdDebug(125) << "KAccelActions::remove( \"" << sAction << "\" ): this = " << this << " m_pKAccelBase = " << m_pKAccelBase << endl;

        int iAction = actionIndex( sAction );
        if( iAction < 0 )
                return false;

        if( m_pKAccelBase )
                m_pKAccelBase->slotRemoveAction( m_prgActions[iAction] );
        delete m_prgActions[iAction];

        for( uint i = iAction; i < m_nSize - 1; i++ )
                m_prgActions[i] = m_prgActions[i+1];
        m_nSize--;

        return true;
}

bool KAccelActions::readActions( const QString& sConfigGroup, KConfigBase* pConfig )
{
        return KAccelShortcutList(*this, false).readSettings( sConfigGroup, pConfig );
}
# 504 "/coolo/prod/kdelibs/kdecore/kaccelaction.cpp"
bool KAccelActions::writeActions( const QString &sGroup, KConfigBase* pConfig,
                        bool bWriteAll, bool bGlobal ) const
{
        kdDebug(125) << "KAccelActions::writeActions( " << sGroup << ", " << pConfig << ", " << bWriteAll << ", " << bGlobal << " )" << endl;
        if( !pConfig )
                pConfig = KGlobal::config();
        KConfigGroupSaver cs( pConfig, sGroup );

        for( uint i = 0; i < m_nSize; i++ ) {
                if( m_prgActions[i] == 0 ) {
                        kdWarning(125) << "KAccelActions::writeActions(): encountered null pointer at m_prgActions[" << i << "]" << endl;
                        continue;
                }
                const KAccelAction& action = *m_prgActions[i];

                QString s;
                bool bConfigHasAction = !pConfig->readEntry( action.m_sName ).isEmpty();
                bool bSameAsDefault = true;
                bool bWriteAction = false;

                if( action.m_bConfigurable ) {
                        s = action.toStringInternal();
                        bSameAsDefault = (action.m_cut == action.shortcutDefault());


                        if( s.isEmpty() )
                                s = "none";



                        if( bWriteAll || !bSameAsDefault )
                                bWriteAction = true;

                        if( bWriteAction ) {
                                kdDebug(125) << "\twriting " << action.m_sName << " = " << s << endl;


                                pConfig->writeEntry( action.m_sName, s, true, bGlobal );
                        }


                        else if( bConfigHasAction ) {
                                kdDebug(125) << "\tremoving " << action.m_sName << " because == default" << endl;
                                pConfig->deleteEntry( action.m_sName, bGlobal );
                        }

                }
        }

        pConfig->sync();
        return true;
}

void KAccelActions::emitKeycodeChanged()
{
        if( m_pKAccelBase )
                m_pKAccelBase->emitSignal( KAccelBase::KEYCODE_CHANGED );
}

uint KAccelActions::count() const
        { return m_nSize; }
# 33 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kshortcutmenu.cpp" 1
# 21 "/coolo/prod/kdelibs/kdecore/kshortcutmenu.cpp"
# 1 "/coolo/prod/qt-copy/include/qlabel.h" 1
# 39 "/coolo/prod/qt-copy/include/qlabel.h"







class QSimpleRichText;
class QLabelPrivate;

class QLabel : public QFrame
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   

public:
    QLabel( QWidget *parent, const char* name=0, WFlags f=0 );
    QLabel( const QString &text, QWidget *parent, const char* name=0,
            WFlags f=0 );
    QLabel( QWidget *buddy, const QString &,
            QWidget *parent, const char* name=0, WFlags f=0 );
    ~QLabel();

    QString text() const { return ltext; }
    QPixmap *pixmap() const { return lpixmap; }

    QPicture *picture() const { return lpicture; }


    QMovie *movie() const;


    TextFormat textFormat() const;
    void setTextFormat( TextFormat );

    int alignment() const { return align; }
    virtual void setAlignment( int );
    int indent() const { return extraMargin; }
    void setIndent( int );

    bool autoResize() const { return autoresize; }
    virtual void setAutoResize( bool );

    bool hasScaledContents() const;
    void setScaledContents( bool );

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    virtual void setBuddy( QWidget * );
    QWidget *buddy() const;

    int heightForWidth(int) const;

    void setFont( const QFont &f );

public :
    virtual void setText( const QString &);
    virtual void setPixmap( const QPixmap & );

    virtual void setPicture( const QPicture & );


    virtual void setMovie( const QMovie & );

    virtual void setNum( int );
    virtual void setNum( double );
    void clear();

protected:
    void drawContents( QPainter * );
    void fontChange( const QFont & );
    void resizeEvent( QResizeEvent* );

private :

    void acceleratorSlot();
    void buddyDied();


    void movieUpdated(const QRect&);
    void movieResized(const QSize&);


private:
    void init();
    void clearContents();
    void updateLabel( QSize oldSizeHint );
    QSize sizeForWidth( int w ) const;
    QString ltext;
    QPixmap *lpixmap;

    QPicture *lpicture;


    QMovie * lmovie;


    QWidget * lbuddy;

    ushort align;
    short extraMargin;
    uint autoresize:1;
    uint scaledcontents :1;
    TextFormat textformat;

    QSimpleRichText* doc;


    QAccel * accel;

    QLabelPrivate* d;

    friend class QTipLabel;

private:

    QLabel( const QLabel & );
    QLabel &operator=( const QLabel & );

};
# 22 "/coolo/prod/kdelibs/kdecore/kshortcutmenu.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qpopupmenu.h" 1
# 39 "/coolo/prod/qt-copy/include/qpopupmenu.h"



# 1 "/coolo/prod/qt-copy/include/qmenudata.h" 1
# 39 "/coolo/prod/qt-copy/include/qmenudata.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 43 "/coolo/prod/qt-copy/include/qmenudata.h" 2



# 1 "/coolo/prod/qt-copy/include/qsignal.h" 1
# 39 "/coolo/prod/qt-copy/include/qsignal.h"







class QSignal : public QObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
    QSignal( QObject *parent=0, const char *name=0 );
    ~QSignal();

    bool connect( const QObject *receiver, const char *member );
    bool disconnect( const QObject *receiver, const char *member=0 );

    void activate();


    bool isBlocked() const { return QObject::signalsBlocked(); }
    void block( bool b ) { QObject::blockSignals( b ); }

    void setParameter( int value );
    int parameter() const;




    void setValue( const QVariant &value );
    QVariant value() const;

protected:

    void signal( const QVariant& );

    void intSignal( int );

private:

    QVariant val;

private:

    QSignal( const QSignal & );
    QSignal &operator=( const QSignal & );

};
# 47 "/coolo/prod/qt-copy/include/qmenudata.h" 2





class QPopupMenu;
class QMenuDataData;
class QObject;

class QCustomMenuItem;
class QMenuItemData;

class QMenuItem
{
friend class QMenuData;
public:
    QMenuItem();
   ~QMenuItem();

    int id() const { return ident; }
    QIconSet *iconSet() const { return iconset_data; }
    QString text() const { return text_data; }
    QString whatsThis() const { return whatsthis_data; }
    QPixmap *pixmap() const { return pixmap_data; }
    QPopupMenu *popup() const { return popup_menu; }
    QWidget *widget() const { return widget_item; }
    QCustomMenuItem *custom() const;

    QKeySequence key() const { return accel_key; }

    QSignal *signal() const { return signal_data; }
    bool isSeparator() const { return is_separator; }
    bool isEnabled() const { return is_enabled; }
    bool isChecked() const { return is_checked; }
    bool isDirty() const { return is_dirty; }
    bool isVisible() const { return is_visible; }
    bool isEnabledAndVisible() const { return is_enabled && is_visible; }

    void setText( const QString &text ) { text_data = text; }
    void setDirty( bool dirty ) { is_dirty = dirty; }
    void setVisible( bool visible ) { is_visible = visible; }
    void setWhatsThis( const QString &text ) { whatsthis_data = text; }

private:
    int ident;
    QIconSet *iconset_data;
    QString text_data;
    QString whatsthis_data;
    QPixmap *pixmap_data;
    QPopupMenu *popup_menu;
    QWidget *widget_item;

    QKeySequence accel_key;

    QSignal *signal_data;
    uint is_separator : 1;
    uint is_enabled : 1;
    uint is_checked : 1;
    uint is_dirty : 1;
    uint is_visible : 1;
    QMenuItemData* d;

    QMenuItemData* extra();

private:

    QMenuItem( const QMenuItem & );
    QMenuItem &operator=( const QMenuItem & );

};


typedef QPtrList<QMenuItem> QMenuItemList;
typedef QPtrListIterator<QMenuItem> QMenuItemListIt;


class QCustomMenuItem : public Qt
{
public:
    QCustomMenuItem();
    virtual ~QCustomMenuItem();
    virtual bool fullSpan() const;
    virtual bool isSeparator() const;
    virtual void setFont( const QFont& font );
    virtual void paint( QPainter* p, const QColorGroup& cg, bool act,
                        bool enabled, int x, int y, int w, int h ) = 0;
    virtual QSize sizeHint() = 0;
};


class QMenuData
{
friend class QMenuBar;
friend class QPopupMenu;
public:
    QMenuData();
    virtual ~QMenuData();

    uint count() const;


    int insertItem( const QString &text,
                            const QObject *receiver, const char* member,
                            const QKeySequence& accel = 0, int id = -1, int index = -1 );
    int insertItem( const QIconSet& icon,
                            const QString &text,
                            const QObject *receiver, const char* member,
                            const QKeySequence& accel = 0, int id = -1, int index = -1 );
    int insertItem( const QPixmap &pixmap,
                            const QObject *receiver, const char* member,
                            const QKeySequence& accel = 0, int id = -1, int index = -1 );
    int insertItem( const QIconSet& icon,
                            const QPixmap &pixmap,
                            const QObject *receiver, const char* member,
                            const QKeySequence& accel = 0, int id = -1, int index = -1 );

    int insertItem( const QString &text, int id=-1, int index=-1 );
    int insertItem( const QIconSet& icon,
                            const QString &text, int id=-1, int index=-1 );

    int insertItem( const QString &text, QPopupMenu *popup,
                            int id=-1, int index=-1 );
    int insertItem( const QIconSet& icon,
                            const QString &text, QPopupMenu *popup,
                            int id=-1, int index=-1 );


    int insertItem( const QPixmap &pixmap, int id=-1, int index=-1 );
    int insertItem( const QIconSet& icon,
                            const QPixmap &pixmap, int id=-1, int index=-1 );
    int insertItem( const QPixmap &pixmap, QPopupMenu *popup,
                            int id=-1, int index=-1 );
    int insertItem( const QIconSet& icon,
                            const QPixmap &pixmap, QPopupMenu *popup,
                            int id=-1, int index=-1 );

    int insertItem( QWidget* widget, int id=-1, int index=-1 );

    int insertItem( const QIconSet& icon, QCustomMenuItem* custom, int id=-1, int index=-1 );
    int insertItem( QCustomMenuItem* custom, int id=-1, int index=-1 );


    int insertSeparator( int index=-1 );

    void removeItem( int id );
    void removeItemAt( int index );
    void clear();


    QKeySequence accel( int id ) const;
    void setAccel( const QKeySequence& key, int id );


    QIconSet *iconSet( int id ) const;
    QString text( int id ) const;
    QPixmap *pixmap( int id ) const;

    void setWhatsThis( int id, const QString& );
    QString whatsThis( int id ) const;


    void changeItem( int id, const QString &text );
    void changeItem( int id, const QPixmap &pixmap );
    void changeItem( int id, const QIconSet &icon, const QString &text );
    void changeItem( int id, const QIconSet &icon, const QPixmap &pixmap );

    void changeItem( const QString &text, int id ) { changeItem( id, text); }
    void changeItem( const QPixmap &pixmap, int id ) { changeItem( id, pixmap ); }
    void changeItem( const QIconSet &icon, const QString &text, int id ) {
        changeItem( id, icon, text );
    }

    bool isItemActive( int id ) const;

    bool isItemEnabled( int id ) const;
    void setItemEnabled( int id, bool enable );

    bool isItemChecked( int id ) const;
    void setItemChecked( int id, bool check );

    bool isItemVisible( int id ) const;
    void setItemVisible( int id, bool visible );

    virtual void updateItem( int id );

    int indexOf( int id ) const;
    int idAt( int index ) const;
    virtual void setId( int index, int id );

    bool connectItem( int id,
                             const QObject *receiver, const char* member );
    bool disconnectItem( int id,
                                const QObject *receiver, const char* member );

    bool setItemParameter( int id, int param );
    int itemParameter( int id ) const;

    QMenuItem *findItem( int id ) const;
    QMenuItem *findItem( int id, QMenuData ** parent ) const;
    QMenuItem * findPopup( QPopupMenu *, int *index = 0 );

    virtual void activateItemAt( int index );

protected:
    int actItem;
    QMenuItemList *mitems;
    QMenuData *parentMenu;
    uint isPopupMenu : 1;
    uint isMenuBar : 1;
    uint badSize : 1;
    uint mouseBtDn : 1;
    uint avoid_circularity : 1;
    uint actItemDown : 1;
    virtual void menuContentsChanged();
    virtual void menuStateChanged();
    virtual void menuInsPopup( QPopupMenu * );
    virtual void menuDelPopup( QPopupMenu * );

private:
    int insertAny( const QString *, const QPixmap *, QPopupMenu *,
                           const QIconSet*, int, int, QWidget* = 0, QCustomMenuItem* = 0);
    void removePopup( QPopupMenu * );
    void changeItemIconSet( int id, const QIconSet &icon );

    QMenuDataData *d;

private:

    QMenuData( const QMenuData & );
    QMenuData &operator=( const QMenuData & );

};
# 44 "/coolo/prod/qt-copy/include/qpopupmenu.h" 2



class QPopupMenuPrivate;

class QPopupMenu : public QFrame, public QMenuData
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
public:
    QPopupMenu( QWidget* parent=0, const char* name=0 );
    ~QPopupMenu();

    void popup( const QPoint & pos, int indexAtPoint = -1 );
    void updateItem( int id );

    virtual void setCheckable( bool );
    bool isCheckable() const;

    void setFont( const QFont & );
    void show();
    void hide();

    int exec();
    int exec( const QPoint & pos, int indexAtPoint = 0 );

    virtual void setActiveItem( int );
    QSize sizeHint() const;

    int idAt( int index ) const { return QMenuData::idAt( index ); }
    int idAt( const QPoint& pos ) const;

    bool customWhatsThis() const;

    int insertTearOffHandle( int id=-1, int index=-1 );

    void activateItemAt( int index );
    QRect itemGeometry( int index );


protected:
    void activated( int itemId );
    void highlighted( int itemId );
    void activatedRedirect( int itemId );
    void highlightedRedirect( int itemId );
    void aboutToShow();
    void aboutToHide();

protected:
    int itemHeight( int ) const;
    int itemHeight( QMenuItem* mi ) const;
    void drawItem( QPainter* p, int tab, QMenuItem* mi,
                   bool act, int x, int y, int w, int h);

    void drawContents( QPainter * );

    void closeEvent( QCloseEvent *e );
    void paintEvent( QPaintEvent * );
    void mousePressEvent( QMouseEvent * );
    void mouseReleaseEvent( QMouseEvent * );
    void mouseMoveEvent( QMouseEvent * );
    void keyPressEvent( QKeyEvent * );
    void focusInEvent( QFocusEvent * );
    void focusOutEvent( QFocusEvent * );
    void timerEvent( QTimerEvent * );
    void leaveEvent( QEvent * );
    void styleChange( QStyle& );
    void enabledChange( bool );
    int columns() const;

    bool focusNextPrevChild( bool next );

    int itemAtPos( const QPoint &, bool ignoreSeparator = TRUE ) const;

private :
    void subActivated( int itemId );
    void subHighlighted( int itemId );

    void accelActivated( int itemId );
    void accelDestroyed();

    void popupDestroyed( QObject* );
    void modalActivation( int );

    void subMenuTimer();
    void subScrollTimer();
    void allowAnimation();
    void toggleTearOff();

    void performDelayedChanges();

private:
    void updateScrollerState();
    void menuContentsChanged();
    void menuStateChanged();
    void performDelayedContentsChanged();
    void performDelayedStateChanged();
    void menuInsPopup( QPopupMenu * );
    void menuDelPopup( QPopupMenu * );
    void frameChanged();

    void actSig( int, bool = FALSE );
    void hilitSig( int );
    virtual void setFirstItemActive();
    void hideAllPopups();
    void hidePopups();
    bool tryMenuBar( QMouseEvent * );
    void byeMenuBar();

    void updateSize();
    void updateRow( int row );

    void updateAccel( QWidget * );
    void enableAccel( bool );

    QPopupMenuPrivate *d;

    QAccel *autoaccel;







    int popupActive;
    int tab;
    uint accelDisabled : 1;
    uint checkable : 1;
    uint connectModalRecursionSafety : 1;
    uint tornOff : 1;
    uint pendingDelayedContentsChanges : 1;
    uint pendingDelayedStateChanges : 1;
    int maxPMWidth;
    int ncols;
    bool snapToMouse;
    bool tryMouseEvent( QPopupMenu *, QMouseEvent * );

    friend class QMenuData;
    friend class QMenuBar;

    void connectModal(QPopupMenu* receiver, bool doConnect);

private:

    QPopupMenu( const QPopupMenu & );
    QPopupMenu &operator=( const QPopupMenu & );

};
# 23 "/coolo/prod/kdelibs/kdecore/kshortcutmenu.cpp" 2




# 1 "/coolo/prod/kdelibs/kdecore/kshortcutmenu.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kshortcutmenu.h"






class QLabel;

class KAccelActions;




class KShortcutMenu : public QPopupMenu
{
        public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
 public:
        KShortcutMenu( QWidget* pParent, KAccelActions* pActions, KKeySequence seq );

        bool insertAction( uint iAction, KKeySequence seq );

        void updateShortcuts();

 protected:
        void keyPressEvent( QKeyEvent* pEvent );

 private:
        int searchForKey( KKey key );
        void keepItemsMatching( KKey key );

 private:
        typedef QMap<uint, KKeySequence> IndexToKKeySequence;

        KAccelActions* m_pActions;
        KKeySequence m_seq;
        QLabel* pTitle;
        IndexToKKeySequence m_seqs;
};
# 28 "/coolo/prod/kdelibs/kdecore/kshortcutmenu.cpp" 2


KShortcutMenu::KShortcutMenu( QWidget* pParent, KAccelActions* pActions, KKeySequence seq )
: QPopupMenu( pParent ),
        m_pActions( pActions ),
        m_seq( seq )
{
        kdDebug() << seq.toStringInternal() << endl;

        QFont fontTitle = KGlobalSettings::menuFont();
        fontTitle.setBold( true );

        pTitle = new QLabel( "", (QWidget*)0 );
        pTitle->setFont( fontTitle );
        pTitle->setFrameShape( QFrame::Panel );

        insertItem( pTitle );
}

bool KShortcutMenu::insertAction( uint iAction, KKeySequence seq )
{
        KAccelAction* pAction = m_pActions->actionPtr( iAction );

        if( pAction ) {
                insertItem( "", iAction );
                m_seqs[indexOf(iAction)] = seq;
                return true;
        } else
                return false;
}


void KShortcutMenu::updateShortcuts()
{
        pTitle->setText( m_seq.toString() + ",..." );

        for( uint iItem = 1; iItem < count(); iItem++ ) {
                int iAction = idAt( iItem );
                if( iAction >= 0 ) {
                        KAccelAction* pAction = m_pActions->actionPtr( iAction );
                        if( pAction ) {
                                KKeySequence seq = m_seqs[iItem];
                                QString sSeq = seq.key(m_seq.count()).toString();
                                for( uint iKey = m_seq.count() + 1; iKey < seq.count(); iKey++ )
                                        sSeq += QString(",") + seq.key(iKey).toString();

                                kdDebug(125) << "seq = " << seq.toStringInternal() << " sSeq = " << sSeq << endl;
                                changeItem( iAction, pAction->label() + "\t" + sSeq );
                        }
                }
        }
}

void KShortcutMenu::keyPressEvent( QKeyEvent* pEvent )
{
        kdDebug() << "keypress; " << pEvent->key() << endl;
        KKey key( pEvent );

        switch( pEvent->key() ) {
         case Key_Shift:
         case Key_Control:
         case Key_Alt:
         case Key_Meta:
         case Key_Super_L:
         case Key_Super_R:
         case Key_Hyper_L:
         case Key_Hyper_R:
                break;
         default:
                int iItem = searchForKey( key );

                if( iItem == -1 ) {
                        key = pEvent->key();
                        iItem = searchForKey( key );
                }

                if( iItem == -1 ) {


                        if( pEvent->key() == Qt::Key_Up || pEvent->key() == Qt::Key_Down ||
                            pEvent->key() == Qt::Key_Enter || pEvent->key() == Qt::Key_Return )
                                QPopupMenu::keyPressEvent( pEvent );
                        else
                                close();
                }
                else if( iItem == 0 )
                        keepItemsMatching( key );
                else
                        activateItemAt( iItem );
        }
}

int KShortcutMenu::searchForKey( KKey key )
{
        int iItemFound = -1;
        uint iKey = m_seq.count();

        for( uint iItem = 1; iItem < count(); iItem++ ) {
                if( m_seqs.contains( iItem ) ) {
                        KKey keyItem = m_seqs[iItem].key( iKey );

                        if( key == keyItem ) {
                                if( iItemFound == -1 )
                                        iItemFound = iItem;
                                else
                                        return 0;
                        }
                }
        }

        return iItemFound;
}

void KShortcutMenu::keepItemsMatching( KKey key )
{
        kdDebug(125) << "MyAccel::keepItemsMatching( " << key.toStringInternal() << " )" << endl;

        uint iKey = m_seq.count();
        m_seq.setKey( iKey, key );

        for( uint iItem = 1; iItem < count(); iItem++ ) {
                if( m_seqs.contains( iItem ) ) {
                        KKey keyItem = m_seqs[iItem].key( iKey );
                        if( key != keyItem ) {
                                m_seqs.remove( iItem );
                                removeItemAt( iItem-- );
                        }
                }
        }

        updateShortcuts();
}

# 1 "../kdecore/kshortcutmenu.moc" 1
# 11 "../kdecore/kshortcutmenu.moc"
# 1 "../../../prod/kdelibs/kdecore/kshortcutmenu.h" 1
# 12 "../kdecore/kshortcutmenu.moc" 2
# 22 "../kdecore/kshortcutmenu.moc"
const char *KShortcutMenu::className() const
{
    return "KShortcutMenu";
}

QMetaObject *KShortcutMenu::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KShortcutMenu( "KShortcutMenu", &KShortcutMenu::staticMetaObject );
# 50 "../kdecore/kshortcutmenu.moc"
QMetaObject* KShortcutMenu::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QPopupMenu::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KShortcutMenu", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KShortcutMenu.setMetaObject( metaObj );
    return metaObj;
}

void* KShortcutMenu::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KShortcutMenu" ) )
        return this;
    return QPopupMenu::qt_cast( clname );
}

bool KShortcutMenu::qt_invoke( int _id, QUObject* _o )
{
    return QPopupMenu::qt_invoke(_id,_o);
}

bool KShortcutMenu::qt_emit( int _id, QUObject* _o )
{
    return QPopupMenu::qt_emit(_id,_o);
}


bool KShortcutMenu::qt_property( int id, int f, QVariant* v)
{
    return QPopupMenu::qt_property( id, f, v);
}

bool KShortcutMenu::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 162 "/coolo/prod/kdelibs/kdecore/kshortcutmenu.cpp" 2
# 34 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaccelbase.cpp" 1
# 46 "/coolo/prod/kdelibs/kdecore/kaccelbase.cpp"
KAccelBase::KAccelBase( int fInitCode )
: m_rgActions( this )
{
        kdDebug(125) << "KAccelBase(): this = " << this << endl;
        m_bNativeKeys = fInitCode & NATIVE_KEYS;
        m_bEnabled = true;
        m_sConfigGroup = "Shortcuts";
        m_bConfigIsGlobal = false;
        m_bAutoUpdate = false;
        mtemp_pActionRemoving = 0;
}

KAccelBase::~KAccelBase()
{
        kdDebug(125) << "~KAccelBase(): this = " << this << endl;
}

uint KAccelBase::actionCount() const { return m_rgActions.count(); }
KAccelActions& KAccelBase::actions() { return m_rgActions; }
bool KAccelBase::isEnabled() const { return m_bEnabled; }

KAccelAction* KAccelBase::actionPtr( const QString& sAction )
        { return m_rgActions.actionPtr( sAction ); }

const KAccelAction* KAccelBase::actionPtr( const QString& sAction ) const
        { return m_rgActions.actionPtr( sAction ); }

KAccelAction* KAccelBase::actionPtr( const KKeyServer::Key& key )
{
        if( !m_mapKeyToAction.contains( key ) )
                return 0;

        return m_mapKeyToAction[key].pAction;
}

KAccelAction* KAccelBase::actionPtr( const KKey& key )
{
        KKeyServer::Key k2;
        k2.init( key, !m_bNativeKeys );
        return actionPtr( k2 );
}

void KAccelBase::setConfigGroup( const QString& sConfigGroup )
        { m_sConfigGroup = sConfigGroup; }

void KAccelBase::setConfigGlobal( bool global )
        { m_bConfigIsGlobal = global; }

bool KAccelBase::setActionEnabled( const QString& sAction, bool bEnable )
{
        KAccelAction* pAction = actionPtr( sAction );
        if( pAction ) {
                if( pAction->m_bEnabled != bEnable ) {
                        kdDebug(125) << "KAccelBase::setActionEnabled( " << sAction << ", " << bEnable << " )" << endl;
                        pAction->m_bEnabled = bEnable;
                        if( m_bAutoUpdate ) {

                                if( bEnable )
                                        insertConnection( pAction );
                                else if( pAction->isConnected() )
                                        removeConnection( pAction );
                        }
                }
                return true;
        }
        return false;
}

bool KAccelBase::setAutoUpdate( bool bAuto )
{
        kdDebug(125) << "KAccelBase::setAutoUpdate( " << bAuto << " ): m_bAutoUpdate on entrance = " << m_bAutoUpdate << endl;
        bool b = m_bAutoUpdate;
        if( !m_bAutoUpdate && bAuto )
                updateConnections();
        m_bAutoUpdate = bAuto;
        return b;
}

KAccelAction* KAccelBase::insert( const QString& sAction, const QString& sDesc, const QString& sHelp,
                        const KShortcut& rgCutDefaults3, const KShortcut& rgCutDefaults4,
                        const QObject* pObjSlot, const char* psMethodSlot,
                        bool bConfigurable, bool bEnabled )
{

        KAccelAction* pAction = m_rgActions.insert(
                sAction, sDesc, sHelp,
                rgCutDefaults3, rgCutDefaults4,
                pObjSlot, psMethodSlot,
                bConfigurable, bEnabled );

        if( pAction && m_bAutoUpdate )
                insertConnection( pAction );


        return pAction;
}

KAccelAction* KAccelBase::insert( const QString& sName, const QString& sDesc )
        { return m_rgActions.insert( sName, sDesc ); }

bool KAccelBase::remove( const QString& sAction )
{
        return m_rgActions.remove( sAction );
}

void KAccelBase::slotRemoveAction( KAccelAction* pAction )
{
        removeConnection( pAction );
}

bool KAccelBase::setActionSlot( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot )
{
        kdDebug(125) << "KAccelBase::setActionSlot( " << sAction << ", " << pObjSlot << ", " << psMethodSlot << " )\n";
        KAccelAction* pAction = m_rgActions.actionPtr( sAction );
        if( pAction ) {

                if( m_bAutoUpdate && pAction->isConnected() ) {
                        kdDebug(125) << "\tm_pObjSlot = " << pAction->m_pObjSlot << " m_psMethodSlot = " << pAction->m_psMethodSlot << endl;
                        removeConnection( pAction );
                }

                pAction->m_pObjSlot = pObjSlot;
                pAction->m_psMethodSlot = psMethodSlot;


                if( m_bAutoUpdate && pObjSlot && psMethodSlot )
                        insertConnection( pAction );

                return true;
        } else
                return false;
}
# 243 "/coolo/prod/kdelibs/kdecore/kaccelbase.cpp"
struct KAccelBase::X
{
        uint iAction, iSeq, iVari;
        KKeyServer::Key key;

        X() {}
        X( uint _iAction, uint _iSeq, uint _iVari, const KKeyServer::Key& _key )
                { iAction = _iAction; iSeq = _iSeq; iVari = _iVari; key = _key; }

        int compare( const X& x )
        {
                int n = key.compare( x.key );
                if( n != 0 ) return n;
                if( iVari != x.iVari ) return iVari - x.iVari;
                if( iSeq != x.iSeq ) return iSeq - x.iSeq;
                return 0;
        }

        bool operator <( const X& x ) { return compare( x ) < 0; }
        bool operator >( const X& x ) { return compare( x ) > 0; }
        bool operator <=( const X& x ) { return compare( x ) <= 0; }
};
# 308 "/coolo/prod/kdelibs/kdecore/kaccelbase.cpp"
bool KAccelBase::updateConnections()
{
        kdDebug(125) << "KAccelBase::updateConnections()  this = " << this << endl;


        QValueVector<X> rgKeys;
        createKeyList( rgKeys );
        m_rgActionsNonUnique.clear();

        KKeyToActionMap mapKeyToAction;
        for( uint i = 0; i < rgKeys.size(); i++ ) {
                X& x = rgKeys[i];
                KKeyServer::Key& key = x.key;
                ActionInfo info;
                bool bNonUnique = false;

                info.pAction = m_rgActions.actionPtr( x.iAction );
                info.iSeq = x.iSeq;
                info.iVariation = x.iVari;


                if( info.pAction->shortcut().seq(info.iSeq).count() > 1 )
                        bNonUnique = true;

                else if( i < rgKeys.size() - 1 && key == rgKeys[i+1].key ) {


                        if( info.iVariation == rgKeys[i+1].iVari && info.iSeq == rgKeys[i+1].iSeq )
                                bNonUnique = true;

                        kdDebug(125) << "key conflict = " << key.key().toStringInternal()
                                << " action1 = " << info.pAction->name()
                                << " action2 = " << m_rgActions.actionPtr( rgKeys[i+1].iAction )->name()
                                << " non-unique = " << bNonUnique << endl;


                        while( i < rgKeys.size() - 1 && key == rgKeys[i+1].key )
                                i++;
                }

                if( bNonUnique ) {

                        if( m_mapKeyToAction.contains( key ) ) {
                                KAccelAction* pAction = m_mapKeyToAction[key].pAction;
                                if( pAction ) {
                                        m_mapKeyToAction.remove( key );
                                        disconnectKey( *pAction, key );
                                        pAction->decConnections();
                                        m_rgActionsNonUnique.append( pAction );
                                }
                        }

                        m_rgActionsNonUnique.append( info.pAction );
                        info.pAction = 0;
                }


                mapKeyToAction[key] = info;
        }


        for( KKeyToActionMap::iterator it = m_mapKeyToAction.begin(); it != m_mapKeyToAction.end(); ++it ) {
                const KKeyServer::Key& key = it.key();
                KAccelAction* pAction = (*it).pAction;

                if( !mapKeyToAction.contains( key ) || mapKeyToAction[key].pAction != pAction ) {
                        if( pAction ) {
                                disconnectKey( *pAction, key );
                                pAction->decConnections();
                        } else
                                disconnectKey( key );
                }
        }




        for( KKeyToActionMap::iterator it = mapKeyToAction.begin(); it != mapKeyToAction.end(); ++it ) {
                const KKeyServer::Key& key = it.key();
                KAccelAction* pAction = (*it).pAction;
                if( !m_mapKeyToAction.contains( key ) || m_mapKeyToAction[key].pAction != pAction ) {


                        if( pAction ) {
                                if( connectKey( *pAction, key ) )
                                        pAction->incConnections();
                        } else
                                connectKey( key );
                }
        }


        m_mapKeyToAction = mapKeyToAction;


        for( KKeyToActionMap::iterator it = m_mapKeyToAction.begin(); it != m_mapKeyToAction.end(); ++it ) {
                kdDebug(125) << "Key: " << it.key().key().toStringInternal() << " => '"
                        << (((*it).pAction) ? (*it).pAction->name() : QString::null) << "'" << endl;
        }

        return true;
}


void KAccelBase::createKeyList( QValueVector<struct X>& rgKeys )
{

        if( !m_bEnabled )
                return;



        for( uint iAction = 0; iAction < m_rgActions.count(); iAction++ ) {
                KAccelAction* pAction = m_rgActions.actionPtr( iAction );
                if( pAction && pAction->m_pObjSlot && pAction->m_psMethodSlot && pAction != mtemp_pActionRemoving ) {

                        for( uint iSeq = 0; iSeq < pAction->shortcut().count(); iSeq++ ) {
                                const KKeySequence& seq = pAction->shortcut().seq(iSeq);
                                if( seq.count() > 0 ) {
                                        KKeyServer::Variations vars;
                                        vars.init( seq.key(0), !m_bNativeKeys );
                                        for( uint iVari = 0; iVari < vars.count(); iVari++ ) {
                                                if( vars.key(iVari).code() && vars.key(iVari).sym() )
                                                        rgKeys.push_back( X( iAction, iSeq, iVari, vars.key( iVari ) ) );

                                        }
                                }


                        }
                }
        }


        qHeapSort( rgKeys.begin(), rgKeys.end() );
}

bool KAccelBase::insertConnection( KAccelAction* pAction )
{
        if( !pAction->m_pObjSlot || !pAction->m_psMethodSlot )
                return true;

        kdDebug(125) << "KAccelBase::insertConnection( " << pAction << "=\"" << pAction->m_sName << "\"; shortcut = " << pAction->shortcut().toStringInternal() << " )  this = " << this << endl;


        for( uint iSeq = 0; iSeq < pAction->shortcut().count(); iSeq++ ) {

                KKeyServer::Variations vars;
                vars.init( pAction->shortcut().seq(iSeq).key(0), !m_bNativeKeys );
                for( uint iVari = 0; iVari < vars.count(); iVari++ ) {
                        const KKeyServer::Key& key = vars.key( iVari );


                        if( key.sym() ) {
                                if( !m_mapKeyToAction.contains( key ) ) {

                                        if( pAction->shortcut().seq(iSeq).count() == 1 ) {
                                                m_mapKeyToAction[key] = ActionInfo( pAction, iSeq, iVari );
                                                if( connectKey( *pAction, key ) )
                                                        pAction->incConnections();
                                        }

                                        else {
                                                m_mapKeyToAction[key] = ActionInfo( 0, 0, 0 );

                                                if( m_rgActionsNonUnique.findIndex( pAction ) == -1 )
                                                        m_rgActionsNonUnique.append( pAction );
                                                if( connectKey( key ) )
                                                        pAction->incConnections();
                                        }
                                } else {



                                        if( m_mapKeyToAction[key].pAction != pAction
                                            && m_mapKeyToAction[key].pAction != 0 ) {
                                                kdDebug(125) << "Key conflict: call updateConnections():"
                                                        << " key = " << key.key().toStringInternal() << endl;
                                                return updateConnections();
                                        }
                                }
                        }
                }
        }
# 505 "/coolo/prod/kdelibs/kdecore/kaccelbase.cpp"
        return true;
}

bool KAccelBase::removeConnection( KAccelAction* pAction )
{
        kdDebug(125) << "KAccelBase::removeConnection( " << pAction << " = \"" << pAction->m_sName << "\"; shortcut = " << pAction->m_cut.toStringInternal() << " ): this = " << this << endl;




        if( m_rgActionsNonUnique.findIndex( pAction ) >= 0 ) {
                mtemp_pActionRemoving = pAction;
                bool b = updateConnections();
                mtemp_pActionRemoving = 0;
                return b;
        }

        KKeyToActionMap::iterator it = m_mapKeyToAction.begin();
        while( it != m_mapKeyToAction.end() ) {
                KKeyServer::Key key = it.key();
                ActionInfo* pInfo = &(*it);


                if( pAction == pInfo->pAction ) {
                        disconnectKey( *pAction, key );
                        pAction->decConnections();

                        KKeyToActionMap::iterator itRemove = it++;
                        m_mapKeyToAction.remove( itRemove );
                } else
                        ++it;
        }
        return true;
}

bool KAccelBase::setShortcut( const QString& sAction, const KShortcut& cut )
{
        KAccelAction* pAction = actionPtr( sAction );
        if( pAction ) {
                if( m_bAutoUpdate )
                        removeConnection( pAction );

                pAction->setShortcut( cut );

                if( m_bAutoUpdate && !pAction->shortcut().isNull() )
                        insertConnection( pAction );
                return true;
        } else
                return false;
}

void KAccelBase::readSettings( KConfigBase* pConfig )
{
        m_rgActions.readActions( m_sConfigGroup, pConfig );
        if( m_bAutoUpdate )
                updateConnections();
}

void KAccelBase::writeSettings( KConfigBase* pConfig ) const
{
        m_rgActions.writeActions( m_sConfigGroup, pConfig, m_bConfigIsGlobal, m_bConfigIsGlobal );
}

QPopupMenu* KAccelBase::createPopupMenu( QWidget* pParent, const KKeySequence& seq )
{
        KShortcutMenu* pMenu = new KShortcutMenu( pParent, &actions(), seq );

        bool bActionInserted = false;
        bool bInsertSeparator = false;
        for( uint i = 0; i < actionCount(); i++ ) {
                const KAccelAction* pAction = actions().actionPtr( i );

                if( !pAction->isEnabled() )
                        continue;




                if( bActionInserted && !pAction->isConfigurable() && pAction->name().contains( ':' ) )
                        bInsertSeparator = true;

                for( uint iSeq = 0; iSeq < pAction->shortcut().count(); iSeq++ ) {
                        const KKeySequence& seqAction = pAction->shortcut().seq(iSeq);
                        if( seqAction.startsWith( seq ) ) {
                                if( bInsertSeparator ) {
                                        pMenu->insertSeparator();
                                        bInsertSeparator = false;
                                }

                                pMenu->insertAction( i, seqAction );



                                bActionInserted = true;
                                break;
                        }
                }
        }
        pMenu->updateShortcuts();
        return pMenu;
}
# 35 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaccel.cpp" 1
# 33 "/coolo/prod/kdelibs/kdecore/kaccel.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kaccelprivate.h" 1








class KAccelPrivate : public QObject, public KAccelBase
{
        public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
 public:
        KAccel* m_pAccel;
        QWidget* m_pWatch;
        QMap<int, int> m_mapIDToKey;
        QMap<int, KAccelAction*> m_mapIDToAction;
        QTimer m_timerShowMenu;

        KAccelPrivate( KAccel* pParent, QWidget* pWatch );

        virtual void setEnabled( bool );

        bool setEnabled( const QString& sAction, bool bEnable );

        virtual bool removeAction( const QString& sAction );

        virtual bool emitSignal( KAccelBase::Signal );
        virtual bool connectKey( KAccelAction&, const KKeyServer::Key& );
        virtual bool connectKey( const KKeyServer::Key& );
        virtual bool disconnectKey( KAccelAction&, const KKeyServer::Key& );
        virtual bool disconnectKey( const KKeyServer::Key& );

 protected:
        void menuItemActivated();
        void activateInt( int );

 private :
        void slotKeyPressed( int id );
        void slotShowMenu();
        void slotMenuActivated( int iAction );

        bool eventFilter( QObject* pWatched, QEvent* pEvent );
};
# 34 "/coolo/prod/kdelibs/kdecore/kaccel.cpp" 2
# 49 "/coolo/prod/kdelibs/kdecore/kaccel.cpp"
bool kde_g_bKillAccelOverride = false;

class KAccelEventHandler : public QWidget
{
 public:
        static KAccelEventHandler* self()
        {
                if( !g_pSelf )
                        g_pSelf = new KAccelEventHandler;
                return g_pSelf;
        }

        static bool active() { return g_bActive; }
        static void accelActivated( bool b ) { g_bAccelActivated = b; }

 private:
        KAccelEventHandler();


        bool x11Event( XEvent* pEvent );


        static KAccelEventHandler* g_pSelf;
        static bool g_bActive;
        static bool g_bAccelActivated;
};

KAccelEventHandler* KAccelEventHandler::g_pSelf = 0;
bool KAccelEventHandler::g_bActive = false;
bool KAccelEventHandler::g_bAccelActivated = false;

KAccelEventHandler::KAccelEventHandler()
{

                KApplication::kApplication()->installX11EventFilter( this );

}


bool KAccelEventHandler::x11Event( XEvent* pEvent )
{
        if( QWidget::keyboardGrabber() || !KApplication::kApplication()->focusWidget() )
                return false;

        if( pEvent->type == XKeyPress ) {
                KKeyNative keyNative( pEvent );
                KKey key( keyNative );
                key.simplify();
                int keyCodeQt = key.keyCodeQt();
                int state = 0;
                if( key.modFlags() & KKey::SHIFT ) state |= Qt::ShiftButton;
                if( key.modFlags() & KKey::CTRL ) state |= Qt::ControlButton;
                if( key.modFlags() & KKey::ALT ) state |= Qt::AltButton;

                QKeyEvent ke( QEvent::AccelOverride, keyCodeQt, 0, state );
                ke.ignore();

                g_bActive = true;
                g_bAccelActivated = false;
                KApplication::kApplication()->sendEvent( KApplication::kApplication()->focusWidget(), &ke );
                g_bActive = false;



                if( ke.isAccepted() && !g_bAccelActivated )
                        kde_g_bKillAccelOverride = true;


                return g_bAccelActivated;
        }

        return false;
}






KAccelPrivate::KAccelPrivate( KAccel* pParent, QWidget* pWatch )
: KAccelBase( KAccelBase::QT_KEYS )
{

        m_pAccel = pParent;
        m_pWatch = pWatch;
        m_bAutoUpdate = true;
        connect( (QAccel*)m_pAccel, "2""activated(int)", this, "1""slotKeyPressed(int)" );

        if( m_pWatch )
                m_pWatch->installEventFilter( this );
        KAccelEventHandler::self();
}

void KAccelPrivate::setEnabled( bool bEnabled )
{
        m_bEnabled = bEnabled;
        ((QAccel*)m_pAccel)->setEnabled( bEnabled );
}

bool KAccelPrivate::setEnabled( const QString& sAction, bool bEnable )
{
        kdDebug(125) << "KAccelPrivate::setEnabled( \"" << sAction << "\", " << bEnable << " ): this = " << this << endl;
        KAccelAction* pAction = actionPtr( sAction );
        if( !pAction )
                return false;
        if( pAction->isEnabled() == bEnable )
                return true;

        pAction->setEnabled( bEnable );

        QMap<int, KAccelAction*>::iterator it = m_mapIDToAction.begin();
        for( ; it != m_mapIDToAction.end(); ++it ) {
                if( *it == pAction )
                        ((QAccel*)m_pAccel)->setItemEnabled( it.key(), bEnable );
        }
        return true;
}

bool KAccelPrivate::removeAction( const QString& sAction )
{



        KAccelAction* pAction = actions().actionPtr( sAction );
        if( pAction ) {
                int nID = pAction->getID();

                bool b = KAccelBase::remove( sAction );
                ((QAccel*)m_pAccel)->removeItem( nID );
                return b;
        } else
                return false;
}

bool KAccelPrivate::emitSignal( KAccelBase::Signal signal )
{
        if( signal == KAccelBase::KEYCODE_CHANGED ) {
                m_pAccel->emitKeycodeChanged();
                return true;
        }
        return false;
}

bool KAccelPrivate::connectKey( KAccelAction& action, const KKeyServer::Key& key )
{
        uint keyQt = key.keyCodeQt();
        int nID = ((QAccel*)m_pAccel)->insertItem( keyQt );
        m_mapIDToAction[nID] = &action;
        m_mapIDToKey[nID] = keyQt;

        if( action.objSlotPtr() && action.methodSlotPtr() ) {
                ((QAccel*)m_pAccel)->connectItem( nID, action.objSlotPtr(), action.methodSlotPtr() );
                if( !action.isEnabled() )
                        ((QAccel*)m_pAccel)->setItemEnabled( nID, false );
        }

        kdDebug(125) << "KAccelPrivate::connectKey( \"" << action.name() << "\", " << key.key().toStringInternal() << " = 0x" << QString::number(keyQt,16) << " ): id = " << nID << " m_pObjSlot = " << action.objSlotPtr() << endl;

        return nID != 0;
}

bool KAccelPrivate::connectKey( const KKeyServer::Key& key )
{
        uint keyQt = key.keyCodeQt();
        int nID = ((QAccel*)m_pAccel)->insertItem( keyQt );

        m_mapIDToKey[nID] = keyQt;

        kdDebug(125) << "KAccelPrivate::connectKey( " << key.key().toStringInternal() << " = 0x" << QString::number(keyQt,16) << " ): id = " << nID << endl;
        return nID != 0;
}

bool KAccelPrivate::disconnectKey( KAccelAction& action, const KKeyServer::Key& key )
{
        int keyQt = key.keyCodeQt();
        QMap<int, int>::iterator it = m_mapIDToKey.begin();
        for( ; it != m_mapIDToKey.end(); ++it ) {

                if( *it == keyQt ) {
                        int nID = it.key();
                        kdDebug(125) << "KAccelPrivate::disconnectKey( \"" << action.name() << "\", 0x" << QString::number(keyQt,16) << " ) : id = " << nID << " m_pObjSlot = " << action.objSlotPtr() << endl;
                        ((QAccel*)m_pAccel)->removeItem( nID );
                        m_mapIDToAction.remove( nID );
                        m_mapIDToKey.remove( it );
                        return true;
                }
        }

        kdWarning(125) << "Didn't find key in m_mapIDToKey." << endl;
        return false;
}

bool KAccelPrivate::disconnectKey( const KKeyServer::Key& key )
{
        int keyQt = key.keyCodeQt();
        kdDebug(125) << "KAccelPrivate::disconnectKey( 0x" << QString::number(keyQt,16) << " )" << endl;
        QMap<int, int>::iterator it = m_mapIDToKey.begin();
        for( ; it != m_mapIDToKey.end(); ++it ) {
                if( *it == keyQt ) {
                        ((QAccel*)m_pAccel)->removeItem( it.key() );
                        m_mapIDToKey.remove( it );
                        return true;
                }
        }

        kdWarning(125) << "Didn't find key in m_mapIDTokey." << endl;
        return false;
}

void KAccelPrivate::slotKeyPressed( int id )
{
        kdDebug(125) << "KAccelPrivate::slotKeyPressed( " << id << " )" << endl;

        if( m_mapIDToKey.contains( id ) ) {
                KKey key = m_mapIDToKey[id];
                KKeySequence seq( key );
                QPopupMenu* pMenu = createPopupMenu( m_pWatch, seq );







                if( pMenu->count() == 2 && static_cast<int>( pMenu->accel(1) ) == 0 ) {
                        int iAction = pMenu->idAt(1);
                        slotMenuActivated( iAction );
                } else {
                        connect( pMenu, "2""activated(int)", this, "1""slotMenuActivated(int)" );
                        pMenu->exec( m_pWatch->mapToGlobal( QPoint( 0, 0 ) ) );
                        disconnect( pMenu, "2""activated(int)", this, "1""slotMenuActivated(int)" );
                }
                delete pMenu;
        }
}

void KAccelPrivate::slotShowMenu()
{
}

void KAccelPrivate::slotMenuActivated( int iAction )
{
        kdDebug(125) << "KAccelPrivate::slotMenuActivated( " << iAction << " )" << endl;
        KAccelAction* pAction = actions().actionPtr( iAction );
        if( pAction ) {
                connect( this, "2""menuItemActivated()", pAction->objSlotPtr(), pAction->methodSlotPtr() );
                menuItemActivated();
                disconnect( this, "2""menuItemActivated()", pAction->objSlotPtr(), pAction->methodSlotPtr() );
        }
}

bool KAccelPrivate::eventFilter( QObject* , QEvent* pEvent )
{
        if( KAccelEventHandler::active() && pEvent->type() == QEvent::AccelOverride && m_bEnabled ) {
                QKeyEvent* pKeyEvent = (QKeyEvent*) pEvent;
                KKey key( pKeyEvent );
                kdDebug(125) << "KAccelPrivate::eventFilter( AccelOverride ): this = " << this << ", key = " << key.toStringInternal() << endl;
                int keyCodeQt = key.keyCodeQt();
                QMap<int, int>::iterator it = m_mapIDToKey.begin();
                for( ; it != m_mapIDToKey.end(); ++it ) {
                        if( (*it) == keyCodeQt ) {
                                int nID = it.key();
                                kdDebug(125) << "shortcut found!" << endl;
                                if( m_mapIDToAction.contains( nID ) ) {

                                        KAccelAction* pAction = m_mapIDToAction[nID];
                                        if( !pAction->isEnabled() )
                                                continue;
                                        connect( this, "2""menuItemActivated()", pAction->objSlotPtr(), pAction->methodSlotPtr() );
                                        menuItemActivated();
                                        disconnect( this, "2""menuItemActivated()", pAction->objSlotPtr(), pAction->methodSlotPtr() );
                                } else
                                        slotKeyPressed( nID );

                                pKeyEvent->accept();
                                KAccelEventHandler::accelActivated( true );
                                return true;
                        }
                }
        }
        return false;
}





KAccel::KAccel( QWidget* pParent, const char* psName )
: QAccel( pParent, (psName) ? psName : "KAccel-QAccel" )
{
        kdDebug(125) << "KAccel( pParent = " << pParent << ", psName = " << psName << " ): this = " << this << endl;
        d = new KAccelPrivate( this, pParent );
}

KAccel::KAccel( QWidget* watch, QObject* pParent, const char* psName )
: QAccel( watch, pParent, (psName) ? psName : "KAccel-QAccel" )
{
        kdDebug(125) << "KAccel( watch = " << watch << ", pParent = " << pParent << ", psName = " << psName << " ): this = " << this << endl;
        if( !watch )
                kdDebug(125) << kdBacktrace() << endl;
        d = new KAccelPrivate( this, watch );
}

KAccel::~KAccel()
{
        kdDebug(125) << "~KAccel(): this = " << this << endl;
        delete d;
}

KAccelActions& KAccel::actions() { return d->actions(); }
const KAccelActions& KAccel::actions() const { return d->actions(); }
bool KAccel::isEnabled() { return d->isEnabled(); }
void KAccel::setEnabled( bool bEnabled ) { d->setEnabled( bEnabled ); }
bool KAccel::setAutoUpdate( bool bAuto ) { return d->setAutoUpdate( bAuto ); }

KAccelAction* KAccel::insert( const QString& sAction, const QString& sLabel, const QString& sWhatsThis,
                const KShortcut& cutDef,
                const QObject* pObjSlot, const char* psMethodSlot,
                bool bConfigurable, bool bEnabled )
{
        return d->insert( sAction, sLabel, sWhatsThis,
                cutDef, cutDef,
                pObjSlot, psMethodSlot,
                bConfigurable, bEnabled );
}

KAccelAction* KAccel::insert( const QString& sAction, const QString& sLabel, const QString& sWhatsThis,
                const KShortcut& cutDef3, const KShortcut& cutDef4,
                const QObject* pObjSlot, const char* psMethodSlot,
                bool bConfigurable, bool bEnabled )
{
        return d->insert( sAction, sLabel, sWhatsThis,
                cutDef3, cutDef4,
                pObjSlot, psMethodSlot,
                bConfigurable, bEnabled );
}

KAccelAction* KAccel::insert( const char* psAction, const KShortcut& cutDef,
                const QObject* pObjSlot, const char* psMethodSlot,
                bool bConfigurable, bool bEnabled )
{
        return d->insert( psAction, i18n(psAction), QString::null,
                cutDef, cutDef,
                pObjSlot, psMethodSlot,
                bConfigurable, bEnabled );
}

KAccelAction* KAccel::insert( KStdAccel::StdAccel id,
                const QObject* pObjSlot, const char* psMethodSlot,
                bool bConfigurable, bool bEnabled )
{
        QString sAction = KStdAccel::name( id );
        if( sAction.isEmpty() )
                return 0;

        KAccelAction* pAction = d->insert( sAction, KStdAccel::label( id ), KStdAccel::whatsThis( id ),
                KStdAccel::shortcutDefault3( id ), KStdAccel::shortcutDefault4( id ),
                pObjSlot, psMethodSlot,
                bConfigurable, bEnabled );
        if( pAction )
                pAction->setShortcut( KStdAccel::shortcut( id ) );

        return pAction;
}

bool KAccel::remove( const QString& sAction )
        { return d->removeAction( sAction ); }
bool KAccel::updateConnections()
        { return d->updateConnections(); }

const KShortcut& KAccel::shortcut( const QString& sAction ) const
{
        const KAccelAction* pAction = actions().actionPtr( sAction );
        return (pAction) ? pAction->shortcut() : KShortcut::null();
}

bool KAccel::setSlot( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot )
        { return d->setActionSlot( sAction, pObjSlot, psMethodSlot ); }

bool KAccel::setEnabled( const QString& sAction, bool bEnable )
        { return d->setEnabled( sAction, bEnable ); }

bool KAccel::setShortcut( const QString& sAction, const KShortcut& cut )
{
        kdDebug(125) << "KAccel::setShortcut( \"" << sAction << "\", " << cut.toStringInternal() << " )" << endl;
        KAccelAction* pAction = actions().actionPtr( sAction );
        if( pAction ) {
                if( pAction->shortcut() != cut )
                        return d->setShortcut( sAction, cut );
                return true;
        }
        return false;
}

const QString& KAccel::configGroup() const
        { return d->configGroup(); }

void KAccel::setConfigGroup( const QString& s )
        { d->setConfigGroup( s ); }

bool KAccel::readSettings( KConfigBase* pConfig )
{
        d->readSettings( pConfig );
        return true;
}

bool KAccel::writeSettings( KConfigBase* pConfig ) const
        { d->writeSettings( pConfig ); return true; }

void KAccel::emitKeycodeChanged()
{
        kdDebug(125) << "KAccel::emitKeycodeChanged()" << endl;
        keycodeChanged();
}






bool KAccel::insertItem( const QString& sLabel, const QString& sAction,
                const char* cutsDef,
                int , QPopupMenu *, bool bConfigurable )
{
        KShortcut cut( cutsDef );
        bool b = d->insert( sAction, sLabel, QString::null,
                cut, cut,
                0, 0,
                bConfigurable ) != 0;
        return b;
}

bool KAccel::insertItem( const QString& sLabel, const QString& sAction,
                int key,
                int , QPopupMenu*, bool bConfigurable )
{
        KShortcut cut;
        cut.init( QKeySequence(key) );
        KAccelAction* pAction = d->insert( sAction, sLabel, QString::null,
                cut, cut,
                0, 0,
                bConfigurable );
        return pAction != 0;
}


bool KAccel::insertStdItem( KStdAccel::StdAccel id, const QString& sLabel )
{
        KAccelAction* pAction = d->insert( KStdAccel::action( id ), sLabel, QString::null,
                KStdAccel::shortcutDefault3( id ), KStdAccel::shortcutDefault4( id ),
                0, 0 );
        if( pAction )
                pAction->setShortcut( KStdAccel::shortcut( id ) );

        return true;
}

bool KAccel::connectItem( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot, bool bActivate )
{
        kdDebug(125) << "KAccel::connectItem( " << sAction << ", " << pObjSlot << ", " << psMethodSlot << " )" << endl;
        if( bActivate == false )
                d->setActionEnabled( sAction, false );
        bool b = setSlot( sAction, pObjSlot, psMethodSlot );
        if( bActivate == true )
                d->setActionEnabled( sAction, true );
        return b;
}

bool KAccel::removeItem( const QString& sAction )
        { return d->removeAction( sAction ); }

bool KAccel::setItemEnabled( const QString& sAction, bool bEnable )
        { return setEnabled( sAction, bEnable ); }

void KAccel::changeMenuAccel( QPopupMenu *menu, int id, const QString& action )
{
        KAccelAction* pAction = actions().actionPtr( action );
        QString s = menu->text( id );
        if( !pAction || s.isEmpty() )
                return;

        int i = s.find( '\t' );

        QString k = pAction->shortcut().seq(0).toString();
        if( k.isEmpty() )
                return;

        if ( i >= 0 )
                s.replace( i+1, s.length()-i, k );
        else {
                s += '\t';
                s += k;
        }

        QPixmap *pp = menu->pixmap(id);
        if( pp && !pp->isNull() )
                menu->changeItem( *pp, s, id );
        else
                menu->changeItem( s, id );
}

void KAccel::changeMenuAccel( QPopupMenu *menu, int id, KStdAccel::StdAccel accel )
{
        changeMenuAccel( menu, id, KStdAccel::name( accel ) );
}

int KAccel::stringToKey( const QString& sKey )
{
        return KKey( sKey ).keyCodeQt();
}

int KAccel::currentKey( const QString& sAction ) const
{
        KAccelAction* pAction = d->actionPtr( sAction );
        if( pAction )
                return pAction->shortcut().keyCodeQt();
        return 0;
}

QString KAccel::findKey( int key ) const
{
        KAccelAction* pAction = d->actionPtr( KKey(key) );
        if( pAction )
                return pAction->name();
        else
                return QString::null;
}


void KAccel::virtual_hook( int, void* )
{ }

# 1 "../kdecore/kaccel.moc" 1
# 11 "../kdecore/kaccel.moc"
# 1 "../../../prod/kdelibs/kdecore/kaccel.h" 1
# 12 "../kdecore/kaccel.moc" 2
# 22 "../kdecore/kaccel.moc"
const char *KAccel::className() const
{
    return "KAccel";
}

QMetaObject *KAccel::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KAccel( "KAccel", &KAccel::staticMetaObject );
# 50 "../kdecore/kaccel.moc"
QMetaObject* KAccel::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QAccel::staticMetaObject();
    static const QUMethod signal_0 = {"keycodeChanged", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "keycodeChanged()", &signal_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KAccel", parentObject,
        0, 0,
        signal_tbl, 1,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KAccel.setMetaObject( metaObj );
    return metaObj;
}

void* KAccel::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KAccel" ) )
        return this;
    return QAccel::qt_cast( clname );
}


void KAccel::keycodeChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 0 );
}

bool KAccel::qt_invoke( int _id, QUObject* _o )
{
    return QAccel::qt_invoke(_id,_o);
}

bool KAccel::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: keycodeChanged(); break;
    default:
        return QAccel::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KAccel::qt_property( int id, int f, QVariant* v)
{
    return QAccel::qt_property( id, f, v);
}

bool KAccel::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 582 "/coolo/prod/kdelibs/kdecore/kaccel.cpp" 2
# 1 "../kdecore/kaccelprivate.moc" 1
# 11 "../kdecore/kaccelprivate.moc"
# 1 "../../../prod/kdelibs/kdecore/kaccelprivate.h" 1
# 12 "../kdecore/kaccelprivate.moc" 2
# 22 "../kdecore/kaccelprivate.moc"
const char *KAccelPrivate::className() const
{
    return "KAccelPrivate";
}

QMetaObject *KAccelPrivate::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KAccelPrivate( "KAccelPrivate", &KAccelPrivate::staticMetaObject );
# 50 "../kdecore/kaccelprivate.moc"
QMetaObject* KAccelPrivate::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { "id", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_0 = {"slotKeyPressed", 1, param_slot_0 };
    static const QUMethod slot_1 = {"slotShowMenu", 0, 0 };
    static const QUParameter param_slot_2[] = {
        { "iAction", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_2 = {"slotMenuActivated", 1, param_slot_2 };
    static const QUParameter param_slot_3[] = {
        { 0, &static_QUType_bool, 0, QUParameter::Out },
        { "pWatched", &static_QUType_ptr, "QObject", QUParameter::In },
        { "pEvent", &static_QUType_ptr, "QEvent", QUParameter::In }
    };
    static const QUMethod slot_3 = {"eventFilter", 3, param_slot_3 };
    static const QMetaData slot_tbl[] = {
        { "slotKeyPressed(int)", &slot_0, QMetaData::Private },
        { "slotShowMenu()", &slot_1, QMetaData::Private },
        { "slotMenuActivated(int)", &slot_2, QMetaData::Private },
        { "eventFilter(QObject*,QEvent*)", &slot_3, QMetaData::Private }
    };
    static const QUMethod signal_0 = {"menuItemActivated", 0, 0 };
    static const QUParameter param_signal_1[] = {
        { 0, &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_1 = {"activateInt", 1, param_signal_1 };
    static const QMetaData signal_tbl[] = {
        { "menuItemActivated()", &signal_0, QMetaData::Public },
        { "activateInt(int)", &signal_1, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KAccelPrivate", parentObject,
        slot_tbl, 4,
        signal_tbl, 2,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KAccelPrivate.setMetaObject( metaObj );
    return metaObj;
}

void* KAccelPrivate::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KAccelPrivate" ) )
        return this;
    if ( !qstrcmp( clname, "KAccelBase" ) )
        return (KAccelBase*)this;
    return QObject::qt_cast( clname );
}


void KAccelPrivate::menuItemActivated()
{
    activate_signal( staticMetaObject()->signalOffset() + 0 );
}


void KAccelPrivate::activateInt( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 1, t0 );
}

bool KAccelPrivate::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotKeyPressed((int)static_QUType_int.get(_o+1)); break;
    case 1: slotShowMenu(); break;
    case 2: slotMenuActivated((int)static_QUType_int.get(_o+1)); break;
    case 3: static_QUType_bool.set(_o,eventFilter((QObject*)static_QUType_ptr.get(_o+1),(QEvent*)static_QUType_ptr.get(_o+2))); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KAccelPrivate::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: menuItemActivated(); break;
    case 1: activateInt((int)static_QUType_int.get(_o+1)); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KAccelPrivate::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KAccelPrivate::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 583 "/coolo/prod/kdelibs/kdecore/kaccel.cpp" 2
# 36 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.cpp" 1
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 2 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.cpp" 2




# 1 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.h" 1

# 14 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.h"
class KGlobalAccelPrivate : public QWidget, public KAccelBase
{
        friend class KGlobalAccel;
        public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
 public:
        KGlobalAccelPrivate();
        virtual ~KGlobalAccelPrivate();

        virtual void setEnabled( bool );

        virtual bool emitSignal( Signal );
        virtual bool connectKey( KAccelAction&, const KKeyServer::Key& );
        virtual bool connectKey( const KKeyServer::Key& );
        virtual bool disconnectKey( KAccelAction&, const KKeyServer::Key& );
        virtual bool disconnectKey( const KKeyServer::Key& );

 protected:




        class CodeMod
        {
         public:



                uchar code;



                uint mod;




                bool operator < ( const CodeMod& b ) const
                {
                        if( code < b.code ) return true;
                        if( code == b.code && mod < b.mod ) return true;
                        return false;
                }
        };
        typedef QMap<CodeMod, KAccelAction*> CodeModMap;

        CodeModMap m_rgCodeModToAction;




        bool grabKey( const KKeyServer::Key&, bool bGrab, KAccelAction* );
# 73 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.h"
        virtual bool x11Event( XEvent* );
        void x11MappingNotify();
        bool x11KeyPress( const XEvent *pEvent );
        void activate( KAccelAction* pAction, const KKeySequence& seq );

 protected :
        void slotActivated( int iAction );
};
# 7 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h"




class QPopupMenu;
class QWidget;
class KAccelAction;
class KAccelActions;
class KConfigBase;

class KGlobalAccelPrivate;
# 45 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h"
class KGlobalAccel : public QObject
{
        public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
 public:






        KGlobalAccel( QObject* pParent, const char* psName = 0 );
        virtual ~KGlobalAccel();





        bool isEnabled();





        void setEnabled( bool bEnabled );
# 92 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h"
        KAccelAction* insert( const QString& sAction, const QString& sLabel, const QString& sWhatsThis,
                         const KShortcut& cutDef3, const KShortcut& cutDef4,
                         const QObject* pObjSlot, const char* psMethodSlot,
                         bool bConfigurable = true, bool bEnabled = true );







        bool remove( const QString& sAction );
# 112 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h"
        KAccelAction* insert( const QString& sName, const QString& sLabel );





        bool updateConnections();






        const KShortcut& shortcut( const QString& sAction ) const;






        bool setShortcut( const QString& sAction, const KShortcut &shortcut );
# 141 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h"
        bool setSlot( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot );






        bool setEnabled( const QString& sAction, bool bEnabled );






        const QString& configGroup() const;






        void setConfigGroup( const QString &cg );
# 172 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h"
        bool readSettings( KConfigBase* pConfig = 0 );
# 183 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h"
        bool writeSettings( KConfigBase* pConfig = 0 ) const;
# 195 "/coolo/prod/kdelibs/kdecore/kglobalaccel.h"
        bool writeSettings( KConfigBase* pConfig, bool bGlobal ) const;





        static bool useFourModifierKeys();

 private:

        KAccelActions& actions();
        const KAccelActions& actions() const;

        friend class KGlobalAccelPrivate;
        friend class KAccelShortcutList;
protected:

        virtual void virtual_hook( int id, void* data );
private:
        class KGlobalAccelPrivate* d;
};
# 8 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.cpp" 2
# 25 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.cpp"
# 1 "/usr/X11R6/include/X11/keysym.h" 1
# 52 "/usr/X11R6/include/X11/keysym.h"

# 1 "/usr/X11R6/include/X11/keysymdef.h" 1
# 52 "/usr/X11R6/include/X11/keysymdef.h"
# 61 "/usr/X11R6/include/X11/keysymdef.h"





















# 189 "/usr/X11R6/include/X11/keysymdef.h"




# 275 "/usr/X11R6/include/X11/keysymdef.h"






# 429 "/usr/X11R6/include/X11/keysymdef.h"

# 635 "/usr/X11R6/include/X11/keysymdef.h"
# 700 "/usr/X11R6/include/X11/keysymdef.h"
# 731 "/usr/X11R6/include/X11/keysymdef.h"







# 808 "/usr/X11R6/include/X11/keysymdef.h"
# 819 "/usr/X11R6/include/X11/keysymdef.h"
# 897 "/usr/X11R6/include/X11/keysymdef.h"









# 1144 "/usr/X11R6/include/X11/keysymdef.h"
# 1434 "/usr/X11R6/include/X11/keysymdef.h"
# 1482 "/usr/X11R6/include/X11/keysymdef.h"
# 1575 "/usr/X11R6/include/X11/keysymdef.h"














# 1705 "/usr/X11R6/include/X11/keysymdef.h"
# 1815 "/usr/X11R6/include/X11/keysymdef.h"
# 1863 "/usr/X11R6/include/X11/keysymdef.h"



# 1902 "/usr/X11R6/include/X11/keysymdef.h"




# 74 "/usr/X11R6/include/X11/keysym.h" 2
# 26 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/fixx11h.h" 1
# 31 "/coolo/prod/kdelibs/kdecore/fixx11h.h"
namespace X
{
# 220 "/coolo/prod/kdelibs/kdecore/fixx11h.h"
}

using namespace X;
# 27 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.cpp" 2

extern "C" {
  static int XGrabErrorHandler( Display *, XErrorEvent *e ) {
        if ( e->error_code != 10 ) {
            kdWarning() << "grabKey: got X error " << e->type << " instead of BadAccess\n";
        }
        return 1;
  }
}







static uint g_keyModMaskXAccel = 0;
static uint g_keyModMaskXOnOrOff = 0;

static void calculateGrabMasks()
{
        g_keyModMaskXAccel = KKeyServer::accelModMaskX();
        g_keyModMaskXOnOrOff =
                        KKeyServer::modXLock() |
                        KKeyServer::modXNumLock() |
                        KKeyServer::modXScrollLock();


}



KGlobalAccelPrivate::KGlobalAccelPrivate()
: KAccelBase( KAccelBase::NATIVE_KEYS )
{
        m_sConfigGroup = "Global Shortcuts";
        KApplication::kApplication()->installX11EventFilter( this );
}

KGlobalAccelPrivate::~KGlobalAccelPrivate()
{




}

void KGlobalAccelPrivate::setEnabled( bool bEnable )
{
        m_bEnabled = bEnable;

}

bool KGlobalAccelPrivate::emitSignal( Signal )
{
        return false;
}

bool KGlobalAccelPrivate::connectKey( KAccelAction& action, const KKeyServer::Key& key )
        { return grabKey( key, true, &action ); }
bool KGlobalAccelPrivate::connectKey( const KKeyServer::Key& key )
        { return grabKey( key, true, 0 ); }
bool KGlobalAccelPrivate::disconnectKey( KAccelAction& action, const KKeyServer::Key& key )
        { return grabKey( key, false, &action ); }
bool KGlobalAccelPrivate::disconnectKey( const KKeyServer::Key& key )
        { return grabKey( key, false, 0 ); }

bool KGlobalAccelPrivate::grabKey( const KKeyServer::Key& key, bool bGrab, KAccelAction* pAction )
{
        if( !key.code() ) {
                kdWarning(125) << "KGlobalAccelPrivate::grabKey( " << key.key().toStringInternal() << ", " << bGrab << ", \"" << (pAction ? pAction->name().latin1() : "(null)") << "\" ): Tried to grab key with null code." << endl;
                return false;
        }


        if( g_keyModMaskXOnOrOff == 0 )
                calculateGrabMasks();

        uchar keyCodeX = key.code();
        uint keyModX = key.mod() & g_keyModMaskXAccel;



        kdDebug(125) << QString( "grabKey( key: '%1', bGrab: %2 ): keyCodeX: %3 keyModX: %4\n" )
                .arg( key.key().toStringInternal() ).arg( bGrab )
                .arg( keyCodeX, 0, 16 ).arg( keyModX, 0, 16 );

        if( !keyCodeX )
                return false;


        KXErrorHandler handler( XGrabErrorHandler );







        QString sDebug = QString("\tcode: 0x%1 state: 0x%2 | ").arg(keyCodeX,0,16).arg(keyModX,0,16);

        uint keyModMaskX = ~g_keyModMaskXOnOrOff;
        for( uint irrelevantBitsMask = 0; irrelevantBitsMask <= 0xff; irrelevantBitsMask++ ) {
                if( (irrelevantBitsMask & keyModMaskX) == 0 ) {

                        sDebug += QString("0x%3, ").arg(irrelevantBitsMask, 0, 16);

                        if( bGrab )
                                XGrabKey( qt_xdisplay(), keyCodeX, keyModX | irrelevantBitsMask,
                                        qt_xrootwin(), 1, 1, 0 );
                        else
                                XUngrabKey( qt_xdisplay(), keyCodeX, keyModX | irrelevantBitsMask, qt_xrootwin() );
                }
        }

        kdDebug(125) << sDebug << endl;


        bool failed = false;
        if( bGrab ) {

                failed = handler.error( true );


                if( failed ) {
                        kdDebug(125) << "grab failed!\n";
                        for( uint m = 0; m <= 0xff; m++ ) {
                                if( m & keyModMaskX == 0 )
                                        XUngrabKey( qt_xdisplay(), keyCodeX, keyModX | m, qt_xrootwin() );
                                }
                }
        }
        if( !failed )
        {
                CodeMod codemod;
                codemod.code = keyCodeX;
                codemod.mod = keyModX;
                if( key.mod() & KKeyServer::MODE_SWITCH )
                        codemod.mod |= KKeyServer::MODE_SWITCH;

                if( bGrab )
                        m_rgCodeModToAction.insert( codemod, pAction );
                else
                        m_rgCodeModToAction.remove( codemod );
        }
        return !failed;
}

bool KGlobalAccelPrivate::x11Event( XEvent* pEvent )
{

        switch( pEvent->type ) {
         case 34:
                XRefreshKeyboardMapping( &pEvent->xmapping );
                x11MappingNotify();
                return false;
         case XKeyPress:
                if( x11KeyPress( pEvent ) )
                        return true;
         default:
                return QWidget::x11Event( pEvent );
        }
}

void KGlobalAccelPrivate::x11MappingNotify()
{
        kdDebug(125) << "KGlobalAccelPrivate::x11MappingNotify()" << endl;
        if( m_bEnabled ) {

                KKeyServer::initializeMods();
                calculateGrabMasks();

                updateConnections();
        }
}

bool KGlobalAccelPrivate::x11KeyPress( const XEvent *pEvent )
{

        if ( !QWidget::keyboardGrabber() && !QApplication::activePopupWidget() ) {
                XUngrabKeyboard( qt_xdisplay(), pEvent->xkey.time );
                XFlush( qt_xdisplay());
        }

        if( !m_bEnabled )
                return false;

        CodeMod codemod;
        codemod.code = pEvent->xkey.keycode;
        codemod.mod = pEvent->xkey.state & (g_keyModMaskXAccel | KKeyServer::MODE_SWITCH);



        if( pEvent->xkey.state & KKeyServer::modXNumLock() ) {

                uint sym = XKeycodeToKeysym( qt_xdisplay(), codemod.code, 0 );

                if( sym >= 0xFF80 && sym <= 0xFFB9 ) {
                        switch( sym ) {


                                case 0xFFAA:
                                case 0xFFAB:
                                case 0xFFAD:
                                case 0xFFAF:
                                        break;
                                default:
                                        if( codemod.mod & KKeyServer::modXShift() )
                                                codemod.mod &= ~KKeyServer::modXShift();
                                        else
                                                codemod.mod |= KKeyServer::modXShift();
                        }
                }
        }

        KKeyNative keyNative( pEvent );
        KKey key = keyNative;

        kdDebug(125) << "x11KeyPress: seek " << key.toStringInternal()
                << QString( " keyCodeX: %1 state: %2 keyModX: %3" )
                        .arg( codemod.code, 0, 16 ).arg( pEvent->xkey.state, 0, 16 ).arg( codemod.mod, 0, 16 ) << endl;


        if( !m_rgCodeModToAction.contains( codemod ) ) {

                for( CodeModMap::ConstIterator it = m_rgCodeModToAction.begin(); it != m_rgCodeModToAction.end(); ++it ) {
                        KAccelAction* pAction = *it;
                        kdDebug(125) << "\tcode: " << QString::number(it.key().code, 16) << " mod: " << QString::number(it.key().mod, 16)
                                << (pAction ? QString(" name: \"%1\" shortcut: %2").arg(pAction->name()).arg(pAction->shortcut().toStringInternal()) : QString::null)
                                << endl;
                }

                return false;
        }
        KAccelAction* pAction = m_rgCodeModToAction[codemod];

        if( !pAction ) {
                static bool recursion_block = false;
                if( !recursion_block ) {
                        recursion_block = true;
                        QPopupMenu* pMenu = createPopupMenu( 0, KKeySequence(key) );
                        connect( pMenu, "2""activated(int)", this, "1""slotActivated(int)" );
                        pMenu->exec( QPoint( 0, 0 ) );
                        disconnect( pMenu, "2""activated(int)", this, "1""slotActivated(int)");
                        delete pMenu;
                        recursion_block = false;
                }
        } else if( !pAction->objSlotPtr() || !pAction->isEnabled() )
                return false;
        else
                activate( pAction, KKeySequence(key) );

        return true;
}

void KGlobalAccelPrivate::activate( KAccelAction* pAction, const KKeySequence& seq )
{
        kdDebug(125) << "KGlobalAccelPrivate::activate( \"" << pAction->name() << "\" ) " << endl;

        QRegExp rexPassIndex( "([ ]*int[ ]*)" );
        QRegExp rexPassInfo( " QString" );
        QRegExp rexIndex( " ([0-9]+)$" );




        if( rexPassIndex.search( pAction->methodSlotPtr() ) >= 0 && rexIndex.search( pAction->name() ) >= 0 ) {
                int n = rexIndex.cap(1).toInt();
                kdDebug(125) << "Calling " << pAction->methodSlotPtr() << " int = " << n << endl;
                int slot_id = pAction->objSlotPtr()->metaObject()->findSlot( normalizeSignalSlot( pAction->methodSlotPtr() ).data() + 1, true );
                if( slot_id >= 0 ) {
                    QUObject o[2];
                    static_QUType_int.set(o+1,n);
                    const_cast< QObject* >( pAction->objSlotPtr())->qt_invoke( slot_id, o );
                }
        } else if( rexPassInfo.search( pAction->methodSlotPtr() ) ) {
                int slot_id = pAction->objSlotPtr()->metaObject()->findSlot( normalizeSignalSlot( pAction->methodSlotPtr() ).data() + 1, true );
                if( slot_id >= 0 ) {
                    QUObject o[4];
                    static_QUType_QString.set(o+1,pAction->name());
                    static_QUType_QString.set(o+2,pAction->label());
                    static_QUType_ptr.set(o+3,&seq);
                    const_cast< QObject* >( pAction->objSlotPtr())->qt_invoke( slot_id, o );
                }
        } else {
                int slot_id = pAction->objSlotPtr()->metaObject()->findSlot( normalizeSignalSlot( pAction->methodSlotPtr() ).data() + 1, true );
                if( slot_id >= 0 )
                    const_cast< QObject* >( pAction->objSlotPtr())->qt_invoke( slot_id, 0 );
        }
}

void KGlobalAccelPrivate::slotActivated( int iAction )
{
        KAccelAction* pAction = actions().actionPtr( iAction );
        if( pAction )
                activate( pAction, KKeySequence() );
}

# 1 "../kdecore/kglobalaccel_x11.moc" 1
# 11 "../kdecore/kglobalaccel_x11.moc"
# 1 "../../../prod/kdelibs/kdecore/kglobalaccel_x11.h" 1
# 12 "../kdecore/kglobalaccel_x11.moc" 2
# 22 "../kdecore/kglobalaccel_x11.moc"
const char *KGlobalAccelPrivate::className() const
{
    return "KGlobalAccelPrivate";
}

QMetaObject *KGlobalAccelPrivate::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KGlobalAccelPrivate( "KGlobalAccelPrivate", &KGlobalAccelPrivate::staticMetaObject );
# 50 "../kdecore/kglobalaccel_x11.moc"
QMetaObject* KGlobalAccelPrivate::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QWidget::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { "iAction", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_0 = {"slotActivated", 1, param_slot_0 };
    static const QMetaData slot_tbl[] = {
        { "slotActivated(int)", &slot_0, QMetaData::Protected }
    };
    metaObj = QMetaObject::new_metaobject(
        "KGlobalAccelPrivate", parentObject,
        slot_tbl, 1,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KGlobalAccelPrivate.setMetaObject( metaObj );
    return metaObj;
}

void* KGlobalAccelPrivate::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KGlobalAccelPrivate" ) )
        return this;
    if ( !qstrcmp( clname, "KAccelBase" ) )
        return (KAccelBase*)this;
    return QWidget::qt_cast( clname );
}

bool KGlobalAccelPrivate::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotActivated((int)static_QUType_int.get(_o+1)); break;
    default:
        return QWidget::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KGlobalAccelPrivate::qt_emit( int _id, QUObject* _o )
{
    return QWidget::qt_emit(_id,_o);
}


bool KGlobalAccelPrivate::qt_property( int id, int f, QVariant* v)
{
    return QWidget::qt_property( id, f, v);
}

bool KGlobalAccelPrivate::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 326 "/coolo/prod/kdelibs/kdecore/kglobalaccel_x11.cpp" 2
# 37 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kglobalaccel.cpp" 1
# 16 "/coolo/prod/kdelibs/kdecore/kglobalaccel.cpp"
KGlobalAccel::KGlobalAccel( QObject* pParent, const char* psName )
: QObject( pParent, psName )
{
        kdDebug(125) << "KGlobalAccel(): this = " << this << endl;
        d = new KGlobalAccelPrivate();
}

KGlobalAccel::~KGlobalAccel()
{
        kdDebug(125) << "~KGlobalAccel(): this = " << this << endl;
        delete d;
}





KAccelActions& KGlobalAccel::actions()
        { return d->actions(); }

const KAccelActions& KGlobalAccel::actions() const
        { return d->actions(); }

bool KGlobalAccel::isEnabled()
        { return ((KAccelBase*)d)->isEnabled(); }

void KGlobalAccel::setEnabled( bool bEnabled )
        { d->setEnabled( bEnabled ); }

KAccelAction* KGlobalAccel::insert( const QString& sAction, const QString& sDesc, const QString& sHelp,
                const KShortcut& cutDef3, const KShortcut& cutDef4,
                const QObject* pObjSlot, const char* psMethodSlot,
                bool bConfigurable, bool bEnabled )
{
        return d->insert( sAction, sDesc, sHelp,
                cutDef3, cutDef4,
                pObjSlot, psMethodSlot,
                bConfigurable, bEnabled );
}

KAccelAction* KGlobalAccel::insert( const QString& sName, const QString& sDesc )
        { return d->insert( sName, sDesc ); }
bool KGlobalAccel::updateConnections()
        { return d->updateConnections(); }

bool KGlobalAccel::remove( const QString& sAction )
        { return d->remove( sAction ); }

const KShortcut& KGlobalAccel::shortcut( const QString& sAction ) const
{
        const KAccelAction* pAction = d->actions().actionPtr( sAction );
        return (pAction) ? pAction->shortcut() : KShortcut::null();
}

bool KGlobalAccel::setShortcut( const QString& sAction, const KShortcut& cut )
        { return d->setShortcut( sAction, cut ); }
bool KGlobalAccel::setSlot( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot )
        { return d->setActionSlot( sAction, pObjSlot, psMethodSlot ); }

const QString& KGlobalAccel::configGroup() const
        { return d->configGroup(); }

void KGlobalAccel::setConfigGroup( const QString& s )
        { d->setConfigGroup( s ); }

bool KGlobalAccel::readSettings( KConfigBase* pConfig )
        { d->readSettings( pConfig ); return true; }
bool KGlobalAccel::writeSettings( KConfigBase* pConfig ) const
        { d->writeSettings( pConfig ); return true; }
bool KGlobalAccel::writeSettings( KConfigBase* pConfig, bool bGlobal ) const
{
        d->setConfigGlobal( bGlobal );
        d->writeSettings( pConfig );
        return true;
}

bool KGlobalAccel::useFourModifierKeys()
        { return KAccelAction::useFourModifierKeys(); }

void KGlobalAccel::virtual_hook( int, void* )
{ }

# 1 "../kdecore/kglobalaccel.moc" 1
# 11 "../kdecore/kglobalaccel.moc"
# 1 "../../../prod/kdelibs/kdecore/kglobalaccel.h" 1
# 12 "../kdecore/kglobalaccel.moc" 2
# 22 "../kdecore/kglobalaccel.moc"
const char *KGlobalAccel::className() const
{
    return "KGlobalAccel";
}

QMetaObject *KGlobalAccel::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KGlobalAccel( "KGlobalAccel", &KGlobalAccel::staticMetaObject );
# 50 "../kdecore/kglobalaccel.moc"
QMetaObject* KGlobalAccel::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KGlobalAccel", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KGlobalAccel.setMetaObject( metaObj );
    return metaObj;
}

void* KGlobalAccel::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KGlobalAccel" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KGlobalAccel::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KGlobalAccel::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KGlobalAccel::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KGlobalAccel::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 99 "/coolo/prod/kdelibs/kdecore/kglobalaccel.cpp" 2
# 38 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kstdaccel.cpp" 1
# 20 "/coolo/prod/kdelibs/kdecore/kstdaccel.cpp"
# 33 "/coolo/prod/kdelibs/kdecore/kstdaccel.cpp"
namespace KStdAccel
{

struct KStdAccelInfo
{
        StdAccel id;
        const char* psName;
        const char* psDesc;
        int cutDefault, cutDefault4, cutDefault3B, cutDefault4B;
        KShortcut cut;
        bool bInitialized;
};

static KStdAccelInfo g_infoStdAccel[] =
{
        {AccelNone, "Group:File", ("File"), 0, 0, 0, 0, KShortcut(), false },
        { Open, ("Open"), 0, Qt::CTRL+Qt::Key_O, 0, 0, 0, KShortcut(), false },
        { New, ("New"), 0, Qt::CTRL+Qt::Key_N, 0, 0, 0, KShortcut(), false },
        { Close, ("Close"), 0, Qt::CTRL+Qt::Key_W, Qt::CTRL+Qt::Key_Escape, 0, Qt::CTRL+Qt::Key_W, KShortcut(), false },
        { Save, ("Save"), 0, Qt::CTRL+Qt::Key_S, 0, 0, 0, KShortcut(), false },
        { Print, ("Print"), 0, Qt::CTRL+Qt::Key_P, 0, 0, 0, KShortcut(), false },
        { Quit, ("Quit"), 0, Qt::CTRL+Qt::Key_Q, 0, 0, 0, KShortcut(), false },
        {AccelNone, "Group:Edit", ("Edit"), 0, 0, 0, 0, KShortcut(), false },
        { Undo, ("Undo"), 0, Qt::CTRL+Qt::Key_Z, 0, 0, 0, KShortcut(), false },
        { Redo, ("Redo"), 0, Qt::CTRL+Qt::SHIFT+Qt::Key_Z, 0, 0, 0, KShortcut(), false },
        { Cut, ("Cut"), 0, Qt::CTRL+Qt::Key_X, 0, Qt::SHIFT+Qt::Key_Delete, 0, KShortcut(), false },
        { Copy, ("Copy"), 0, Qt::CTRL+Qt::Key_C, 0, Qt::CTRL+Qt::Key_Insert, 0, KShortcut(), false },
        { Paste, ("Paste"), 0, Qt::CTRL+Qt::Key_V, 0, Qt::SHIFT+Qt::Key_Insert, 0, KShortcut(), false },
        { SelectAll, "SelectAll", ("Select All"), Qt::CTRL+Qt::Key_A, 0, 0, 0, KShortcut(), false },
        { Deselect, ("Deselect"), 0, Qt::CTRL+Qt::SHIFT+Qt::Key_A, 0, 0, 0, KShortcut(), false },
        { DeleteWordBack, "DeleteWordBack", ("Delete Word Backwards"), Qt::CTRL+Qt::Key_Backspace, 0, 0, 0, KShortcut(), false },
        { DeleteWordForward, "DeleteWordForward", ("Delete Word Forward"), Qt::CTRL+Qt::Key_Delete, 0, 0, 0, KShortcut(), false },
        { Find, ("Find"), 0, Qt::CTRL+Qt::Key_F, 0, 0, 0, KShortcut(), false },
        { FindNext, "FindNext", ("Find Next"), Qt::Key_F3, 0, 0, 0, KShortcut(), false },
        { FindPrev, "FindPrev", ("Find Prev"), Qt::SHIFT+Qt::Key_F3, 0, 0, 0, KShortcut(), false },
        { Replace, ("Replace"), 0, Qt::CTRL+Qt::Key_R, 0, 0, 0, KShortcut(), false },
        {AccelNone, "Group:Navigation", ("Navigation"), 0, 0, 0, 0, KShortcut(), false },
        { Home, ("Home"), 0, Qt::CTRL+Qt::Key_Home, 0, 0, 0, KShortcut(), false },
        { End, ("End"), 0, Qt::CTRL+Qt::Key_End, 0, 0, 0, KShortcut(), false },
        { Prior, ("Prior"), 0, Qt::Key_Prior, 0, 0, 0, KShortcut(), false },
        { Next, ("Next"), 0, Qt::Key_Next, 0, 0, 0, KShortcut(), false },
        { GotoLine, "GotoLine", ("Go to Line"), Qt::CTRL+Qt::Key_G, 0, 0, 0, KShortcut(), false },
        { AddBookmark, "AddBookmark", ("Add Bookmark"), Qt::CTRL+Qt::Key_B, 0, 0, 0, KShortcut(), false },
        { ZoomIn, "ZoomIn", ("Zoom In"), Qt::CTRL+Qt::Key_Plus, 0, 0, 0, KShortcut(), false },
        { ZoomOut, "ZoomOut", ("Zoom Out"), Qt::CTRL+Qt::Key_Minus, 0, 0, 0, KShortcut(), false },
        { Up, ("Up"), 0, Qt::ALT+Qt::Key_Up, 0, 0, 0, KShortcut(), false },
        { Back, ("Back"), 0, Qt::ALT+Qt::Key_Left, 0, 0, 0, KShortcut(), false },
        { Forward, ("Forward"), 0, Qt::ALT+Qt::Key_Right, 0, 0, 0, KShortcut(), false },
        { Reload, ("Reload"), 0, Qt::Key_F5, 0, 0, 0, KShortcut(), false },
        { PopupMenuContext, "PopupMenuContext", ("Popup Menu Context"), Qt::Key_Menu, 0, 0, 0, KShortcut(), false },
        { ShowMenubar, "ShowMenubar", ("Show Menu Bar"), Qt::CTRL+Qt::Key_M, 0, 0, 0, KShortcut(), false },
        { TabNext, ("Activate Next Tab"), 0, Qt::CTRL+Qt::Key_Less, 0, Qt::CTRL+Qt::Key_BracketRight, 0, KShortcut(), false },
        { TabPrev, ("Activate Previous Tab"), 0, Qt::CTRL+Qt::Key_Greater, 0, Qt::CTRL+Qt::Key_BracketLeft, 0, KShortcut(), false },
        { FullScreen, "FullScreen", ("Full Screen Mode"), Qt::CTRL+Qt::SHIFT+Qt::Key_F, 0, 0, 0, KShortcut(), false },
        {AccelNone, "Group:Help", ("Help"), 0, 0, 0, 0, KShortcut(), false },
        { Help, ("Help"), 0, Qt::Key_F1, 0, 0, 0, KShortcut(), false },
        { WhatsThis, "WhatsThis", ("What's This"), Qt::SHIFT+Qt::Key_F1, 0, 0, 0, KShortcut(), false },
        {AccelNone, "Group:TextCompletion", ("Text Completion"), 0, 0, 0, 0, KShortcut(), false },
        { TextCompletion, "TextCompletion", ("Text Completion"), Qt::CTRL+Qt::Key_E, 0, 0, 0, KShortcut(), false },
        { PrevCompletion, "PrevCompletion", ("Previous Completion Match"), Qt::CTRL+Qt::Key_Up, 0, 0, 0, KShortcut(), false },
        { NextCompletion, "NextCompletion", ("Next Completion Match"), Qt::CTRL+Qt::Key_Down, 0, 0, 0, KShortcut(), false },
        { SubstringCompletion, "SubstringCompletion", ("Substring Completion"), Qt::CTRL+Qt::Key_T, 0, 0, 0, KShortcut(), false },
        { RotateUp, "RotateUp", ("Previous Item in List"), Qt::Key_Up, 0, 0, 0, KShortcut(), false },
        { RotateDown, "RotateDown", ("Next Item in List"), Qt::Key_Down, 0, 0, 0, KShortcut(), false },
        { AccelNone, 0, 0, 0, 0, 0, 0, KShortcut(), false }
};

static KStdAccelInfo* infoPtr( StdAccel id )
{
        if( id != AccelNone ) {
                for( uint i = 0; g_infoStdAccel[i].psName != 0; i++ ) {
                        if( g_infoStdAccel[i].id == id )
                                return &g_infoStdAccel[i];
                }
        }
        return 0;
}

static void initialize( StdAccel id )
{
        KConfigGroupSaver saver( KGlobal::config(), "Shortcuts" );
        KStdAccelInfo* pInfo = infoPtr( id );

        if( !pInfo ) {
                kdWarning(125) << "KStdAccel: id not found!" << endl;
                return;
        }

        if( saver.config()->hasKey( pInfo->psName ) ) {
                QString s = saver.config()->readEntry( pInfo->psName );
                if( s != "none" )
                        pInfo->cut.init( s );
                else
                        pInfo->cut.clear();
        } else
                pInfo->cut = shortcutDefault( id );
        pInfo->bInitialized = true;
}

QString name( StdAccel id )
{
        KStdAccelInfo* pInfo = infoPtr( id );
        if( !pInfo )
                return QString::null;
        return pInfo->psName;
}

QString label( StdAccel id )
{
        KStdAccelInfo* pInfo = infoPtr( id );
        if( !pInfo )
                return QString::null;
        return i18n((pInfo->psDesc) ? pInfo->psDesc : pInfo->psName);
}


QString whatsThis( StdAccel )
{




                return QString::null;
}

const KShortcut& shortcut( StdAccel id )
{
        KStdAccelInfo* pInfo = infoPtr( id );
        if( !pInfo )
                return KShortcut::null();

        if( !pInfo->bInitialized )
                initialize( id );

        return pInfo->cut;
}

StdAccel findStdAccel( const KKeySequence& seq )
{
        if( !seq.isNull() ) {
                for( uint i = 0; g_infoStdAccel[i].psName != 0; i++ ) {
                        StdAccel id = g_infoStdAccel[i].id;
                        if( id != AccelNone ) {
                                if( !g_infoStdAccel[i].bInitialized )
                                        initialize( id );
                                if( g_infoStdAccel[i].cut.contains( seq ) )
                                        return id;
                        }
                }
        }
        return AccelNone;
}

KShortcut shortcutDefault( StdAccel id )
{
        return (KAccelAction::useFourModifierKeys())
                ? shortcutDefault4(id) : shortcutDefault3(id);
}

KShortcut shortcutDefault3( StdAccel id )
{
        KShortcut cut;

        KStdAccelInfo* pInfo = infoPtr( id );
        if( pInfo ) {
                if( pInfo->cutDefault )
                        cut.init( pInfo->cutDefault );


                if( pInfo->cutDefault3B )
                        cut.append( KKey(pInfo->cutDefault3B) );
        }

        return cut;
}

KShortcut shortcutDefault4( StdAccel id )
{
        KShortcut cut;

        KStdAccelInfo* pInfo = infoPtr( id );
        if( pInfo ) {
                KStdAccelInfo& info = *pInfo;
                KKeySequence key2;

                cut.init( (info.cutDefault4) ?
                        QKeySequence(info.cutDefault) : QKeySequence(info.cutDefault4) );

                if( info.cutDefault4B )
                        key2.init( QKeySequence(info.cutDefault4B) );
                else if( info.cutDefault3B )
                        key2.init( QKeySequence(info.cutDefault3B) );

                if( key2.count() )
                        cut.append( key2 );
        }

        return cut;
}

void createAccelActions( KAccelActions& actions )
{
        actions.clear();

        for( uint i = 0; g_infoStdAccel[i].psName != 0; i++ ) {
                StdAccel id = g_infoStdAccel[i].id;
                KStdAccelInfo* pInfo = &g_infoStdAccel[i];

                if( id != AccelNone ) {
                        actions.insert( pInfo->psName,
                                i18n((pInfo->psDesc) ? pInfo->psDesc : pInfo->psName),
                                QString::null,
                                shortcutDefault3(id),
                                shortcutDefault4(id) );
                } else
                        actions.insert( pInfo->psName, i18n(pInfo->psDesc) );
        }
}

const KShortcut& open() { return shortcut( Open ); }
const KShortcut& openNew() { return shortcut( New ); }
const KShortcut& close() { return shortcut( Close ); }
const KShortcut& save() { return shortcut( Save ); }
const KShortcut& print() { return shortcut( Print ); }
const KShortcut& quit() { return shortcut( Quit ); }
const KShortcut& cut() { return shortcut( Cut ); }
const KShortcut& copy() { return shortcut( Copy ); }
const KShortcut& paste() { return shortcut( Paste ); }
const KShortcut& deleteWordBack() { return shortcut( DeleteWordBack ); }
const KShortcut& deleteWordForward() { return shortcut( DeleteWordForward ); }
const KShortcut& undo() { return shortcut( Undo ); }
const KShortcut& redo() { return shortcut( Redo ); }
const KShortcut& find() { return shortcut( Find ); }
const KShortcut& findNext() { return shortcut( FindNext ); }
const KShortcut& findPrev() { return shortcut( FindPrev ); }
const KShortcut& replace() { return shortcut( Replace ); }
const KShortcut& home() { return shortcut( Home ); }
const KShortcut& end() { return shortcut( End ); }
const KShortcut& prior() { return shortcut( Prior ); }
const KShortcut& next() { return shortcut( Next ); }
const KShortcut& gotoLine() { return shortcut( GotoLine ); }
const KShortcut& addBookmark() { return shortcut( AddBookmark ); }
const KShortcut& tabNext() { return shortcut( TabNext ); }
const KShortcut& tabPrev() { return shortcut( TabPrev ); }
const KShortcut& fullScreen() { return shortcut( FullScreen ); }
const KShortcut& zoomIn() { return shortcut( ZoomIn ); }
const KShortcut& zoomOut() { return shortcut( ZoomOut ); }
const KShortcut& help() { return shortcut( Help ); }
const KShortcut& completion() { return shortcut( TextCompletion ); }
const KShortcut& prevCompletion() { return shortcut( PrevCompletion ); }
const KShortcut& nextCompletion() { return shortcut( NextCompletion ); }
const KShortcut& rotateUp() { return shortcut( RotateUp ); }
const KShortcut& rotateDown() { return shortcut( RotateDown ); }
const KShortcut& substringCompletion() { return shortcut( SubstringCompletion ); }
const KShortcut& popupMenuContext() { return shortcut( PopupMenuContext ); }
const KShortcut& whatsThis() { return shortcut( WhatsThis ); }
const KShortcut& reload() { return shortcut( Reload ); }
const KShortcut& selectAll() { return shortcut( SelectAll ); }
const KShortcut& up() { return shortcut( Up ); }
const KShortcut& back() { return shortcut( Back ); }
const KShortcut& forward() { return shortcut( Forward ); }
const KShortcut& showMenubar() { return shortcut( ShowMenubar ); }





ShortcutList::ShortcutList()
        { }

ShortcutList::~ShortcutList()
        { }

uint ShortcutList::count() const
{
        static uint g_nAccels = 0;
        if( g_nAccels == 0 ) {
                for( ; g_infoStdAccel[g_nAccels].psName != 0; g_nAccels++ )
                        ;
        }
        return g_nAccels;
}

QString ShortcutList::name( uint i ) const
        { return g_infoStdAccel[i].psName; }

QString ShortcutList::label( uint i ) const
        { return i18n((g_infoStdAccel[i].psDesc) ? g_infoStdAccel[i].psDesc : g_infoStdAccel[i].psName); }

QString ShortcutList::whatsThis( uint ) const
        { return QString::null; }

const KShortcut& ShortcutList::shortcut( uint i ) const
{
        if( !g_infoStdAccel[i].bInitialized )
                initialize( g_infoStdAccel[i].id );
        return g_infoStdAccel[i].cut;
}

const KShortcut& ShortcutList::shortcutDefault( uint i ) const
{
        static KShortcut cut;
        cut = KStdAccel::shortcutDefault( g_infoStdAccel[i].id );
        return cut;
}

bool ShortcutList::isConfigurable( uint i ) const
        { return (g_infoStdAccel[i].id != AccelNone); }

bool ShortcutList::setShortcut( uint i, const KShortcut& cut )
        { g_infoStdAccel[i].cut = cut; return true; }

QVariant ShortcutList::getOther( Other, uint ) const
        { return QVariant(); }

bool ShortcutList::setOther( Other, uint, QVariant )
        { return false; }

bool ShortcutList::save() const
{
        return writeSettings( QString::null, 0, false, true );
}

QString action(StdAccel id)
        { return name(id); }
QString description(StdAccel id)
        { return label(id); }
int key(StdAccel id)
        { return shortcut(id).keyCodeQt(); }
int defaultKey(StdAccel id)
        { return shortcutDefault(id).keyCodeQt(); }

bool isEqual(const QKeyEvent* ev, int keyQt)
{
        KKey key1( ev ), key2( keyQt );
        return key1 == key2;
}

}

#undef __KSTDACCEL_CPP_
# 39 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kshortcutlist.cpp" 1
# 18 "/coolo/prod/kdelibs/kdecore/kshortcutlist.cpp"
KShortcutList::KShortcutList()
{
}

KShortcutList::~KShortcutList()
{
}

bool KShortcutList::isGlobal( uint ) const
{
        return false;
}

int KShortcutList::index( const QString& sName ) const
{
        uint nSize = count();
        for( uint i = 0;
             i < nSize;
             ++i )
            if( name( i ) == sName )
                return i;
        return -1;
}

int KShortcutList::index( const KKeySequence& seq ) const
{
        if( seq.isNull() )
                return -1;

        uint nSize = count();
        for( uint i = 0; i < nSize; i++ ) {
                if( shortcut(i).contains( seq ) )
                        return i;
        }

        return -1;
}

const KInstance* KShortcutList::instance() const
{
        return 0;
}

QVariant KShortcutList::getOther( Other, uint ) const
{
        return QVariant();
}

bool KShortcutList::setOther( Other, uint, QVariant )
{
        return false;
}

bool KShortcutList::readSettings( const QString& sConfigGroup, KConfigBase* pConfig )
{
        kdDebug(125) << "KShortcutList::readSettings( \"" << sConfigGroup << "\", " << pConfig << " ) start" << endl;
        if( !pConfig )
                pConfig = KGlobal::config();
        QString sGroup = (!sConfigGroup.isEmpty()) ? sConfigGroup : QString("Shortcuts");



        if( sGroup == "Shortcuts" && pConfig->hasGroup( "Keys" ) ) {
                readSettings( "Keys", pConfig );
        }

        kdDebug(125) << "\treadSettings( \"" << sGroup << "\", " << pConfig << " )" << endl;
        if( !pConfig->hasGroup( sGroup ) )
                return true;
        KConfigGroupSaver cgs( pConfig, sGroup );

        uint nSize = count();
        for( uint i = 0; i < nSize; i++ ) {
                if( isConfigurable(i) ) {
                        QString sEntry = pConfig->readEntry( name(i) );
                        if( !sEntry.isEmpty() ) {
                                if( sEntry == "none" )
                                        setShortcut( i, KShortcut() );
                                else
                                        setShortcut( i, KShortcut(sEntry) );
                        }
                        else
                                setShortcut( i, shortcutDefault(i) );
                        kdDebug(125) << "\t" << name(i) << " = '" << sEntry << "'" << endl;
                }
        }

        kdDebug(125) << "KShortcutList::readSettings done" << endl;
        return true;
}

bool KShortcutList::writeSettings( const QString &sConfigGroup, KConfigBase* pConfig, bool bWriteAll, bool bGlobal ) const
{
        kdDebug(125) << "KShortcutList::writeSettings( " << sConfigGroup << ", " << pConfig << ", " << bWriteAll << ", " << bGlobal << " )" << endl;
        if( !pConfig )
                pConfig = KGlobal::config();

        QString sGroup = (!sConfigGroup.isEmpty()) ? sConfigGroup : QString("Shortcuts");


        if( pConfig->hasGroup( "Keys" ) )
                pConfig->deleteGroup( "Keys", true );

        KConfigGroupSaver cs( pConfig, sGroup );

        uint nSize = count();
        for( uint i = 0; i < nSize; i++ ) {
                if( isConfigurable(i) ) {
                        const QString& sName = name(i);
                        bool bConfigHasAction = !pConfig->readEntry( sName ).isEmpty();
                        bool bSameAsDefault = (shortcut(i) == shortcutDefault(i));


                        if( bWriteAll || !bSameAsDefault ) {
                                QString s = shortcut(i).toStringInternal();
                                if( s.isEmpty() )
                                        s = "none";
                                kdDebug(125) << "\twriting " << sName << " = " << s << endl;
                                pConfig->writeEntry( sName, s, true, bGlobal );
                        }


                        else if( bConfigHasAction ) {
                                kdDebug(125) << "\tremoving " << sName << " because == default" << endl;
                                pConfig->deleteEntry( sName, false, bGlobal );
                        }
                }
        }

        pConfig->sync();
        return true;
}





KAccelShortcutList::KAccelShortcutList( KAccel* pAccel )
: m_actions( pAccel->actions() )
{
        m_bGlobal = false;
}

KAccelShortcutList::KAccelShortcutList( KGlobalAccel* pAccel )
: m_actions( pAccel->actions() )
{
        m_bGlobal = true;
}

KAccelShortcutList::KAccelShortcutList( KAccelActions& actions, bool bGlobal )
: m_actions( actions )
{
        m_bGlobal = bGlobal;
}


KAccelShortcutList::~KAccelShortcutList()
        { }
uint KAccelShortcutList::count() const
        { return m_actions.count(); }
QString KAccelShortcutList::name( uint i ) const
        { return m_actions.actionPtr(i)->name(); }
QString KAccelShortcutList::label( uint i ) const
        { return m_actions.actionPtr(i)->label(); }
QString KAccelShortcutList::whatsThis( uint i ) const
        { return m_actions.actionPtr(i)->whatsThis(); }
const KShortcut& KAccelShortcutList::shortcut( uint i ) const
        { return m_actions.actionPtr(i)->shortcut(); }
const KShortcut& KAccelShortcutList::shortcutDefault( uint i ) const
        { return m_actions.actionPtr(i)->shortcutDefault(); }
bool KAccelShortcutList::isConfigurable( uint i ) const
        { return m_actions.actionPtr(i)->isConfigurable(); }
bool KAccelShortcutList::setShortcut( uint i, const KShortcut& cut )
        { return m_actions.actionPtr(i)->setShortcut( cut ); }
QVariant KAccelShortcutList::getOther( Other, uint ) const
        { return QVariant(); }
bool KAccelShortcutList::isGlobal( uint ) const
        { return m_bGlobal; }
bool KAccelShortcutList::setOther( Other, uint, QVariant )
        { return false; }
bool KAccelShortcutList::save() const
        { return writeSettings(); }

void KShortcutList::virtual_hook( int, void* )
{ }

void KAccelShortcutList::virtual_hook( int id, void* data )
{ KShortcutList::virtual_hook( id, data ); }

void KStdAccel::ShortcutList::virtual_hook( int id, void* data )
{ KShortcutList::virtual_hook( id, data ); }
# 40 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcrash.cpp" 1
# 28 "/coolo/prod/kdelibs/kdecore/kcrash.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 29 "/coolo/prod/kdelibs/kdecore/kcrash.cpp" 2
# 45 "/coolo/prod/kdelibs/kdecore/kcrash.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kaboutdata.h" 1
# 46 "/coolo/prod/kdelibs/kdecore/kcrash.cpp" 2
# 54 "/coolo/prod/kdelibs/kdecore/kcrash.cpp"
KCrash::HandlerType KCrash::_emergencySaveFunction = 0;
KCrash::HandlerType KCrash::_crashHandler = 0;
const char *KCrash::appName = 0;
const char *KCrash::appPath = 0;




void
KCrash::setEmergencySaveFunction (HandlerType saveFunction)
{
  _emergencySaveFunction = saveFunction;





  if (_emergencySaveFunction && !_crashHandler)
    _crashHandler = defaultCrashHandler;
}




void
KCrash::setCrashHandler (HandlerType handler)
{
  if (!handler)
    handler = ((__sighandler_t) 0);

  sigset_t mask;
  sigemptyset(&mask);


  signal (11, handler);
  sigaddset(&mask, 11);


  signal (8, handler);
  sigaddset(&mask, 8);


  signal (4, handler);
  sigaddset(&mask, 4);


  signal (6, handler);
  sigaddset(&mask, 6);


  sigprocmask(1, &mask, 0);

  _crashHandler = handler;
}

void
KCrash::defaultCrashHandler (int sig)
{


  static int crashRecursionCounter = 0;
  crashRecursionCounter++;

  signal(14, ((__sighandler_t) 0));
  alarm(3);

  if (crashRecursionCounter < 2) {
    if (_emergencySaveFunction) {
      _emergencySaveFunction (sig);
    }
    crashRecursionCounter++;
  }


  DCOPClient::emergencyClose();

  struct rlimit rlp;
  getrlimit(RLIMIT_NOFILE, &rlp);
  for (int i = 0; i < (int)rlp.rlim_cur; i++)
    close(i);

  bool shuttingDown = false;


  if ( !shuttingDown )
  {
    if (crashRecursionCounter < 3)
    {
      if (appName)
      {

        fprintf(stderr, "KCrash: crashing... crashRecursionCounter = %d\n", crashRecursionCounter);
        fprintf(stderr, "KCrash: Application Name = %s path = %s pid = %d\n", appName ? appName : "<unknown>" , appPath ? appPath : "<unknown>", getpid());




        pid_t pid = fork();

        if (pid <= 0) {


          char * argv[18];
          int i = 0;


          argv[i++] = qstrdup("drkonqi");


          argv[i++] = qstrdup("-display");

          if ( qt_xdisplay() )
            argv[i++] = XDisplayString(qt_xdisplay());
          else
            argv[i++] = getenv("DISPLAY");





          argv[i++] = qstrdup("--appname");
          argv[i++] = qstrdup(appName);
          if (KApplication::loadedByKdeinit)
            argv[i++] = qstrdup("--kdeinit");


          if (appPath) {
            argv[i++] = qstrdup("--apppath");
            argv[i++] = qstrdup(appPath);
          }


          QCString tmp;
          tmp.setNum(sig);
          argv[i++] = qstrdup("--signal");
          argv[i++] = qstrdup(tmp.data());



          if (pid == 0) {
            tmp.setNum(getppid());
            argv[i++] = qstrdup("--pid");
            argv[i++] = qstrdup(tmp.data());
          }

          const KInstance *instance = KGlobal::_instance;
          const KAboutData *about = instance ? instance->aboutData() : 0;
          if (about) {
            if (!about->version().isNull()) {
              argv[i++] = qstrdup("--appversion");
              argv[i++] = qstrdup(about->version().utf8());
            }

            if (!about->programName().isNull()) {
              argv[i++] = qstrdup("--programname");
              argv[i++] = qstrdup(about->programName().utf8());
            }

            if (!about->bugAddress().isNull()) {
              argv[i++] = qstrdup("--bugaddress");
              argv[i++] = qstrdup(about->bugAddress().utf8());
            }
          }

          if ( KApplication::kApplication() && !KApplication::kApplication()->startupId().isNull()) {
            argv[i++] = qstrdup("--startupid");
            argv[i++] = qstrdup(KApplication::kApplication()->startupId());
          }


          argv[i++] = __null;

          setgid(getgid());
          setuid(getuid());

          execvp("drkonqi", argv);





        }
        else
        {

          alarm(0);


          waitpid(pid, __null, 0);
          _exit(253);
        }
      }
      else {
        fprintf(stderr, "Unknown appname\n");
      }
    }

    if (crashRecursionCounter < 4)
    {
      fprintf(stderr, "Unable to start Dr. Konqi\n");
    }
  }

  _exit(255);
}
# 41 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kurl.cpp" 1
# 25 "/coolo/prod/kdelibs/kdecore/kurl.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kidna.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kidna.h"



namespace KIDNA {






    QCString toAsciiCString(const QString &idna);







    QString toAscii(const QString &idna);





    QString toUnicode(const QString &idna);
}
# 26 "/coolo/prod/kdelibs/kdecore/kurl.cpp" 2



# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 30 "/coolo/prod/kdelibs/kdecore/kurl.cpp" 2




# 1 "/coolo/prod/qt-copy/include/qurl.h" 1
# 39 "/coolo/prod/qt-copy/include/qurl.h"







class QUrlPrivate;

class QUrl
{
public:
    QUrl();
    QUrl( const QString& url );
    QUrl( const QUrl& url );
    QUrl( const QUrl& url, const QString& relUrl, bool checkSlash = FALSE );
    virtual ~QUrl();

    QString protocol() const;
    virtual void setProtocol( const QString& protocol );

    QString user() const;
    virtual void setUser( const QString& user );
    bool hasUser() const;

    QString password() const;
    virtual void setPassword( const QString& pass );
    bool hasPassword() const;

    QString host() const;
    virtual void setHost( const QString& user );
    bool hasHost() const;

    int port() const;
    virtual void setPort( int port );
    bool hasPort() const;

    QString path( bool correct = TRUE ) const;
    virtual void setPath( const QString& path );
    bool hasPath() const;

    virtual void setEncodedPathAndQuery( const QString& enc );
    QString encodedPathAndQuery();

    virtual void setQuery( const QString& txt );
    QString query() const;

    QString ref() const;
    virtual void setRef( const QString& txt );
    bool hasRef() const;

    bool isValid() const;
    bool isLocalFile() const;

    virtual void addPath( const QString& path );
    virtual void setFileName( const QString& txt );

    QString fileName() const;
    QString dirPath() const;

    QUrl& operator=( const QUrl& url );
    QUrl& operator=( const QString& url );

    bool operator==( const QUrl& url ) const;
    bool operator==( const QString& url ) const;

    static void decode( QString& url );
    static void encode( QString& url );

    operator QString() const;
    virtual QString toString( bool encodedPath = FALSE, bool forcePrependProtocol = TRUE ) const;

    virtual bool cdUp();

    static bool isRelativeUrl( const QString &url );

protected:
    virtual void reset();
    virtual bool parse( const QString& url );

private:
    QUrlPrivate *d;

};
# 35 "/coolo/prod/kdelibs/kdecore/kurl.cpp" 2







static const QString fileProt = "file";

static QTextCodec * codecForHint( int encoding_hint )
{
    return QTextCodec::codecForMib( encoding_hint );
}

static QString encode( const QString& segment, bool encode_slash, int encoding_hint )
{
  const char *encode_string;
  if (encode_slash)
    encode_string = "<>#@\"&%?={}|^~[]\'`\\:+/";
  else
    encode_string = "<>#@\"&%?={}|^~[]\'`\\:+";

  QCString local;
  if (encoding_hint==0)
    local = segment.local8Bit();
  else
  {
      QTextCodec * textCodec = codecForHint( encoding_hint );
      if (!textCodec)
          local = segment.local8Bit();
      else
          local = textCodec->fromUnicode( segment );
  }

  int old_length = local.length();

  if ( !old_length )
    return segment.isNull() ? QString::null : QString("");


  QChar *new_segment = new QChar[ old_length * 3 + 1 ];
  int new_length = 0;

  for ( int i = 0; i < old_length; i++ )
  {




    unsigned char character = local[i];
    if ( (character <= 32) || (character >= 127) ||
         strchr(encode_string, character) )
    {
      new_segment[ new_length++ ] = '%';

      unsigned int c = character / 16;
      c += (c > 9) ? ('A' - 10) : '0';
      new_segment[ new_length++ ] = c;

      c = character % 16;
      c += (c > 9) ? ('A' - 10) : '0';
      new_segment[ new_length++ ] = c;

    }
    else
      new_segment[ new_length++ ] = local[i];
  }

  QString result = QString(new_segment, new_length);
  delete [] new_segment;
  return result;
}

static QString encodeHost( const QString& segment, bool encode_slash, int encoding_hint )
{





  (void)encode_slash;;
  (void)encoding_hint;;
  return KIDNA::toAscii(segment);



}

static int hex2int( unsigned int _char )
{
  if ( _char >= 'A' && _char <='F')
    return _char - 'A' + 10;
  if ( _char >= 'a' && _char <='f')
    return _char - 'a' + 10;
  if ( _char >= '0' && _char <='9')
    return _char - '0';
  return -1;
}
# 144 "/coolo/prod/kdelibs/kdecore/kurl.cpp"
static QString lazy_encode( const QString& segment )
{
  int old_length = segment.length();

  if ( !old_length )
    return QString::null;


  QChar *new_segment = new QChar[ old_length * 3 + 1 ];
  int new_length = 0;

  for ( int i = 0; i < old_length; i++ )
  {
    unsigned int character = segment[i].unicode();


    if ((character < 32) ||
        ((character == '%') &&
           (i+2 < old_length) &&
          (hex2int(segment[i+1].unicode())!= -1) &&
          (hex2int(segment[i+2].unicode())!= -1)) ||
        (character == '?') ||
        (character == '@') ||
        (character == '#') ||
        ((character == 32) && (i+1 == old_length)))
    {
      new_segment[ new_length++ ] = '%';

      unsigned int c = character / 16;
      c += (c > 9) ? ('A' - 10) : '0';
      new_segment[ new_length++ ] = c;

      c = character % 16;
      c += (c > 9) ? ('A' - 10) : '0';
      new_segment[ new_length++ ] = c;
    }
    else
    new_segment[ new_length++ ] = segment[i];
  }

  QString result = QString(new_segment, new_length);
  delete [] new_segment;
  return result;
}

static void decode( const QString& segment, QString &decoded, QString &encoded, int encoding_hint=0, bool updateDecoded = true )
{
  decoded = QString::null;
  encoded = segment;

  int old_length = segment.length();
  if ( !old_length )
    return;

  QTextCodec *textCodec = 0;
  if (encoding_hint)
      textCodec = codecForHint( encoding_hint );

  if (!textCodec)
      textCodec = QTextCodec::codecForLocale();

  QCString csegment = textCodec->fromUnicode(segment);

  if (textCodec->toUnicode(csegment) != segment)
  {

      textCodec = codecForHint( 106 );
      csegment = textCodec->fromUnicode(segment);
  }
  old_length = csegment.length();

  int new_length = 0;
  int new_length2 = 0;


  char *new_segment = new char[ old_length + 1 ];
  QChar *new_usegment = new QChar[ old_length * 3 + 1 ];

  int i = 0;
  while( i < old_length )
  {
    bool bReencode = false;
    unsigned char character = csegment[ i++ ];
    if ((character <= ' ') || (character > 127))
       bReencode = true;

    new_usegment [ new_length2++ ] = character;
    if (character == '%' )
    {
      int a = i+1 < old_length ? hex2int( csegment[i] ) : -1;
      int b = i+1 < old_length ? hex2int( csegment[i+1] ) : -1;
      if ((a == -1) || (b == -1))
      {

         bReencode = true;
      }
      else
      {

         character = a * 16 + b;
         if (!character && updateDecoded)
            break;

         new_usegment [ new_length2++ ] = (unsigned char) csegment[i++];
         new_usegment [ new_length2++ ] = (unsigned char) csegment[i++];
      }
    }
    if (bReencode)
    {
      new_length2--;
      new_usegment [ new_length2++ ] = '%';

      unsigned int c = character / 16;
      c += (c > 9) ? ('A' - 10) : '0';
      new_usegment[ new_length2++ ] = c;

      c = character % 16;
      c += (c > 9) ? ('A' - 10) : '0';
      new_usegment[ new_length2++ ] = c;
    }

    new_segment [ new_length++ ] = character;
  }
  new_segment [ new_length ] = 0;

  encoded = QString( new_usegment, new_length2);


  if (updateDecoded)
  {
     QByteArray array;
     array.setRawData(new_segment, new_length);
     decoded = textCodec->toUnicode( array, new_length );
     array.resetRawData(new_segment, new_length);
     QCString validate = textCodec->fromUnicode(decoded);

     if (strcmp(validate.data(), new_segment) != 0)
     {
        decoded = QString::fromLocal8Bit(new_segment, new_length);
     }
  }

  delete [] new_segment;
  delete [] new_usegment;
}

static QString decode(const QString &segment, int encoding_hint = 0)
{
  QString result;
  QString tmp;
  decode(segment, result, tmp, encoding_hint);
  return result;
}

static QString cleanpath(const QString &path, bool cleanDirSeparator=true)
{
  if (path.isEmpty()) return QString::null;
  int len = path.length();
  bool slash = (len && path[len-1] == '/') ||
               (len > 1 && path[len-2] == '/' && path[len-1] == '.');







  QString result;
  int cdUp, orig_pos, pos;

  cdUp = 0;
  pos = orig_pos = len;
  while ( pos && (pos = path.findRev('/',--pos)) != -1 )
  {
    len = orig_pos - pos - 1;
    if ( len == 2 && path[pos+1] == '.' && path[pos+2] == '.' )
      cdUp++;
    else
    {


      if ( (len || !cleanDirSeparator) &&
           (len != 1 || path[pos+1] != '.' ) )
      {
          if ( !cdUp )
              result.prepend(path.mid(pos, len+1));
          else
              cdUp--;
      }
    }
    orig_pos = pos;
  }

  if ( result.isEmpty() )
    result = "/";
  else if ( slash && result[result.length()-1] != '/' )
       result.append('/');

  return result;
}

bool KURL::isRelativeURL(const QString &_url)
{
  int len = _url.length();
  if (!len) return true;
  const QChar *str = _url.unicode();


  if (!isalpha(str[0].latin1()))
     return true;

  for(int i = 1; i < len; i++)
  {
     char c = str[i].latin1();
     if (c == ':')
        return false;


     if (!isalpha(c) && !isdigit(c) && (c != '+') && (c != '-'))
        return true;
  }

  return true;
}

KURL::List::List(const KURL &url)
{
    append( url );
}

KURL::List::List(const QStringList &list)
{
  for (QStringList::ConstIterator it = list.begin();
       it != list.end();
       it++)
    {
      append( KURL(*it) );
    }
}

QStringList KURL::List::toStringList() const
{
  QStringList lst;
   for( KURL::List::ConstIterator it = begin();
        it != end();
        it++)
   {
      lst.append( (*it).url() );
   }
   return lst;
}


KURL::KURL()
{
  reset();
}

KURL::~KURL()
{
}


KURL::KURL( const QString &url, int encoding_hint )
{
  reset();
  parse( url, encoding_hint );
}

KURL::KURL( const char * url, int encoding_hint )
{
  reset();
  parse( QString::fromLatin1(url), encoding_hint );
}

KURL::KURL( const QCString& url, int encoding_hint )
{
  reset();
  parse( QString::fromLatin1(url), encoding_hint );
}

KURL::KURL( const KURL& _u )
{
  *this = _u;
}

QDataStream & operator<< (QDataStream & s, const KURL & a)
{
  QString QueryForWire=a.m_strQuery_encoded;
  if (!a.m_strQuery_encoded.isNull())
    QueryForWire.prepend("?");

    s << a.m_strProtocol << a.m_strUser << a.m_strPass << a.m_strHost
      << a.m_strPath << a.m_strPath_encoded << QueryForWire << a.m_strRef_encoded
      << Q_INT8(a.m_bIsMalformed ? 1 : 0) << a.m_iPort;
    return s;
}

QDataStream & operator>> (QDataStream & s, KURL & a)
{
    Q_INT8 malf;
    QString QueryFromWire;
    s >> a.m_strProtocol >> a.m_strUser >> a.m_strPass >> a.m_strHost
      >> a.m_strPath >> a.m_strPath_encoded >> QueryFromWire >> a.m_strRef_encoded
      >> malf >> a.m_iPort;
    a.m_bIsMalformed = (malf != 0);

    if ( QueryFromWire.isEmpty() )
      a.m_strQuery_encoded = QString::null;
    else
      a.m_strQuery_encoded = QueryFromWire.mid(1);

    return s;
}


KURL::KURL( const QUrl &u )
{
  *this = u;
}


KURL::KURL( const KURL& _u, const QString& _rel_url, int encoding_hint )
{
  if (_u.hasSubURL())
  {
    KURL::List lst = split( _u );
    KURL u(lst.last(), _rel_url, encoding_hint);
    lst.remove( lst.last() );
    lst.append( u );
    *this = join( lst );
    return;
  }



  QString rUrl = _rel_url;
  int len = _u.m_strProtocol.length();
  if ( !_u.m_strHost.isEmpty() && !rUrl.isEmpty() &&
       rUrl.find( _u.m_strProtocol, 0, false ) == 0 &&
       rUrl[len] == ':' && (rUrl[len+1] != '/' ||
       (rUrl[len+1] == '/' && rUrl[len+2] != '/')) )
  {
    rUrl.remove( 0, rUrl.find( ':' ) + 1 );
  }

  if ( rUrl.isEmpty() )
  {
    *this = _u;
  }
  else if ( rUrl[0] == '#' )
  {
    *this = _u;
    QString ref = decode(rUrl.mid(1), encoding_hint);
    if ( ref.isNull() )
        ref = "";
    setHTMLRef( ref );
  }
  else if ( isRelativeURL( rUrl) )
  {
    *this = _u;
    m_strQuery_encoded = QString::null;
    m_strRef_encoded = QString::null;
    if ( rUrl[0] == '/')
    {
        if ((rUrl.length() > 1) && (rUrl[1] == '/'))
        {
           m_strHost = QString::null;
        }
        m_strPath = QString::null;
        m_strPath_encoded = QString::null;
    }
    else if ( rUrl[0] != '?' )
    {
       int pos = m_strPath.findRev( '/' );
       if (pos >= 0)
          m_strPath.truncate(pos);
       m_strPath += '/';
       if (!m_strPath_encoded.isEmpty())
       {
          pos = m_strPath_encoded.findRev( '/' );
          if (pos >= 0)
             m_strPath_encoded.truncate(pos);
          m_strPath_encoded += '/';
       }
    }
    else
    {
       if ( m_strPath.isEmpty() )
          m_strPath = '/';
    }
    KURL tmp( url() + rUrl, encoding_hint);
    *this = tmp;
    cleanPath(false);
  }
  else
  {
    KURL tmp( rUrl, encoding_hint);
    *this = tmp;

    if (!_u.m_strUser.isEmpty() && m_strUser.isEmpty() && (_u.m_strHost == m_strHost) && (_u.m_strProtocol == m_strProtocol))
    {
       m_strUser = _u.m_strUser;
       m_strPass = _u.m_strPass;
    }
  }
}

void KURL::reset()
{
  m_strProtocol = QString::null;
  m_strUser = QString::null;
  m_strPass = QString::null;
  m_strHost = QString::null;
  m_strPath = QString::null;
  m_strPath_encoded = QString::null;
  m_strQuery_encoded = QString::null;
  m_strRef_encoded = QString::null;
  m_bIsMalformed = true;
  m_iPort = 0;
}

bool KURL::isEmpty() const
{
  return (m_strPath.isEmpty() && m_strProtocol.isEmpty());
}

void KURL::parse( const QString& _url, int encoding_hint )
{



  if ( _url.isEmpty() )
  {
    m_strProtocol = _url;
    return;
  }

  QString port;
  bool badHostName = false;
  int start = 0;
  uint len = _url.length();
  const QChar* buf = _url.unicode();
  const QChar* orig = buf;

  QChar delim;
  QString tmp;

  uint pos = 0;


  QChar x = buf[pos++];
  if ( x == '/' )
    goto Node9;
  if ( !isalpha( (int)x ) )
    goto NodeErr;




  while( pos < len && (isalpha((int)buf[pos]) || isdigit((int)buf[pos]) ||
          buf[pos] == '+' || buf[pos] == '-')) pos++;

  if ( pos+2 < len && buf[pos] == ':' && buf[pos+1] == '/' && buf[pos+2] == '/' )
    {
      m_strProtocol = QString( orig, pos ).lower();
      pos += 3;
    }
  else if (pos+1 < len && buf[pos] == ':' )
    {
      m_strProtocol = QString( orig, pos ).lower();

      pos++;
      start = pos;
      goto Node9;
    }
  else
    goto NodeErr;


  if ( pos == len )
      goto NodeErr;
  start = pos;


  if (buf[pos] == '[')
      goto Node8;

  x = buf[pos];
  while( (x != ':') && (x != '@') && (x != '/') && (x != '?') && (x != '#') )
  {
     if ((x == '\"') || (x == ';') || (x == '<'))
        badHostName = true;
     if (++pos == len)
        break;
     x = buf[pos];
  }
  if ( pos == len )
    {
      if (badHostName)
         goto NodeErr;

      setHost(decode(QString( buf + start, pos - start ), encoding_hint));
      goto NodeOk;
    }
  if ( x == '@' )
    {
      m_strUser = decode(QString( buf + start, pos - start ), encoding_hint);
      pos++;
      goto Node7;
    }
  else if ( (x == '/') || (x == '?') || (x == '#'))
    {
      if (badHostName)
         goto NodeErr;

      setHost(decode(QString( buf + start, pos - start ), encoding_hint));
      start = pos;
      goto Node9;
    }
  else if ( x != ':' )
    goto NodeErr;
  m_strUser = decode(QString( buf + start, pos - start ), encoding_hint);
  pos++;


  if ( pos == len )
    goto NodeErr;
  start = pos++;


  while( (pos < len) &&
                (buf[pos] != '@') &&
                (buf[pos] != '/') &&
                (buf[pos] != '?') &&
                (buf[pos] != '#')) pos++;


  if ( (pos == len) || (buf[pos] != '@') )
    {

      if (badHostName)
         goto NodeErr;
      setHost(m_strUser);
      m_strUser = QString::null;
      QString tmp( buf + start, pos - start );
      char *endptr;
      m_iPort = (unsigned short int)strtol(tmp.ascii(), &endptr, 10);
      if ((pos == len) && (strlen(endptr) == 0))
        goto NodeOk;

      pos -= strlen(endptr);
      if ((buf[pos] != '@') &&
          (buf[pos] != '/') &&
          (buf[pos] != '?') &&
          (buf[pos] != '#'))
        goto NodeErr;

      start = pos++;
      goto Node9;
    }
  m_strPass = decode(QString( buf + start, pos - start), encoding_hint);
  pos++;


 Node7:
  if ( pos == len )
    goto NodeErr;

 Node8:
  if (buf[pos] == '[')
  {

    start = ++pos;

    if (pos == len)
    {
       badHostName = true;
       goto NodeErr;
    }

    badHostName = false;
    x = buf[pos];
    while( (x != ']') )
    {
       if ((x == '\"') || (x == ';') || (x == '<'))
          badHostName = true;
       if (++pos == len)
       {
          badHostName = true;
          break;
       }
       x = buf[pos];
    }
    if (badHostName)
       goto NodeErr;
    setHost(decode(QString( buf + start, pos - start ), encoding_hint));
    if (pos < len) pos++;
    if (pos == len)
       goto NodeOk;
  }
  else
  {

    start = pos;


    badHostName = false;
    x = buf[pos];
    while( (x != ':') && (x != '@') && (x != '/') && (x != '?') && (x != '#') )
    {
       if ((x == '\"') || (x == ';') || (x == '<'))
          badHostName = true;
       if (++pos == len)
          break;
       x = buf[pos];
    }
    if (badHostName)
       goto NodeErr;
    if ( pos == len )
    {
       setHost(decode(QString( buf + start, pos - start ), encoding_hint));
       goto NodeOk;
    }
    setHost(decode(QString( buf + start, pos - start ), encoding_hint));
  }
  x = buf[pos];
  if ( x == '/' )
    {
      start = pos++;
      goto Node9;
    }
  else if ( x != ':' )
    goto NodeErr;
  pos++;


  if ( pos == len )
    goto NodeErr;
  start = pos;
  if ( !isdigit( buf[pos++] ) )
    goto NodeErr;


  while( pos < len && isdigit( buf[pos] ) ) pos++;
  port = QString( buf + start, pos - start );
  m_iPort = port.toUShort();
  if ( pos == len )
    goto NodeOk;
  start = pos++;

 Node9:

  while( pos < len && buf[pos] != '#' && buf[pos]!='?' ) pos++;

  tmp = QString( buf + start, pos - start );

  setEncodedPath( tmp, encoding_hint );

  if ( pos == len )
      goto NodeOk;


  delim = (buf[pos++]=='#'?'?':'#');

  start = pos;

  while(pos < len && buf[pos]!=delim ) pos++;

  tmp = QString(buf + start, pos - start);
  if (delim=='#')
      setQuery(tmp, encoding_hint);
  else
      m_strRef_encoded = tmp;

  if (pos == len)
      goto NodeOk;


  tmp = QString( buf + pos + 1, len - pos - 1);
  if (delim == '#')
      m_strRef_encoded = tmp;
  else
      setQuery(tmp, encoding_hint);

 NodeOk:

  m_bIsMalformed = false;


  if (m_strProtocol.isEmpty())
  {
    m_strProtocol = fileProt;
  }
  return;

 NodeErr:

  reset();
  m_strProtocol = _url;
}

KURL& KURL::operator=( const QString& _url )
{
  reset();
  parse( _url );

  return *this;
}

KURL& KURL::operator=( const char * _url )
{
  reset();
  parse( QString::fromLatin1(_url) );

  return *this;
}


KURL& KURL::operator=( const QUrl & u )
{
  m_strProtocol = u.protocol();
  m_strUser = u.user();
  m_strPass = u.password();
  m_strHost = u.host();
  m_strPath = u.path( FALSE );
  m_strPath_encoded = QString::null;
  m_strQuery_encoded = u.query();
  m_strRef_encoded = u.ref();
  m_bIsMalformed = !u.isValid();
  m_iPort = u.port();

  return *this;
}


KURL& KURL::operator=( const KURL& _u )
{
  m_strProtocol = _u.m_strProtocol;
  m_strUser = _u.m_strUser;
  m_strPass = _u.m_strPass;
  m_strHost = _u.m_strHost;
  m_strPath = _u.m_strPath;
  m_strPath_encoded = _u.m_strPath_encoded;
  m_strQuery_encoded = _u.m_strQuery_encoded;
  m_strRef_encoded = _u.m_strRef_encoded;
  m_bIsMalformed = _u.m_bIsMalformed;
  m_iPort = _u.m_iPort;

  return *this;
}

bool KURL::operator<( const KURL& _u) const
{
  int i;
  if (!_u.isValid())
  {
     if (!isValid())
     {
        i = m_strProtocol.compare(_u.m_strProtocol);
        return (i < 0);
     }
     return false;
  }
  if (!isValid())
     return true;

  i = m_strProtocol.compare(_u.m_strProtocol);
  if (i) return (i < 0);

  i = m_strHost.compare(_u.m_strHost);
  if (i) return (i < 0);

  if (m_iPort != _u.m_iPort) return (m_iPort < _u.m_iPort);

  i = m_strPath.compare(_u.m_strPath);
  if (i) return (i < 0);

  i = m_strQuery_encoded.compare(_u.m_strQuery_encoded);
  if (i) return (i < 0);

  i = m_strRef_encoded.compare(_u.m_strRef_encoded);
  if (i) return (i < 0);

  i = m_strUser.compare(_u.m_strUser);
  if (i) return (i < 0);

  i = m_strPass.compare(_u.m_strPass);
  if (i) return (i < 0);

  return false;
}

bool KURL::operator==( const KURL& _u ) const
{
  if ( !isValid() || !_u.isValid() )
    return false;

  if ( m_strProtocol == _u.m_strProtocol &&
       m_strUser == _u.m_strUser &&
       m_strPass == _u.m_strPass &&
       m_strHost == _u.m_strHost &&
       m_strPath == _u.m_strPath &&

       ( m_strPath_encoded.isNull() || _u.m_strPath_encoded.isNull() ||
         m_strPath_encoded == _u.m_strPath_encoded ) &&
       m_strQuery_encoded == _u.m_strQuery_encoded &&
       m_strRef_encoded == _u.m_strRef_encoded &&
       m_iPort == _u.m_iPort )
  {
    return true;
  }

  return false;
}

bool KURL::operator==( const QString& _u ) const
{
  KURL u( _u );
  return ( *this == u );
}

bool KURL::cmp( const KURL &u, bool ignore_trailing ) const
{
  return equals( u, ignore_trailing );
}

bool KURL::equals( const KURL &_u, bool ignore_trailing ) const
{
  if ( !isValid() || !_u.isValid() )
    return false;

  if ( ignore_trailing )
  {
    QString path1 = path(1);
    QString path2 = _u.path(1);
    if ( path1 != path2 )
      return false;

    if ( m_strProtocol == _u.m_strProtocol &&
         m_strUser == _u.m_strUser &&
         m_strPass == _u.m_strPass &&
         m_strHost == _u.m_strHost &&
         m_strQuery_encoded == _u.m_strQuery_encoded &&
         m_strRef_encoded == _u.m_strRef_encoded &&
         m_iPort == _u.m_iPort )
      return true;

    return false;
  }

  return ( *this == _u );
}

bool KURL::isParentOf( const KURL& _u ) const
{
  if ( !isValid() || !_u.isValid() )
    return false;

  if ( m_strProtocol == _u.m_strProtocol &&
       m_strUser == _u.m_strUser &&
       m_strPass == _u.m_strPass &&
       m_strHost == _u.m_strHost &&
       m_strQuery_encoded == _u.m_strQuery_encoded &&
       m_strRef_encoded == _u.m_strRef_encoded &&
       m_iPort == _u.m_iPort )
  {
    if ( path().isEmpty() || _u.path().isEmpty() )
        return false;

    QString p1( cleanpath( path() ) );
    if ( p1[p1.length()-1] != '/' )
        p1 += '/';
    QString p2( cleanpath( _u.path() ) );
    if ( p2[p2.length()-1] != '/' )
        p2 += '/';





    return p2.startsWith( p1 );
  }
  return false;
}

void KURL::setFileName( const QString& _txt )
{
  m_strRef_encoded = QString::null;
  int i = 0;
  while( _txt[i] == '/' ) ++i;
  QString tmp;
  if ( i )
    tmp = _txt.mid( i );
  else
    tmp = _txt;

  QString path = m_strPath_encoded.isEmpty() ? m_strPath : m_strPath_encoded;
  if ( path.isEmpty() )
    path = "/";
  else
  {
    int lastSlash = path.findRev( '/' );
    if ( lastSlash == -1)
    {


      path = "/";
    }
    else if ( path.right(1) != "/" )
      path.truncate( lastSlash+1 );
  }
  if (m_strPath_encoded.isEmpty())
  {
     path += tmp;
     setPath( path );
  }
  else
  {
     path += encode_string(tmp);
     setEncodedPath( path );
  }
  cleanPath();
}

void KURL::cleanPath( bool cleanDirSeparator )
{
  m_strPath = cleanpath(m_strPath, cleanDirSeparator);

  m_strPath_encoded = cleanpath(m_strPath_encoded, cleanDirSeparator);
}

static QString trailingSlash( int _trailing, const QString &path )
{
  QString result = path;

  if ( _trailing == 0 )
    return result;
  else if ( _trailing == 1 )
  {
    int len = result.length();
    if ( len == 0 )
      result = QString::null;
    else if ( result[ len - 1 ] != '/' )
      result += "/";
    return result;
  }
  else if ( _trailing == -1 )
  {
    if ( result == "/" )
      return result;
    int len = result.length();
    if ( len != 0 && result[ len - 1 ] == '/' )
      result.truncate( len - 1 );
    return result;
  }
  else {
    (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kurl.cpp", 1101, __PRETTY_FUNCTION__), 0)));
    return QString::null;
  }
}

void KURL::adjustPath( int _trailing )
{
  if (!m_strPath_encoded.isEmpty())
  {
     m_strPath_encoded = trailingSlash( _trailing, m_strPath_encoded );
  }
  m_strPath = trailingSlash( _trailing, m_strPath );
}


QString KURL::encodedPathAndQuery( int _trailing, bool _no_empty_path, int encoding_hint ) const
{
  QString tmp;
  if (!m_strPath_encoded.isEmpty() && encoding_hint == 0)
  {
     tmp = trailingSlash( _trailing, m_strPath_encoded );
  }
  else
  {
     tmp = path( _trailing );
     if ( _no_empty_path && tmp.isEmpty() )
        tmp = "/";
     tmp = encode( tmp, false, encoding_hint );
  }


  if (!m_strQuery_encoded.isNull())
      tmp += '?' + m_strQuery_encoded;
  return tmp;
}

void KURL::setEncodedPath( const QString& _txt, int encoding_hint )
{
  m_strPath_encoded = _txt;

  decode( m_strPath_encoded, m_strPath, m_strPath_encoded, encoding_hint );

  if (m_strProtocol == fileProt)
     m_strPath_encoded = QString::null;
}


void KURL::setEncodedPathAndQuery( const QString& _txt, int encoding_hint )
{
  int pos = _txt.find( '?' );
  if ( pos == -1 )
  {
    setEncodedPath(_txt, encoding_hint);
    m_strQuery_encoded = QString::null;
  }
  else
  {
    setEncodedPath(_txt.left( pos ), encoding_hint);
    setQuery(_txt.right(_txt.length() - pos - 1), encoding_hint);
  }
}

QString KURL::path( int _trailing ) const
{
  return trailingSlash( _trailing, path() );
}

bool KURL::isLocalFile() const
{
  if ( (m_strProtocol != fileProt ) || hasSubURL() )
     return false;

  if (m_strHost.isEmpty() || (m_strHost == "localhost"))
     return true;

  char hostname[ 256 ];
  hostname[ 0 ] = '\0';
  if (!gethostname( hostname, 255 ))
     hostname[sizeof(hostname)-1] = '\0';

  for(char *p = hostname; *p; p++)
     *p = tolower(*p);

  return (m_strHost == hostname);
}

void KURL::setFileEncoding(const QString &encoding)
{
  if (!isLocalFile())
     return;

  QString q = query();

  if (!q.isEmpty() && (q[0] == '?'))
     q = q.mid(1);

  QStringList args = QStringList::split('&', q);
  for(QStringList::Iterator it = args.begin();
      it != args.end();)
  {
      QString s = decode_string(*it);
      if (s.startsWith("charset="))
         it = args.erase(it);
      else
         ++it;
  }
  if (!encoding.isEmpty())
     args.append("charset="+encode_string(encoding));

  if (args.isEmpty())
     setQuery(QString::null);
  else
     setQuery(args.join("&"));
}

QString KURL::fileEncoding() const
{
  if (!isLocalFile())
     return QString::null;

  QString q = query();

  if (q.isEmpty())
     return QString::null;

  if (q[0] == '?')
     q = q.mid(1);

  QStringList args = QStringList::split('&', q);
  for(QStringList::ConstIterator it = args.begin();
      it != args.end();
      ++it)
  {
      QString s = decode_string(*it);
      if (s.startsWith("charset="))
         return s.mid(8);
  }
  return QString::null;
}

bool KURL::hasSubURL() const
{
  if ( m_strProtocol.isEmpty() || m_bIsMalformed )
    return false;
  if (m_strRef_encoded.isEmpty())
     return false;
  if (m_strRef_encoded.startsWith("gzip:"))
     return true;
  if (m_strRef_encoded.startsWith("bzip:"))
     return true;
  if (m_strRef_encoded.startsWith("bzip2:"))
     return true;
  if (m_strRef_encoded.startsWith("tar:"))
     return true;
  if (m_strRef_encoded.startsWith("ar:"))
     return true;
  if (m_strRef_encoded.startsWith("zip:"))
     return true;
  if ( m_strProtocol == "error" )
     return true;
  return false;
}

QString KURL::url( int _trailing, int encoding_hint ) const
{
  if( m_bIsMalformed )
  {



    return m_strProtocol;
  }

  QString u = m_strProtocol;
  if (!u.isEmpty())
     u += ":";

  if ( hasHost() )
  {
    u += "//";
    if ( hasUser() )
    {
      u += encode(m_strUser, true, encoding_hint);
      if ( hasPass() )
      {
        u += ":";
        u += encode(m_strPass, true, encoding_hint);
      }
      u += "@";
    }
    bool IPv6 = (m_strHost.find(':') != -1);
    if (IPv6)
       u += '[' + m_strHost + ']';
    else
       u += encodeHost(m_strHost, true, encoding_hint);
    if ( m_iPort != 0 ) {
      QString buffer;
      buffer.sprintf( ":%u", m_iPort );
      u += buffer;
    }
  }

  u += encodedPathAndQuery( _trailing, false, encoding_hint );

  if ( hasRef() )
  {
    u += "#";
    u += m_strRef_encoded;
  }

  return u;
}

QString KURL::prettyURL( int _trailing ) const
{
  if( m_bIsMalformed )
  {



    return m_strProtocol;
  }

  QString u = m_strProtocol;
  if (!u.isEmpty())
     u += ":";

  if ( hasHost() )
  {
    u += "//";
    if ( hasUser() )
    {
      u += lazy_encode(m_strUser);

      u += "@";
    }
    bool IPv6 = (m_strHost.find(':') != -1);
    if (IPv6)
    {
       u += '[' + m_strHost + ']';
    }
    else
    {
       u += lazy_encode(m_strHost);
    }
    if ( m_iPort != 0 ) {
      QString buffer;
      buffer.sprintf( ":%u", m_iPort );
      u += buffer;
    }
  }

  u += trailingSlash( _trailing, lazy_encode( m_strPath ) );
  if (!m_strQuery_encoded.isNull())
      u += '?' + m_strQuery_encoded;

  if ( hasRef() )
  {
    u += "#";
    u += m_strRef_encoded;
  }

  return u;
}

QString KURL::prettyURL( int _trailing, AdjustementFlags _flags) const
{
        QString u = prettyURL(_trailing);
        if (_flags & StripFileProtocol && u.startsWith("file:"))
                u.remove(0, 5);
        return u;
}

QString KURL::htmlURL() const
{
  return QStyleSheet::escape(prettyURL());
}

KURL::List KURL::split( const KURL& _url )
{
  QString ref;
  KURL::List lst;
  KURL url = _url;

  while(true)
  {
     KURL u = url;
     u.m_strRef_encoded = QString::null;
     lst.append(u);
     if (url.hasSubURL())
     {
        url = KURL(url.m_strRef_encoded);
     }
     else
     {
        ref = url.m_strRef_encoded;
        break;
     }
  }


  KURL::List::Iterator it;
  for( it = lst.begin() ; it != lst.end(); ++it )
  {
     (*it).m_strRef_encoded = ref;
  }

  return lst;
}

KURL::List KURL::split( const QString& _url )
{
  return split(KURL(_url));
}

KURL KURL::join( const KURL::List & lst )
{
  if (lst.isEmpty()) return KURL();
  KURL tmp;

  KURL::List::ConstIterator first = lst.fromLast();
  for( KURL::List::ConstIterator it = first; it != lst.end(); --it )
  {
     KURL u(*it);
     if (it != first)
     {
        if (!u.m_strRef_encoded) u.m_strRef_encoded = tmp.url();
        else u.m_strRef_encoded += "#" + tmp.url();
     }
     tmp = u;
  }

  return tmp;
}

QString KURL::fileName( bool _strip_trailing_slash ) const
{
  QString fname;
  if (hasSubURL()) {
    KURL::List list = KURL::split(*this);
    KURL::List::Iterator it = list.fromLast();
    return (*it).fileName(_strip_trailing_slash);
  }
  const QString &path = m_strPath;

  int len = path.length();
  if ( len == 0 )
    return fname;

  if ( _strip_trailing_slash )
  {
    while ( len >= 1 && path[ len - 1 ] == '/' )
      len--;
  }
  else if ( path[ len - 1 ] == '/' )
    return fname;


  if ( len == 1 && path[ 0 ] == '/' )
    return fname;


  int n = 1;
  if (!m_strPath_encoded.isEmpty())
  {



     int i = m_strPath_encoded.findRev( '/', len - 1 );
     QString fileName_encoded = m_strPath_encoded.mid(i+1);
     n += fileName_encoded.contains("%2f", false);
  }
  int i = len;
  do {
    i = path.findRev( '/', i - 1 );
  }
  while (--n && (i > 0));



  if ( i == -1 ) {
    if ( len == (int)path.length() )
      fname = path;
    else

      fname = path.left( len );
  }
  else
  {
     fname = path.mid( i + 1, len - i - 1 );
  }
  return fname;
}

void KURL::addPath( const QString& _txt )
{
  if (hasSubURL())
  {
     KURL::List lst = split( *this );
     KURL &u = lst.last();
     u.addPath(_txt);
     *this = join( lst );
     return;
  }

  m_strPath_encoded = QString::null;

  if ( _txt.isEmpty() )
    return;

  int i = 0;
  int len = m_strPath.length();

  if ( len == 0 ) {
    while( _txt[i] == '/' ) ++i;
  }

  else if ( _txt[0] != '/' && ( len == 0 || m_strPath[ len - 1 ] != '/' ) )
    m_strPath += "/";


  i = 0;
  if ( len != 0 && m_strPath[ len - 1 ] == '/' )
  {
    while( _txt[i] == '/' )
      ++i;
  }

  m_strPath += _txt.mid( i );
}

QString KURL::directory( bool _strip_trailing_slash_from_result,
                         bool _ignore_trailing_slash_in_path ) const
{
  QString result = m_strPath_encoded.isEmpty() ? m_strPath : m_strPath_encoded;
  if ( _ignore_trailing_slash_in_path )
    result = trailingSlash( -1, result );

  if ( result.isEmpty() || result == "/" )
    return result;

  int i = result.findRev( "/" );


  if ( i == -1 )
    return QString::null;

  if ( i == 0 )
  {
    result = "/";
    return result;
  }

  if ( _strip_trailing_slash_from_result )
    result = result.left( i );
  else
    result = result.left( i + 1 );

  if (!m_strPath_encoded.isEmpty())
    result = decode(result);

  return result;
}


bool KURL::cd( const QString& _dir )
{
  if ( _dir.isEmpty() || m_bIsMalformed )
    return false;

  if (hasSubURL())
  {
     KURL::List lst = split( *this );
     KURL &u = lst.last();
     u.cd(_dir);
     *this = join( lst );
     return true;
  }


  if ( _dir[0] == '/' )
  {
    m_strPath_encoded = QString::null;
    m_strPath = _dir;
    setHTMLRef( QString::null );
    m_strQuery_encoded = QString::null;
    return true;
  }


  if ( ( _dir[0] == '~' ) && ( m_strProtocol == fileProt ))
  {
    m_strPath_encoded = QString::null;
    m_strPath = QDir::homeDirPath();
    m_strPath += "/";
    m_strPath += _dir.right(m_strPath.length() - 1);
    setHTMLRef( QString::null );
    m_strQuery_encoded = QString::null;
    return true;
  }






  QString p = path(1);
  p += _dir;
  p = cleanpath( p );
  setPath( p );

  setHTMLRef( QString::null );
  m_strQuery_encoded = QString::null;

  return true;
}

KURL KURL::upURL( ) const
{
  if (!query().isEmpty())
  {
     KURL u(*this);
     u.setQuery(QString::null);
     return u;
  };

  if (!hasSubURL())
  {
     KURL u(*this);
     u.cd("../");
     return u;
  }


  KURL::List lst = split( *this );
  if (lst.isEmpty())
      return KURL();
  while (true)
  {
     KURL &u = lst.last();
     QString old = u.path();
     u.cd("../");
     if (u.path() != old)
         break;
     if (lst.count() == 1)
         break;
     lst.remove(lst.fromLast());
  }
  return join( lst );
}

QString KURL::htmlRef() const
{
  if ( !hasSubURL() )
  {
    return decode( ref() );
  }

  List lst = split( *this );
  return decode( (*lst.begin()).ref() );
}

QString KURL::encodedHtmlRef() const
{
  if ( !hasSubURL() )
  {
    return ref();
  }

  List lst = split( *this );
  return (*lst.begin()).ref();
}

void KURL::setHTMLRef( const QString& _ref )
{
  if ( !hasSubURL() )
  {
    m_strRef_encoded = encode( _ref, true, 0 );
    return;
  }

  List lst = split( *this );

  (*lst.begin()).setRef( encode( _ref, true, 0 ) );

  *this = join( lst );
}

bool KURL::hasHTMLRef() const
{
  if ( !hasSubURL() )
  {
    return hasRef();
  }

  List lst = split( *this );
  return (*lst.begin()).hasRef();
}

void
KURL::setProtocol( const QString& _txt )
{
   m_strProtocol = _txt;
   m_bIsMalformed = false;
}

void
KURL::setUser( const QString& _txt )
{
   m_strUser = _txt;
}

void
KURL::setPass( const QString& _txt )
{
   m_strPass = _txt;
}

void
KURL::setHost( const QString& _txt )
{

   m_strHost = KIDNA::toUnicode(_txt);
   if (m_strHost.isEmpty())
      m_strHost = _txt.lower();



}

void
KURL::setPort( unsigned short int _p )
{
   m_iPort = _p;
}

void KURL::setPath( const QString & path )
{
  if (isEmpty())
    m_bIsMalformed = false;
  if (m_strProtocol.isEmpty())
  {
    m_strProtocol = fileProt;
  }
  m_strPath = path;
  m_strPath_encoded = QString::null;
}

void KURL::setDirectory( const QString &dir)
{
  if ( dir.endsWith("/"))
     setPath(dir);
  else
     setPath(dir+"/");
}

void KURL::setQuery( const QString &_txt, int encoding_hint)
{
   if (!_txt.length())
   {
      m_strQuery_encoded = _txt;
      return;
   }
   if (_txt[0] =='?')
      m_strQuery_encoded = _txt.mid(1);
   else
      m_strQuery_encoded = _txt;

   int l = m_strQuery_encoded.length();
   int i = 0;
   QString result;
   while (i < l)
   {
      int s = i;


      while(i < l)
      {
         char c = m_strQuery_encoded[i].latin1();
         if ((c == '&') || (c == ':') || (c == ';') ||
             (c == '=') || (c == '/') || (c == '?'))
            break;
         i++;
      }
      if (i > s)
      {
         QString tmp = m_strQuery_encoded.mid(s, i-s);
         QString newTmp;
         decode( tmp, newTmp, tmp, encoding_hint, false );
         result += tmp;
      }
      if (i < l)
      {
         result += m_strQuery_encoded[i];
         i++;
      }
   }
   m_strQuery_encoded = result;
}

QString KURL::query() const
{
    if (m_strQuery_encoded.isNull())
        return QString::null;
    return '?'+m_strQuery_encoded;
}

QString KURL::decode_string(const QString &str, int encoding_hint)
{
   return decode(str, encoding_hint);
}

QString KURL::encode_string(const QString &str, int encoding_hint)
{
   return encode(str, false, encoding_hint);
}

QString KURL::encode_string_no_slash(const QString &str, int encoding_hint)
{
   return encode(str, true, encoding_hint);
}

bool urlcmp( const QString& _url1, const QString& _url2 )
{

  if ( _url1.isEmpty() && _url2.isEmpty() )
    return true;

  if ( _url1.isEmpty() || _url2.isEmpty() )
    return false;

  KURL::List list1 = KURL::split( _url1 );
  KURL::List list2 = KURL::split( _url2 );


  if ( list1.isEmpty() || list2.isEmpty() )
    return false;

  return ( list1 == list2 );
}

bool urlcmp( const QString& _url1, const QString& _url2, bool _ignore_trailing, bool _ignore_ref )
{

  if ( _url1.isEmpty() && _url2.isEmpty() )
    return true;

  if ( _url1.isEmpty() || _url2.isEmpty() )
    return false;

  KURL::List list1 = KURL::split( _url1 );
  KURL::List list2 = KURL::split( _url2 );


  if ( list1.isEmpty() || list2.isEmpty() )
    return false;

  unsigned int size = list1.count();
  if ( list2.count() != size )
    return false;

  if ( _ignore_ref )
  {
    (*list1.begin()).setRef(QString::null);
    (*list2.begin()).setRef(QString::null);
  }

  KURL::List::Iterator it1 = list1.begin();
  KURL::List::Iterator it2 = list2.begin();
  for( ; it1 != list1.end() ; ++it1, ++it2 )
    if ( !(*it1).equals( *it2, _ignore_trailing ) )
      return false;

  return true;
}

QMap< QString, QString > KURL::queryItems( int options ) const {
  return queryItems(options, 0);
}

QMap< QString, QString > KURL::queryItems( int options, int encoding_hint ) const {
  if ( m_strQuery_encoded.isEmpty() )
    return QMap<QString,QString>();

  QMap< QString, QString > result;
  QStringList items = QStringList::split( '&', m_strQuery_encoded );
  for ( QStringList::const_iterator it = items.begin() ; it != items.end() ; ++it ) {
    int equal_pos = (*it).find( '=' );
    if ( equal_pos > 0 ) {
      QString name = (*it).left( equal_pos );
      if ( options & CaseInsensitiveKeys )
        name = name.lower();
      QString value = (*it).mid( equal_pos + 1 );
      if ( value.isEmpty() )
        result.insert( name, QString::fromLatin1("") );
      else {

        value.replace( '+', ' ' );
        result.insert( name, decode_string( value, encoding_hint ) );
      }
    } else if ( equal_pos < 0 ) {
      QString name = (*it);
      if ( options & CaseInsensitiveKeys )
        name = name.lower();
      result.insert( name, QString::null );
    }
  }

  return result;
}

QString KURL::queryItem( const QString& _item ) const
{
  return queryItem( _item, 0 );
}

QString KURL::queryItem( const QString& _item, int encoding_hint ) const
{
  QString item = _item + '=';
  if ( m_strQuery_encoded.length() <= 1 )
    return QString::null;

  QStringList items = QStringList::split( '&', m_strQuery_encoded );
  unsigned int _len = item.length();
  for ( QStringList::ConstIterator it = items.begin(); it != items.end(); ++it )
  {
    if ( (*it).startsWith( item ) )
    {
      if ( (*it).length() > _len )
      {
        QString str = (*it).mid( _len );
        str.replace( '+', ' ' );
        return decode_string( str, encoding_hint );
      }
      else
        return QString::fromLatin1("");
    }
  }

  return QString::null;
}

void KURL::removeQueryItem( const QString& _item )
{
  QString item = _item + '=';
  if ( m_strQuery_encoded.length() <= 1 )
    return;

  QStringList items = QStringList::split( '&', m_strQuery_encoded );
  for ( QStringList::Iterator it = items.begin(); it != items.end(); )
  {
    if ( (*it).startsWith( item ) || (*it == _item) )
    {
      QStringList::Iterator deleteIt = it;
      ++it;
      items.remove(deleteIt);
    }
    else
    {
       ++it;
    }
  }
  m_strQuery_encoded = items.join( "&" );
}

void KURL::addQueryItem( const QString& _item, const QString& _value, int encoding_hint )
{
  QString item = _item + '=';
  QString value = encode( _value, true, encoding_hint );

  if (!m_strQuery_encoded.isEmpty())
     m_strQuery_encoded += '&';
  m_strQuery_encoded += item + value;
}


KURL KURL::fromPathOrURL( const QString& text )
{
    if ( text.isEmpty() )
        return KURL();

    KURL url;
    if ( text[0] == '/' )
        url.setPath( text );
    else
        url = text;

    return url;
}

static QString _relativePath(const QString &base_dir, const QString &path, bool &isParent)
{
   QString _base_dir(QDir::cleanDirPath(base_dir));
   QString _path(QDir::cleanDirPath(path.isEmpty() || (path[0] != '/') ? _base_dir+"/"+path : path));

   if (_base_dir.isEmpty())
      return _path;

   if (_base_dir[_base_dir.length()-1] != '/')
      _base_dir.append('/');

   QStringList list1 = QStringList::split('/', _base_dir);
   QStringList list2 = QStringList::split('/', _path);


   uint level = 0;
   uint maxLevel = ((list1.count()) < (list2.count()) ? (list1.count()) : (list2.count()));
   while((level < maxLevel) && (list1[level] == list2[level])) level++;

   QString result;

   for(uint i = level; i < list1.count(); i++)
      result.append("../");


   for(uint i = level; i < list2.count(); i++)
      result.append(list2[i]).append("/");

   if ((level < list2.count()) && (path[path.length()-1] != '/'))
      result.truncate(result.length()-1);

   isParent = (level == list1.count());

   return result;
}

QString KURL::relativePath(const QString &base_dir, const QString &path, bool *isParent)
{
   bool parent;
   QString result = _relativePath(base_dir, path, parent);
   if (parent)
      result.prepend("./");

   if (isParent)
      *isParent = parent;

   return result;
}


QString KURL::relativeURL(const KURL &base_url, const KURL &url, int encoding_hint)
{
   if ((url.protocol() != base_url.protocol()) ||
       (url.host() != base_url.host()) ||
       (url.port() && url.port() != base_url.port()) ||
       (url.hasUser() && url.user() != base_url.user()) ||
       (url.hasPass() && url.pass() != base_url.pass()))
   {
      return url.url(0, encoding_hint);
   }

   QString relURL;

   if ((base_url.path() != url.path()) || (base_url.query() != url.query()))
   {
      bool dummy;
      QString basePath = base_url.directory(false, false);
      relURL = encode( _relativePath(basePath, url.path(), dummy), false, encoding_hint);
      relURL += url.query();
   }

   if ( url.hasRef() )
   {
      relURL += "#";
      relURL += url.ref();
   }

   if ( relURL.isEmpty() )
      return "./";

   return relURL;
}
# 42 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kregexp.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/kregexp.cpp"
# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 23 "/coolo/prod/kdelibs/kdecore/kregexp.cpp" 2


# 1 "/coolo/prod/kdelibs/kdecore/kregexp.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/kregexp.h"



class KRegExpPrivate;
# 61 "/coolo/prod/kdelibs/kdecore/kregexp.h"
class __attribute__ ((deprecated)) KRegExp
{
public:




  KRegExp();







  KRegExp( const char *_pattern, const char *_mode = "" );
  ~KRegExp();
# 86 "/coolo/prod/kdelibs/kdecore/kregexp.h"
  bool compile( const char *_pattern, const char *_mode = "" );






  bool match( const char *_string );
# 107 "/coolo/prod/kdelibs/kdecore/kregexp.h"
  const char *group( int _grp );







  int groupStart( int _grp );







  int groupEnd( int _grp );

private:
  KRegExpPrivate *m_pPrivate;
};
# 26 "/coolo/prod/kdelibs/kdecore/kregexp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kregpriv.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/kregpriv.h"

extern "C" {
# 1 "/usr/include/regex.h" 1 3 4
# 23 "/usr/include/regex.h" 3 4



extern "C" {
# 43 "/usr/include/regex.h" 3 4
typedef long int s_reg_t;
typedef unsigned long int active_reg_t;






typedef unsigned long int reg_syntax_t;












# 80 "/usr/include/regex.h" 3 4











































































extern reg_syntax_t re_syntax_options;




















































# 252 "/usr/include/regex.h" 3 4
#undef RE_DUP_MAX


















# 285 "/usr/include/regex.h" 3 4






typedef enum
{

  REG_ENOSYS = -1,


  REG_NOERROR = 0,
  REG_NOMATCH,



  REG_BADPAT,
  REG_ECOLLATE,
  REG_ECTYPE,
  REG_EESCAPE,
  REG_ESUBREG,
  REG_EBRACK,
  REG_EPAREN,
  REG_EBRACE,
  REG_BADBR,
  REG_ERANGE,
  REG_ESPACE,
  REG_BADRPT,


  REG_EEND,
  REG_ESIZE,
  REG_ERPAREN
} reg_errcode_t;
# 330 "/usr/include/regex.h" 3 4


struct re_pattern_buffer
{




  unsigned char *buffer;


  unsigned long int allocated;


  unsigned long int used;


  reg_syntax_t syntax;




  char *fastmap;





  char * translate;


  size_t re_nsub;






  unsigned can_be_null : 1;





  unsigned regs_allocated : 2;



  unsigned fastmap_accurate : 1;



  unsigned no_sub : 1;



  unsigned not_bol : 1;


  unsigned not_eol : 1;


  unsigned newline_anchor : 1;


};

typedef struct re_pattern_buffer regex_t;


typedef int regoff_t;




struct re_registers
{
  unsigned num_regs;
  regoff_t *start;
  regoff_t *end;
};












typedef struct
{
  regoff_t rm_so;
  regoff_t rm_eo;
} regmatch_t;
# 444 "/usr/include/regex.h" 3 4
# 454 "/usr/include/regex.h" 3 4
extern reg_syntax_t re_set_syntax (reg_syntax_t syntax);




extern const char *re_compile_pattern
  (const char *pattern, size_t length, struct re_pattern_buffer *buffer);






extern int re_compile_fastmap (struct re_pattern_buffer *buffer);







extern int re_search
  (struct re_pattern_buffer *buffer, const char *string, int length, int start, int range, struct re_registers *regs);





extern int re_search_2
  (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, int range, struct re_registers *regs, int stop);






extern int re_match
  (struct re_pattern_buffer *buffer, const char *string, int length, int start, struct re_registers *regs);




extern int re_match_2
  (struct re_pattern_buffer *buffer, const char *string1, int length1, const char *string2, int length2, int start, struct re_registers *regs, int stop);
# 514 "/usr/include/regex.h" 3 4
extern void re_set_registers
  (struct re_pattern_buffer *buffer, struct re_registers *regs, unsigned num_regs, regoff_t *starts, regoff_t *ends);
# 547 "/usr/include/regex.h" 3 4
extern int regcomp (regex_t *__restrict __preg, const char *__restrict __pattern, int __cflags);



extern int regexec (const regex_t *__restrict __preg, const char *__restrict __string, size_t __nmatch, regmatch_t __pmatch[], int __eflags);




extern size_t regerror (int __errcode, const regex_t *__preg, char *__errbuf, size_t __errbuf_size);


extern void regfree (regex_t *__preg);



}
# 23 "/coolo/prod/kdelibs/kdecore/kregpriv.h" 2
}

class KRegExpDataPtr;







class KRegExpPrivate
{
public:
  KRegExpPrivate();
  KRegExpPrivate( const char *_pattern, const char *_mode = "" );
  ~KRegExpPrivate();

  bool compile( const char *_pattern, const char *_mode = "" );

  bool match( const char *_string );
  const char *group( int _grp );
  int groupStart( int _grp );
  int groupEnd( int _grp );

protected:
  regex_t m_pattern;
  regmatch_t m_matches[ 10 ];
  char* m_strMatches[10];
  bool m_bInit;

private:
  KRegExpDataPtr *d;
};
# 27 "/coolo/prod/kdelibs/kdecore/kregexp.cpp" 2


KRegExpPrivate::KRegExpPrivate()
{
  m_bInit = false;

  for ( int i = 0; i < 10; i++ )
    m_strMatches[i] = 0L;
}

KRegExpPrivate::KRegExpPrivate( const char *_pattern, const char *_mode )
{
  m_bInit = false;

  for ( int i = 0; i < 10; i++ )
    m_strMatches[i] = 0L;

  compile( _pattern, _mode );
}

KRegExpPrivate::~KRegExpPrivate()
{
  for ( int i = 0; i < 10; i++ )
    if ( m_strMatches[i] )
      free( m_strMatches[i] );

  if ( m_bInit )
    regfree( &m_pattern );
}

bool KRegExpPrivate::compile( const char *_pattern, const char *_mode )
{
  if ( m_bInit )
    regfree( &m_pattern );

  int res = regcomp( &m_pattern, _pattern, ( strchr( _mode, 'i' ) != 0L ? (1 << 1) : 0 ) | 1 );
  if ( res == 0 )
    m_bInit = true;

  return ( res == 0 );
}

bool KRegExpPrivate::match( const char *_string )
{
  if ( !m_bInit )
  {
    kdDebug(128) << "You must compile a pattern before you can try to match it" << endl;
    (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kregexp.cpp", 74, __PRETTY_FUNCTION__), 0)));
  }

  for ( int i = 0; i < 10; i++ )
  {
    m_matches[i].rm_so = -1;
    m_matches[i].rm_eo = -1;
    if ( m_strMatches[i] )
    {
      free( m_strMatches[i] );
      m_strMatches[i] = 0L;
    }
  }

  int res = regexec( &m_pattern, _string, 10, m_matches, 0 );
  if ( res != 0 )
    return false;

  int slen = strlen( _string );

  for ( int j = 0; j < 10; j++ )
  {
    if ( m_matches[j].rm_so >= 0 && m_matches[j].rm_eo >= 0 &&
         m_matches[j].rm_so <= slen && m_matches[j].rm_eo <= slen &&
         m_matches[j].rm_so <= m_matches[j].rm_eo )
    {
      int len = m_matches[j].rm_eo - m_matches[j].rm_so;
      m_strMatches[j] = ( char* )malloc( len + 1 );
      memcpy( m_strMatches[j], _string + m_matches[j].rm_so, len );
      m_strMatches[j][ len ] = 0;
    }
  }

  return true;
}

const char* KRegExpPrivate::group( int _grp )
{
  if ( _grp < 0 || _grp >= 10 )
  {
    kdDebug(128) << "You may only use a group in the range of 0..9" << endl;
    (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kregexp.cpp", 115, __PRETTY_FUNCTION__), 0)));
  }

  return m_strMatches[ _grp ];
}

int KRegExpPrivate::groupStart( int _grp )
{
  if ( _grp < 0 || _grp >= 10 )
  {
    kdDebug(128) << "You may only use a group in the range of 0..9" << endl;
    (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kregexp.cpp", 126, __PRETTY_FUNCTION__), 0)));
  }

  return m_matches[ _grp ].rm_so;
}

int KRegExpPrivate::groupEnd( int _grp )
{
  if ( _grp < 0 || _grp >= 10 )
  {
    kdDebug(128) << "You may only use a group in the range of 0..9" << endl;
    (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kregexp.cpp", 137, __PRETTY_FUNCTION__), 0)));
  }

  return m_matches[ _grp ].rm_eo;
}

KRegExp::KRegExp()
{
  m_pPrivate = new KRegExpPrivate;
}

KRegExp::KRegExp( const char *_pattern, const char *_mode)
{
  m_pPrivate = new KRegExpPrivate( _pattern, _mode );
}

KRegExp::~KRegExp()
{
  delete m_pPrivate;
}

bool KRegExp::compile( const char *_pattern, const char *_mode)
{
  return m_pPrivate->compile( _pattern, _mode );
}

bool KRegExp::match( const char *_string )
{
  return m_pPrivate->match( _string );
}

const char* KRegExp::group( int _grp )
{
  return m_pPrivate->group( _grp );
}

int KRegExp::groupStart( int _grp )
{
  return m_pPrivate->groupStart( _grp );
}

int KRegExp::groupEnd( int _grp )
{
  return m_pPrivate->groupEnd( _grp );
}
# 43 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kglobal.cpp" 1
# 25 "/coolo/prod/kdelibs/kdecore/kglobal.cpp"
# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 26 "/coolo/prod/kdelibs/kdecore/kglobal.cpp" 2
# 43 "/coolo/prod/kdelibs/kdecore/kglobal.cpp"







static void kglobal_init();

KStandardDirs *KGlobal::dirs()
{
    if (!_instance) qFatal("Fatal error: you need to have a KInstance object before\n" "you do anything that requires it! Examples of this are config\n" "objects, standard directories or translations.");;

    return _instance->dirs();
}

KConfig *KGlobal::config()
{
    if (!_instance) qFatal("Fatal error: you need to have a KInstance object before\n" "you do anything that requires it! Examples of this are config\n" "objects, standard directories or translations.");;

    return _instance->config();
}

KIconLoader *KGlobal::iconLoader()
{
    if (!_instance) qFatal("Fatal error: you need to have a KInstance object before\n" "you do anything that requires it! Examples of this are config\n" "objects, standard directories or translations.");;

    return _instance->iconLoader();
}

KInstance *KGlobal::instance()
{
    if (!_instance) qFatal("Fatal error: you need to have a KInstance object before\n" "you do anything that requires it! Examples of this are config\n" "objects, standard directories or translations.");;
    return _instance;
}

KLocale *KGlobal::locale()
{
    if( _locale == 0 ) {
        if (!_instance)
           return 0;
        kglobal_init();


        KLocale::initInstance();
    }

    return _locale;
}

KCharsets *KGlobal::charsets()
{
    if( _charsets == 0 ) {
        _charsets =new KCharsets();
        kglobal_init();
    }

    return _charsets;
}

void KGlobal::setActiveInstance(KInstance *i)
{
    _activeInstance = i;
    if (i && _locale)
        _locale->setActiveCatalogue(QString::fromUtf8(i->instanceName()));
}







const QString &
KGlobal::staticQString(const char *str)
{
   return staticQString(QString::fromLatin1(str));
}

class KStringDict : public QDict<QString>
{
public:
   KStringDict() : QDict<QString>(139) { };
};







const QString &
KGlobal::staticQString(const QString &str)
{
    if (!_stringDict) {
      _stringDict = new KStringDict;
      _stringDict->setAutoDelete( true );
      kglobal_init();
    }
   QString *result = _stringDict->find(str);
   if (!result)
   {
      result = new QString(str);
      _stringDict->insert(str, result);
   }
   return *result;
}

class KStaticDeleterList: public QPtrList<KStaticDeleterBase>
{
public:
   KStaticDeleterList() { };
};

void
KGlobal::registerStaticDeleter(KStaticDeleterBase *obj)
{
   if (!_staticDeleters)
      kglobal_init();
   if (_staticDeleters->find(obj) == -1)
      _staticDeleters->append(obj);
}

void
KGlobal::unregisterStaticDeleter(KStaticDeleterBase *obj)
{
   if (_staticDeleters)
      _staticDeleters->removeRef(obj);
}

void
KGlobal::deleteStaticDeleters()
{
    if (!KGlobal::_staticDeleters)
        return;

    for(;_staticDeleters->count();)
    {
        _staticDeleters->take(0)->destructObject();
    }

    delete KGlobal::_staticDeleters;
    KGlobal::_staticDeleters = 0;
}



KStringDict *KGlobal::_stringDict = 0;
KInstance *KGlobal::_instance = 0;
KInstance *KGlobal::_activeInstance = 0;
KLocale *KGlobal::_locale = 0;
KCharsets *KGlobal::_charsets = 0;
KStaticDeleterList *KGlobal::_staticDeleters = 0;

static void kglobal_freeAll()
{
    delete KGlobal::_locale;
    KGlobal::_locale = 0;
    delete KGlobal::_charsets;
    KGlobal::_charsets = 0;
    delete KGlobal::_stringDict;
    KGlobal::_stringDict = 0;
    KGlobal::deleteStaticDeleters();

    KGlobal::setActiveInstance(0);
}

static bool addedFreeAll = false;

static void kglobal_init()
{
    if (addedFreeAll)
        return;

    addedFreeAll = true;
    KGlobal::_staticDeleters = new KStaticDeleterList;

    qAddPostRoutine( kglobal_freeAll );
}
# 44 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kglobalsettings.cpp" 1
# 18 "/coolo/prod/kdelibs/kdecore/kglobalsettings.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 19 "/coolo/prod/kdelibs/kdecore/kglobalsettings.cpp" 2
# 52 "/coolo/prod/kdelibs/kdecore/kglobalsettings.cpp"
QString* KGlobalSettings::s_desktopPath = 0;
QString* KGlobalSettings::s_autostartPath = 0;
QString* KGlobalSettings::s_trashPath = 0;
QString* KGlobalSettings::s_documentPath = 0;
QFont *KGlobalSettings::_generalFont = 0;
QFont *KGlobalSettings::_fixedFont = 0;
QFont *KGlobalSettings::_toolBarFont = 0;
QFont *KGlobalSettings::_menuFont = 0;
QFont *KGlobalSettings::_windowTitleFont = 0;
QFont *KGlobalSettings::_taskbarFont = 0;
QFont *KGlobalSettings::_largeFont = 0;
QColor *KGlobalSettings::kde2Blue = 0;
QColor *KGlobalSettings::kde2Gray = 0;
QColor *KGlobalSettings::kde2AlternateColor = 0;

KGlobalSettings::KMouseSettings *KGlobalSettings::s_mouseSettings = 0;

int KGlobalSettings::dndEventDelay()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "General" );
    return c->readNumEntry("StartDragDist", QApplication::startDragDistance());
}

bool KGlobalSettings::singleClick()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "KDE" );
    return c->readBoolEntry("SingleClick", true);
}

KGlobalSettings::TearOffHandle KGlobalSettings::insertTearOffHandle()
{
    int tearoff;
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "KDE" );
    tearoff =c->readNumEntry("InsertTearOffHandle", 0);
    return (TearOffHandle) tearoff;
}

bool KGlobalSettings::changeCursorOverIcon()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "KDE" );
    return c->readBoolEntry("ChangeCursor", true);
}

bool KGlobalSettings::visualActivate()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "KDE" );
    return c->readBoolEntry("VisualActivate", true);
}

unsigned int KGlobalSettings::visualActivateSpeed()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "KDE" );
    return
        c->readNumEntry(
            "VisualActivateSpeed",
            50
        );
}



int KGlobalSettings::autoSelectDelay()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "KDE" );
    return c->readNumEntry("AutoSelectDelay", -1);
}

KGlobalSettings::Completion KGlobalSettings::completionMode()
{
    int completion;
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "General" );
    completion = c->readNumEntry("completionMode", -1);
    if ((completion < (int) CompletionNone) ||
        (completion > (int) CompletionPopupAuto))
      {
        completion = (int) CompletionPopup;
      }
  return (Completion) completion;
}

bool KGlobalSettings::showContextMenusOnPress ()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs (c, "ContextMenus");

    return cgs.config()->readBoolEntry("ShowOnPress", true);
}

int KGlobalSettings::contextMenuKey ()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs (c, "Shortcuts");

    KShortcut cut (cgs.config()->readEntry ("PopupMenuContext", "Menu"));
    return cut.keyCodeQt();
}

QColor KGlobalSettings::toolBarHighlightColor()
{
    initColors();
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("Toolbar style") );
    return c->readColorEntry("HighlightColor", kde2Blue);
}

QColor KGlobalSettings::inactiveTitleColor()
{
    if (!kde2Gray)
        kde2Gray = new QColor(220, 220, 220);
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("WM") );
    return c->readColorEntry( "inactiveBackground", kde2Gray );
}

QColor KGlobalSettings::inactiveTextColor()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("WM") );
    return c->readColorEntry( "inactiveForeground", &Qt::darkGray );
}

QColor KGlobalSettings::activeTitleColor()
{
    initColors();
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("WM") );
    return c->readColorEntry( "activeBackground", kde2Blue);
}

QColor KGlobalSettings::activeTextColor()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("WM") );
    return c->readColorEntry( "activeForeground", &Qt::white );
}

int KGlobalSettings::contrast()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("KDE") );
    return c->readNumEntry( "contrast", 7 );
}




QColor KGlobalSettings::baseColor()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    return c->readColorEntry( "windowBackground", &Qt::white );
}




QColor KGlobalSettings::textColor()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    return c->readColorEntry( "windowForeground", &Qt::black );
}




QColor KGlobalSettings::highlightedTextColor()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    return c->readColorEntry( "selectForeground", &Qt::white );
}




QColor KGlobalSettings::highlightColor()
{
    initColors();
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    return c->readColorEntry( "selectBackground", kde2Blue );
}

QColor KGlobalSettings::alternateBackgroundColor()
{
    initColors();
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    *kde2AlternateColor = calculateAlternateBackgroundColor( baseColor() );
    return c->readColorEntry( "alternateBackground", kde2AlternateColor );
}

QColor KGlobalSettings::calculateAlternateBackgroundColor(const QColor& base)
{
    if (base == Qt::white)
        return QColor(238,246,255);
    else
    {
        int h, s, v;
        base.hsv( &h, &s, &v );
        if (v > 128)
            return base.dark(106);
        else if (base != Qt::black)
            return base.light(110);

        return QColor(32,32,32);
    }
}

QColor KGlobalSettings::linkColor()
{
    initColors();
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    return c->readColorEntry( "linkColor", kde2Blue );
}

QColor KGlobalSettings::visitedLinkColor()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    return c->readColorEntry( "visitedLinkColor", &Qt::magenta );
}

QFont KGlobalSettings::generalFont()
{
    if (_generalFont)
        return *_generalFont;


    _generalFont = new QFont("helvetica", 12);
    _generalFont->setPointSize(12);
    _generalFont->setStyleHint(QFont::SansSerif);

    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    *_generalFont = c->readFontEntry("font", _generalFont);

    return *_generalFont;
}

QFont KGlobalSettings::fixedFont()
{
    if (_fixedFont)
        return *_fixedFont;


    _fixedFont = new QFont("courier", 12);
    _fixedFont->setPointSize(12);
    _fixedFont->setStyleHint(QFont::TypeWriter);

    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    *_fixedFont = c->readFontEntry("fixed", _fixedFont);

    return *_fixedFont;
}

QFont KGlobalSettings::toolBarFont()
{
    if(_toolBarFont)
        return *_toolBarFont;


    _toolBarFont = new QFont("helvetica", 10);
    _toolBarFont->setPointSize(10);
    _toolBarFont->setStyleHint(QFont::SansSerif);

    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    *_toolBarFont = c->readFontEntry("toolBarFont", _toolBarFont);

    return *_toolBarFont;
}

QFont KGlobalSettings::menuFont()
{
    if(_menuFont)
        return *_menuFont;


    _menuFont = new QFont("helvetica", 12);
    _menuFont->setPointSize(12);
    _menuFont->setStyleHint(QFont::SansSerif);

    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    *_menuFont = c->readFontEntry("menuFont", _menuFont);

    return *_menuFont;
}

QFont KGlobalSettings::windowTitleFont()
{
    if(_windowTitleFont)
        return *_windowTitleFont;


    _windowTitleFont = new QFont("helvetica", 12, QFont::Bold);
    _windowTitleFont->setPointSize(12);
    _windowTitleFont->setStyleHint(QFont::SansSerif);

    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("WM") );
    *_windowTitleFont = c->readFontEntry("activeFont", _windowTitleFont);

    return *_windowTitleFont;
}

QFont KGlobalSettings::taskbarFont()
{
    if(_taskbarFont)
        return *_taskbarFont;


    _taskbarFont = new QFont("helvetica", 11);
    _taskbarFont->setPointSize(11);
    _taskbarFont->setStyleHint(QFont::SansSerif);

    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, QString::fromLatin1("General") );
    *_taskbarFont = c->readFontEntry("taskbarFont", _taskbarFont);

    return *_taskbarFont;
}


QFont KGlobalSettings::largeFont(const QString &text)
{
    QFontDatabase db;
    QStringList fam = db.families();


    if (fam.remove("Arial"))
       fam.prepend("Arial");
    if (fam.remove("Verdana"))
       fam.prepend("Verdana");
    if (fam.remove("Tahoma"))
       fam.prepend("Tahoma");
    if (fam.remove("Lucida Sans"))
       fam.prepend("Lucida Sans");
    if (fam.remove("Lucidux Sans"))
       fam.prepend("Lucidux Sans");
    if (fam.remove("Nimbus Sans"))
       fam.prepend("Nimbus Sans");
    if (fam.remove("Gothic I"))
       fam.prepend("Gothic I");

    if (_largeFont)
        fam.prepend(_largeFont->family());

    for(QStringList::ConstIterator it = fam.begin();
        it != fam.end(); ++it)
    {
        if (db.isSmoothlyScalable(*it) && !db.isFixedPitch(*it))
        {
            QFont font(*it);
            font.setPixelSize(75);
            QFontMetrics metrics(font);
            int h = metrics.height();
            if ((h < 60) || ( h > 90))
                continue;

            bool ok = true;
            for(unsigned int i = 0; i < text.length(); i++)
            {
                if (!metrics.inFont(text[i]))
                {
                    ok = false;
                    break;
                }
            }
            if (!ok)
                continue;

            font.setPointSize(48);
            _largeFont = new QFont(font);
            return *_largeFont;
        }
    }
    _largeFont = new QFont(KGlobalSettings::generalFont());
    _largeFont->setPointSize(48);
    return *_largeFont;
}

void KGlobalSettings::initStatic()
{
    if ( s_desktopPath != 0 )
        return;

    s_desktopPath = new QString();
    s_autostartPath = new QString();
    s_trashPath = new QString();
    s_documentPath = new QString();

    KConfig *config = KGlobal::config();
    KConfigGroupSaver cgs( config, "Paths" );


    *s_desktopPath = QDir::homeDirPath() + "/Desktop/";
    *s_desktopPath = config->readPathEntry( "Desktop", *s_desktopPath);
    if ( !s_desktopPath->startsWith("/") )
      s_desktopPath->prepend( QDir::homeDirPath() + "/" );
    *s_desktopPath = QDir::cleanDirPath( *s_desktopPath );
    if ( !s_desktopPath->endsWith("/") )
      s_desktopPath->append('/');


    *s_trashPath = *s_desktopPath + i18n("Trash") + "/";
    *s_trashPath = config->readPathEntry( "Trash" , *s_trashPath);
    if ( !s_trashPath->startsWith("/") )
      s_trashPath->prepend( QDir::homeDirPath() + "/" );
    *s_trashPath = QDir::cleanDirPath( *s_trashPath );
    if ( !s_trashPath->endsWith("/") )
      s_trashPath->append('/');

    if ( !config->hasKey( "Trash" ) )
    {
      config->writePathEntry( "Trash", *s_trashPath, true, true );
      config->sync();
    }


    *s_autostartPath = KGlobal::dirs()->localkdedir() + "Autostart/";
    *s_autostartPath = config->readPathEntry( "Autostart" , *s_autostartPath);
    if ( !s_autostartPath->startsWith("/") )
      s_autostartPath->prepend( QDir::homeDirPath() + "/" );
    *s_autostartPath = QDir::cleanDirPath( *s_autostartPath );
    if ( !s_autostartPath->endsWith("/") )
      s_autostartPath->append('/');


    *s_documentPath = config->readPathEntry( "Documents" );
    if ( !s_documentPath->startsWith("/") )
      s_documentPath->prepend( QDir::homeDirPath() + "/" );
    *s_documentPath = QDir::cleanDirPath( *s_documentPath );
    if ( !s_documentPath->endsWith("/"))
      s_documentPath->append('/');



    if (KApplication::kApplication())
        KApplication::kApplication()->addKipcEventMask(KIPC::SettingsChanged);

}

void KGlobalSettings::initColors()
{
    if (!kde2Blue) {
      if (QPixmap::defaultDepth() > 8)
        kde2Blue = new QColor(84, 112, 152);
      else
        kde2Blue = new QColor(0, 0, 192);
    }
    if (!kde2AlternateColor)
      kde2AlternateColor = new QColor(240, 240, 240);
}

void KGlobalSettings::rereadFontSettings()
{
    delete _generalFont;
    _generalFont = 0L;
    delete _fixedFont;
    _fixedFont = 0L;
    delete _menuFont;
    _menuFont = 0L;
    delete _toolBarFont;
    _toolBarFont = 0L;
    delete _windowTitleFont;
    _windowTitleFont = 0L;
    delete _taskbarFont;
    _taskbarFont = 0L;
}

void KGlobalSettings::rereadPathSettings()
{
    kdDebug() << "KGlobalSettings::rereadPathSettings" << endl;
    delete s_autostartPath;
    s_autostartPath = 0L;
    delete s_trashPath;
    s_trashPath = 0L;
    delete s_desktopPath;
    s_desktopPath = 0L;
    delete s_documentPath;
    s_documentPath = 0L;
}

KGlobalSettings::KMouseSettings & KGlobalSettings::mouseSettings()
{
    if ( ! s_mouseSettings )
    {
        s_mouseSettings = new KMouseSettings;
        KMouseSettings & s = *s_mouseSettings;

        KConfigGroupSaver cgs( KGlobal::config(), "Mouse" );
        QString setting = KGlobal::config()->readEntry("MouseButtonMapping");
        if (setting == "RightHanded")
            s.handed = KMouseSettings::RightHanded;
        else if (setting == "LeftHanded")
            s.handed = KMouseSettings::LeftHanded;
        else
        {




            s.handed = KMouseSettings::RightHanded;
            unsigned char map[5];
            switch (XGetPointerMapping(KApplication::kApplication()->getDisplay(), map, 5))
            {
                case 2:
                    if ( (int)map[0] == 1 && (int)map[1] == 2 )
                        s.handed = KMouseSettings::RightHanded;
                    else if ( (int)map[0] == 2 && (int)map[1] == 1 )
                        s.handed = KMouseSettings::LeftHanded;
                    break;
                case 3:
                case 5:
                    if ( (int)map[0] == 1 && (int)map[2] == 3 )
                        s.handed = KMouseSettings::RightHanded;
                    else if ( (int)map[0] == 3 && (int)map[2] == 1 )
                        s.handed = KMouseSettings::LeftHanded;
                    break;
                default:
                    break;
            }



        }
    }
    return *s_mouseSettings;
}

void KGlobalSettings::rereadMouseSettings()
{
    delete s_mouseSettings;
    s_mouseSettings = 0L;
}

bool KGlobalSettings::isMultiHead()
{
    QCString multiHead = getenv("KDE_MULTIHEAD");
    if (!multiHead.isEmpty()) {
        return (multiHead.lower() == "true");
    }
    return false;
}

bool KGlobalSettings::wheelMouseZooms()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "KDE" );
    return c->readBoolEntry( "WheelMouseZooms", false );
}

QRect KGlobalSettings::splashScreenDesktopGeometry()
{
    QDesktopWidget *dw = QApplication::desktop();

    if (dw->isVirtualDesktop()) {
        KConfigGroup group(KGlobal::config(), "Windows");
        int scr = group.readNumEntry("Unmanaged", -3);
        if (group.readBoolEntry("XineramaEnabled", true) && scr != -2) {
            if (scr == -3)
                scr = dw->screenNumber(QCursor::pos());
            return dw->screenGeometry(scr);
        } else {
            return dw->geometry();
        }
    } else {
        return dw->geometry();
    }
}

QRect KGlobalSettings::desktopGeometry(const QPoint& point)
{
    QDesktopWidget *dw = QApplication::desktop();

    if (dw->isVirtualDesktop()) {
        KConfigGroup group(KGlobal::config(), "Windows");
        if (group.readBoolEntry("XineramaEnabled", true) &&
            group.readBoolEntry("XineramaPlacementEnabled", true)) {
            return dw->screenGeometry(dw->screenNumber(point));
        } else {
            return dw->geometry();
        }
    } else {
        return dw->geometry();
    }
}

QRect KGlobalSettings::desktopGeometry(QWidget* w)
{
    QDesktopWidget *dw = QApplication::desktop();

    if (dw->isVirtualDesktop()) {
        KConfigGroup group(KGlobal::config(), "Windows");
        if (group.readBoolEntry("XineramaEnabled", true) &&
            group.readBoolEntry("XineramaPlacementEnabled", true)) {
            if (w)
                return dw->screenGeometry(dw->screenNumber(w));
            else return dw->screenGeometry(-1);
        } else {
            return dw->geometry();
        }
    } else {
        return dw->geometry();
    }
}

bool KGlobalSettings::showIconsOnPushButtons()
{
    KConfig *c = KGlobal::config();
    KConfigGroupSaver cgs( c, "KDE" );
    return c->readBoolEntry("ShowIconsOnPushButtons",
        false);
}

bool KGlobalSettings::showFilePreview(const KURL &url)
{
    KConfigGroup g(KGlobal::config(), "PreviewSettings");
    QString protocol = url.protocol();
    QString protocolClass = KProtocolInfo::protocolClass(protocol);
    return g.readBoolEntry(protocol, (protocolClass == ":local") );
}
# 45 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kallocator.cpp" 1
# 30 "/coolo/prod/kdelibs/kdecore/kallocator.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kallocator.h" 1
# 28 "/coolo/prod/kdelibs/kdecore/kallocator.h"



class KZoneAllocatorPrivate;
# 47 "/coolo/prod/kdelibs/kdecore/kallocator.h"
class KZoneAllocator
{
public:




    KZoneAllocator(unsigned long _blockSize = 8*1024);




    ~KZoneAllocator();






    void* allocate(size_t _size);
# 88 "/coolo/prod/kdelibs/kdecore/kallocator.h"
    void deallocate(void *ptr);
# 110 "/coolo/prod/kdelibs/kdecore/kallocator.h"
    void free_since(void *ptr);

protected:
    class MemBlock;
    typedef QValueList<MemBlock *> MemList;
    void addBlock(MemBlock *b);
    void delBlock(MemBlock *b);
    void insertHash(MemBlock *b);
    void initHash();
    MemBlock *currentBlock;
    unsigned long blockSize;
    unsigned long blockOffset;
    unsigned int log2;
    unsigned int num_blocks;
    MemList **hashList;
    unsigned int hashSize;
    bool hashDirty;
private:
    KZoneAllocatorPrivate *d;
};
# 31 "/coolo/prod/kdelibs/kdecore/kallocator.cpp" 2


class KZoneAllocator::MemBlock
{
  public:
    MemBlock(size_t s) : size(s), ref(0), older(0), newer(0)
      { begin = new char[s]; }
    ~MemBlock() { delete [] begin; }
    bool is_in(void *ptr) const {return !(begin > (char *)ptr
                                          || (begin + size) <= (char *)ptr); }
    size_t size;
    unsigned int ref;
    char *begin;
    MemBlock *older;
    MemBlock *newer;
};

KZoneAllocator::KZoneAllocator(unsigned long _blockSize)
: currentBlock(0), blockSize(1), blockOffset(0), log2(0), num_blocks(0),
  hashList(0), hashSize(0), hashDirty(true)
{
  while (blockSize < _blockSize)
    blockSize <<= 1, log2++;


  blockOffset = blockSize + 1;
}

KZoneAllocator::~KZoneAllocator()
{
  unsigned int count = 0;
  if (hashList) {


    for (unsigned int i = 0; i < hashSize; i++)
      delete hashList[i];
    delete [] hashList;
    hashList = 0;
  }
  MemBlock *next;
  for (; currentBlock; currentBlock = next) {
    next = currentBlock->older;
    delete currentBlock;
    count++;
  }


  if (count > 1)
    qDebug("zone still contained %d blocks", count);

}

void KZoneAllocator::insertHash(MemBlock *b)
{
  unsigned int adr = ((unsigned long)b->begin) & (~(blockSize - 1));
  unsigned int end = ((unsigned long)b->begin) + blockSize;
  while (adr < end) {
    unsigned int key = adr >> log2;
    key = key & (hashSize - 1);
    if (!hashList[key])
      hashList[key] = new QValueList<MemBlock *>;
    hashList[key]->append(b);
    adr += blockSize;
  }
}

void KZoneAllocator::addBlock(MemBlock *b)
{
  b->newer = 0;
  b->older = currentBlock;
  if (currentBlock)
    b->older->newer = b;
  currentBlock = b;
  num_blocks++;



  if (hashList && ((num_blocks / 4) > hashSize && hashSize < 64*1024))
    hashDirty = true;


  if (hashList && !hashDirty)
    insertHash (b);
}

void KZoneAllocator::initHash()
{
  if (hashList) {
    for (unsigned int i = 0; i < hashSize; i++)
      delete hashList[i];
    delete [] hashList;
    hashList = 0;
  }
  hashSize = 1;
  while (hashSize < num_blocks)
    hashSize <<= 1;
  if (hashSize < 1024)
    hashSize = 1024;
  if (hashSize > 64*1024)
    hashSize = 64*1024;
  hashList = new QValueList<MemBlock *> *[hashSize];
  memset (hashList, 0, sizeof(QValueList<MemBlock*> *) * hashSize);
  hashDirty = false;
  for (MemBlock *b = currentBlock; b; b = b->older)
    insertHash(b);
}

void KZoneAllocator::delBlock(MemBlock *b)
{


  if (hashList && !hashDirty) {
    unsigned int adr = ((unsigned long)b->begin) & (~(blockSize - 1));
    unsigned int end = ((unsigned long)b->begin) + blockSize;
    while (adr < end) {
      unsigned int key = adr >> log2;
      key = key & (hashSize - 1);
      if (hashList[key]) {
        QValueList<MemBlock *> *list = hashList[key];
        QValueList<MemBlock *>::Iterator it = list->begin();
        QValueList<MemBlock *>::Iterator endit = list->end();
        for (; it != endit; ++it)
          if (*it == b) {
            list->remove(it);
            break;
          }
      }
      adr += blockSize;
    }
  }
  if (b->older)
    b->older->newer = b->newer;
  if (b->newer)
    b->newer->older = b->older;
  if (b == currentBlock) {
    currentBlock = 0;
    blockOffset = blockSize;
  }
  delete b;
  num_blocks--;
}

void *
KZoneAllocator::allocate(size_t _size)
{

   const size_t alignment = sizeof(void *) - 1;
   _size = (_size + alignment) & ~alignment;

   if ((unsigned long) _size + blockOffset > blockSize)
   {
      if (_size > blockSize) {
        qDebug("KZoneAllocator: allocating more than %lu bytes", blockSize);
        return 0;
      }
      addBlock(new MemBlock(blockSize));
      blockOffset = 0;

   }
   void *result = (void *)(currentBlock->begin+blockOffset);
   currentBlock->ref++;
   blockOffset += _size;
   return result;
}

void
KZoneAllocator::deallocate(void *ptr)
{
  if (hashDirty)
    initHash();

  unsigned int key = (((unsigned long)ptr) >> log2) & (hashSize - 1);
  QValueList<MemBlock *> *list = hashList[key];
  if (!list) {



    return;
  }
  QValueList<MemBlock*>::ConstIterator it = list->begin();
  QValueList<MemBlock*>::ConstIterator endit = list->end();
  for (; it != endit; ++it) {
    MemBlock *cur = *it;
    if (cur->is_in(ptr)) {
      if (!--cur->ref) {
        if (cur != currentBlock)
          delBlock (cur);
        else
          blockOffset = 0;
      }
      return;
    }
  }



}

void
KZoneAllocator::free_since(void *ptr)
{



  if (hashList && !hashDirty)
    {
      const MemBlock *b;
      unsigned int removed = 0;
      for (b = currentBlock; b; b = b->older, removed++)
        if (b->is_in (ptr))
          break;
      if (hashSize >= 4 * (num_blocks - removed))
        hashDirty = true;
    }
  while (currentBlock && !currentBlock->is_in(ptr)) {
    currentBlock = currentBlock->older;
    delBlock (currentBlock->newer);
  }
  blockOffset = ((char*)ptr) - currentBlock->begin;
}
# 46 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kvmallocator.cpp" 1
# 37 "/coolo/prod/kdelibs/kdecore/kvmallocator.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kvmallocator.h" 1
# 26 "/coolo/prod/kdelibs/kdecore/kvmallocator.h"




class KVMAllocatorPrivate;
# 40 "/coolo/prod/kdelibs/kdecore/kvmallocator.h"
class KVMAllocator
{
public:
    struct Block;




    KVMAllocator();




    ~KVMAllocator();






    Block *allocate(size_t _size);





    void free(Block *block);
# 78 "/coolo/prod/kdelibs/kdecore/kvmallocator.h"
    bool copyBlock(void *dest, Block *src, int _offset = 0, size_t length = 0);





    void copy(void *dest, Block *src, int _offset = 0, size_t length = 0) __attribute__ ((deprecated));
# 96 "/coolo/prod/kdelibs/kdecore/kvmallocator.h"
    bool copyBlock(Block *dest, void *src, int _offset = 0, size_t length = 0);





    void copy(Block *dest, void *src, int _offset = 0, size_t length = 0) __attribute__ ((deprecated));





    void *map(Block *block);





    void unmap(Block *block);

private:
    KVMAllocatorPrivate *d;
};
# 38 "/coolo/prod/kdelibs/kdecore/kvmallocator.cpp" 2



struct KVMAllocator::Block
{
   off_t start;
   size_t length;
   size_t size;
   void *mmap;
};


class KVMAllocatorPrivate
{
public:
   KTempFile *tempfile;
   off_t max_length;
   QMap<off_t, KVMAllocator::Block> used_blocks;
   QMap<off_t, KVMAllocator::Block> free_blocks;
};




KVMAllocator::KVMAllocator()
{
   d = new KVMAllocatorPrivate;
   d->tempfile = 0;
   d->max_length = 0;
}




KVMAllocator::~KVMAllocator()
{
   delete d->tempfile;
   delete d;
}





KVMAllocator::Block *
KVMAllocator::allocate(size_t _size)
{
   if (!d->tempfile)
   {
      d->tempfile = new KTempFile(QString::null, "vmdata");
      d->tempfile->unlink();
   }

   QMap<off_t,KVMAllocator::Block>::iterator it;
   it = d->free_blocks.begin();
   while (it != d->free_blocks.end())
   {
      if (it.data().size > _size)
      {
         Block &free_block = it.data();
         Block block;
         kdDebug(13020)<<"VM alloc: using block from free list "<<(long)free_block.start<<" size ="<<(long)free_block.size<<" request = "<<_size<< endl;
         block.start = free_block.start;
         block.length = _size;
         block.size = (_size + 4095) & ~4095;
         block.mmap = 0;
         free_block.size -= block.size;
         free_block.start += block.size;
         if (!free_block.size)
            d->free_blocks.remove(it);
         it = d->used_blocks.replace(block.start, block);
         return &(it.data());
      }
      ++it;
   }



   Block block;
   block.start = d->max_length;
   block.length = _size;
   block.size = (_size + 4095) & ~4095;
   block.mmap = 0;
   kdDebug(13020)<<"VM alloc: using new block "<<(long)block.start<<" size ="<<(long)block.size<<" request = "<<_size<< endl;
   it = d->used_blocks.replace(block.start, block);
   d->max_length += block.size;
   return &(it.data());
}




void
KVMAllocator::free(Block *block_p)
{
   Block block = *block_p;
   if (block.mmap)
   {
      kdDebug(13020)<<"VM free: Block "<<(long)block.start<<" is still mmapped!"<<endl;
      return;
   }
   QMap<off_t,KVMAllocator::Block>::iterator it;
   it = d->used_blocks.find(block.start);
   if (it == d->used_blocks.end())
   {
      kdDebug(13020)<<"VM free: Block "<<(long)block.start<<" is not allocated."<<endl;
      return;
   }
   d->used_blocks.remove(it);
   it = d->free_blocks.replace(block.start, block);
   QMap<off_t,KVMAllocator::Block>::iterator before = it;
   --before;
   if (before != d->free_blocks.end())
   {
      Block &block_before = before.data();
      if ((block_before.start + off_t(block_before.size)) == block.start)
      {

         kdDebug(13020) << "VM merging: Block "<< (long)block_before.start<<
                           " with "<< (long)block.start<< " (before)" << endl;
         block.size += block_before.size;
         block.start = block_before.start;
         it.data() = block;
         d->free_blocks.remove(before);
      }
   }

   QMap<off_t,KVMAllocator::Block>::iterator after = it;
   ++after;
   if (after != d->free_blocks.end())
   {
      Block &block_after = after.data();
      if ((block.start + off_t(block.size)) == block_after.start)
      {

         kdDebug(13020) << "VM merging: Block "<< (long)block.start<<
                           " with "<< (long)block_after.start<< " (after)" << endl;
         block.size += block_after.size;
         it.data() = block;
         d->free_blocks.remove(after);
      }
   }
}




void
KVMAllocator::copy(void *dest, Block *src, int _offset, size_t length)
{
   (void) copyBlock(dest, src, _offset, length);
}

bool
KVMAllocator::copyBlock(void *dest, Block *src, int _offset, size_t length)
{

   lseek(d->tempfile->handle(), src->start+_offset, 0);
   if (length == 0)
      length = src->length - _offset;
   int to_go = length;
   int done = 0;
   char *buf = (char *) dest;
   while(done < to_go)
   {
      int n = read(d->tempfile->handle(), buf+done, to_go);
      if (n <= 0)
      {
         if (n < 0)
            return false;
         else
            return true;
      }
      done += n;
      to_go -= n;
   }

   return true;
}




void
KVMAllocator::copy(Block *dest, void *src, int _offset, size_t length)
{
   (void) copyBlock(dest, src, _offset, length);
}

bool
KVMAllocator::copyBlock(Block *dest, void *src, int _offset, size_t length)
{

   lseek(d->tempfile->handle(), dest->start+_offset, 0);
   if (length == 0)
      length = dest->length - _offset;
   int to_go = length;
   int done = 0;
   char *buf = (char *) src;
   while(done < to_go)
   {
      int n = write(d->tempfile->handle(), buf+done, to_go);
      if (n <= 0) return false;
      done += n;
      to_go -= n;
   }

   return true;
}




void *
KVMAllocator::map(Block *block)
{
   if (block->mmap)
      return block->mmap;

   void *result = mmap(0, block->length, 0x1| 0x2,
                       0x01, d->tempfile->handle(), block->start);
   block->mmap = result;
   return block->mmap;
}




void
KVMAllocator::unmap(Block *block)
{


   munmap((char *)block->mmap, block->length);
   block->mmap = 0;
}
# 47 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kmimesourcefactory.cpp" 1
# 27 "/coolo/prod/kdelibs/kdecore/kmimesourcefactory.cpp"
class KMimeSourceFactoryPrivate
{
public:
  inline KMimeSourceFactoryPrivate (KIconLoader* loader)
        : kil (loader)
  {}

  KIconLoader* kil;
};

KMimeSourceFactory::KMimeSourceFactory (KIconLoader* loader)
  : QMimeSourceFactory (),
        d (new KMimeSourceFactoryPrivate (loader))
{
}

KMimeSourceFactory::~KMimeSourceFactory()
{
  delete d;
}

QString KMimeSourceFactory::makeAbsolute (const QString& absOrRelName, const QString& context) const
{
  QString myName;
  QString myContext;

  const int pos = absOrRelName.find ('|');
  if (pos > -1)
        {
          myContext = absOrRelName.left (pos);
          myName = absOrRelName.right (absOrRelName.length() - myContext.length() - 1);
        }

  QString result;

  if (myContext == "desktop")
        {
          result = d->kil->iconPath (myName, KIcon::Desktop);
        }
  else if (myContext == "toolbar")
        {
          result = d->kil->iconPath (myName, KIcon::Toolbar);
        }
  else if (myContext == "maintoolbar")
        {
          result = d->kil->iconPath (myName, KIcon::MainToolbar);
        }
  else if (myContext == "small")
        {
          result = d->kil->iconPath (myName, KIcon::Small);
        }
  else if (myContext == "user")
        {
          result = d->kil->iconPath (myName, KIcon::User);
        }

  if (result.isEmpty())
        result = QMimeSourceFactory::makeAbsolute (absOrRelName, context);

  return result;
}

void KMimeSourceFactory::virtual_hook( int, void* )
{ }
# 48 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kinstance.cpp" 1
# 24 "/coolo/prod/kdelibs/kdecore/kinstance.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kaboutdata.h" 1
# 25 "/coolo/prod/kdelibs/kdecore/kinstance.cpp" 2







class KInstancePrivate
{
public:
    KInstancePrivate ()
    {
        mimeSourceFactory = 0L;
    }

    ~KInstancePrivate ()
    {
        delete mimeSourceFactory;
    }

    KMimeSourceFactory* mimeSourceFactory;
    QString configName;
    bool ownAboutdata;
};

KInstance::KInstance( const QCString& name)
  : _dirs (0L),
    _config (0L),
    _iconLoader (0L),
    _name( name ), _aboutData( new KAboutData( name, "", 0 ) )
{
    ((!name.isEmpty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!name.isEmpty()","/coolo/prod/kdelibs/kdecore/kinstance.cpp",56));
    if (!KGlobal::_instance)
    {
      KGlobal::_instance = this;
      KGlobal::setActiveInstance(this);
    }

    d = new KInstancePrivate ();
    d->ownAboutdata = true;
}

KInstance::KInstance( const KAboutData * aboutData )
  : _dirs (0L),
    _config (0L),
    _iconLoader (0L),
    _name( aboutData->appName() ), _aboutData( aboutData )
{
    ((!_name.isEmpty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!_name.isEmpty()","/coolo/prod/kdelibs/kdecore/kinstance.cpp",73));

    if (!KGlobal::_instance)
    {
      KGlobal::_instance = this;
      KGlobal::setActiveInstance(this);
    }

    d = new KInstancePrivate ();
    d->ownAboutdata = false;
}

KInstance::KInstance( KInstance* src )
  : _dirs ( src->_dirs ),
    _config ( src->_config ),
    _iconLoader ( src->_iconLoader ),
    _name( src->_name ), _aboutData( src->_aboutData )
{
    ((!_name.isEmpty()) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!_name.isEmpty()","/coolo/prod/kdelibs/kdecore/kinstance.cpp",91));

    if (!KGlobal::_instance || KGlobal::_instance == src )
    {
      KGlobal::_instance = this;
      KGlobal::setActiveInstance(this);
    }

    d = new KInstancePrivate ();
    d->ownAboutdata = src->d->ownAboutdata;

    src->_dirs = 0L;
    src->_config = 0L;
    src->_iconLoader = 0L;
    src->_aboutData = 0L;
    delete src;
}

KInstance::~KInstance()
{
    if (d->ownAboutdata)
        delete _aboutData;
    _aboutData = 0;

    delete d;
    d = 0;

    delete _iconLoader;
    _iconLoader = 0;
    delete _config;
    _config = 0;
    delete _dirs;
    _dirs = 0;

    if (KGlobal::_instance == this)
        KGlobal::_instance = 0;
    if (KGlobal::activeInstance() == this)
        KGlobal::setActiveInstance(0);
}


KStandardDirs *KInstance::dirs() const
{
    if( _dirs == 0 ) {
        _dirs = new KStandardDirs( );
        if (_config)
            if (_dirs->addCustomized(_config))
                _config->reparseConfiguration();
    }

    return _dirs;
}

KConfig *KInstance::config() const
{
    if( _config == 0 ) {
        if ( !d->configName.isEmpty() )
        {
            _config = new KConfig( d->configName );

            _config->setGroup( "KDE Action Restrictions" );
            if (_config->readBoolEntry( "custom_config", true))
            {
               _config->setGroup(QString::null);
            }
            else
            {
               delete _config;
               _config = 0;
            }

        }

        if ( _config == 0 )
        {
            if ( !_name.isEmpty() )
                _config = new KConfig( _name + "rc");
            else
                _config = new KConfig();
        }
        if (_dirs)
            if (_dirs->addCustomized(_config))
                _config->reparseConfiguration();
    }

    return _config;
}

void KInstance::setConfigName(const QString &configName)
{
    d->configName = configName;
}

KIconLoader *KInstance::iconLoader() const
{
    if( _iconLoader == 0 ) {
        _iconLoader = new KIconLoader( _name, dirs() );
    _iconLoader->enableDelayedIconSetLoading( true );
    }

    return _iconLoader;
}

void KInstance::newIconLoader() const
{
    KIconTheme::reconfigure();
    _iconLoader->reconfigure( _name, dirs() );
}

const KAboutData * KInstance::aboutData() const
{
    return _aboutData;
}

QCString KInstance::instanceName() const
{
    return _name;
}

KMimeSourceFactory* KInstance::mimeSourceFactory () const
{
  if (!d->mimeSourceFactory)
  {
    d->mimeSourceFactory = new KMimeSourceFactory(iconLoader());
  }

  return d->mimeSourceFactory;
}

void KInstance::virtual_hook( int, void* )
{ }
# 49 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kpalette.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/kpalette.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kpalette.h" 1
# 23 "/coolo/prod/kdelibs/kdecore/kpalette.h"






class KPalettePrivate;
# 46 "/coolo/prod/kdelibs/kdecore/kpalette.h"
class KPalette
{
public:





   static QStringList getPaletteList();






   KPalette(const QString &name=QString::null);




   KPalette(const KPalette &);




   virtual ~KPalette();




   KPalette& operator=( const KPalette &);






   bool save();





   QString description() const
        { return mDesc; }





   void setDescription(const QString &desc)
        { mDesc = desc; }





   QString name() const
        { return mName; }





   void setName(const QString &name)
        { mName = name; }






   enum Editable { Yes,
                   No,
                   Ask
   };





   Editable editable() const
        { return mEditable; }





   void setEditable(Editable editable)
        { mEditable = editable; }





   int nrColors() const
        { return (int) mKolorList.count(); }






   QColor color(int index);







   int findColor(const QColor &color) const;
# 166 "/coolo/prod/kdelibs/kdecore/kpalette.h"
   QString colorName(int index);
# 175 "/coolo/prod/kdelibs/kdecore/kpalette.h"
   QString colorName(const QColor &color)
        { return colorName( findColor(color)); }
# 185 "/coolo/prod/kdelibs/kdecore/kpalette.h"
   int addColor(const QColor &newColor,
                const QString &newColorName = QString::null);
# 197 "/coolo/prod/kdelibs/kdecore/kpalette.h"
   int changeColor(int index,
                   const QColor &newColor,
                   const QString &newColorName = QString::null);
# 210 "/coolo/prod/kdelibs/kdecore/kpalette.h"
   int changeColor(const QColor &oldColor,
                   const QColor &newColor,
                   const QString &newColorName = QString::null)
        { return changeColor( findColor(oldColor), newColor, newColorName); }

private:
   typedef struct { QColor color; QString name; } kolor;
   QPtrList<kolor> mKolorList;

   QString mName;
   QString mDesc;
   Editable mEditable;

   KPalettePrivate *d;
};
# 23 "/coolo/prod/kdelibs/kdecore/kpalette.cpp" 2






# 1 "/coolo/prod/kdelibs/kdecore/kstringhandler.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
# 69 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
class KStringHandler
{
public:







    static QString word( const QString &text , uint pos );
# 93 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString word( const QString &text , const char *range );
# 104 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString insword( const QString &text , const QString &word , uint pos );
# 115 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString setword( const QString &text , const QString &word , uint pos );
# 129 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString remrange( const QString &text , const char *range );
# 138 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString remword( const QString &text , uint pos );







    static QString remword( const QString &text , const QString &word );






    static QString capwords( const QString &text );






    static QStringList capwords( const QStringList &list );






    static QString reverse( const QString &text );






    static QStringList reverse( const QStringList &list );
# 184 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString ljust( const QString &text , uint width );
# 194 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString rjust( const QString &text , uint width );
# 204 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString center( const QString &text , uint width );







    static QString lsqueeze( const QString & str, uint maxlen = 40 );
# 224 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString lEmSqueeze( const QString & name,
                               const QFontMetrics& fontMetrics,
                               uint maxlen = 30 );
# 237 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString lPixelSqueeze( const QString & name,
                                  const QFontMetrics& fontMetrics,
                                  uint maxPixels );







    static QString csqueeze( const QString & str, uint maxlen = 40 );
# 259 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString cEmSqueeze( const QString & name,
                               const QFontMetrics& fontMetrics,
                               uint maxlen = 30 );
# 272 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString cPixelSqueeze( const QString & name,
                                  const QFontMetrics& fontMetrics,
                                  uint maxPixels );







    static QString rsqueeze( const QString & str, uint maxlen = 40 );
# 294 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString rEmSqueeze( const QString & name,
                               const QFontMetrics& fontMetrics,
                               uint maxlen = 30 );
# 307 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString rPixelSqueeze( const QString & name,
                                  const QFontMetrics& fontMetrics,
                                  uint maxPixels );
# 319 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static bool matchFileName( const QString& filename, const QString& pattern );
# 338 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QStringList perlSplit
      (const QString & sep, const QString & s, uint max = 0);
# 358 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QStringList perlSplit
      (const QChar & sep, const QString & s, uint max = 0);
# 378 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QStringList perlSplit
      (const QRegExp & sep, const QString & s, uint max = 0);
# 389 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString tagURLs( const QString& text );
# 404 "/coolo/prod/kdelibs/kdecore/kstringhandler.h"
    static QString obscure( const QString &str );







    static __attribute__ ((deprecated)) bool matchFilename( const QString& filename, const QString& pattern )
    {
        return matchFileName (filename, pattern);
    };

};
# 30 "/coolo/prod/kdelibs/kdecore/kpalette.cpp" 2

template class QPtrList<KPalette::kolor>;

QStringList
KPalette::getPaletteList()
{
  QStringList paletteList;
  KGlobal::dirs()->findAllResources("config", "colors/*", false, true, paletteList);

  int strip = strlen("colors/");
  for(QStringList::Iterator it = paletteList.begin();
      it != paletteList.end();
      it++)
  {
      (*it) = (*it).mid(strip);
  }

  return paletteList;
}

KPalette::KPalette(const QString &name)
 : mName(name)
{
  mKolorList.setAutoDelete(true);
  if (mName.isEmpty()) return;

  QString filename = locate("config", "colors/"+mName);
  if (filename.isEmpty()) return;

  QFile paletteFile(filename);
  if (!paletteFile.exists()) return;
  if (!paletteFile.open(0x0001)) return;

  uint maxLength = 1024;
  QString line;



  if (paletteFile.readLine(line, maxLength) == -1) return;
  if (line.find(" Palette") == -1) return;

  char *buffer = new char[maxLength];

  while( paletteFile.readLine(line, maxLength) != -1)
  {
     if (line[0] == '#')
     {

        line = line.mid(1);
        line = line.stripWhiteSpace();
        if (!line.isEmpty())
        {
           mDesc += line+"\n";
        }
     }
     else
     {

        line = line.stripWhiteSpace();
        if (line.isEmpty()) continue;
        int red, green, blue;
        int pos = 0;
        buffer[0] = '\0';
        if (sscanf(line.ascii(), "%d %d %d%n", &red, &green, &blue, &pos) >= 3)
        {
           if (red > 255) red = 255;
           if (red < 0) red = 0;
           if (green > 255) green = 255;
           if (green < 0) green = 0;
           if (blue > 255) blue = 255;
           if (blue < 0) blue = 0;
           kolor *node = new kolor();
           node->color.setRgb(red, green, blue);
           node->name = line.mid(pos).stripWhiteSpace();
           if (node->name.isNull()) node->name = "";
           mKolorList.append( node );
        }
     }
  }
  delete [] buffer;
}

KPalette::KPalette(const KPalette &p)
 : mName(p.mName), mDesc(p.mDesc), mEditable(p.mEditable)
{
   mKolorList.setAutoDelete(true);



   QPtrList<kolor> *nonConstList = (QPtrList<kolor> *) &p.mKolorList;
   for(kolor *node = nonConstList->first(); node; node = nonConstList->next())
   {
       mKolorList.append(new kolor(*node));
   }
}

KPalette::~KPalette()
{

}

bool
KPalette::save()
{
   QString filename = locateLocal("config", "colors/"+mName);
   KSaveFile sf(filename);
   if (sf.status() != 0) return false;

   QTextStream *str = sf.textStream();

   QString description = mDesc.stripWhiteSpace();
   description = "#"+QStringList::split("\n", description, true).join("\n#");

   (*str) << "KDE RGB Palette\n";
   (*str) << description << "\n";


   QPtrList<kolor> *nonConstList = (QPtrList<kolor> *) (&mKolorList);
   for(kolor *node = nonConstList->first(); node; node = nonConstList->next())
   {
       int r,g,b;
       node->color.rgb(&r, &g, &b);
       (*str) << r << " " << g << " " << b << " " << node->name << "\n";
   }
   return sf.close();
}


KPalette&
KPalette::operator=( const KPalette &p)
{
  if (&p == this) return *this;
  mKolorList.clear();



  QPtrList<kolor> *nonConstList = (QPtrList<kolor> *) &p.mKolorList;
  for(kolor *node = nonConstList->first(); node; node = nonConstList->next())
  {
     mKolorList.append(new kolor(*node));
  }
  mName = p.mName;
  mDesc = p.mDesc;
  mEditable = p.mEditable;
  return *this;
}

QColor
KPalette::color(int index)
{
  if ((index < 0) || (index >= nrColors()))
        return QColor();

  kolor *node = mKolorList.at(index);
  if (!node)
        return QColor();

  return node->color;
}

int
KPalette::findColor(const QColor &color) const
{
  int index;
  QPtrListIterator<kolor> it( mKolorList );
  for (index = 0; it.current(); ++it, ++index)
  {
     if (it.current()->color == color)
         return index;
  }
  return -1;
}

QString
KPalette::colorName(int index)
{
  if ((index < 0) || (index >= nrColors()))
        return QString::null;

  kolor *node = mKolorList.at(index);
  if (!node)
        return QString::null;

  return node->name;
}

int
KPalette::addColor(const QColor &newColor, const QString &newColorName)
{
  kolor *node = new kolor();
  node->color = newColor;
  node->name = newColorName;
  mKolorList.append( node );
  return nrColors()-1;
}

int
KPalette::changeColor(int index,
                      const QColor &newColor,
                      const QString &newColorName)
{
  if ((index < 0) || (index >= nrColors()))
        return -1;

  kolor *node = mKolorList.at(index);
  if (!node)
        return -1;

  node->color = newColor;
  node->name = newColorName;
  return index;
}
# 50 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kipc.cpp" 1
# 28 "/coolo/prod/kdelibs/kdecore/kipc.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 29 "/coolo/prod/kdelibs/kdecore/kipc.cpp" 2
# 42 "/coolo/prod/kdelibs/kdecore/kipc.cpp"
static long getSimpleProperty(Window w, Atom a)
{
    Atom real_type;
    int format;
    unsigned long n, extra, *p = 0, res;
    int status;

    res = 0;
    status = XGetWindowProperty(qt_xdisplay(), w, a, 0L, 1L, 0, a,
            &real_type, &format, &n, &extra, (unsigned char **) &p);
    if ((status == Success) && (n == 1) && (format == 32))
        res = p[0];
    if (p) XFree((char *) p);
    return res;
}


void KIPC::sendMessage(Message msg, WId w, int data)
{

    static Atom a = 0;
    if (a == 0)
        a = XInternAtom(qt_xdisplay(), "KIPC_COMM_ATOM", 0);
    XEvent ev;
    ev.xclient.type = 33;
    ev.xclient.display = qt_xdisplay();
    ev.xclient.window = (Window) w;
    ev.xclient.message_type = a;
    ev.xclient.format = 32;
    ev.xclient.data.l[0] = msg;
    ev.xclient.data.l[1] = data;
    XSendEvent(qt_xdisplay(), (Window) w, 0, 0L, &ev);


    static Atom kde1 = 0;
    if ( msg == PaletteChanged || msg == FontChanged ) {
        if ( kde1 == 0 )
            kde1 = XInternAtom(qt_xdisplay(), "KDEChangeGeneral", 0 );
        ev.xclient.message_type = kde1;
        XSendEvent(qt_xdisplay(), (Window) w, 0, 0L, &ev);
    }


}


void KIPC::sendMessageAll(Message msg, int data)
{

    unsigned int i, nrootwins;
    Window dw1, dw2, *rootwins = 0;
    Display *dpy = qt_xdisplay();
    int screen_count = (((_XPrivDisplay)dpy)->nscreens);

    KXErrorHandler handler;
    for (int s = 0; s < screen_count; s++) {
        Window root = ((&((_XPrivDisplay)dpy)->screens[s])->root);

        XQueryTree(dpy, root, &dw1, &dw2, &rootwins, &nrootwins);
        Atom a = XInternAtom(qt_xdisplay(), "KDE_DESKTOP_WINDOW", 0);
        for (i = 0; i < nrootwins; i++)
            {
                if (getSimpleProperty(rootwins[i], a) != 0L)
                    sendMessage(msg, rootwins[i], data);
            }
        XFree((char *) rootwins);
    }
    XSync(dpy,0);

}
# 51 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/klibloader.cpp" 1
# 19 "/coolo/prod/kdelibs/kdecore/klibloader.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 20 "/coolo/prod/kdelibs/kdecore/klibloader.cpp" 2

# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 22 "/coolo/prod/kdelibs/kdecore/klibloader.cpp" 2



# 1 "/coolo/prod/qt-copy/include/qobjectdict.h" 1
# 39 "/coolo/prod/qt-copy/include/qobjectdict.h"
# 51 "/coolo/prod/qt-copy/include/qobjectdict.h"
class QObjectDictionary : public QAsciiDict<QMetaObject>
{
public:
    QObjectDictionary(int size=17,bool cs=TRUE,bool ck=TRUE)
        : QAsciiDict<QMetaObject>(size,cs,ck) {}
    QObjectDictionary( const QObjectDictionary &dict )
        : QAsciiDict<QMetaObject>(dict) {}
   ~QObjectDictionary() { clear(); }
    QObjectDictionary &operator=(const QObjectDictionary &dict)
        { return (QObjectDictionary&)QAsciiDict<QMetaObject>::operator=(dict);}
};
# 26 "/coolo/prod/kdelibs/kdecore/klibloader.cpp" 2
# 35 "/coolo/prod/kdelibs/kdecore/klibloader.cpp"
# 1 "/coolo/prod/kdelibs/libltdl/ltdl.h" 1
# 29 "/coolo/prod/kdelibs/libltdl/ltdl.h"
# 41 "/coolo/prod/kdelibs/libltdl/ltdl.h"





extern "C" {






# 72 "/coolo/prod/kdelibs/libltdl/ltdl.h"






# 118 "/coolo/prod/kdelibs/libltdl/ltdl.h"
# 133 "/coolo/prod/kdelibs/libltdl/ltdl.h"
# 143 "/coolo/prod/kdelibs/libltdl/ltdl.h"
typedef struct lt_dlhandle_struct *lt_dlhandle;


extern int lt_dlinit (void);
extern int lt_dlexit (void);


extern int lt_dladdsearchdir (const char *search_dir);
extern int lt_dlsetsearchpath (const char *search_path);
extern const char *lt_dlgetsearchpath (void);


extern lt_dlhandle lt_dlopen (const char *filename);
extern lt_dlhandle lt_dlopenext (const char *filename);
extern void* lt_dlsym (lt_dlhandle handle, const char *name);

extern const char *lt_dlerror (void);
extern int lt_dlclose (lt_dlhandle handle);


extern int lt_dlmakeresident (lt_dlhandle handle);
extern int lt_dlisresident (lt_dlhandle handle);







typedef void lt_dlmutex_lock (void);
typedef void lt_dlmutex_unlock (void);
typedef void lt_dlmutex_seterror (const char *error);
typedef const char *lt_dlmutex_geterror (void);

extern int lt_dlmutex_register (lt_dlmutex_lock *lock, lt_dlmutex_unlock *unlock, lt_dlmutex_seterror *seterror, lt_dlmutex_geterror *geterror);
# 189 "/coolo/prod/kdelibs/libltdl/ltdl.h"
extern void* (*lt_dlmalloc) (size_t size);
extern void (*lt_dlfree) (void* ptr);
# 200 "/coolo/prod/kdelibs/libltdl/ltdl.h"
typedef struct {
  const char *name;
  void* address;
} lt_dlsymlist;

extern int lt_dlpreload (const lt_dlsymlist *preloaded);
extern int lt_dlpreload_default
                                (const lt_dlsymlist *preloaded);

# 221 "/coolo/prod/kdelibs/libltdl/ltdl.h"
typedef struct {
  char *filename;
  char *name;
  int ref_count;

} lt_dlinfo;

extern const lt_dlinfo *lt_dlgetinfo (lt_dlhandle handle);
extern lt_dlhandle lt_dlhandle_next (lt_dlhandle place);
extern int lt_dlforeach ( int (*func) (lt_dlhandle handle, void* data), void* data);




typedef unsigned lt_dlcaller_id;

extern lt_dlcaller_id lt_dlcaller_register (void);
extern void* lt_dlcaller_set_data (lt_dlcaller_id key, lt_dlhandle handle, void* data);


extern void* lt_dlcaller_get_data (lt_dlcaller_id key, lt_dlhandle handle);







typedef struct lt_dlloader lt_dlloader;
typedef void* lt_user_data;
typedef void* lt_module;


typedef lt_module lt_module_open (lt_user_data loader_data, const char *filename);

typedef int lt_module_close (lt_user_data loader_data, lt_module handle);

typedef void* lt_find_sym (lt_user_data loader_data, lt_module handle, const char *symbol);


typedef int lt_dlloader_exit (lt_user_data loader_data);

struct lt_user_dlloader {
  const char *sym_prefix;
  lt_module_open *module_open;
  lt_module_close *module_close;
  lt_find_sym *find_sym;
  lt_dlloader_exit *dlloader_exit;
  lt_user_data dlloader_data;
};

extern lt_dlloader *lt_dlloader_next (lt_dlloader *place);
extern lt_dlloader *lt_dlloader_find ( const char *loader_name);

extern const char *lt_dlloader_name (lt_dlloader *place);
extern lt_user_data *lt_dlloader_data (lt_dlloader *place);
extern int lt_dlloader_add (lt_dlloader *place, const struct lt_user_dlloader *dlloader, const char *loader_name);


extern int lt_dlloader_remove ( const char *loader_name);
# 292 "/coolo/prod/kdelibs/libltdl/ltdl.h"
# 313 "/coolo/prod/kdelibs/libltdl/ltdl.h"
enum {
        LT_ERROR_UNKNOWN, LT_ERROR_DLOPEN_NOT_SUPPORTED, LT_ERROR_INVALID_LOADER, LT_ERROR_INIT_LOADER, LT_ERROR_REMOVE_LOADER, LT_ERROR_FILE_NOT_FOUND, LT_ERROR_DEPLIB_NOT_FOUND, LT_ERROR_NO_SYMBOLS, LT_ERROR_CANNOT_OPEN, LT_ERROR_CANNOT_CLOSE, LT_ERROR_SYMBOL_NOT_FOUND, LT_ERROR_NO_MEMORY, LT_ERROR_INVALID_HANDLE, LT_ERROR_BUFFER_OVERFLOW, LT_ERROR_INVALID_ERRORCODE, LT_ERROR_SHUTDOWN, LT_ERROR_CLOSE_RESIDENT_MODULE, LT_ERROR_INVALID_MUTEX_ARGS,
#undef LT_ERROR

        LT_ERROR_MAX
};


extern int lt_dladderror (const char *diagnostic);
extern int lt_dlseterror (int errorcode);












}
# 36 "/coolo/prod/kdelibs/kdecore/klibloader.cpp" 2






template class QAsciiDict<KLibrary>;





# 1 "/usr/include/dlfcn.h" 1 3 4
# 21 "/usr/include/dlfcn.h" 3 4




# 1 "/usr/include/bits/dlfcn.h" 1 3 4
# 25 "/usr/include/bits/dlfcn.h" 3 4










# 54 "/usr/include/bits/dlfcn.h" 3 4


extern "C" {


extern void _dl_mcount_wrapper_check (void *__selfpc) throw ();

}
# 27 "/usr/include/dlfcn.h" 2 3 4














extern "C" {



extern void *dlopen (__const char *__file, int __mode) throw ();



extern int dlclose (void *__handle) throw ();



extern void *dlsym (void *__restrict __handle,
                    __const char *__restrict __name) throw ();




extern void *dlvsym (void *__restrict __handle,
                     __const char *__restrict __name,
                     __const char *__restrict __version) throw ();





extern char *dlerror (void) throw ();





typedef struct
{
  __const char *dli_fname;
  void *dli_fbase;
  __const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (__const void *__address, Dl_info *__info) throw ();


}
# 49 "/coolo/prod/kdelibs/kdecore/klibloader.cpp" 2



# 63 "/coolo/prod/kdelibs/kdecore/klibloader.cpp"
extern "C" {
extern int lt_dlopen_flag;
}

class KLibLoaderPrivate
{
public:
    QPtrList<KLibWrapPrivate> loaded_stack;
    QPtrList<KLibWrapPrivate> pending_close;
    enum {UNKNOWN, UNLOAD, DONT_UNLOAD} unload_mode;

    QString errorMessage;
};

KLibLoader* KLibLoader::s_self = 0;



KLibFactory::KLibFactory( QObject* parent, const char* name )
    : QObject( parent, name )
{
}

KLibFactory::~KLibFactory()
{

}

QObject* KLibFactory::create( QObject* parent, const char* name, const char* classname, const QStringList &args )
{
    QObject* obj = createObject( parent, name, classname, args );
    if ( obj )
        objectCreated( obj );
    return obj;
}


QObject* KLibFactory::createObject( QObject*, const char*, const char*, const QStringList &)
{
    return 0;
}




KLibrary::KLibrary( const QString& libname, const QString& filename, void * handle )
{

    (void) KLibLoader::self();
    m_libname = libname;
    m_filename = filename;
    m_handle = handle;
    m_factory = 0;
    m_timer = 0;
}

KLibrary::~KLibrary()
{

    if ( m_timer && m_timer->isActive() )
        m_timer->stop();


    if ( m_objs.count() > 0 )
        {
            QPtrListIterator<QObject> it( m_objs );
            for ( ; it.current() ; ++it )
                {
                    kdDebug(150) << "Factory still has object " << it.current() << " " << it.current()->name () << " Library = " << m_libname << endl;
                    disconnect( it.current(), "2""destroyed()",
                                this, "1""slotObjectDestroyed()" );
                }
            m_objs.setAutoDelete(true);
            m_objs.clear();
        }

    if ( m_factory ) {

        delete m_factory;
        m_factory = 0L;
    }
}

QString KLibrary::name() const
{
    return m_libname;
}

QString KLibrary::fileName() const
{
    return m_filename;
}

KLibFactory* KLibrary::factory()
{
    if ( m_factory )
        return m_factory;

        QCString symname;
        symname.sprintf("init_%s", name().latin1() );

    void* sym = symbol( symname );
        if ( !sym )
        {
            KLibLoader::self()->d->errorMessage = i18n( "The library %1 does not offer an %2 function." ).arg( name() ).arg( "init_" + name() );
            kdWarning(150) << KLibLoader::self()->d->errorMessage << endl;
            return 0;
    }

    typedef KLibFactory* (*t_func)();
    t_func func = (t_func)sym;
    m_factory = func();

    if( !m_factory )
    {
        KLibLoader::self()->d->errorMessage = i18n( "The library %1 does not offer a KDE compatible factory." ).arg( name() );
        kdWarning(150) << KLibLoader::self()->d->errorMessage << endl;
        return 0;
    }

    connect( m_factory, "2""objectCreated( QObject * )",
             this, "1""slotObjectCreated( QObject * )" );

    return m_factory;
}

void* KLibrary::symbol( const char* symname ) const
{
    void* sym = lt_dlsym( (lt_dlhandle) m_handle, symname );
    if ( !sym )
    {
        KLibLoader::self()->d->errorMessage = "KLibrary: " + QString::fromLatin1( lt_dlerror() );
        kdWarning(150) << KLibLoader::self()->d->errorMessage << endl;
        return 0;
    }

    return sym;
}

bool KLibrary::hasSymbol( const char* symname ) const
{
    void* sym = lt_dlsym( (lt_dlhandle) m_handle, symname );
    return (sym != 0L );
}

void KLibrary::unload() const
{
   if (KLibLoader::s_self)
      KLibLoader::s_self->unloadLibrary(QFile::encodeName(name()));
}

void KLibrary::slotObjectCreated( QObject *obj )
{
  if ( !obj )
    return;

  if ( m_timer && m_timer->isActive() )
    m_timer->stop();

  if ( m_objs.containsRef( obj ) )
      return;

  connect( obj, "2""destroyed()",
           this, "1""slotObjectDestroyed()" );

  m_objs.append( obj );
}

void KLibrary::slotObjectDestroyed()
{
  m_objs.removeRef( sender() );

  if ( m_objs.count() == 0 )
  {



    if ( !m_timer )
    {
      m_timer = new QTimer( this, "klibrary_shutdown_timer" );
      connect( m_timer, "2""timeout()",
               this, "1""slotTimeout()" );
    }




    m_timer->start( 1000*10, true );
  }
}

void KLibrary::slotTimeout()
{
  if ( m_objs.count() != 0 )
    return;





  delete this;
}






class KLibWrapPrivate
{
public:
    KLibWrapPrivate(KLibrary *l, lt_dlhandle h);

    KLibrary *lib;
    enum {UNKNOWN, UNLOAD, DONT_UNLOAD} unload_mode;
    int ref_count;
    lt_dlhandle handle;
    QString name;
    QString filename;
};

KLibWrapPrivate::KLibWrapPrivate(KLibrary *l, lt_dlhandle h)
 : lib(l), ref_count(1), handle(h), name(l->name()), filename(l->fileName())
{
    unload_mode = UNKNOWN;
    if (lt_dlsym(handle, "__kde_do_not_unload") != 0) {

        unload_mode = DONT_UNLOAD;
    } else if (lt_dlsym(handle, "__kde_do_unload") != 0) {
        unload_mode = UNLOAD;
    }
}

KLibLoader* KLibLoader::self()
{
    if ( !s_self )
        s_self = new KLibLoader;
    return s_self;
}

void KLibLoader::cleanUp()
{
  if ( !s_self )
    return;

  delete s_self;
  s_self = 0L;
}

KLibLoader::KLibLoader( QObject* parent, const char* name )
    : QObject( parent, name )
{
    s_self = this;
    d = new KLibLoaderPrivate;
    lt_dlinit();
    d->unload_mode = KLibLoaderPrivate::UNKNOWN;
    if (getenv("KDE_NOUNLOAD") != 0)
        d->unload_mode = KLibLoaderPrivate::DONT_UNLOAD;
    else if (getenv("KDE_DOUNLOAD") != 0)
        d->unload_mode = KLibLoaderPrivate::UNLOAD;
    d->loaded_stack.setAutoDelete( true );
}

KLibLoader::~KLibLoader()
{


    QAsciiDictIterator<KLibWrapPrivate> it( m_libs );
    for (; it.current(); ++it )
    {
      kdDebug(150) << "The KLibLoader contains the library " << it.current()->name
        << " (" << it.current()->lib << ")" << endl;
      d->pending_close.append(it.current());
    }

    close_pending(0);

    delete d;
    d = 0L;
}


QString KLibLoader::findLibrary( const char * name, const KInstance * instance )
{
    QCString libname( name );




    int pos = libname.findRev('/');
    if (pos < 0)
      pos = 0;
    if (libname.find('.', pos) < 0)
      libname += ".la";



    QString libfile;
    if (libname[0] == '/')
      libfile = libname;
    else
    {
      libfile = instance->dirs()->findResource( "module", libname );
      if ( libfile.isEmpty() )
      {
        libfile = instance->dirs()->findResource( "lib", libname );

        if ( !libfile.isEmpty() && libname.left(3) == "lib" )
          kdDebug(150) << "library " << libname << " not found under 'module' but under 'lib'" << endl;

      }
      if ( libfile.isEmpty() )
      {

        kdDebug(150) << "library=" << libname << ": No file names " << libname.data() << " found in paths." << endl;

            self()->d->errorMessage = i18n("Library files for \"%1\" not found in paths").arg(libname);
      }
      else
            self()->d->errorMessage = QString::null;
    }
    return libfile;
}


KLibrary* KLibLoader::globalLibrary( const char *name )
{
KLibrary *tmp;
int olt_dlopen_flag = lt_dlopen_flag;

   lt_dlopen_flag |= 0x00100;
   kdDebug(150) << "Loading the next library global with flag "
                << lt_dlopen_flag
                << "." << endl;
   tmp = library(name);
   lt_dlopen_flag = olt_dlopen_flag;

return tmp;
}


KLibrary* KLibLoader::library( const char *name )
{
    if (!name)
        return 0;

    KLibWrapPrivate* wrap = m_libs[name];
    if (wrap) {

      wrap->ref_count++;
      return wrap->lib;
    }



    QPtrListIterator<KLibWrapPrivate> it(d->loaded_stack);
    for (; it.current(); ++it) {
      if (it.current()->name == name)
        wrap = it.current();
    }

    if (wrap) {
      d->pending_close.removeRef(wrap);
      if (!wrap->lib) {

        wrap->lib = new KLibrary( name, wrap->filename, wrap->handle );
      }
      wrap->ref_count++;
    } else {
      QString libfile = findLibrary( name );
      if ( libfile.isEmpty() )
        return 0;

      lt_dlhandle handle = lt_dlopen( libfile.latin1() );
      if ( !handle )
      {
        const char* errmsg = lt_dlerror();
        if(errmsg)
            d->errorMessage = QString::fromLatin1(errmsg);
        else
            d->errorMessage = QString::null;
        return 0;
      }
      else
        d->errorMessage = QString::null;

      KLibrary *lib = new KLibrary( name, libfile, handle );
      wrap = new KLibWrapPrivate(lib, handle);
      d->loaded_stack.prepend(wrap);
    }
    m_libs.insert( name, wrap );

    connect( wrap->lib, "2""destroyed()",
             this, "1""slotLibraryDestroyed()" );

    return wrap->lib;
}

QString KLibLoader::lastErrorMessage() const
{
    return d->errorMessage;
}

void KLibLoader::unloadLibrary( const char *libname )
{
  KLibWrapPrivate *wrap = m_libs[ libname ];
  if (!wrap)
    return;
  if (--wrap->ref_count)
    return;



  m_libs.remove( libname );

  disconnect( wrap->lib, "2""destroyed()",
              this, "1""slotLibraryDestroyed()" );
  close_pending( wrap );
}

KLibFactory* KLibLoader::factory( const char* name )
{
    KLibrary* lib = library( name );
    if ( !lib )
        return 0;

    return lib->factory();
}

void KLibLoader::slotLibraryDestroyed()
{
  const KLibrary *lib = static_cast<const KLibrary *>( sender() );

  QAsciiDictIterator<KLibWrapPrivate> it( m_libs );
  for (; it.current(); ++it )
    if ( it.current()->lib == lib )
    {
      KLibWrapPrivate *wrap = it.current();
      wrap->lib = 0;
      m_libs.remove( it.currentKey() );
      close_pending( wrap );
      return;
    }
}

void KLibLoader::close_pending(KLibWrapPrivate *wrap)
{
  if (wrap && !d->pending_close.containsRef( wrap ))
    d->pending_close.append( wrap );



  QPtrListIterator<KLibWrapPrivate> it(d->pending_close);
  for (; it.current(); ++it) {
    wrap = it.current();
    if (wrap->lib) {
      disconnect( wrap->lib, "2""destroyed()",
                  this, "1""slotLibraryDestroyed()" );
      delete wrap->lib;
      wrap->lib = 0L;
    }
  }

  if (d->unload_mode == KLibLoaderPrivate::DONT_UNLOAD) return;

  bool deleted_one = false;
  while ((wrap = d->loaded_stack.first())) {




    if (d->unload_mode != KLibLoaderPrivate::UNLOAD
        && wrap->unload_mode != KLibWrapPrivate::UNLOAD)
      break;



    if (!d->pending_close.containsRef( wrap )) {
      if (!deleted_one)


      break;
    }





    if ( !deleted_one ) {
# 562 "/coolo/prod/kdelibs/kdecore/klibloader.cpp"
      QWidgetList *widgetlist = QApplication::topLevelWidgets();
      QWidget *co = widgetlist->first();
      while (co) {
        if (qstrcmp(co->name(), "internal clipboard owner") == 0) {
          if (XGetSelectionOwner(co->x11Display(), ((Atom) 1)) == co->winId())
            KApplication::kApplication()->clipboard()->setText(KApplication::kApplication()->clipboard()->text());

          break;
        }
        co = widgetlist->next();
      }
      delete widgetlist;
    }




    deleted_one = true;
    lt_dlclose(wrap->handle);
    d->pending_close.removeRef(wrap);

    d->loaded_stack.remove();
  }
}

void KLibLoader::virtual_hook( int, void* )
{ }

void KLibFactory::virtual_hook( int, void* )
{ }

# 1 "../kdecore/klibloader.moc" 1
# 11 "../kdecore/klibloader.moc"
# 1 "../../../prod/kdelibs/kdecore/klibloader.h" 1
# 12 "../kdecore/klibloader.moc" 2
# 22 "../kdecore/klibloader.moc"
const char *KLibrary::className() const
{
    return "KLibrary";
}

QMetaObject *KLibrary::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KLibrary( "KLibrary", &KLibrary::staticMetaObject );
# 50 "../kdecore/klibloader.moc"
QMetaObject* KLibrary::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { "obj", &static_QUType_ptr, "QObject", QUParameter::In }
    };
    static const QUMethod slot_0 = {"slotObjectCreated", 1, param_slot_0 };
    static const QUMethod slot_1 = {"slotObjectDestroyed", 0, 0 };
    static const QUMethod slot_2 = {"slotTimeout", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "slotObjectCreated(QObject*)", &slot_0, QMetaData::Private },
        { "slotObjectDestroyed()", &slot_1, QMetaData::Private },
        { "slotTimeout()", &slot_2, QMetaData::Private }
    };
    metaObj = QMetaObject::new_metaobject(
        "KLibrary", parentObject,
        slot_tbl, 3,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KLibrary.setMetaObject( metaObj );
    return metaObj;
}

void* KLibrary::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KLibrary" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KLibrary::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotObjectCreated((QObject*)static_QUType_ptr.get(_o+1)); break;
    case 1: slotObjectDestroyed(); break;
    case 2: slotTimeout(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KLibrary::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KLibrary::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KLibrary::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }



const char *KLibLoader::className() const
{
    return "KLibLoader";
}

QMetaObject *KLibLoader::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KLibLoader( "KLibLoader", &KLibLoader::staticMetaObject );
# 141 "../kdecore/klibloader.moc"
QMetaObject* KLibLoader::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod slot_0 = {"slotLibraryDestroyed", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "slotLibraryDestroyed()", &slot_0, QMetaData::Private }
    };
    metaObj = QMetaObject::new_metaobject(
        "KLibLoader", parentObject,
        slot_tbl, 1,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KLibLoader.setMetaObject( metaObj );
    return metaObj;
}

void* KLibLoader::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KLibLoader" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KLibLoader::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotLibraryDestroyed(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KLibLoader::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KLibLoader::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KLibLoader::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }



const char *KLibFactory::className() const
{
    return "KLibFactory";
}

QMetaObject *KLibFactory::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KLibFactory( "KLibFactory", &KLibFactory::staticMetaObject );
# 223 "../kdecore/klibloader.moc"
QMetaObject* KLibFactory::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUParameter param_signal_0[] = {
        { "obj", &static_QUType_ptr, "QObject", QUParameter::In }
    };
    static const QUMethod signal_0 = {"objectCreated", 1, param_signal_0 };
    static const QMetaData signal_tbl[] = {
        { "objectCreated(QObject*)", &signal_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KLibFactory", parentObject,
        0, 0,
        signal_tbl, 1,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KLibFactory.setMetaObject( metaObj );
    return metaObj;
}

void* KLibFactory::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KLibFactory" ) )
        return this;
    return QObject::qt_cast( clname );
}





void KLibFactory::objectCreated( QObject* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 0 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}

bool KLibFactory::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KLibFactory::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: objectCreated((QObject*)static_QUType_ptr.get(_o+1)); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KLibFactory::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KLibFactory::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 594 "/coolo/prod/kdelibs/kdecore/klibloader.cpp" 2
# 52 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ktempfile.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/ktempfile.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/ktempfile.cpp" 2
# 59 "/coolo/prod/kdelibs/kdecore/ktempfile.cpp"
KTempFile::KTempFile(QString filePrefix, QString fileExtension, int mode)
{
   bAutoDelete = false;
   mFd = -1;
   mStream = 0;
   mFile = 0;
   mTextStream = 0;
   mDataStream = 0;
   mError = 0;
   bOpen = false;
   if (fileExtension.isEmpty())
      fileExtension = ".tmp";
   if (filePrefix.isEmpty())
   {
      filePrefix = locateLocal("tmp", KGlobal::instance()->instanceName());
   }
   (void) create(filePrefix, fileExtension, mode);
}

KTempFile::KTempFile(bool)
{
   bAutoDelete = false;
   mFd = -1;
   mStream = 0;
   mFile = 0;
   mTextStream = 0;
   mDataStream = 0;
   mError = 0;
   bOpen = false;
}

bool
KTempFile::create(const QString &filePrefix, const QString &fileExtension,
                  int mode)
{

   (void) KApplication::random();

   QCString ext = QFile::encodeName(fileExtension);
   QCString nme = QFile::encodeName(filePrefix) + "XXXXXX" + ext;
   if((mFd = mkstemps(nme.data(), ext.length())) < 0)
   {

       QCString nme = QFile::encodeName(filePrefix) + "XXXXXX" + ext;
       qWarning("KTempFile: Error trying to create %s: %s", nme.data(), strerror((*__errno_location ())));
       mError = (*__errno_location ());
       mTmpName = QString::null;
       return false;
   }


   mTmpName = QFile::decodeName(nme);
   mode_t tmp = 0;
   mode_t umsk = umask(tmp);
   umask(umsk);
   chmod(nme, mode&(~umsk));


   bOpen = true;


   chown(nme, getuid(), getgid());
   return true;
}

KTempFile::~KTempFile()
{
   close();
   if (bAutoDelete)
      unlink();
}

int
KTempFile::status() const
{
   return mError;
}

QString
KTempFile::name() const
{
   return mTmpName;
}

int
KTempFile::handle() const
{
   return mFd;
}

FILE *
KTempFile::fstream()
{
   if (mStream) return mStream;
   if (mFd < 0) return 0;


   mStream = fdopen(mFd, "r+");
   if (!mStream) {
     qWarning("KTempFile: Error trying to open %s: %s", mTmpName.latin1(), strerror((*__errno_location ())));
     mError = (*__errno_location ());
   }
   return mStream;
}

QFile *
KTempFile::file()
{
   if (mFile) return mFile;
   if ( !fstream() ) return 0;

   mFile = new QFile();
   mFile->setName( name() );
   mFile->open(0x0003, mStream);
   return mFile;
}

QTextStream *
KTempFile::textStream()
{
   if (mTextStream) return mTextStream;
   if ( !file() ) return 0;

   mTextStream = new QTextStream( mFile );
   return mTextStream;
}

QDataStream *
KTempFile::dataStream()
{
   if (mDataStream) return mDataStream;
   if ( !file() ) return 0;

   mDataStream = new QDataStream( mFile );
   return mDataStream;
}

void
KTempFile::unlink()
{
   if (!mTmpName.isEmpty())
      QFile::remove( mTmpName );
   mTmpName = QString::null;
}

bool
KTempFile::close()
{
   int result = 0;
   delete mTextStream; mTextStream = 0;
   delete mDataStream; mDataStream = 0;
   delete mFile; mFile = 0;

   if (mStream)
   {
      result = ferror(mStream);
      if (result)
         mError = 28;

      result = fclose(mStream);
      mStream = 0;
      mFd = -1;
      if (result != 0) {
         qWarning("KTempFile: Error trying to closing %s: %s", mTmpName.latin1(), strerror((*__errno_location ())));
         mError = (*__errno_location ());
      }
   }


   if (mFd >= 0)
   {
      result = ::close(mFd);
      mFd = -1;
      if (result != 0) {
         qWarning("KTempFile: Error trying to closing %s: %s", mTmpName.latin1(), strerror((*__errno_location ())));
         mError = (*__errno_location ());
      }
   }

   bOpen = false;
   return (mError == 0);
}
# 53 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 23 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp" 2




# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 28 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp" 2
# 1 "/usr/include/errno.h" 1 3 4
# 29 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp" 2
# 39 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kaboutdata.h" 1
# 40 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp" 2
# 48 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.h"




class KUniqueApplicationPrivate;
# 41 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.h"
class KUniqueApplication : public KApplication, public DCOPObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
# 60 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.h"
  KUniqueApplication( bool allowStyles=true,
                      bool GUIenabled=true,
                      bool configUnique=false);







  static void addCmdLineOptions();
# 101 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.h"
  static bool start();




  virtual ~KUniqueApplication();
# 120 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.h"
  bool process(const QCString &fun, const QByteArray &data,
               QCString &replyType, QByteArray &replyData);
# 143 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.h"
  virtual int newInstance();

private:



  void delayRequest(const QCString &fun, const QByteArray &data);

private :



  void processDelayed();

  void newInstanceNoFork();

  static KInstance* initHack( bool configUnique );

private:
  static bool s_nofork;
  static bool s_multipleInstances;
  static bool s_uniqueTestDone;

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KUniqueApplicationPrivate *d;
};
# 49 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp" 2




# 62 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp"
bool KUniqueApplication::s_nofork = false;
bool KUniqueApplication::s_multipleInstances = false;
bool KUniqueApplication::s_uniqueTestDone = false;

static KCmdLineOptions kunique_options[] =
{
  { "nofork", "Don't run in the background.", 0 },
  { 0, 0, 0 }
};

struct DCOPRequest {
   QCString fun;
   QByteArray data;
   DCOPClientTransaction *transaction;
};

class KUniqueApplicationPrivate {
public:
   QPtrList <DCOPRequest> requestList;
   bool processingRequest;
   bool firstInstance;
   QCString asn_id;
};

void
KUniqueApplication::addCmdLineOptions()
{
  KCmdLineArgs::addCmdLineOptions(kunique_options, 0, "kuniqueapp", "kde" );
}

bool
KUniqueApplication::start()
{
  if( s_uniqueTestDone )
    return true;
  s_uniqueTestDone = true;
  addCmdLineOptions();
  KCmdLineArgs *args = KCmdLineArgs::parsedArgs("kuniqueapp");
  s_nofork = !args->isSet("fork");
  delete args;

  QCString appName = KCmdLineArgs::about->appName();

  if (s_nofork)
  {
     if (s_multipleInstances)
     {
        QCString pid;
        pid.setNum(getpid());
        appName = appName + "-" + pid;
     }
     dcopClient()->registerAs(appName, false );

     return true;
  }
  DCOPClient *dc;
  int fd[2];
  signed char result;
  if (0 > pipe(fd))
  {
     kdError() << "KUniqueApplication: pipe() failed!" << endl;
     ::exit(255);
  }
  int fork_result = fork();
  switch(fork_result) {
  case -1:
     kdError() << "KUniqueApplication: fork() failed!" << endl;
     ::exit(255);
     break;
  case 0:

     ::close(fd[0]);
     if (s_multipleInstances)
        appName.append("-").append(QCString().setNum(getpid()));
     dc = dcopClient();
     {
        QCString regName = dc->registerAs(appName, false);
        if (regName.isEmpty())
        {

           if (QCString(getenv("DISPLAY")).isEmpty())
           {
              kdError() << "KUniqueApplication: Can't determine DISPLAY. Aborting." << endl;
              result = -1;
              ::write(fd[1], &result, 1);
              ::exit(255);
           }


           startKdeinit();
           regName = dc->registerAs(appName, false);
           if (regName.isEmpty())
           {
              kdError() << "KUniqueApplication: Can't setup DCOP communication." << endl;
              result = -1;
              delete dc;
              ::write(fd[1], &result, 1);
              ::exit(255);
           }
        }
        if (regName != appName)
        {

           result = 0;
           delete dc;
           ::write(fd[1], &result, 1);
           ::close(fd[1]);



           KStartupInfoId id;
           if( KApplication::kApplication() != __null )
               id.initId( KApplication::kApplication()->startupId());
           else
               id = KStartupInfo::currentStartupIdEnv();
           if( !id.none())
           {
               Display* disp = XOpenDisplay( __null );
               if( disp != __null )
               {
                   KStartupInfo::sendFinishX( disp, id );
                   XCloseDisplay( disp );
               }
           }


           return false;
        }
     }

     {


         KStartupInfoId id;
         if( KApplication::kApplication() != __null )
             id.initId( KApplication::kApplication()->startupId());
         else
             id = KStartupInfo::currentStartupIdEnv();
         if( !id.none())
         {
            Display* disp = XOpenDisplay( __null );
            if( disp != __null )
               {
               KStartupInfoData data;
               data.addPid( getpid());
               KStartupInfo::sendChangeX( disp, id, data );
               XCloseDisplay( disp );
               }
         }


     }
     result = 0;
     ::write(fd[1], &result, 1);
     ::close(fd[1]);
     return true;
  default:



     if (s_multipleInstances)
        appName.append("-").append(QCString().setNum(fork_result));
     ::close(fd[1]);
     for(;;)
     {
       int n = ::read(fd[0], &result, 1);
       if (n == 1) break;
       if (n == 0)
       {
          kdError() << "KUniqueApplication: Pipe closed unexpectedly." << endl;
          ::exit(255);
       }
       if ((*__errno_location ()) != 4)
       {
          kdError() << "KUniqueApplication: Error reading from pipe." << endl;
          ::exit(255);
       }
     }
     ::close(fd[0]);

     if (result != 0)
        ::exit(result);

     dc = new DCOPClient();
     if (!dc->attach())
     {
        kdError() << "KUniqueApplication: Parent process can't attach to DCOP." << endl;
        delete dc;
        ::exit(255);
     }
     if (!dc->isApplicationRegistered(appName)) {
        kdError() << "KUniqueApplication: Registering failed!" << endl;
     }

     QCString new_asn_id;

     KStartupInfoId id;
     if( KApplication::kApplication() != __null )
         id.initId( KApplication::kApplication()->startupId());
     else
         id = KStartupInfo::currentStartupIdEnv();
     if( !id.none())
         new_asn_id = id.id();


     QByteArray data, reply;
     QDataStream ds(data, 0x0002);

     KCmdLineArgs::saveAppArgs(ds);
     ds << new_asn_id;

     QCString replyType;
     if (!dc->call(appName, KCmdLineArgs::about->appName(), "newInstance()", data, replyType, reply))
     {
        kdError() << "Communication problem with " << KCmdLineArgs::about->appName() << ", it probably crashed." << endl;
        delete dc;
        ::exit(255);
     }
     if (replyType != "int")
     {
        kdError() << "KUniqueApplication: DCOP communication error!" << endl;
        delete dc;
        ::exit(255);
     }
     QDataStream rs(reply, 0x0001);
     int exitCode;
     rs >> exitCode;
     delete dc;
     ::exit(exitCode);
     break;
  }
  return false;
}


KUniqueApplication::KUniqueApplication(bool allowStyles, bool GUIenabled, bool configUnique)
  : KApplication( allowStyles, GUIenabled, initHack( configUnique )),
    DCOPObject(KCmdLineArgs::about->appName())
{
  d = new KUniqueApplicationPrivate;
  d->processingRequest = false;
  d->firstInstance = true;

  if (s_nofork)

    QTimer::singleShot( 0, this, "1""newInstanceNoFork()" );
}

KUniqueApplication::~KUniqueApplication()
{
  delete d;
}


KInstance* KUniqueApplication::initHack( bool configUnique )
{
  KInstance* inst = new KInstance( KCmdLineArgs::about );
  if (configUnique)
  {
    KConfigGroupSaver saver( inst->config(), "KDE" );
    s_multipleInstances = inst->config()->readBoolEntry("MultipleInstances", false);
  }
  if( !start())

      ::exit( 0 );
  return inst;
}

void KUniqueApplication::newInstanceNoFork()
{
  if (dcopClient()->isSuspended())
  {

    QTimer::singleShot( 200, this, "1""newInstanceNoFork()" );
    return;
  }

  newInstance();

}

bool KUniqueApplication::process(const QCString &fun, const QByteArray &data,
                                 QCString &replyType, QByteArray &replyData)
{
  if (fun == "newInstance()")
  {
    delayRequest(fun, data);
    return true;
  } else
    return DCOPObject::process(fun, data, replyType, replyData);
}

void
KUniqueApplication::delayRequest(const QCString &fun, const QByteArray &data)
{
  DCOPRequest *request = new DCOPRequest;
  request->fun = fun;
  request->data = data;
  request->transaction = dcopClient()->beginTransaction();
  d->requestList.append(request);
  if (!d->processingRequest)
  {
     QTimer::singleShot(0, this, "1""processDelayed()");
  }
}

void
KUniqueApplication::processDelayed()
{
  if (dcopClient()->isSuspended())
  {

    QTimer::singleShot( 200, this, "1""processDelayed()");
    return;
  }
  d->processingRequest = true;
  while( !d->requestList.isEmpty() )
  {
     DCOPRequest *request = d->requestList.take(0);
     QByteArray replyData;
     QCString replyType;
     if (request->fun == "newInstance()") {
       QDataStream ds(request->data, 0x0001);
       KCmdLineArgs::loadAppArgs(ds);
       if( !ds.atEnd())
           ds >> d->asn_id;
       int exitCode = newInstance();
       d->asn_id = QCString();
       QDataStream rs(replyData, 0x0002);
       rs << exitCode;
       replyType = "int";
     }
     dcopClient()->endTransaction( request->transaction, replyType, replyData);
     delete request;
  }

  d->processingRequest = false;
}



extern Time qt_x_time;


int KUniqueApplication::newInstance()
{
  if (!d->firstInstance)
  {

    if ( mainWidget() )
    {
      mainWidget()->show();

      long activate = true;
      if( !d->asn_id.isEmpty())
      {
          NETRootInfo i( qt_xdisplay(), NET::Supported );
          if( i.isSupported( NET::WM2StartupId ))
          {
              KStartupInfo::setWindowStartupId( mainWidget()->winId(), d->asn_id );
              activate = false;
          }
      }
      if( activate )




          KWin::setActiveWindow( mainWidget()->winId(), qt_x_time );

    }
  }
  d->firstInstance = false;
  return 0;
}

void KUniqueApplication::virtual_hook( int id, void* data )
{ KApplication::virtual_hook( id, data );
  DCOPObject::virtual_hook( id, data ); }

# 1 "../kdecore/kuniqueapplication.moc" 1
# 11 "../kdecore/kuniqueapplication.moc"
# 1 "../../../prod/kdelibs/kdecore/kuniqueapplication.h" 1
# 12 "../kdecore/kuniqueapplication.moc" 2
# 22 "../kdecore/kuniqueapplication.moc"
const char *KUniqueApplication::className() const
{
    return "KUniqueApplication";
}

QMetaObject *KUniqueApplication::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KUniqueApplication( "KUniqueApplication", &KUniqueApplication::staticMetaObject );
# 50 "../kdecore/kuniqueapplication.moc"
QMetaObject* KUniqueApplication::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KApplication::staticMetaObject();
    static const QUMethod slot_0 = {"processDelayed", 0, 0 };
    static const QUMethod slot_1 = {"newInstanceNoFork", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "processDelayed()", &slot_0, QMetaData::Private },
        { "newInstanceNoFork()", &slot_1, QMetaData::Private }
    };
    metaObj = QMetaObject::new_metaobject(
        "KUniqueApplication", parentObject,
        slot_tbl, 2,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KUniqueApplication.setMetaObject( metaObj );
    return metaObj;
}

void* KUniqueApplication::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KUniqueApplication" ) )
        return this;
    if ( !qstrcmp( clname, "DCOPObject" ) )
        return (DCOPObject*)this;
    return KApplication::qt_cast( clname );
}

bool KUniqueApplication::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: processDelayed(); break;
    case 1: newInstanceNoFork(); break;
    default:
        return KApplication::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KUniqueApplication::qt_emit( int _id, QUObject* _o )
{
    return KApplication::qt_emit(_id,_o);
}


bool KUniqueApplication::qt_property( int id, int f, QVariant* v)
{
    return KApplication::qt_property( id, f, v);
}

bool KUniqueApplication::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 443 "/coolo/prod/kdelibs/kdecore/kuniqueapplication.cpp" 2
# 54 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 1
# 25 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp"
# 1 "/coolo/prod/qt-copy/include/qmenubar.h" 1
# 39 "/coolo/prod/qt-copy/include/qmenubar.h"
# 49 "/coolo/prod/qt-copy/include/qmenubar.h"
class QPopupMenu;

class QMenuBar : public QFrame, public QMenuData
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   

public:
    QMenuBar( QWidget* parent=0, const char* name=0 );
    ~QMenuBar();

    void updateItem( int id );

    void show();
    void hide();

    bool eventFilter( QObject *, QEvent * );

    int heightForWidth(int) const;

    enum Separator { Never=0, InWindowsStyle=1 };
    Separator separator() const;
    virtual void setSeparator( Separator when );

    void setDefaultUp( bool );
    bool isDefaultUp() const;

    bool customWhatsThis() const;

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize minimumSizeHint() const;

    void activateItemAt( int index );






protected:
    void activated( int itemId );
    void highlighted( int itemId );

protected:
    void drawContents( QPainter * );
    void fontChange( const QFont & );
    void mousePressEvent( QMouseEvent * );
    void mouseReleaseEvent( QMouseEvent * );
    void mouseMoveEvent( QMouseEvent * );
    void keyPressEvent( QKeyEvent * );
    void focusInEvent( QFocusEvent * );
    void focusOutEvent( QFocusEvent * );
    void resizeEvent( QResizeEvent * );
    void leaveEvent( QEvent * );
    void menuContentsChanged();
    void menuStateChanged();
    void styleChange( QStyle& );
    int itemAtPos( const QPoint & );
    void hidePopups();
    QRect itemRect( int item );

private :
    void subActivated( int itemId );
    void subHighlighted( int itemId );

    void accelActivated( int itemId );
    void accelDestroyed();

    void popupDestroyed( QObject* );
    void performDelayedChanges();

    void languageChange();

private:
    void performDelayedContentsChanged();
    void performDelayedStateChanged();
    void menuInsPopup( QPopupMenu * );
    void menuDelPopup( QPopupMenu * );
    void frameChanged();

    bool tryMouseEvent( QPopupMenu *, QMouseEvent * );
    void tryKeyEvent( QPopupMenu *, QKeyEvent * );
    void goodbye( bool cancelled = FALSE );
    void openActPopup();

    void setActiveItem( int index, bool show = TRUE, bool activate_first_item = TRUE );
    void setAltMode( bool );

    int calculateRects( int max_width = -1 );


    void setupAccelerators();
    QAccel *autoaccel;

    QRect *irects;
    int rightSide;

    uint mseparator : 1;
    uint waitforalt : 1;
    uint popupvisible : 1;
    uint hasmouse : 1;
    uint defaultup : 1;
    uint toggleclose : 1;
    uint pendingDelayedContentsChanges : 1;
    uint pendingDelayedStateChanges : 1;

    friend class QPopupMenu;
# 190 "/coolo/prod/qt-copy/include/qmenubar.h"
private:


    QMenuBar( const QMenuBar & );
    QMenuBar &operator=( const QMenuBar & );

};
# 26 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qmainwindow.h" 1
# 39 "/coolo/prod/qt-copy/include/qmainwindow.h"



# 1 "/coolo/prod/qt-copy/include/qtoolbar.h" 1
# 39 "/coolo/prod/qt-copy/include/qtoolbar.h"


# 1 "/coolo/prod/qt-copy/include/qdockwindow.h" 1
# 39 "/coolo/prod/qt-copy/include/qdockwindow.h"







class QDockWindowHandle;
class QDockWindowTitleBar;
class QPainter;
class QDockWindowResizeHandle;
class QBoxLayout;
class QHBoxLayout;
class QVBoxLayout;
class QDockArea;
class QWidgetResizeHandler;
class QMainWindow;
class QDockAreaLayout;
class QDockWindowPrivate;
class QToolBar;
class QWindowsXPStyle;

class QDockWindow : public QFrame
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   
   
   
   
   

    friend class QDockWindowHandle;
    friend class QDockWindowTitleBar;
    friend class QDockArea;
    friend class QDockAreaLayout;
    friend class QMainWindow;
    friend class QToolBar;
    friend class QWindowsXPStyle;

public:
    enum Place { InDock, OutsideDock };
    enum CloseMode { Never = 0, Docked = 1, Undocked = 2, Always = Docked | Undocked };

    QDockWindow( Place p = InDock, QWidget* parent=0, const char* name=0, WFlags f = 0 );
    QDockWindow( QWidget* parent, const char* name=0, WFlags f = 0 );
    ~QDockWindow();

    virtual void setWidget( QWidget *w );
    QWidget *widget() const;

    Place place() const { return curPlace; }

    QDockArea *area() const;

    virtual void setCloseMode( int m );
    bool isCloseEnabled() const;
    int closeMode() const;

    virtual void setResizeEnabled( bool b );
    virtual void setMovingEnabled( bool b );
    bool isResizeEnabled() const;
    bool isMovingEnabled() const;

    virtual void setHorizontallyStretchable( bool b );
    virtual void setVerticallyStretchable( bool b );
    bool isHorizontallyStretchable() const;
    bool isVerticallyStretchable() const;
    void setHorizontalStretchable( bool b ) { setHorizontallyStretchable( b ); }
    void setVerticalStretchable( bool b ) { setVerticallyStretchable( b ); }
    bool isHorizontalStretchable() const { return isHorizontallyStretchable(); }
    bool isVerticalStretchable() const { return isVerticallyStretchable(); }
    bool isStretchable() const;

    virtual void setOffset( int o );
    int offset() const;

    virtual void setFixedExtentWidth( int w );
    virtual void setFixedExtentHeight( int h );
    QSize fixedExtent() const;

    virtual void setNewLine( bool b );
    bool newLine() const;

    Qt::Orientation orientation() const;

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize minimumSizeHint() const;

    QBoxLayout *boxLayout();

    virtual void setOpaqueMoving( bool b );
    bool opaqueMoving() const;

    bool eventFilter( QObject *o, QEvent *e );





protected:
    void orientationChanged( Orientation o );
    void placeChanged( QDockWindow::Place p );
    void visibilityChanged( bool );

public :
    virtual void undock( QWidget *w );
    virtual void undock() { undock( 0 ); }
    virtual void dock();
    virtual void setOrientation( Orientation o );
    void setCaption( const QString &s );

protected:
    void resizeEvent( QResizeEvent *e );
    void showEvent( QShowEvent *e );
    void hideEvent( QHideEvent *e );
    void contextMenuEvent( QContextMenuEvent *e );

    void drawFrame( QPainter * );
    void drawContents( QPainter * );

    bool event( QEvent *e );

private :
    void toggleVisible() { if ( !isVisible() ) show(); else hide(); }

private:
    QDockWindow( Place p, QWidget* parent, const char* name, WFlags f, bool toolbar );

    void handleMove( const QPoint &pos, const QPoint &gp, bool drawRect );
    void updateGui();
    void updateSplitterVisibility( bool visible );

    void startRectDraw( const QPoint &so, bool drawRect );
    void endRectDraw( bool drawRect );
    void updatePosition( const QPoint &globalPos );
    QWidget *areaAt( const QPoint &gp );
    void removeFromDock( bool fixNewLines = TRUE );
    void swapRect( QRect &r, Qt::Orientation o, const QPoint &offset, QDockArea *area );
    void init();

private:
    QDockWindowHandle *horHandle, *verHandle;
    QDockWindowTitleBar *titleBar;
    QWidget *wid;
    QPainter *unclippedPainter;
    QDockArea *dockArea, *tmpDockArea;
    QRect currRect;
    Place curPlace;
    Place state;
    bool resizeEnabled : 1;
    bool moveEnabled : 1;
    bool nl : 1;
    bool opaque : 1;
    bool isToolbar : 1;
    bool stretchable[ 3 ];
    Orientation startOrientation;
    int cMode;
    QPoint startOffset;
    int offs;
    QSize fExtent;
    QDockWindowResizeHandle *hHandleTop, *hHandleBottom, *vHandleLeft, *vHandleRight;
    QVBoxLayout *hbox;
    QHBoxLayout *vbox;
    QBoxLayout *childBox;
    void *dockWindowData;
    QPoint lastPos;
    QSize lastSize;
    QWidgetResizeHandler *widgetResizeHandler;
    QDockWindowPrivate *d;

private:

    QDockWindow( const QDockWindow & );
    QDockWindow& operator=( const QDockWindow & );

};

inline QDockArea *QDockWindow::area() const
{
    return dockArea;
}

# 1 "/coolo/prod/qt-copy/include/qwinexport.h" 1
# 231 "/coolo/prod/qt-copy/include/qdockwindow.h" 2
# 43 "/coolo/prod/qt-copy/include/qtoolbar.h" 2




class QMainWindow;
class QButton;
class QBoxLayout;
class QToolBarPrivate;

class QToolBar: public QDockWindow
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   

public:
    QToolBar( const QString &label,
              QMainWindow *, ToolBarDock = DockTop,
              bool newLine = FALSE, const char* name=0 );
    QToolBar( const QString &label, QMainWindow *, QWidget *,
              bool newLine = FALSE, const char* name=0, WFlags f = 0 );
    QToolBar( QMainWindow* parent=0, const char* name=0 );
    ~QToolBar();

    void addSeparator();

    void show();
    void hide();

    QMainWindow * mainWindow() const;

    virtual void setStretchableWidget( QWidget * );

    bool event( QEvent * e );

    virtual void setLabel( const QString & );
    QString label() const;

    virtual void clear();

    QSize minimumSize() const;
    QSize minimumSizeHint() const;

    void setOrientation( Orientation o );
    void setMinimumSize( int minw, int minh );

protected:
    void resizeEvent( QResizeEvent *e );
    void styleChange( QStyle & );

private :
    void createPopup();

private:
    void init();
    void checkForExtension( const QSize &sz );
    QToolBarPrivate * d;
    QMainWindow * mw;
    QWidget * sw;
    QString l;

    friend class QMainWindow;

private:

    QToolBar( const QToolBar & );
    QToolBar& operator=( const QToolBar & );

};
# 44 "/coolo/prod/qt-copy/include/qmainwindow.h" 2






class QMenuBar;
class QStatusBar;
class QToolTipGroup;
class QMainWindowPrivate;
class QMainWindowLayout;
class QPopupMenu;

class QMainWindow: public QWidget
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   

public:
    QMainWindow( QWidget* parent=0, const char* name=0, WFlags f = WType_TopLevel );
    ~QMainWindow();


    QMenuBar * menuBar() const;

    QStatusBar * statusBar() const;

    QToolTipGroup * toolTipGroup() const;


    virtual void setCentralWidget( QWidget * );
    QWidget * centralWidget() const;

    virtual void setDockEnabled( Dock dock, bool enable );
    bool isDockEnabled( Dock dock ) const;
    bool isDockEnabled( QDockArea *area ) const;
    virtual void setDockEnabled( QDockWindow *tb, Dock dock, bool enable );
    bool isDockEnabled( QDockWindow *tb, Dock dock ) const;
    bool isDockEnabled( QDockWindow *tb, QDockArea *area ) const;

    virtual void addDockWindow( QDockWindow *, Dock = DockTop, bool newLine = FALSE );
    virtual void addDockWindow( QDockWindow *, const QString &label,
                                Dock = DockTop, bool newLine = FALSE );
    virtual void moveDockWindow( QDockWindow *, Dock = DockTop );
    virtual void moveDockWindow( QDockWindow *, Dock, bool nl, int index, int extraOffset = -1 );
    virtual void removeDockWindow( QDockWindow * );

    void show();
    void hide();
    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    bool rightJustification() const;
    bool usesBigPixmaps() const;
    bool usesTextLabel() const;
    bool dockWindowsMovable() const;
    bool opaqueMoving() const;

    bool eventFilter( QObject*, QEvent* );

    bool getLocation( QDockWindow *tb, Dock &dock, int &index, bool &nl, int &extraOffset ) const;

    QPtrList<QDockWindow> dockWindows( Dock dock ) const;
    QPtrList<QDockWindow> dockWindows() const;
    void lineUpDockWindows( bool keepNewLines = FALSE );

    bool isDockMenuEnabled() const;


    bool hasDockWindow( QDockWindow *dw );

    void addToolBar( QDockWindow *, Dock = DockTop, bool newLine = FALSE );
    void addToolBar( QDockWindow *, const QString &label,
                     Dock = DockTop, bool newLine = FALSE );
    void moveToolBar( QDockWindow *, Dock = DockTop );
    void moveToolBar( QDockWindow *, Dock, bool nl, int index, int extraOffset = -1 );
    void removeToolBar( QDockWindow * );

    bool toolBarsMovable() const;
    QPtrList<QToolBar> toolBars( Dock dock ) const;
    void lineUpToolBars( bool keepNewLines = FALSE );


    virtual QDockArea *dockingArea( const QPoint &p );
    QDockArea *leftDock() const;
    QDockArea *rightDock() const;
    QDockArea *topDock() const;
    QDockArea *bottomDock() const;

    virtual bool isCustomizable() const;

    bool appropriate( QDockWindow *dw ) const;

    enum DockWindows { OnlyToolBars, NoToolBars, AllDockWindows };
    QPopupMenu *createDockWindowMenu( DockWindows dockWindows = AllDockWindows ) const;

public :
    virtual void setRightJustification( bool );
    virtual void setUsesBigPixmaps( bool );
    virtual void setUsesTextLabel( bool );
    virtual void setDockWindowsMovable( bool );
    virtual void setOpaqueMoving( bool );
    virtual void setDockMenuEnabled( bool );
    virtual void whatsThis();
    virtual void setAppropriate( QDockWindow *dw, bool a );
    virtual void customize();


    void setToolBarsMovable( bool );

protected:
    void pixmapSizeChanged( bool );
    void usesTextLabelChanged( bool );
    void dockWindowPositionChanged( QDockWindow * );



    void toolBarPositionChanged( QToolBar * );


protected :
    virtual void setUpLayout();
    virtual bool showDockMenu( const QPoint &globalPos );
    void menuAboutToShow();

protected:
    void paintEvent( QPaintEvent * );
    void childEvent( QChildEvent * );
    bool event( QEvent * );
    void styleChange( QStyle& );

private :
    void slotPlaceChanged();
    void doLineUp() { lineUpDockWindows( TRUE ); }

private:
    QMainWindowPrivate * d;
    void triggerLayout( bool deleteLayout = TRUE);
    bool dockMainWindow( QObject *dock );


    virtual void setMenuBar( QMenuBar * );

    virtual void setStatusBar( QStatusBar * );

    virtual void setToolTipGroup( QToolTipGroup * );


    friend class QDockWindow;
    friend class QMenuBar;
    friend class QHideDock;
    friend class QToolBar;
    friend class QMainWindowLayout;
private:

    QMainWindow( const QMainWindow & );
    QMainWindow& operator=( const QMainWindow & );

};


inline void QMainWindow::addToolBar( QDockWindow *w, ToolBarDock dock, bool newLine )
{
    addDockWindow( w, dock, newLine );
}

inline void QMainWindow::addToolBar( QDockWindow *w, const QString &label,
                              ToolBarDock dock, bool newLine )
{
    addDockWindow( w, label, dock, newLine );
}

inline void QMainWindow::moveToolBar( QDockWindow *w, ToolBarDock dock )
{
    moveDockWindow( w, dock );
}

inline void QMainWindow::moveToolBar( QDockWindow *w, ToolBarDock dock, bool nl, int index, int extraOffset )
{
    moveDockWindow( w, dock, nl, index, extraOffset );
}

inline void QMainWindow::removeToolBar( QDockWindow *w )
{
    removeDockWindow( w );
}

inline bool QMainWindow::toolBarsMovable() const
{
    return dockWindowsMovable();
}

inline void QMainWindow::lineUpToolBars( bool keepNewLines )
{
    lineUpDockWindows( keepNewLines );
}

inline void QMainWindow::setToolBarsMovable( bool b )
{
    setDockWindowsMovable( b );
}



 QTextStream &operator<<( QTextStream &, const QMainWindow & );
 QTextStream &operator>>( QTextStream &, QMainWindow & );
# 28 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qtabbar.h" 1
# 37 "/coolo/prod/qt-copy/include/qtabbar.h"
# 46 "/coolo/prod/qt-copy/include/qtabbar.h"
class QTabBar;
class QIconSet;

class QTab : public Qt
{
    friend class QTabBar;
    friend class QTabWidget;

public:
    QTab();
    virtual ~QTab();
    QTab( const QString& text );
    QTab( const QIconSet& icon, const QString& text = QString::null );

    void setText( const QString& text);
    QString text() const { return label; }
    void setIconSet( const QIconSet& icon );
    QIconSet* iconSet() const { return iconset; }
    void setRect( const QRect& rect ) { r = rect; }
    QRect rect() const { return r; }
    void setEnabled( bool enable ) { enabled = enable; }
    bool isEnabled() const { return enabled; }
    void setIdentifier( int i ) { id = i; }
    int identifier() const { return id; }

private:
    void setTabBar( QTabBar *tb );
    QString label;
    QRect r;
    bool enabled;
    int id;
    QIconSet* iconset;
    QTabBar *tb;
};


struct QTabPrivate;


class QTabBar: public QWidget
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   

public:
    QTabBar( QWidget* parent=0, const char* name=0 );
    ~QTabBar();

    enum Shape { RoundedAbove, RoundedBelow,
                 TriangularAbove, TriangularBelow };

    Shape shape() const;
    virtual void setShape( Shape );

    void show();

    virtual int addTab( QTab * );
    virtual int insertTab( QTab *, int index = -1 );
    virtual void removeTab( QTab * );

    virtual void setTabEnabled( int, bool );
    bool isTabEnabled( int ) const;


    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    int currentTab() const;
    int keyboardFocusTab() const;

    QTab * tab( int ) const;
    QTab * tabAt( int ) const;
    int indexOf( int ) const;
    int count() const;

    virtual void layoutTabs();
    virtual QTab * selectTab( const QPoint & p ) const;

    void removeToolTip( int index );
    void setToolTip( int index, const QString & tip );
    QString toolTip( int index ) const;

public :
    virtual void setCurrentTab( int );
    virtual void setCurrentTab( QTab * );

protected:
    void selected( int );
    void layoutChanged();

protected:
    virtual void paint( QPainter *, QTab *, bool ) const;
    virtual void paintLabel( QPainter*, const QRect&, QTab*, bool ) const;

    void focusInEvent( QFocusEvent *e );
    void focusOutEvent( QFocusEvent *e );

    void resizeEvent( QResizeEvent * );
    void paintEvent( QPaintEvent * );
    void mousePressEvent ( QMouseEvent * );
    void mouseMoveEvent ( QMouseEvent * );
    void mouseReleaseEvent ( QMouseEvent * );
    void keyPressEvent( QKeyEvent * );
    void styleChange( QStyle& );
    void fontChange ( const QFont & );

    bool event( QEvent *e );

    QPtrList<QTab> * tabList();

private :
    void scrollTabs();

private:
    QPtrList<QTab> * l;
    QPtrList<QTab> * lstatic;
    void makeVisible( QTab* t = 0 );
    void updateArrowButtons();
    QTabPrivate * d;

    friend class QTabBarToolTip;
    friend class QTab;

private:

    QTabBar( const QTabBar & );
    QTabBar& operator=( const QTabBar & );

};
# 29 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qwidgetstack.h" 1
# 39 "/coolo/prod/qt-copy/include/qwidgetstack.h"
# 50 "/coolo/prod/qt-copy/include/qwidgetstack.h"
class QWidgetStackPrivate;


class QWidgetStack: public QFrame
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QWidgetStack( QWidget* parent=0, const char* name=0 );
    QWidgetStack( QWidget* parent, const char* name, WFlags f);

    ~QWidgetStack();

    int addWidget( QWidget *, int = -1 );
    void removeWidget( QWidget * );

    QSize sizeHint() const;
    QSize minimumSizeHint() const;
    void show();

    QWidget * widget( int ) const;
    int id( QWidget * ) const;

    QWidget * visibleWidget() const;

    void setFrameRect( const QRect & );

protected:
    void aboutToShow( int );
    void aboutToShow( QWidget * );

public :
    void raiseWidget( int );
    void raiseWidget( QWidget * );

protected:
    void frameChanged();
    void resizeEvent( QResizeEvent * );

    virtual void setChildGeometries();
    void childEvent( QChildEvent * );

private:
    void init();

    QWidgetStackPrivate * d;
    QIntDict<QWidget> * dict;
    QPtrDict<QWidget> * focusWidgets;
    QWidget * topWidget;
    QWidget * invisible;

private:

    QWidgetStack( const QWidgetStack & );
    QWidgetStack& operator=( const QWidgetStack & );

};
# 30 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2



# 1 "/coolo/prod/kdelibs/kdeui/kstdaction.h" 1
# 20 "/coolo/prod/kdelibs/kdeui/kstdaction.h"

class QObject;
class KAction;
class KActionCollection;
class KRecentFilesAction;
class KToggleAction;
class KToggleToolBarAction;
# 113 "/coolo/prod/kdelibs/kdeui/kstdaction.h"
namespace KStdAction
{



        enum StdAction {
                ActionNone,


                New, Open, OpenRecent, Save, SaveAs, Revert, Close,
                Print, PrintPreview, Mail, Quit,


                Undo, Redo, Cut, Copy, Paste, SelectAll, Deselect, Find, FindNext, FindPrev,
                Replace,


                ActualSize, FitToPage, FitToWidth, FitToHeight, ZoomIn, ZoomOut,
                Zoom, Redisplay,


                Up, Back, Forward, Home, Prior, Next, Goto, GotoPage, GotoLine,
                FirstPage, LastPage,


                AddBookmark, EditBookmarks,


                Spelling,


                ShowMenubar, ShowToolbar, ShowStatusbar,
                SaveOptions, KeyBindings,
                Preferences, ConfigureToolbars,


                Help, HelpContents, WhatsThis, ReportBug, AboutApp, AboutKDE,
                TipofDay,


                ConfigureNotifications,
                FullScreen,
                Clear
        };





        KAction* create( StdAction id, const char *name,
                const QObject *recvr, const char *slot,
                KActionCollection* parent );

        inline KAction* create( StdAction id,
                const QObject *recvr, const char *slot,
                KActionCollection* parent )
                { return KStdAction::create( id, 0, recvr, slot, parent ); }





        inline KAction *action(StdAction act_enum,
                const QObject *recvr, const char *slot,
                KActionCollection *parent, const char *name = 0L )
                { return KStdAction::create( act_enum, name, recvr, slot, parent ); }




        const char* name( StdAction id );


        inline const char* stdName(StdAction act_enum) { return name( act_enum ); }






        QStringList stdNames();




        KAction *openNew(const QObject *recvr, const char *slot, KActionCollection* parent, const char *name = 0 );




        KAction *open(const QObject *recvr, const char *slot, KActionCollection* parent, const char *name = 0 );






        KRecentFilesAction *openRecent(const QObject *recvr, const char *slot, KActionCollection* parent, const char *name = 0 );




        KAction *save(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *saveAs(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );





        KAction *revert(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *close(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *print(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *printPreview(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *mail(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *quit(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *undo(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *redo(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *cut(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *copy(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );





        KAction *paste(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );





        KAction *clear(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *selectAll(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *deselect(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *find(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *findNext(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *findPrev(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *replace(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *actualSize(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *fitToPage(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *fitToWidth(const QObject *recvr, const char *slot,
                KActionCollection* parent, const char *name = 0 );




        KAction *fitToHeight(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );




        KAction *zoomIn(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *zoomOut(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *zoom(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *redisplay(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *up(const QObject *recvr, const char *slot,
                        KActionCollection* parent, const char *name = 0 );




        KAction *back(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *forward(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *home(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *prior(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *next(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *goTo(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );





        KAction *gotoPage(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *gotoLine(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *firstPage(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *lastPage(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *addBookmark(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );




        KAction *editBookmarks(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );




        KAction *spelling(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );





        KToggleAction *showMenubar(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );
# 482 "/coolo/prod/kdelibs/kdeui/kstdaction.h"
        KToggleAction *showToolbar(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );






        KToggleToolBarAction *showToolbar(const char* toolBarName,
                                        KActionCollection* parent, const char *name = 0 );




        KToggleAction *showStatusbar(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );





        KToggleAction *fullScreen(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );




        KAction *saveOptions(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );




        KAction *keyBindings(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );




        KAction *preferences(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );




        KAction *configureToolbars(const QObject *recvr,
                                        const char *slot,
                                        KActionCollection* parent,
                                        const char *name = 0 );





        KAction *configureNotifications(const QObject *recvr,
                                        const char *slot,
                                        KActionCollection *parent,
                                        const char *name = 0);




        KAction *help(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *helpContents(const QObject *recvr, const char *slot,
                                        KActionCollection* parent, const char *name = 0 );




        KAction *whatsThis(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );





        KAction *tipOfDay(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *reportBug(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *aboutApp(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );




        KAction *aboutKDE(const QObject *recvr, const char *slot,
                                KActionCollection* parent, const char *name = 0 );
}
# 34 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2




# 1 "/coolo/prod/kdelibs/kdecore/kaccelmanager_private.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kaccelmanager_private.h"
# 42 "/coolo/prod/kdelibs/kdecore/kaccelmanager_private.h"
class KAccelString
{
public:

  KAccelString() : m_pureText(), m_accel(-1) {};
  KAccelString(const QString &input, int initalWeight=-1);

  void calculateWeights(int initialWeight);

  const QString &pure() const { return m_pureText; };
  QString accelerated() const;

  int accel() const { return m_accel; };
  void setAccel(int accel) { m_accel = accel; };

  int originalAccel() const { return m_orig_accel; }
  QString originalText() const { return m_origText; }

  QChar accelerator() const;

  int maxWeight(int &index, const QString &used);

  bool operator == (const KAccelString &c) const { return m_pureText == c.m_pureText && m_accel == c.m_accel && m_orig_accel == c.m_orig_accel; }


private:

  int stripAccelerator(QString &input);

  void dump();

  QString m_pureText, m_origText;
  int m_accel, m_orig_accel;
  QMemArray<int> m_weight;

};


typedef QValueList<KAccelString> KAccelStringList;
# 91 "/coolo/prod/kdelibs/kdecore/kaccelmanager_private.h"
class KAccelManagerAlgorithm
{
public:

  static const int DEFAULT_WEIGHT;

  static const int FIRST_CHARACTER_EXTRA_WEIGHT;
  static const int WORD_BEGINNING_EXTRA_WEIGHT;
  static const int WANTED_ACCEL_EXTRA_WEIGHT;
  static const int DIALOG_BUTTON_EXTRA_WEIGHT;
  static const int STANDARD_ACCEL;

  static const int ACTION_ELEMENT_WEIGHT;
  static const int GROUP_BOX_WEIGHT;
  static const int MENU_TITLE_WEIGHT;

  static void findAccelerators(KAccelStringList &result, QString &used);

};


class QPopupMenu;
# 125 "/coolo/prod/kdelibs/kdecore/kaccelmanager_private.h"
class KPopupAccelManager : public QObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:

  static void manage(QPopupMenu *popup);


protected:

  KPopupAccelManager(QPopupMenu *popup);


private :

  void aboutToShow();


private:

  void calculateAccelerators();

  void findMenuEntries(KAccelStringList &list);
  void setMenuEntries(const KAccelStringList &list);

  QPopupMenu *m_popup;
  KAccelStringList m_entries;
  int m_count;

};
# 39 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2
# 1 "/coolo/prod/kdelibs/kdeui/kstdaction_p.h" 1





namespace KStdAction
{

struct KStdActionInfo
{
        StdAction id;
        KStdAccel::StdAccel idAccel;
        const char* psName;
        const char* psLabel;
        const char* psWhatsThis;
        const char* psIconName;
};

static const KStdActionInfo g_rgActionInfo[] =
{
        { New, KStdAccel::New, "file_new", ("&New"), 0, "filenew" },
        { Open, KStdAccel::Open, "file_open", ("&Open..."), 0, "fileopen" },
        { OpenRecent, KStdAccel::AccelNone, "file_open_recent", ("Open &Recent"), 0, 0 },
        { Save, KStdAccel::Save, "file_save", ("&Save"), 0, "filesave" },
        { SaveAs, KStdAccel::AccelNone, "file_save_as", ("Save &As..."), 0, "filesaveas" },
        { Revert, KStdAccel::AccelNone, "file_revert", ("Re&vert"), 0, "revert" },
        { Close, KStdAccel::Close, "file_close", ("&Close"), 0, "fileclose" },
        { Print, KStdAccel::Print, "file_print", ("&Print..."), 0, "fileprint" },
        { PrintPreview, KStdAccel::AccelNone, "file_print_preview", ("Print Previe&w..."), 0, "filequickprint" },
        { Mail, KStdAccel::AccelNone, "file_mail", ("&Mail..."), 0, "mail_send" },
        { Quit, KStdAccel::Quit, "file_quit", ("&Quit"), 0, "exit" },

        { Undo, KStdAccel::Undo, "edit_undo", ("&Undo"), 0, "undo" },
        { Redo, KStdAccel::Redo, "edit_redo", ("Re&do"), 0, "redo" },
        { Cut, KStdAccel::Cut, "edit_cut", ("Cu&t"), 0, "editcut" },
        { Copy, KStdAccel::Copy, "edit_copy", ("&Copy"), 0, "editcopy" },
        { Paste, KStdAccel::Paste, "edit_paste", ("&Paste"), 0, "editpaste" },
        { Clear, KStdAccel::AccelNone, "edit_clear", ("C&lear"), 0, "editclear" },
        { SelectAll, KStdAccel::SelectAll, "edit_select_all", ("Select &All"), 0, 0 },
        { Deselect, KStdAccel::Deselect, "edit_deselect", ("Dese&lect"), 0, 0 },
        { Find, KStdAccel::Find, "edit_find", ("&Find..."), 0, "find" },
        { FindNext, KStdAccel::FindNext, "edit_find_next", ("Find &Next"), 0, "next" },

        { FindPrev, KStdAccel::FindPrev, "edit_find_last", ("Find Pre&vious"), 0, "previous" },
        { Replace, KStdAccel::Replace, "edit_replace", ("&Replace..."), 0, 0 },

        { ActualSize, KStdAccel::AccelNone, "view_actual_size", ("&Actual Size"), 0, 0 },
        { FitToPage, KStdAccel::AccelNone, "view_fit_to_page", ("&Fit to Page"), 0, 0 },
        { FitToWidth, KStdAccel::AccelNone, "view_fit_to_width", ("Fit to Page &Width"), 0, 0 },
        { FitToHeight, KStdAccel::AccelNone, "view_fit_to_height", ("Fit to Page &Height"), 0, 0 },
        { ZoomIn, KStdAccel::ZoomIn, "view_zoom_in", ("Zoom &In"), 0, "viewmag+" },
        { ZoomOut, KStdAccel::ZoomOut, "view_zoom_out", ("Zoom &Out"), 0, "viewmag-" },
        { Zoom, KStdAccel::AccelNone, "view_zoom", ("&Zoom..."), 0, "viewmag" },
        { Redisplay, KStdAccel::AccelNone, "view_redisplay", ("&Redisplay"), 0, "reload" },

        { Up, KStdAccel::Up, "go_up", ("&Up"), 0, "up" },

        { Back, KStdAccel::Back, "go_back", 0, 0, "back" },
        { Forward, KStdAccel::Forward, "go_forward", 0, 0, "forward" },
        { Home, KStdAccel::Home, "go_home", 0, 0, "gohome" },
        { Prior, KStdAccel::Prior, "go_previous", ("&Previous Page"), 0, "previous" },
        { Next, KStdAccel::Next, "go_next", ("&Next Page"), 0, "next" },
        { Goto, KStdAccel::AccelNone, "go_goto", ("&Go To..."), 0, 0 },
        { GotoPage, KStdAccel::AccelNone, "go_goto_page", ("&Go to Page..."), 0, "goto" },
        { GotoLine, KStdAccel::GotoLine, "go_goto_line", ("&Go to Line..."), 0, 0 },
        { FirstPage, KStdAccel::Home, "go_first", ("&First Page"), 0, "top" },
        { LastPage, KStdAccel::End, "go_last", ("&Last Page"), 0, "bottom" },

        { AddBookmark, KStdAccel::AddBookmark, "bookmark_add", ("&Add Bookmark"), 0, "bookmark_add" },
        { EditBookmarks, KStdAccel::AccelNone, "bookmark_edit", ("&Edit Bookmarks"), 0, "bookmark" },

        { Spelling, KStdAccel::AccelNone, "tools_spelling", ("&Spelling..."), 0, "spellcheck" },

        { ShowMenubar, KStdAccel::ShowMenubar, "options_show_menubar", ("Show &Menubar"), 0, "showmenu" },
        { ShowToolbar, KStdAccel::AccelNone, "options_show_toolbar", ("Show &Toolbar"), 0, 0 },
        { ShowStatusbar, KStdAccel::AccelNone, "options_show_statusbar", ("Show St&atusbar"), 0, 0 },
        { FullScreen, KStdAccel::FullScreen, "fullscreen", ("F&ull Screen Mode"), 0, "window_fullscreen" },
        { SaveOptions, KStdAccel::AccelNone, "options_save_options", ("&Save Settings"), 0, 0 },
        { KeyBindings, KStdAccel::AccelNone, "options_configure_keybinding", ("Configure S&hortcuts..."), 0,"configure_shortcuts" },
        { Preferences, KStdAccel::AccelNone, "options_configure", ("&Configure %1..."), 0, "configure" },
        { ConfigureToolbars, KStdAccel::AccelNone, "options_configure_toolbars", ("Configure Tool&bars..."), 0,"configure_toolbars" },
        { ConfigureNotifications, KStdAccel::AccelNone, "options_configure_notifications", ("Configure &Notifications..."), 0, "knotify" },

        { Help, KStdAccel::Help, "help", 0, 0, "help" },
        { HelpContents, KStdAccel::AccelNone, "help_contents", ("%1 &Handbook"), 0, "contents" },
        { WhatsThis, KStdAccel::WhatsThis, "help_whats_this", ("What's &This?"), 0, "contexthelp" },
        { TipofDay, KStdAccel::AccelNone, "help_show_tip", ("Tip of the &Day"), 0, "idea" },
        { ReportBug, KStdAccel::AccelNone, "help_report_bug", ("&Report Bug..."), 0, 0 },
        { AboutApp, KStdAccel::AccelNone, "help_about_app", ("&About %1"), 0, 0 },
        { AboutKDE, KStdAccel::AccelNone, "help_about_kde", ("About &KDE"), 0,"about_kde" },
        { ActionNone, KStdAccel::AccelNone, 0, 0, 0, 0 }
};

inline const KStdActionInfo* infoPtr( StdAction id )
{
        for( uint i = 0; g_rgActionInfo[i].id != ActionNone; i++ ) {
                if( g_rgActionInfo[i].id == id )
                        return &g_rgActionInfo[i];
        }
        return 0;
}

static inline QStringList internal_stdNames()
{
    QStringList result;

    for( uint i = 0; g_rgActionInfo[i].id != ActionNone; i++ )
        if (g_rgActionInfo[i].psLabel)
            result.append(i18n(g_rgActionInfo[i].psLabel));
    return result;
}

}
# 40 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2

# 1 "/coolo/prod/kdelibs/kdecore/kaccelmanager.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kaccelmanager.h"


class QWidget;
class QString;
# 39 "/coolo/prod/kdelibs/kdecore/kaccelmanager.h"
class KAcceleratorManager
{
public:
# 63 "/coolo/prod/kdelibs/kdecore/kaccelmanager.h"
  static void manage(QWidget *widget);
# 74 "/coolo/prod/kdelibs/kdecore/kaccelmanager.h"
  static void manage(QWidget *widget, bool programmers_mode);


    static void last_manage(QString &added, QString &changed, QString &removed);
};
# 42 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2


const int KAccelManagerAlgorithm::DEFAULT_WEIGHT = 50;

const int KAccelManagerAlgorithm::FIRST_CHARACTER_EXTRA_WEIGHT = 50;

const int KAccelManagerAlgorithm::WORD_BEGINNING_EXTRA_WEIGHT = 50;

const int KAccelManagerAlgorithm::DIALOG_BUTTON_EXTRA_WEIGHT = 300;

const int KAccelManagerAlgorithm::WANTED_ACCEL_EXTRA_WEIGHT = 150;

const int KAccelManagerAlgorithm::ACTION_ELEMENT_WEIGHT = 50;

const int KAccelManagerAlgorithm::GROUP_BOX_WEIGHT = 0;

const int KAccelManagerAlgorithm::MENU_TITLE_WEIGHT = 250;

const int KAccelManagerAlgorithm::STANDARD_ACCEL = 300;
# 83 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp"
class KAcceleratorManagerPrivate
{
public:

    static void manage(QWidget *widget);
    static bool programmers_mode;
    static bool standardName(const QString &str);

    static bool checkChange(const KAccelString &as) {
        QString t2 = as.accelerated();
        QString t1 = as.originalText();
        if (t1 != t2)
        {
            if (as.accel() == -1) {
                removed_string += "<tr><td>" + t1 + "</td></tr>";
            } else if (as.originalAccel() == -1) {
                added_string += "<tr><td>" + t2 + "</td></tr>";
            } else {
                changed_string += "<tr><td>" + t1 + "</td>";
                changed_string += "<td>" + t2 + "</td></tr>";
            }
            return true;
        }
        return false;
    }
    static QString changed_string;
    static QString added_string;
    static QString removed_string;

private:
  class Item;
  typedef QPtrList<Item> ItemList;


  static void traverseChildren(QWidget *widget, Item *item);

  static void manageMenuBar(QMenuBar *mbar, Item *item);
  static void manageTabBar(QTabBar *bar, Item *item);

  static void calculateAccelerators(Item *item, QString &used);

  class Item
  {
  public:

    Item() : m_widget(0), m_children(0), m_index(-1) {};
    ~Item();

    void addChild(Item *item);

    QWidget *m_widget;
    KAccelString m_content;
    ItemList *m_children;
    int m_index;

  };
};


bool KAcceleratorManagerPrivate::programmers_mode = false;
QString KAcceleratorManagerPrivate::changed_string;
QString KAcceleratorManagerPrivate::added_string;
QString KAcceleratorManagerPrivate::removed_string;
static QStringList *kaccmp_sns = 0;
static KStaticDeleter<QStringList> kaccmp_sns_d;

bool KAcceleratorManagerPrivate::standardName(const QString &str)
{
    if (!kaccmp_sns)
        kaccmp_sns_d.setObject(kaccmp_sns, new QStringList(KStdAction::internal_stdNames()));
        return kaccmp_sns->contains(str);
}

KAcceleratorManagerPrivate::Item::~Item()
{
    delete m_children;
}


void KAcceleratorManagerPrivate::Item::addChild(Item *item)
{
    if (!m_children)
        m_children = new ItemList;

    m_children->append(item);
}

void KAcceleratorManagerPrivate::manage(QWidget *widget)
{
    if (widget->inherits("QPopupMenu"))
    {

        KPopupAccelManager::manage(static_cast<QPopupMenu*>(widget));
        return;
    }

    Item *root = new Item;

    traverseChildren(widget, root);

    QString used;
    calculateAccelerators(root, used);
    delete root;
}


void KAcceleratorManagerPrivate::calculateAccelerators(Item *item, QString &used)
{
    if (!item->m_children)
        return;


    KAccelStringList contents;
    for (Item *it = item->m_children->first(); it != 0;
         it = item->m_children->next())
    {
        contents << it->m_content;
    }


    KAccelManagerAlgorithm::findAccelerators(contents, used);


    int cnt = -1;
    for (Item *it = item->m_children->first(); it != 0;
         it = item->m_children->next())
    {
        cnt++;

        if (it->m_widget->inherits("QTabBar"))
        {
            QTabBar *bar = static_cast<QTabBar*>(it->m_widget);
            if (checkChange(contents[cnt]))
                bar->tabAt(it->m_index)->setText(contents[cnt].accelerated());
            continue;
        }
        if (it->m_widget->inherits("QMenuBar"))
        {
            QMenuBar *bar = static_cast<QMenuBar*>(it->m_widget);
            if (it->m_index >= 0)
            {
                QMenuItem *mitem = bar->findItem(bar->idAt(it->m_index));
                if (mitem)
                {
                    checkChange(contents[cnt]);
                    mitem->setText(contents[cnt].accelerated());
                }
                continue;
            }
        }
        int tprop = it->m_widget->metaObject()->findProperty("text", true);
        if (tprop != -1) {
            if (checkChange(contents[cnt]))
                it->m_widget->setProperty("text", contents[cnt].accelerated());
        } else {
            if (checkChange(contents[cnt]))
                it->m_widget->setProperty("title", contents[cnt].accelerated());
        }
    }


    for (Item *it = item->m_children->first(); it != 0;
         it = item->m_children->next())
    {
        if (it->m_widget && it->m_widget->isVisibleTo( item->m_widget ))
            calculateAccelerators(it, used);
    }
}


void KAcceleratorManagerPrivate::traverseChildren(QWidget *widget, Item *item)
{
  QObjectList *childList = widget->queryList("QWidget", 0, false, false);
  for ( QObject *it = childList->first(); it; it = childList->next() )
  {
    QWidget *w = static_cast<QWidget*>(it);

    if ( !w->isVisibleTo( widget ) )
        continue;



    if (w->inherits("QTabBar"))
    {
        manageTabBar(static_cast<QTabBar*>(w), item);
        continue;
    }

    if (w->inherits("QPopupMenu"))
    {

        KPopupAccelManager::manage(static_cast<QPopupMenu*>(w));
        continue;
    }

    if (w->inherits("QMenuBar"))
    {
        manageMenuBar(static_cast<QMenuBar*>(w), item);
        continue;
    }

    if (w->inherits("QComboBox") || w->inherits("QLineEdit") ||
        w->inherits("QTextEdit") || w->inherits("QTextView") ||
        w->inherits("QSpinBox"))
        continue;


    if (w->isFocusEnabled() || (w->inherits("QLabel") && static_cast<QLabel*>(w)->buddy()) || w->inherits("QGroupBox"))
    {
      QString content;
      QVariant variant;
      int tprop = w->metaObject()->findProperty("text", true);
      if (tprop != -1) {
          const QMetaProperty* p = w->metaObject()->property( tprop, true );
          if ( p && p->isValid() )
              w->qt_property( tprop, 1, &variant );
          else
              tprop = -1;
      }

      if (tprop == -1) {
          tprop = w->metaObject()->findProperty("title", true);
          if (tprop != -1) {
              const QMetaProperty* p = w->metaObject()->property( tprop, true );
              if ( p && p->isValid() )
                  w->qt_property( tprop, 1, &variant );
          }
      }

      if (variant.isValid())
          content = variant.toString();

      if (!content.isEmpty())
      {
          Item *i = new Item;
          i->m_widget = w;


          int weight = KAccelManagerAlgorithm::DEFAULT_WEIGHT;
          if (w->inherits("QPushButton") || w->inherits("QCheckBox") || w->inherits("QRadioButton") || w->inherits("QLabel"))
              weight = KAccelManagerAlgorithm::ACTION_ELEMENT_WEIGHT;


          if (w->inherits("QGroupBox"))
              weight = KAccelManagerAlgorithm::GROUP_BOX_WEIGHT;


          if (w->inherits("KDialogBaseButton"))
              weight += KAccelManagerAlgorithm::DIALOG_BUTTON_EXTRA_WEIGHT;

          i->m_content = KAccelString(content, weight);
          item->addChild(i);
      }
    }

    traverseChildren(w, item);
  }
  delete childList;
}


void KAcceleratorManagerPrivate::manageTabBar(QTabBar *bar, Item *item)
{
  for (int i=0; i<bar->count(); i++)
  {
    QString content = bar->tabAt(i)->text();
    if (content.isEmpty())
      continue;

    Item *it = new Item;
    item->addChild(it);
    it->m_widget = bar;
    it->m_index = i;
    it->m_content = KAccelString(content);
  }
}


void KAcceleratorManagerPrivate::manageMenuBar(QMenuBar *mbar, Item *item)
{
    QMenuItem *mitem;
    QString s;

    for (uint i=0; i<mbar->count(); ++i)
    {
        mitem = mbar->findItem(mbar->idAt(i));
        if (!mitem)
            continue;


        if (mitem->isSeparator())
            continue;

        s = mitem->text();
        if (!s.isEmpty())
        {
            Item *it = new Item;
            item->addChild(it);
            it->m_content =
                KAccelString(s,

                             KAccelManagerAlgorithm::MENU_TITLE_WEIGHT);

            it->m_widget = mbar;
            it->m_index = i;
        }


        if (mitem->popup())
            KPopupAccelManager::manage(mitem->popup());
    }
}
# 405 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp"
void KAcceleratorManager::manage(QWidget *widget)
{
    KAcceleratorManager::manage(widget, false);
}

void KAcceleratorManager::manage(QWidget *widget, bool programmers_mode)
{
    KAcceleratorManagerPrivate::changed_string = QString::null;
    KAcceleratorManagerPrivate::added_string = QString::null;
    KAcceleratorManagerPrivate::removed_string = QString::null;
    KAcceleratorManagerPrivate::programmers_mode = programmers_mode;
    KAcceleratorManagerPrivate::manage(widget);
}

void KAcceleratorManager::last_manage(QString &added, QString &changed, QString &removed)
{
    added = KAcceleratorManagerPrivate::added_string;
    changed = KAcceleratorManagerPrivate::changed_string;
    removed = KAcceleratorManagerPrivate::removed_string;
}
# 433 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp"
KAccelString::KAccelString(const QString &input, int initialWeight)
  : m_pureText(input), m_weight()
{
    if (m_pureText.contains('\t'))
        m_pureText = m_pureText.left(m_pureText.find('\t'));
    m_origText = m_pureText;
    m_orig_accel = m_pureText.find("(!)&");
    m_pureText.replace(m_orig_accel, 4, "");
    m_orig_accel = m_pureText.find("(&&)");
    if (m_orig_accel != -1)
        m_pureText.replace(m_orig_accel, 4, "&");
    m_orig_accel = m_accel = stripAccelerator(m_pureText);

    kdDebug(125) << input << " " << m_orig_accel << " " << m_accel << " " << m_pureText << endl;
    if (initialWeight == -1)
        initialWeight = KAccelManagerAlgorithm::DEFAULT_WEIGHT;

    calculateWeights(initialWeight);


}


QString KAccelString::accelerated() const
{
  QString result = m_pureText;
  if (result.isEmpty())
      return result;

  if (KAcceleratorManagerPrivate::programmers_mode)
  {
      int oa = m_orig_accel;

      if (m_accel >= 0) {
          if (m_accel != m_orig_accel) {
              result.insert(m_accel, "(!)&");
              if (m_accel < m_orig_accel)
                  oa += 4;
          } else {
              result.insert(m_accel, "&");
              if (m_accel < m_orig_accel)
                  oa++;
          }
      }

      if (m_accel != m_orig_accel && m_orig_accel >= 0)
          result.insert(oa, "(&&)");
  } else {
    if (m_accel >= 0)
        result.insert(m_accel, "&");
  }
  return result;
}


QChar KAccelString::accelerator() const
{
  if ((m_accel < 0) || (m_accel > (int)m_pureText.length()))
    return QChar();

  return m_pureText[m_accel].lower();
}


void KAccelString::calculateWeights(int initialWeight)
{
  m_weight.resize(m_pureText.length());

  uint pos = 0;
  bool start_character = true;

  while (pos<m_pureText.length())
  {
    QChar c = m_pureText[pos];

    int weight = initialWeight+1;


    if (pos == 0)
      weight += KAccelManagerAlgorithm::FIRST_CHARACTER_EXTRA_WEIGHT;


    if (start_character)
    {
      weight += KAccelManagerAlgorithm::WORD_BEGINNING_EXTRA_WEIGHT;
      start_character = false;
    }


    if (pos < 50)
      weight += (50-pos);


    if ((int)pos == accel()) {
        weight += KAccelManagerAlgorithm::WANTED_ACCEL_EXTRA_WEIGHT;

        if (KAcceleratorManagerPrivate::standardName(m_origText)) {
            weight += KAccelManagerAlgorithm::STANDARD_ACCEL;
        }
    }


    if (!c.isLetterOrNumber())
    {
      weight = 0;
      start_character = true;
    }

    m_weight[pos] = weight;

    ++pos;
  }
}


int KAccelString::stripAccelerator(QString &text)
{

  int p = 0;

  while (p >= 0)
  {
    p = text.find('&', p)+1;

    if (p <= 0 || p >= (int)text.length())
      return -1;

    if (text[p] != '&')
    {
      QChar c = text[p];
      if (c.isPrint())
      {
        text.remove(p-1,1);
        return p-1;
      }
    }

    p++;
  }

  return -1;
}


int KAccelString::maxWeight(int &index, const QString &used)
{
  int max = 0;
  index = -1;

  for (uint pos=0; pos<m_pureText.length(); ++pos)
    if (!used.contains(m_pureText[pos].lower()))
      if (m_weight[pos] > max)
      {
        max = m_weight[pos];
        index = pos;
      }

  return max;
}


void KAccelString::dump()
{
  QString s;
  for (uint i=0; i<m_weight.count(); ++i)
    s += QString("%1(%2) ").arg(pure()[i]).arg(m_weight[i]);
  kdDebug() << "s " << s << endl;
}
# 636 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp"
void KAccelManagerAlgorithm::findAccelerators(KAccelStringList &result, QString &used)
{
  KAccelStringList accel_strings = result;


  for (KAccelStringList::Iterator it = result.begin(); it != result.end(); ++it)
    (*it).setAccel(-1);


  for (uint cnt=0; cnt<accel_strings.count(); ++cnt)
  {
    int max = 0, index = -1, accel = -1;


    for (uint i=0; i<accel_strings.count(); ++i)
    {
      int a;
      int m = accel_strings[i].maxWeight(a, used);
      if (m>max)
      {
        max = m;
        index = i;
        accel = a;
      }
    }


    if (index < 0)
      return;


    if (accel >= 0)
    {
      result[index].setAccel(accel);
      used.append(result[index].accelerator());
    }


    accel_strings[index] = KAccelString();
  }
}
# 685 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp"
KPopupAccelManager::KPopupAccelManager(QPopupMenu *popup)
  : QObject(popup), m_popup(popup), m_count(-1)
{
    aboutToShow();
    connect(popup, "2""aboutToShow()", "1""aboutToShow()");
}


void KPopupAccelManager::aboutToShow()
{





  if (m_count != (int)m_popup->count())
  {
    findMenuEntries(m_entries);
    calculateAccelerators();
    m_count = m_popup->count();
  }
  else
  {
    KAccelStringList entries;
    findMenuEntries(entries);
    if (entries != m_entries)
    {
      m_entries = entries;
      calculateAccelerators();
    }
  }
}


void KPopupAccelManager::calculateAccelerators()
{

  QString used;
  KAccelManagerAlgorithm::findAccelerators(m_entries, used);


  setMenuEntries(m_entries);
}


void KPopupAccelManager::findMenuEntries(KAccelStringList &list)
{
  QMenuItem *mitem;
  QString s;

  list.clear();


  for (uint i=0; i<m_popup->count(); i++)
  {
    mitem = m_popup->findItem(m_popup->idAt(i));
    if (mitem->isSeparator())
      continue;

    s = mitem->text();


    int weight = 50;
    if (s.contains('\t'))
        weight = 0;

    list.append(KAccelString(s, weight));


    if (mitem->popup())
        KPopupAccelManager::manage(mitem->popup());
  }
}


void KPopupAccelManager::setMenuEntries(const KAccelStringList &list)
{
  QMenuItem *mitem;

  uint cnt = 0;
  for (uint i=0; i<m_popup->count(); i++)
  {
    mitem = m_popup->findItem(m_popup->idAt(i));
    if (mitem->isSeparator())
      continue;

    if (KAcceleratorManagerPrivate::checkChange(list[cnt]))
        mitem->setText(list[cnt].accelerated());
    cnt++;
  }
}


void KPopupAccelManager::manage(QPopupMenu *popup)
{

  if (popup->child(0, "KPopupAccelManager", false) == 0 )
    new KPopupAccelManager(popup);
}


# 1 "../kdecore/kaccelmanager_private.moc" 1
# 11 "../kdecore/kaccelmanager_private.moc"
# 1 "../../../prod/kdelibs/kdecore/kaccelmanager_private.h" 1
# 12 "../kdecore/kaccelmanager_private.moc" 2
# 22 "../kdecore/kaccelmanager_private.moc"
const char *KPopupAccelManager::className() const
{
    return "KPopupAccelManager";
}

QMetaObject *KPopupAccelManager::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KPopupAccelManager( "KPopupAccelManager", &KPopupAccelManager::staticMetaObject );
# 50 "../kdecore/kaccelmanager_private.moc"
QMetaObject* KPopupAccelManager::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod slot_0 = {"aboutToShow", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "aboutToShow()", &slot_0, QMetaData::Private }
    };
    metaObj = QMetaObject::new_metaobject(
        "KPopupAccelManager", parentObject,
        slot_tbl, 1,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KPopupAccelManager.setMetaObject( metaObj );
    return metaObj;
}

void* KPopupAccelManager::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KPopupAccelManager" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KPopupAccelManager::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: aboutToShow(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KPopupAccelManager::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KPopupAccelManager::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KPopupAccelManager::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 787 "/coolo/prod/kdelibs/kdecore/kaccelmanager.cpp" 2
# 55 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksavefile.cpp" 1
# 20 "/coolo/prod/kdelibs/kdecore/ksavefile.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 21 "/coolo/prod/kdelibs/kdecore/ksavefile.cpp" 2
# 41 "/coolo/prod/kdelibs/kdecore/ksavefile.cpp"
KSaveFile::KSaveFile(const QString &filename, int mode)
 : mTempFile(true)
{



   if (!checkAccess(filename, 2))
   {
      mTempFile.setError(13);
      return;
   }

   if (mTempFile.create(filename, QString::fromLatin1(".new"), mode))
   {
      mFileName = filename;
   }
   return;
}

KSaveFile::~KSaveFile()
{
   close();
}

QString
KSaveFile::name() const
{
   return mFileName;
}

void
KSaveFile::abort()
{
   mTempFile.unlink();
   mTempFile.close();
}

bool
KSaveFile::close()
{
   if (mTempFile.name().isEmpty())
      return false;
   if (mTempFile.close())
   {
      QDir dir;
      bool result = dir.rename( mTempFile.name(), mFileName);
      if ( result )
      {
         return true;
      }
      mTempFile.setError((*__errno_location ()));
   }


   mTempFile.unlink();
   return false;
}

static int
write_all(int fd, const char *buf, size_t len)
{
   while (len > 0)
   {
      int written = write(fd, buf, len);
      if (written < 0)
      {
          if ((*__errno_location ()) == 4)
             continue;
          return -1;
      }
      buf += written;
      len -= written;
   }
   return 0;
}

bool KSaveFile::backupFile( const QString& qFilename, const QString& backupDir,
                            const QString& backupExtension)
{
   QCString cFilename = QFile::encodeName(qFilename);
   const char *filename = cFilename.data();

   int fd = open( filename, 00);
   if (fd < 0)
      return false;

   struct stat buff;
   if ( fstat( fd, &buff) < 0 )
   {
      ::close( fd );
      return false;
   }

   QCString cBackup;
   if ( backupDir.isEmpty() )
       cBackup = cFilename;
   else
   {
       QCString nameOnly;
       int slash = cFilename.findRev('/');
       if (slash < 0)
           nameOnly = cFilename;
       else
           nameOnly = cFilename.mid(slash + 1);
       cBackup = QFile::encodeName(backupDir);
       if ( backupDir[backupDir.length()-1] != '/' )
           cBackup += '/';
       cBackup += nameOnly;
   }
   cBackup += QFile::encodeName(backupExtension);
   const char *backup = cBackup.data();
   int permissions = buff.st_mode & 07777;

   if ( stat( backup, &buff) == 0)
   {
      if ( unlink( backup ) != 0 )
      {
         ::close(fd);
         return false;
      }
   }

   mode_t old_umask = umask(0);
   int fd2 = open( backup, 01 | 0100 | 0200, permissions | 0200);
   umask(old_umask);

   if ( fd2 < 0 )
   {
      ::close(fd);
      return false;
   }

    char buffer[ 32*1024 ];

    while( 1 )
    {
       int n = ::read( fd, buffer, 32*1024 );
       if (n == -1)
       {
          if ((*__errno_location ()) == 4)
              continue;
          ::close(fd);
          ::close(fd2);
          return false;
       }
       if (n == 0)
          break;

       if (write_all( fd2, buffer, n))
       {
          ::close(fd);
          ::close(fd2);
          return false;
       }
    }

    ::close( fd );

    if (::close(fd2))
        return false;
    return true;
}
# 56 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/krandomsequence.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/krandomsequence.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/krandomsequence.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/krandomsequence.h"

class KRandomSequencePrivate;
class QGList;
# 37 "/coolo/prod/kdelibs/kdecore/krandomsequence.h"
class KRandomSequence
{
public:
# 53 "/coolo/prod/kdelibs/kdecore/krandomsequence.h"
  KRandomSequence( long lngSeed = 0 );




  virtual ~KRandomSequence();




  KRandomSequence(const KRandomSequence &a);




  KRandomSequence &operator=(const KRandomSequence &a);







  void setSeed( long lngSeed = 1 );






  double getDouble();







  unsigned long getLong(unsigned long max);






  bool getBool();






  void randomize(QGList *list);
# 128 "/coolo/prod/kdelibs/kdecore/krandomsequence.h"
  void modulate(int i);

private:
  void Draw();
  long m_lngSeed1;
  long m_lngSeed2;
  long m_lngShufflePos;

  static const int m_nShuffleTableSize;
  long *m_ShuffleArray;

  KRandomSequencePrivate *d;
};
# 24 "/coolo/prod/kdelibs/kdecore/krandomsequence.cpp" 2


const int KRandomSequence::m_nShuffleTableSize = 32;





KRandomSequence::KRandomSequence( long lngSeed1 )
{

  setSeed( lngSeed1 );



  m_ShuffleArray = new long [m_nShuffleTableSize];
}

KRandomSequence::~KRandomSequence()
{
  delete [] m_ShuffleArray;
}

KRandomSequence::KRandomSequence(const KRandomSequence &a)
{

  m_ShuffleArray = new long [m_nShuffleTableSize];
  *this = a;
}

KRandomSequence &
KRandomSequence::operator=(const KRandomSequence &a)
{
  m_lngSeed1 = a.m_lngSeed1;
  m_lngSeed2 = a.m_lngSeed2;
  m_lngShufflePos = a.m_lngShufflePos;
  memcpy(m_ShuffleArray, a.m_ShuffleArray, sizeof(long)*m_nShuffleTableSize);
  return *this;
}






void KRandomSequence::setSeed( long lngSeed1 )
{




  if ( lngSeed1 < 0 )
  {
    m_lngSeed1 = -1;
  }
  else if (lngSeed1 == 0)
  {
    m_lngSeed1 = -((KApplication::random() & ~1)+1);
  }
  else
  {
    m_lngSeed1 = -lngSeed1;
  }
}

static const long sMod1 = 2147483563;
static const long sMod2 = 2147483399;

void KRandomSequence::Draw()
{
  static const long sMM1 = sMod1 - 1;
  static const long sA1 = 40014;
  static const long sA2 = 40692;
  static const long sQ1 = 53668;
  static const long sQ2 = 52774;
  static const long sR1 = 12211;
  static const long sR2 = 3791;
  static const long sDiv = 1 + sMM1 / m_nShuffleTableSize;
# 110 "/coolo/prod/kdelibs/kdecore/krandomsequence.cpp"
  int j;
  long k;


  if ( m_lngSeed1 <= 0 )
  {
    m_lngSeed2 = m_lngSeed1;


    for ( j = m_nShuffleTableSize + 7; j >= 0; j-- )
    {
      k = m_lngSeed1 / sQ1;
      m_lngSeed1 = sA1 * ( m_lngSeed1 - k*sQ1) - k*sR1;
      if ( m_lngSeed1 < 0 )
      {
        m_lngSeed1 += sMod1;
      }

      if ( j < m_nShuffleTableSize )
      {
        m_ShuffleArray[j] = m_lngSeed1;
      }
    }

    m_lngShufflePos = m_ShuffleArray[0];
  }





  k = m_lngSeed1 / sQ1;
  m_lngSeed1 = sA1 * ( m_lngSeed1 - k*sQ1 ) - k*sR1;
  if ( m_lngSeed1 < 0 )
  {
    m_lngSeed1 += sMod1;
  }



  k = m_lngSeed2 / sQ2;
  m_lngSeed2 = sA2 * ( m_lngSeed2 - k*sQ2 ) - k*sR2;
  if ( m_lngSeed2 < 0 )
  {
    m_lngSeed2 += sMod2;
  }

  j = m_lngShufflePos / sDiv;
  m_lngShufflePos = m_ShuffleArray[j] - m_lngSeed2;
  m_ShuffleArray[j] = m_lngSeed1;

  if ( m_lngShufflePos < 1 )
  {
    m_lngShufflePos += sMM1;
  }
}

void
KRandomSequence::modulate(int i)
{
  m_lngSeed2 -= i;
  if ( m_lngSeed2 < 0 )
  {
    m_lngShufflePos += sMod2;
  }
  Draw();
  m_lngSeed1 -= i;
  if ( m_lngSeed1 < 0 )
  {
    m_lngSeed1 += sMod1;
  }
  Draw();
}

double
KRandomSequence::getDouble()
{
  static const double finalAmp = 1.0 / double( sMod1 );
  static const double epsilon = 1.2E-7;
  static const double maxRand = 1.0 - epsilon;
  double temp;
  Draw();

  if ( ( temp = finalAmp * m_lngShufflePos ) > maxRand )
  {

    return maxRand;
  }
  else
  {
    return temp;
  }
}

unsigned long
KRandomSequence::getLong(unsigned long max)
{
  Draw();

  return max ? (((unsigned long) m_lngShufflePos) % max) : 0;
}

bool
KRandomSequence::getBool()
{
  Draw();

  return (((unsigned long) m_lngShufflePos) & 1);
}

class KRandomSequenceList : public QGList
{
  friend class KRandomSequence;
public:
  KRandomSequenceList() : QGList() { }
  virtual void deleteItem( QPtrCollection::Item ) {}
};

void
KRandomSequence::randomize(QGList *_list)
{
  KRandomSequenceList *list = (KRandomSequenceList *)_list;
  KRandomSequenceList l;
  while(list->count())
     l.append(list->takeFirst());

  list->append(l.takeFirst());
  while(l.count())
     list->insertAt(getLong(list->count()+1), l.takeFirst());
}
# 57 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kstringhandler.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/kstringhandler.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 23 "/coolo/prod/kdelibs/kdecore/kstringhandler.cpp" 2



QString KStringHandler::word( const QString &text , uint pos )
{
    QStringList list = QStringList::split( " ", text , true );

    if ( pos < list.count() )
        return list[ pos ];

    return "";
}

QString KStringHandler::word( const QString &text , const char *range )
{





    QStringList list = QStringList::split( " ", text , true );
    QString tmp = "";
    QString r = range;

    if ( text.isEmpty() )
        return tmp;


    QRegExp reg;

    int at = 0;
    int pos = 0;
    int cnt = 0;

    if ( r.find(QRegExp("[0-9]+:[0-9]+")) != -1 )
    {
        at = r.find(":");
        pos = atoi( r.left(at).ascii() );
        cnt = atoi( r.remove(0,at+1).ascii() );
    }
    else if ( r.find(QRegExp(":+[0-9]+")) != -1 )
    {
        at = r.find(":");
        pos = 0;
        cnt = atoi( r.remove(0,at+1).ascii() );
    }
    else if ( r.find(QRegExp("[0-9]+:+")) != -1 )
    {
        at = r.find(":");
        pos = atoi( r.left(at).ascii() );
        cnt = list.count();
    }
    else if ( r.find(QRegExp("[0-9]+")) != -1 )
    {
        pos = atoi( r.ascii() );
        cnt = pos;
    }
    else
    {
        return tmp;
    }




    int wordsToExtract = cnt-pos+1;
    QStringList::Iterator it = list.at( pos);

    while ( (it != list.end()) && (wordsToExtract-- > 0))
    {
       tmp += *it;
       tmp += " ";
       it++;
    }

    return tmp.stripWhiteSpace();
}




QString KStringHandler::insword( const QString &text , const QString &word , uint pos )
{
    if ( text.isEmpty() )
        return word;

    if ( word.isEmpty() )
        return text;


    QStringList list = QStringList::split( " ", text, true );

    if ( pos >= list.count() )
        list.append( word );
    else
        list.insert( list.at(pos) , word );


    return list.join( " " );
}

QString KStringHandler::setword( const QString &text , const QString &word , uint pos )
{
    if ( text.isEmpty() )
        return word;

    if ( word.isEmpty() )
        return text;


    QStringList list = QStringList::split( " ", text, true );

    if ( pos >= list.count() )
        list.append( word );
    else
    {
        list.insert( list.remove( list.at(pos) ) , word );
    }


    return list.join( " " );
}

QString KStringHandler::remrange( const QString &text , const char *range )
{





    QStringList list = QStringList::split( " ", text , true );
    QString tmp = "";
    QString r = range;

    if ( text.isEmpty() )
        return tmp;


    QRegExp reg;

    int at = 0;
    int pos = 0;
    int cnt = 0;

    if ( r.find(QRegExp("[0-9]+:[0-9]+")) != -1 )
    {
        at = r.find(':');
        pos = atoi( r.left(at).ascii() );
        cnt = atoi( r.remove(0,at+1).ascii() );
    }
    else if ( r.find(QRegExp(":+[0-9]+")) != -1 )
    {
        at = r.find(':');
        pos = 0;
        cnt = atoi( r.remove(0,at+1).ascii() );
    }
    else if ( r.find(QRegExp("[0-9]+:+")) != -1 )
    {
        at = r.find(':');
        pos = atoi( r.left(at).ascii() );
        cnt = list.count();
    }
    else if ( r.find(QRegExp("[0-9]+")) != -1 )
    {
        pos = atoi( r.ascii() );
        cnt = pos;
    }
    else
    {
        return text;
    }




    int wordsToDelete = cnt-pos+1;
    QStringList::Iterator it = list.at( pos);

    while ( (it != list.end()) && (wordsToDelete-- > 0))
       it = list.remove( it );

    return list.join( " " );
}

QString KStringHandler::remword( const QString &text , uint pos )
{
    QString tmp = "";

    if ( text.isEmpty() )
        return tmp;


    QStringList list = QStringList::split( " ", text, true );

    if ( pos < list.count() )
        list.remove( list.at( pos ) );


    return list.join( " " );
}

QString KStringHandler::remword( const QString &text , const QString &word )
{
    QString tmp = "";

    if ( text.isEmpty() )
        return tmp;

    if ( word.isEmpty() )
        return text;


    QStringList list = QStringList::split( " ", text, true );

    QStringList::Iterator it = list.find(word);

    if (it != list.end())
       list.remove( it );


    return list.join( " " );
}




QString KStringHandler::capwords( const QString &text )
{
    QString tmp = "";

    if ( text.isEmpty() )
        return tmp;

    QStringList list = QStringList::split( " ", text, true );

    return capwords( QStringList::split( " ", text, true )).join( " " );
}

QStringList KStringHandler::capwords( const QStringList &list )
{
    QStringList tmp;
    QString word;

    if ( list.count() == 0 )
        return tmp;

    for ( QStringList::ConstIterator it= list.begin();
          it != list.end();
          it++)
    {
        word = *it;
        word = word.left(1).upper() + word.remove(0,1);

        tmp.append( word );
    }

    return tmp;
}




QString KStringHandler::reverse( const QString &text )
{
    QString tmp;

    if ( text.isEmpty() )
        return tmp;

    QStringList list;
    list = QStringList::split( " ", text, true );
    list = reverse( list );

    return list.join( " " );
}

QStringList KStringHandler::reverse( const QStringList &list )
{
    QStringList tmp;

    if ( list.count() == 0 )
        return tmp;

    for ( QStringList::ConstIterator it= list.begin();
          it != list.end();
          it++)
        tmp.prepend( *it );

    return tmp;
}




QString KStringHandler::ljust( const QString &text , uint width )
{
    QString tmp = text;
    tmp = tmp.stripWhiteSpace();

    if ( tmp.length() >= width )
        return tmp;

    for ( uint pos = tmp.length() ; pos < width ; pos++ )
        tmp.append(" ");

    return tmp;
}

QString KStringHandler::rjust( const QString &text , uint width )
{
    QString tmp = text;
    tmp = tmp.stripWhiteSpace();

    if ( tmp.length() >= width )
        return tmp;

    for ( uint pos = tmp.length() ; pos < width ; pos++ )
        tmp.prepend(" ");

    return tmp;
}

QString KStringHandler::center( const QString &text , uint width )
{




    QString tmp = text;
    tmp = tmp.stripWhiteSpace();

    if ( tmp.length() >= width )
        return tmp;

    bool left = false;

    for ( uint pos = tmp.length() ; pos < width ; pos++ )
    {
        if ( left )
            tmp.prepend(" ");
        else
            tmp.append(" ");


        left = !left;
    }

    return tmp;
}

QString KStringHandler::lsqueeze( const QString & str, uint maxlen )
{
  if (str.length() > maxlen) {
    int part = maxlen-3;
    return QString("..." + str.right(part));
  }
  else return str;
}

QString KStringHandler::csqueeze( const QString & str, uint maxlen )
{
  if (str.length() > maxlen && maxlen > 3) {
    int part = (maxlen-3)/2;
    return QString(str.left(part) + "..." + str.right(part));
  }
  else return str;
}

QString KStringHandler::rsqueeze( const QString & str, uint maxlen )
{
  if (str.length() > maxlen) {
    int part = maxlen-3;
    return QString(str.left(part) + "...");
  }
  else return str;
}

QString KStringHandler::lEmSqueeze(const QString &name, const QFontMetrics& fontMetrics, uint maxlen)
{
  return lPixelSqueeze(name, fontMetrics, fontMetrics.maxWidth() * maxlen);
}

static inline int emSqueezeLimit(int delta, int min, int max)
{
  if (delta < min) return min;
  if (delta > max) return max;
  return delta;
}

QString KStringHandler::lPixelSqueeze(const QString& name, const QFontMetrics& fontMetrics, uint maxPixels)
{
  uint nameWidth = fontMetrics.width(name);

  if (maxPixels < nameWidth)
  {
    QString tmp = name;
    const uint em = fontMetrics.maxWidth();
    maxPixels -= fontMetrics.width("...");

    while (maxPixels < nameWidth && !tmp.isEmpty())
    {
      int delta = (nameWidth - maxPixels) / em;
      delta = emSqueezeLimit(delta, 1, delta);

      tmp.remove(0, delta);
      nameWidth = fontMetrics.width(tmp);
    }

    return ("..." + tmp);
  }

  return name;
}

QString KStringHandler::cEmSqueeze(const QString& name, const QFontMetrics& fontMetrics, uint maxlen)
{
  return cPixelSqueeze(name, fontMetrics, fontMetrics.maxWidth() * maxlen);
}

QString KStringHandler::cPixelSqueeze(const QString& name, const QFontMetrics& fontMetrics, uint maxPixels)
{
  uint nameWidth = fontMetrics.width(name);

  if (maxPixels < nameWidth)
  {
    QString tmp = name;
    const uint em = fontMetrics.maxWidth();
    maxPixels -= fontMetrics.width("...");

    while (maxPixels < nameWidth && !tmp.isEmpty())
    {
      int length = tmp.length();
      int delta = (nameWidth - maxPixels) / em;
      delta = emSqueezeLimit(delta, 1, length) ;

      tmp.remove((length / 2) - (delta / 2), delta);
      nameWidth = fontMetrics.width(tmp);
    }

    return tmp.insert((tmp.length() + 1) / 2, "...");
  }

  return name;
}

QString KStringHandler::rEmSqueeze(const QString& name, const QFontMetrics& fontMetrics, uint maxlen)
{
  return rPixelSqueeze(name, fontMetrics, fontMetrics.maxWidth() * maxlen);
}

QString KStringHandler::rPixelSqueeze(const QString& name, const QFontMetrics& fontMetrics, uint maxPixels)
{
  uint nameWidth = fontMetrics.width(name);

  if (maxPixels < nameWidth)
  {
    QString tmp = name;
    const uint em = fontMetrics.maxWidth();
    maxPixels -= fontMetrics.width("...");

    while (maxPixels < nameWidth && !tmp.isEmpty())
    {
      int length = tmp.length();
      int delta = (nameWidth - maxPixels) / em;
      delta = emSqueezeLimit(delta, 1, length) ;

      tmp.remove(length - delta, delta);
      nameWidth = fontMetrics.width(tmp);
    }

    return (tmp + "...");
  }

  return name;
}



bool KStringHandler::matchFileName( const QString& filename, const QString& pattern )
{
   int len = filename.length();
   int pattern_len = pattern.length();

   if (!pattern_len)
      return false;


   if ( pattern[ pattern_len - 1 ] == '*' && len + 1 >= pattern_len ) {
      if ( pattern[ 0 ] == '*' )
      {
         return filename.find(pattern.mid(1, pattern_len - 2)) != -1;
      }

      const QChar *c1 = pattern.unicode();
      const QChar *c2 = filename.unicode();
      int cnt = 1;
      while ( cnt < pattern_len && *c1++ == *c2++ )
         ++cnt;
      return cnt == pattern_len;
   }


   if ( pattern[ 0 ] == '*' && len + 1 >= pattern_len )
   {
     const QChar *c1 = pattern.unicode() + pattern_len - 1;
     const QChar *c2 = filename.unicode() + len - 1;
     int cnt = 1;
     while ( cnt < pattern_len && *c1-- == *c2-- )
        ++cnt;
     return cnt == pattern_len;
  }


   return ( filename == pattern );
}

  QStringList
KStringHandler::perlSplit(const QString & sep, const QString & s, uint max)
{
  bool ignoreMax = 0 == max;

  QStringList l;

  int searchStart = 0;

  int tokenStart = s.find(sep, searchStart);

  while (-1 != tokenStart && (ignoreMax || l.count() < max - 1))
  {
    if (!s.mid(searchStart, tokenStart - searchStart).isEmpty())
      l << s.mid(searchStart, tokenStart - searchStart);

    searchStart = tokenStart + sep.length();
    tokenStart = s.find(sep, searchStart);
  }

  if (!s.mid(searchStart, s.length() - searchStart).isEmpty())
    l << s.mid(searchStart, s.length() - searchStart);

  return l;
}

  QStringList
KStringHandler::perlSplit(const QChar & sep, const QString & s, uint max)
{
  bool ignoreMax = 0 == max;

  QStringList l;

  int searchStart = 0;

  int tokenStart = s.find(sep, searchStart);

  while (-1 != tokenStart && (ignoreMax || l.count() < max - 1))
  {
    if (!s.mid(searchStart, tokenStart - searchStart).isEmpty())
      l << s.mid(searchStart, tokenStart - searchStart);

    searchStart = tokenStart + 1;
    tokenStart = s.find(sep, searchStart);
  }

  if (!s.mid(searchStart, s.length() - searchStart).isEmpty())
    l << s.mid(searchStart, s.length() - searchStart);

  return l;
}

  QStringList
KStringHandler::perlSplit(const QRegExp & sep, const QString & s, uint max)
{
  bool ignoreMax = 0 == max;

  QStringList l;

  int searchStart = 0;
  int tokenStart = sep.search(s, searchStart);
  int len = sep.matchedLength();

  while (-1 != tokenStart && (ignoreMax || l.count() < max - 1))
  {
    if (!s.mid(searchStart, tokenStart - searchStart).isEmpty())
      l << s.mid(searchStart, tokenStart - searchStart);

    searchStart = tokenStart + len;
    tokenStart = sep.search(s, searchStart);
    len = sep.matchedLength();
  }

  if (!s.mid(searchStart, s.length() - searchStart).isEmpty())
    l << s.mid(searchStart, s.length() - searchStart);

  return l;
}

 QString
KStringHandler::tagURLs( const QString& text )
{
               QRegExp urlEx("(www\\.(?!\\.)|(f|ht)tp(|s)://)[\\d\\w\\./,:_~\\?=&;#@\\-\\+\\%]+[\\d\\w/]");

    QString richText( text );
    int urlPos = 0, urlLen;
    while ((urlPos = urlEx.search(richText, urlPos)) >= 0)
    {
        urlLen = urlEx.matchedLength();
        QString href = richText.mid( urlPos, urlLen );

        if((urlPos > 0) && richText[urlPos-1].isLetterOrNumber()){
            urlPos++;
            continue;
        }

        QString anchor = "<a href=\"" + href + "\">" + href + "</a>";
        richText.replace( urlPos, urlLen, anchor );


        urlPos += anchor.length();
    }
    return richText;
}

QString KStringHandler::obscure( const QString &str )
{
  QString result;
  for ( uint i = 0; i < str.length(); ++i )
    result += ( str[ i ].unicode() < 0x20 ) ? str[ i ] :
        QChar( 0x1001F - str[ i ].unicode() );

  return result;
}
# 58 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcompletion.cpp" 1
# 24 "/coolo/prod/kdelibs/kdecore/kcompletion.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/knotifyclient.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"



class KInstance;
# 77 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
namespace KNotifyClient
{
    struct InstancePrivate;
        class InstanceStack;
# 94 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
    class Instance
    {
    public:





        Instance(KInstance *instance);




        ~Instance();





        bool useSystemBell() const;




        static KInstance *current();





        static Instance *currentInstance();

    private:
                static InstanceStack *instances();
                InstancePrivate *d;
                static InstanceStack *s_instances;
    };





        enum {
                Default = -1,
                None = 0,
                Sound = 1,
                Messagebox = 2,
                Logfile = 4,
                Stderr = 8,
                PassivePopup = 16,
                Execute = 32,
                Taskbar = 64
        };




        enum {
                Notification=1,
                Warning=2,
                Error=4,
                Catastrophe=8
        };




        enum StandardEvent {
                cannotOpenFile,
                notification,
                warning,
                fatalError,
                catastrophe
        };
# 176 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        bool startDaemon();
# 186 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        int event(const QString &message, const QString &text=QString::null) ;
# 195 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        int event( StandardEvent event, const QString& text=QString::null ) ;
# 207 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        int userEvent(const QString &text=QString::null, int present=Default, int level=Default,
                              const QString &sound=QString::null, const QString &file=QString::null) ;
# 227 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        int event( int winId, const QString& message,
                    const QString& text = QString::null );
# 241 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        int event( int winId, StandardEvent event,
                    const QString& text = QString::null );
# 258 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        int userEvent(int winId, const QString &text=QString::null, int present=Default, int level=Default,
                              const QString &sound=QString::null, const QString &file=QString::null);
# 269 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        void beep(const QString& reason=QString::null);
# 280 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        int getPresentation(const QString &eventname);
# 290 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        QString getFile(const QString &eventname, int present);
# 300 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        int getDefaultPresentation(const QString &eventname);
# 311 "/coolo/prod/kdelibs/kdecore/knotifyclient.h"
        QString getDefaultFile(const QString &eventname, int present);





        KInstance * instance();
}
# 25 "/coolo/prod/kdelibs/kdecore/kcompletion.cpp" 2




# 1 "/coolo/prod/kdelibs/kdecore/kcompletion.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
# 32 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
# 1 "/coolo/prod/kdelibs/kdecore/ksortablevaluelist.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/ksortablevaluelist.h"
# 31 "/coolo/prod/kdelibs/kdecore/ksortablevaluelist.h"
template<class T, class Key = int> class KSortableItem : public QPair<Key,T>
{
public:





    KSortableItem( Key i, const T& t ) : QPair<Key, T>( i, t ) {}




    KSortableItem( const KSortableItem<T, Key> &rhs )
        : QPair<Key,T>( rhs.first, rhs.second ) {}




    KSortableItem() {}




    KSortableItem<T, Key> &operator=( const KSortableItem<T, Key>& i ) {
        this->first = i.first;
        this->second = i.second;
        return *this;
    }






    bool operator> ( const KSortableItem<T, Key>& i2 ) const {
        return (i2.first < this->first);
    }




    bool operator< ( const KSortableItem<T, Key>& i2 ) const {
        return (this->first < i2.first);
    }




    bool operator>= ( const KSortableItem<T, Key>& i2 ) const {
        return (this->first >= i2.first);
    }




    bool operator<= ( const KSortableItem<T, Key>& i2 ) const {
        return !(i2.first < this->first);
    }




    bool operator== ( const KSortableItem<T, Key>& i2 ) const {
        return (this->first == i2.first);
    }




    bool operator!= ( const KSortableItem<T, Key>& i2 ) const {
        return (this->first != i2.first);
    }




    T& value() { return this->second; }




    const T& value() const { return this->second; }




    Key index() const { return this->first; }
};
# 128 "/coolo/prod/kdelibs/kdecore/ksortablevaluelist.h"
template <class T, class Key = int>
class KSortableValueList : public QValueList<KSortableItem<T, Key> >
{
public:





    void insert( Key i, const T& t ) {
        QValueList<KSortableItem<T, Key> >::append( KSortableItem<T, Key>( i, t ) );
    }






    T& operator[]( Key i ) {
        return QValueList<KSortableItem<T, Key> >::operator[]( i ).value();
    }





    const T& operator[]( Key i ) const {
        return QValueList<KSortableItem<T, Key> >::operator[]( i ).value();
    }




    void sort() {
        qHeapSort( *this );
    }
};
# 33 "/coolo/prod/kdelibs/kdecore/kcompletion.h" 2


class KCompTreeNode;
class KCompletionPrivate;
class KCompletionBasePrivate;
class KCompletionMatchesWrapper;
class KCompletionMatches;
class QPopupMenu;
# 131 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
class KCompletion : public QObject
{
   
   
   
   
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:




    enum CompOrder { Sorted,
                     Insertion,
                     Weighted
    };




    KCompletion();






    virtual ~KCompletion();
# 183 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual QString makeCompletion( const QString& string );
# 193 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    QStringList substringCompletion( const QString& string ) const;
# 204 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    QString previousMatch();
# 215 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    QString nextMatch();







    virtual const QString& lastMatch() const { return myLastMatch; }
# 243 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    QStringList items() const;
# 254 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setCompletionMode( KGlobalSettings::Completion mode );
# 263 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    KGlobalSettings::Completion completionMode() const {
        return myCompletionMode;
    }
# 287 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setOrder( CompOrder order );






    CompOrder order() const { return myOrder; }
# 303 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setIgnoreCase( bool ignoreCase );







    bool ignoreCase() const { return myIgnoreCase; }







    QStringList allMatches();






    QStringList allMatches( const QString& string );
# 340 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    KCompletionMatches allWeightedMatches();






    KCompletionMatches allWeightedMatches( const QString& string );
# 362 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setEnableSounds( bool enable ) { myBeep = enable; }
# 371 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    bool isSoundsEnabled() const { return myBeep; }






    bool hasMultipleMatches() const { return myHasMultipleMatches; }






    void enableSounds() { myBeep = true; }





    void disableSounds() { myBeep = false; }


public :






    void slotMakeCompletion( const QString& string ) {
        (void) makeCompletion( string );
    }






    void slotPreviousMatch() {
        (void) previousMatch();
    }






    void slotNextMatch() {
        (void) nextMatch();
    }






    void insertItems( const QStringList& items );
# 445 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setItems( const QStringList& list);







    void addItem( const QString& item);
# 466 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    void addItem( const QString& item, uint weight );







    void removeItem( const QString& item);




    virtual void clear();


protected:






    void match( const QString& item);







    void matches( const QStringList& matchlist);






    void multipleMatches();

protected:
# 520 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void postProcessMatch( QString *match ) const { (void)match; }
# 532 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void postProcessMatches( QStringList * matches ) const { (void)matches;}
# 544 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void postProcessMatches( KCompletionMatches * matches ) const {(void)matches;}

private:
    void addWeightedItem( const QString& );
    QString findCompletion( const QString& string );
    void findAllCompletions( const QString&,
                                        KCompletionMatchesWrapper *matches,
                                        bool& hasMultipleMatches ) const;

    void extractStringsFromNode( const KCompTreeNode *,
                                 const QString& beginning,
                                 KCompletionMatchesWrapper *matches,
                                 bool addWeight = false ) const;
    void extractStringsFromNodeCI( const KCompTreeNode *,
                                   const QString& beginning,
                                   const QString& restString,
                                   KCompletionMatchesWrapper *matches) const;

    enum BeepMode { NoMatch, PartialMatch, Rotation };
    void doBeep( BeepMode ) const;

    KGlobalSettings::Completion myCompletionMode;

    CompOrder myOrder;
    QString myLastString;
    QString myLastMatch;
    QString myCurrentMatch;
    KCompTreeNode * myTreeRoot;
    QStringList myRotations;
    bool myBeep;
    bool myIgnoreCase;
    bool myHasMultipleMatches;
    uint myRotationIndex;


protected:
    virtual void virtual_hook( int id, void* data );
private:
    KCompletionPrivate *d;
};


typedef KSortableValueList<QString> KCompletionMatchesList;
class KCompletionMatchesPrivate;
# 607 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
class KCompletionMatches : public KCompletionMatchesList
{
public:
    KCompletionMatches( bool sort );



    KCompletionMatches( const KCompletionMatchesWrapper& matches );
    ~KCompletionMatches();




    void removeDuplicates();






    QStringList list( bool sort = true ) const;





    bool sorting() const {
        return _sorting;
    }
private:
    bool _sorting;
    KCompletionMatchesPrivate* d;
};
# 655 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
class KCompletionBase
{
public:





    enum KeyBindingType {



        TextCompletion,



        PrevCompletionMatch,



        NextCompletionMatch,



        SubstringCompletion
    };



    typedef QMap<KeyBindingType, KShortcut> KeyBindingMap;




    KCompletionBase();




    virtual ~KCompletionBase();
# 717 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    KCompletion* completionObject( bool hsig = true );
# 741 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setCompletionObject( KCompletion* compObj, bool hsig = true );
# 755 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setHandleSignals( bool handle );
# 767 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    bool isCompletionObjectAutoDeleted() const {
        return m_delegate ? m_delegate->isCompletionObjectAutoDeleted() : m_bAutoDelCompObj;
    }
# 780 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    void setAutoDeleteCompletionObject( bool autoDelete ) {
        if ( m_delegate )
            m_delegate->setAutoDeleteCompletionObject( autoDelete );
        else
            m_bAutoDelCompObj = autoDelete;
    }
# 807 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    void setEnableSignals( bool enable ) {
        if ( m_delegate )
            m_delegate->setEnableSignals( enable );
        else
            m_bEmitSignals = enable;
    }






    bool handleSignals() const { return m_delegate ? m_delegate->handleSignals() : m_bHandleSignals; }






    bool emitSignals() const { return m_delegate ? m_delegate->emitSignals() : m_bEmitSignals; }
# 848 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setCompletionMode( KGlobalSettings::Completion mode );
# 858 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    KGlobalSettings::Completion completionMode() const {
        return m_delegate ? m_delegate->completionMode() : m_iCompletionMode;
    }
# 892 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    bool setKeyBinding( KeyBindingType item , const KShortcut& key );
# 906 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    const KShortcut& getKeyBinding( KeyBindingType item ) const {
        return m_delegate ? m_delegate->getKeyBinding( item ) : m_keyMap[ item ];
    }
# 921 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    void useGlobalKeyBindings();
# 937 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    virtual void setCompletedText( const QString& text ) = 0;






    virtual void setCompletedItems( const QStringList& items ) = 0;
# 957 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    KCompletion* compObj() const { return m_delegate ? m_delegate->compObj() : (KCompletion*) m_pCompObj; }

protected:
# 968 "/coolo/prod/kdelibs/kdecore/kcompletion.h"
    KeyBindingMap getKeyBindings() const { return m_delegate ? m_delegate->getKeyBindings() : m_keyMap; }






    void setDelegate( KCompletionBase *delegate );






    KCompletionBase *delegate() const { return m_delegate; }

private:



    void setup( bool, bool, bool );



    bool m_bAutoDelCompObj;


    bool m_bHandleSignals;

    bool m_bEmitSignals;

    KGlobalSettings::Completion m_iCompletionMode;

    QGuardedPtr<KCompletion> m_pCompObj;

    KeyBindingMap m_keyMap;

    KCompletionBase *m_delegate;


protected:
    virtual void virtual_hook( int id, void* data );
private:
    KCompletionBasePrivate *d;
};
# 30 "/coolo/prod/kdelibs/kdecore/kcompletion.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcompletion_private.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kcompletion_private.h"




class KCompTreeNode;






class KCompTreeNodeList
{
public:
    KCompTreeNodeList() : first(0), last(0), m_count(0) {}
    KCompTreeNode *begin() const { return first; }
    KCompTreeNode *end() const { return last; }

    KCompTreeNode *at(uint index) const;
    void append(KCompTreeNode *item);
    void prepend(KCompTreeNode *item);
    void insert(KCompTreeNode *after, KCompTreeNode *item);
    KCompTreeNode *remove(KCompTreeNode *item);
    uint count() const { return m_count; }

private:
    KCompTreeNode *first, *last;
    uint m_count;
};

typedef KCompTreeNodeList KCompTreeChildren;
# 84 "/coolo/prod/kdelibs/kdecore/kcompletion_private.h"
class KCompTreeNode : public QChar
{
public:
    KCompTreeNode() : QChar(), myWeight(0) {}
    KCompTreeNode( const QChar& ch, uint weight = 0 )
        : QChar( ch ),
          myWeight( weight ) {}
    ~KCompTreeNode();

    void * operator new( size_t s ) {
      return alloc.allocate( s );
    }
    void operator delete( void * s ) {
      alloc.deallocate( s );
    }



    inline KCompTreeNode * find( const QChar& ch ) const {
      KCompTreeNode * cur = myChildren.begin();
      while (cur && (*cur != ch)) cur = cur->next;
      return cur;
    }
    KCompTreeNode * insert( const QChar&, bool sorted );
    void remove( const QString& );

    inline int childrenCount() const { return myChildren.count(); }


    inline void confirm() { myWeight++; }
    inline void confirm(uint w) { myWeight += w; }
    inline void decline() { myWeight--; }
    inline uint weight() const { return myWeight; }

    inline const KCompTreeChildren * children() const {
        return &myChildren;
    }
    inline const KCompTreeNode * childAt(int index) const {
        return myChildren.at(index);
    }
    inline const KCompTreeNode * firstChild() const {
        return myChildren.begin();
    }
    inline const KCompTreeNode * lastChild() const {
        return myChildren.end();
    }




    KCompTreeNode *next;
private:
    uint myWeight;
    KCompTreeNodeList myChildren;
    static KZoneAllocator alloc;
};




typedef KSortableValueList<QString> KCompletionMatchesList;




class KCompletionMatchesWrapper
{
public:
    KCompletionMatchesWrapper( bool sort = false )
        : sortedList( sort ? new KCompletionMatchesList : 0L ),
          dirty( false )
    {}
    ~KCompletionMatchesWrapper() {
        delete sortedList;
    }

    void setSorting( bool sort ) {
        if ( sort && !sortedList )
            sortedList = new KCompletionMatchesList;
        else if ( !sort ) {
            delete sortedList;
            sortedList = 0L;
        }
        stringList.clear();
        dirty = false;
    }

    bool sorting() const {
        return sortedList != 0L;
    }

    void append( int i, const QString& string ) {
        if ( sortedList )
            sortedList->insert( i, string );
        else
            stringList.append( string );
        dirty = true;
    }

    void clear() {
        if ( sortedList )
            sortedList->clear();
        stringList.clear();
        dirty = false;
    }

    uint count() const {
        if ( sortedList )
            return sortedList->count();
        return stringList.count();
    }

    bool isEmpty() const {
        return count() == 0;
    }

    QString first() const {
        return list().first();
    }

    QString last() const {
        return list().last();
    }

    QStringList list() const;

    mutable QStringList stringList;
    KCompletionMatchesList *sortedList;
    mutable bool dirty;
};
# 31 "/coolo/prod/kdelibs/kdecore/kcompletion.cpp" 2


class KCompletionPrivate
{
public:


    KCompletionMatchesWrapper matches;
};

KCompletion::KCompletion()
{
    d = new KCompletionPrivate;

    myCompletionMode = KGlobalSettings::completionMode();
    myTreeRoot = new KCompTreeNode;
    myBeep = true;
    myIgnoreCase = false;
    myHasMultipleMatches = false;
    myRotationIndex = 0;
    setOrder( Insertion );
}

KCompletion::~KCompletion()
{
    delete d;
    delete myTreeRoot;
}

void KCompletion::setOrder( CompOrder order )
{
    myOrder = order;
    d->matches.setSorting( order == Weighted );
}

void KCompletion::setIgnoreCase( bool ignoreCase )
{
    myIgnoreCase = ignoreCase;
}

void KCompletion::setItems( const QStringList& items )
{
    clear();
    insertItems( items );
}


void KCompletion::insertItems( const QStringList& items )
{
    bool weighted = (myOrder == Weighted);
    QStringList::ConstIterator it;
    if ( weighted ) {
        for ( it = items.begin(); it != items.end(); ++it )
            addWeightedItem( *it );
    }
    else {
        for ( it = items.begin(); it != items.end(); ++it )
            addItem( *it, 0 );
    }
}


QStringList KCompletion::items() const
{
    KCompletionMatchesWrapper list;
    bool addWeight = (myOrder == Weighted);
    extractStringsFromNode( myTreeRoot, QString::null, &list, addWeight );

    return list.list();
}


void KCompletion::addItem( const QString& item )
{
    d->matches.clear();
    myRotationIndex = 0;
    myLastString = QString::null;

    addItem( item, 0 );
}

void KCompletion::addItem( const QString& item, uint weight )
{
    if ( item.isEmpty() )
        return;

    KCompTreeNode *node = myTreeRoot;
    uint len = item.length();

    bool sorted = (myOrder == Sorted);
    bool weighted = ((myOrder == Weighted) && weight > 1);




    for ( uint i = 0; i < len; i++ ) {
        node = node->insert( item.at(i), sorted );
        if ( weighted )
            node->confirm( weight -1 );
    }


    node = node->insert( 0x0, true );
    if ( weighted )
        node->confirm( weight -1 );

}

void KCompletion::addWeightedItem( const QString& item )
{
    if ( myOrder != Weighted ) {
        addItem( item, 0 );
        return;
    }

    uint len = item.length();
    uint weight = 0;


    int index = item.findRev(':');
    if ( index > 0 ) {
        bool ok;
        weight = item.mid( index + 1 ).toUInt( &ok );
        if ( !ok )
            weight = 0;

        len = index;
    }

    addItem( item.left( len ), weight );
    return;
}


void KCompletion::removeItem( const QString& item )
{
    d->matches.clear();
    myRotationIndex = 0;
    myLastString = QString::null;

    myTreeRoot->remove( item );
}


void KCompletion::clear()
{
    d->matches.clear();
    myRotationIndex = 0;
    myLastString = QString::null;

    delete myTreeRoot;
    myTreeRoot = new KCompTreeNode;
}


QString KCompletion::makeCompletion( const QString& string )
{
    if ( myCompletionMode == KGlobalSettings::CompletionNone )
        return QString::null;



    d->matches.clear();
    myRotationIndex = 0;
    myHasMultipleMatches = false;
    myLastMatch = myCurrentMatch;



    if ( myCompletionMode == KGlobalSettings::CompletionShell &&
         string == myLastString ) {




        findAllCompletions( string, &d->matches, myHasMultipleMatches );
        QStringList l = d->matches.list();
        postProcessMatches( &l );
        matches( l );

        if ( l.isEmpty() )
            doBeep( NoMatch );

        return QString::null;
    }

    QString completion;

    if ( myCompletionMode == KGlobalSettings::CompletionPopup ||
         myCompletionMode == KGlobalSettings::CompletionPopupAuto ) {
        findAllCompletions( string, &d->matches, myHasMultipleMatches );
        if ( !d->matches.isEmpty() )
            completion = d->matches.first();
    }
    else
        completion = findCompletion( string );

    if ( myHasMultipleMatches )
        multipleMatches();

    myLastString = string;
    myCurrentMatch = completion;

    postProcessMatch( &completion );

    if ( !string.isEmpty() ) {

        match( completion );
    }

    if ( completion.isNull() )
        doBeep( NoMatch );

    return completion;
}


QStringList KCompletion::substringCompletion( const QString& string ) const
{

    bool sorted = (myOrder == Weighted);
    KCompletionMatchesWrapper allItems( sorted );
    extractStringsFromNode( myTreeRoot, QString::null, &allItems, false );

    QStringList list = allItems.list();



    if ( list.isEmpty() ) {
        doBeep( NoMatch );
        return list;
    }

    if ( string.isEmpty() ) {
        postProcessMatches( &list );
        return list;
    }

    QStringList matches;
    QStringList::ConstIterator it = list.begin();

    for( ; it != list.end(); ++it ) {
        QString item = *it;
        if ( item.find( string, 0, false ) != -1 ) {
            postProcessMatch( &item );
            matches.append( item );
        }
    }

    if ( matches.isEmpty() )
        doBeep( NoMatch );

    return matches;
}


void KCompletion::setCompletionMode( KGlobalSettings::Completion mode )
{
    myCompletionMode = mode;
}


QStringList KCompletion::allMatches()
{



    KCompletionMatchesWrapper matches( myOrder == Weighted );
    bool dummy;
    findAllCompletions( myLastString, &matches, dummy );
    QStringList l = matches.list();
    postProcessMatches( &l );
    return l;
}

KCompletionMatches KCompletion::allWeightedMatches()
{



    KCompletionMatchesWrapper matches( myOrder == Weighted );
    bool dummy;
    findAllCompletions( myLastString, &matches, dummy );
    KCompletionMatches ret( matches );
    postProcessMatches( &ret );
    return ret;
}

QStringList KCompletion::allMatches( const QString &string )
{
    KCompletionMatchesWrapper matches( myOrder == Weighted );
    bool dummy;
    findAllCompletions( string, &matches, dummy );
    QStringList l = matches.list();
    postProcessMatches( &l );
    return l;
}

KCompletionMatches KCompletion::allWeightedMatches( const QString &string )
{
    KCompletionMatchesWrapper matches( myOrder == Weighted );
    bool dummy;
    findAllCompletions( string, &matches, dummy );
    KCompletionMatches ret( matches );
    postProcessMatches( &ret );
    return ret;
}





QString KCompletion::nextMatch()
{
    QString completion;
    myLastMatch = myCurrentMatch;

    if ( d->matches.isEmpty() ) {
        findAllCompletions( myLastString, &d->matches, myHasMultipleMatches );
        completion = d->matches.first();
        myCurrentMatch = completion;
        myRotationIndex = 0;
        postProcessMatch( &completion );
        match( completion );
        return completion;
    }

    QStringList matches = d->matches.list();
    myLastMatch = matches[ myRotationIndex++ ];

    if ( myRotationIndex == matches.count() -1 )
        doBeep( Rotation );

    else if ( myRotationIndex == matches.count() )
        myRotationIndex = 0;

    completion = matches[ myRotationIndex ];
    myCurrentMatch = completion;
    postProcessMatch( &completion );
    match( completion );
    return completion;
}



QString KCompletion::previousMatch()
{
    QString completion;
    myLastMatch = myCurrentMatch;

    if ( d->matches.isEmpty() ) {
        findAllCompletions( myLastString, &d->matches, myHasMultipleMatches );
        completion = d->matches.last();
        myCurrentMatch = completion;
        myRotationIndex = 0;
        postProcessMatch( &completion );
        match( completion );
        return completion;
    }

    QStringList matches = d->matches.list();
    myLastMatch = matches[ myRotationIndex ];
    if ( myRotationIndex == 1 )
        doBeep( Rotation );

    else if ( myRotationIndex == 0 )
        myRotationIndex = matches.count();

    myRotationIndex--;

    completion = matches[ myRotationIndex ];
    myCurrentMatch = completion;
    postProcessMatch( &completion );
    match( completion );
    return completion;
}




QString KCompletion::findCompletion( const QString& string )
{
    QChar ch;
    QString completion;
    const KCompTreeNode *node = myTreeRoot;


    for( uint i = 0; i < string.length(); i++ ) {
        ch = string.at( i );
        node = node->find( ch );

        if ( node )
            completion += ch;
        else
            return QString::null;
    }





    while ( node->childrenCount() == 1 ) {
        node = node->firstChild();
        if ( !node->isNull() )
            completion += *node;
    }


    if ( node && node->childrenCount() > 1 ) {
        myHasMultipleMatches = true;

        if ( myCompletionMode == KGlobalSettings::CompletionAuto ) {
            myRotationIndex = 1;
            if (myOrder != Weighted) {
                while ( (node = node->firstChild()) ) {
                    if ( !node->isNull() )
                        completion += *node;
                    else
                        break;
                }
            }
            else {



                const KCompTreeNode* temp_node = 0L;
                while(1) {
                    int count = node->childrenCount();
                    temp_node = node->firstChild();
                    uint weight = temp_node->weight();
                    const KCompTreeNode* hit = temp_node;
                    for( int i = 1; i < count; i++ ) {
                        temp_node = node->childAt(i);
                        if( temp_node->weight() > weight ) {
                            hit = temp_node;
                            weight = hit->weight();
                        }
                    }

                    if ( hit->isNull() )
                        break;

                    node = hit;
                    completion += *node;
                }
            }
        }

        else
            doBeep( PartialMatch );
    }

    return completion;
}


void KCompletion::findAllCompletions(const QString& string,
                                     KCompletionMatchesWrapper *matches,
                                     bool& hasMultipleMatches) const
{


    if ( string.isEmpty() )
        return;

    if ( myIgnoreCase ) {
        extractStringsFromNodeCI( myTreeRoot, QString::null, string, matches );
        hasMultipleMatches = (matches->count() > 1);
        return;
    }

    QChar ch;
    QString completion;
    const KCompTreeNode *node = myTreeRoot;


    for( uint i = 0; i < string.length(); i++ ) {
        ch = string.at( i );
        node = node->find( ch );

        if ( node )
            completion += ch;
        else
            return;
    }





    while ( node->childrenCount() == 1 ) {
        node = node->firstChild();
        if ( !node->isNull() )
            completion += *node;

    }



    if ( node->childrenCount() == 0 )
        matches->append( node->weight(), completion );

    else {


        hasMultipleMatches = true;
        extractStringsFromNode( node, completion, matches );
    }
}


void KCompletion::extractStringsFromNode( const KCompTreeNode *node,
                                          const QString& beginning,
                                          KCompletionMatchesWrapper *matches,
                                          bool addWeight ) const
{
    if ( !node || !matches )
        return;


    const KCompTreeChildren *list = node->children();
    QString string;
    QString w;


    for ( KCompTreeNode *cur = list->begin(); cur ; cur = cur->next) {
        string = beginning;
        node = cur;
        if ( !node->isNull() )
            string += *node;

        while ( node && node->childrenCount() == 1 ) {
            node = node->firstChild();
            if ( node->isNull() )
                break;
            string += *node;
        }

        if ( node && node->isNull() ) {
            if ( addWeight ) {

                string += ':';
                w.setNum( node->weight() );
                string.append( w );
            }
            matches->append( node->weight(), string );
        }


        if ( node && node->childrenCount() > 1 )
            extractStringsFromNode( node, string, matches, addWeight );
    }
}

void KCompletion::extractStringsFromNodeCI( const KCompTreeNode *node,
                                            const QString& beginning,
                                            const QString& restString,
                                            KCompletionMatchesWrapper *matches ) const
{
    if ( restString.isEmpty() ) {
        extractStringsFromNode( node, beginning, matches, false );
        return;
    }

    QChar ch1 = restString.at(0);
    QString newRest = restString.mid(1);
    KCompTreeNode *child1, *child2;

    child1 = node->find( ch1 );
    if ( child1 )
        extractStringsFromNodeCI( child1, beginning + *child1, newRest,
                                  matches );


    if ( ch1.isLetter() ) {

        QChar ch2 = ch1.lower();
        if ( ch1 == ch2 )
            ch2 = ch1.upper();
        if ( ch1 != ch2 ) {
            child2 = node->find( ch2 );
            if ( child2 )
                extractStringsFromNodeCI( child2, beginning + *child2, newRest,
                                          matches );
        }
    }
}


void KCompletion::doBeep( BeepMode mode ) const
{
    if ( !myBeep )
        return;

    QString text, event;

    switch ( mode ) {
        case Rotation:
            event = QString::fromLatin1("Textcompletion: rotation");
            text = i18n("You reached the end of the list\nof matching items.\n");
            break;
        case PartialMatch:
            if ( myCompletionMode == KGlobalSettings::CompletionShell ||
                 myCompletionMode == KGlobalSettings::CompletionMan ) {
                event = QString::fromLatin1("Textcompletion: partial match");
                text = i18n("The completion is ambiguous, more than one\nmatch is available.\n");
            }
            break;
        case NoMatch:
            if ( myCompletionMode == KGlobalSettings::CompletionShell ) {
                event = QString::fromLatin1("Textcompletion: no match");
                text = i18n("There is no matching item available.\n");
            }
            break;
    }

    if ( !text.isEmpty() )
        KNotifyClient::event( event, text );
}
# 661 "/coolo/prod/kdelibs/kdecore/kcompletion.cpp"
KCompTreeNode::~KCompTreeNode()
{

    KCompTreeNode *cur = myChildren.begin();
    while (cur) {
        KCompTreeNode * next = cur->next;
        delete myChildren.remove(cur);
        cur = next;
    }
}




KCompTreeNode * KCompTreeNode::insert( const QChar& ch, bool sorted )
{
    KCompTreeNode *child = find( ch );
    if ( !child ) {
        child = new KCompTreeNode( ch );


        if ( sorted ) {
            KCompTreeNode * prev = 0;
            KCompTreeNode * cur = myChildren.begin();
            while ( cur ) {
                if ( ch > *cur ) {
                    prev = cur;
                    cur = cur->next;
                } else
                    break;
            }
            if (prev)
                myChildren.insert( prev, child );
            else
                myChildren.prepend(child);
        }

        else
            myChildren.append( child );
    }



    child->confirm();

    return child;
}




void KCompTreeNode::remove( const QString& str )
{
    QString string = str;
    string += QChar(0x0);

    QPtrVector<KCompTreeNode> deletables( string.length() + 1 );

    KCompTreeNode *child = 0L;
    KCompTreeNode *parent = this;
    deletables.insert( 0, parent );

    uint i = 0;
    for ( ; i < string.length(); i++ )
    {
        child = parent->find( string.at( i ) );
        if ( child )
            deletables.insert( i + 1, child );
        else
            break;

        parent = child;
    }

    for ( ; i >= 1; i-- )
    {
        parent = deletables.at( i - 1 );
        child = deletables.at( i );
        if ( child->myChildren.count() == 0 )
            delete parent->myChildren.remove( child );
    }
}

QStringList KCompletionMatchesWrapper::list() const
{
    if ( sortedList && dirty ) {
        sortedList->sort();
        dirty = false;

        stringList.clear();


        QValueListConstIterator<KSortableItem<QString> > it;
        for ( it = sortedList->begin(); it != sortedList->end(); ++it )
            stringList.prepend( (*it).value() );
    }

    return stringList;
}

KCompletionMatches::KCompletionMatches( bool sort_P )
    : _sorting( sort_P )
{
}

KCompletionMatches::KCompletionMatches( const KCompletionMatchesWrapper& matches )
    : _sorting( matches.sorting())
{
    if( matches.sortedList != 0L )
        KCompletionMatchesList::operator=( *matches.sortedList );
    else {
        QStringList l = matches.list();
        for( QStringList::ConstIterator it = l.begin();
             it != l.end();
             ++it )
            prepend( KSortableItem<QString, int>( 1, *it ) );
    }
}

KCompletionMatches::~KCompletionMatches()
{
}

QStringList KCompletionMatches::list( bool sort_P ) const
{
    if( _sorting && sort_P )
        const_cast< KCompletionMatches* >( this )->sort();
    QStringList stringList;

    for ( ConstIterator it = begin(); it != end(); ++it )
        stringList.prepend( (*it).value() );
    return stringList;
}

void KCompletionMatches::removeDuplicates()
{
    Iterator it1, it2;
    for ( it1 = begin(); it1 != end(); ++it1 ) {
        for ( (it2 = it1), ++it2; it2 != end();) {
            if( (*it1).value() == (*it2).value()) {

                (*it1).first = kMax( (*it1).index(), (*it2).index());
                it2 = remove( it2 );
                continue;
            }
            ++it2;
        }
    }
}

void KCompTreeNodeList::append(KCompTreeNode *item)
{
    m_count++;
    if (!last) {
        last = item;
        last->next = 0;
        first = item;
        return;
    }
    last->next = item;
    item->next = 0;
    last = item;
}

void KCompTreeNodeList::prepend(KCompTreeNode *item)
{
    m_count++;
    if (!last) {
        last = item;
        last->next = 0;
        first = item;
        return;
    }
    item->next = first;
    first = item;
}

void KCompTreeNodeList::insert(KCompTreeNode *after, KCompTreeNode *item)
{
    if (!after) {
        append(item);
        return;
    }

    m_count++;

    item->next = after->next;
    after->next = item;

    if (after == last)
        last = item;
}

KCompTreeNode *KCompTreeNodeList::remove(KCompTreeNode *item)
{
    if (!first || !item)
        return 0;
    KCompTreeNode *cur = 0;

    if (item == first)
        first = first->next;
    else {
        cur = first;
        while (cur && cur->next != item) cur = cur->next;
        if (!cur)
            return 0;
        cur->next = item->next;
    }
    if (item == last)
        last = cur;
    m_count--;
    return item;
}

KCompTreeNode *KCompTreeNodeList::at(uint index) const
{
    KCompTreeNode *cur = first;
    while (index-- && cur) cur = cur->next;
    return cur;
}

KZoneAllocator KCompTreeNode::alloc(8192);

void KCompletion::virtual_hook( int, void* )
{ }

void KCompletionBase::virtual_hook( int, void* )
{ }

# 1 "../kdecore/kcompletion.moc" 1
# 11 "../kdecore/kcompletion.moc"
# 1 "../../../prod/kdelibs/kdecore/kcompletion.h" 1
# 12 "../kdecore/kcompletion.moc" 2
# 23 "../kdecore/kcompletion.moc"
const char *KCompletion::className() const
{
    return "KCompletion";
}

QMetaObject *KCompletion::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KCompletion( "KCompletion", &KCompletion::staticMetaObject );
# 51 "../kdecore/kcompletion.moc"
QMetaObject* KCompletion::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();

    static const QMetaEnum::Item enum_0[] = {
        { "Sorted", (int) KCompletion::Sorted },
        { "Insertion", (int) KCompletion::Insertion },
        { "Weighted", (int) KCompletion::Weighted }
    };
    static const QMetaEnum enum_tbl[] = {
        { "CompOrder", 3, enum_0, FALSE }
    };

    static const QUParameter param_slot_0[] = {
        { "string", &static_QUType_QString, 0, QUParameter::In }
    };
    static const QUMethod slot_0 = {"slotMakeCompletion", 1, param_slot_0 };
    static const QUMethod slot_1 = {"slotPreviousMatch", 0, 0 };
    static const QUMethod slot_2 = {"slotNextMatch", 0, 0 };
    static const QUParameter param_slot_3[] = {
        { "items", &static_QUType_varptr, "\x04", QUParameter::In }
    };
    static const QUMethod slot_3 = {"insertItems", 1, param_slot_3 };
    static const QUParameter param_slot_4[] = {
        { "list", &static_QUType_varptr, "\x04", QUParameter::In }
    };
    static const QUMethod slot_4 = {"setItems", 1, param_slot_4 };
    static const QUParameter param_slot_5[] = {
        { "item", &static_QUType_QString, 0, QUParameter::In }
    };
    static const QUMethod slot_5 = {"addItem", 1, param_slot_5 };
    static const QUParameter param_slot_6[] = {
        { "item", &static_QUType_QString, 0, QUParameter::In },
        { "weight", &static_QUType_varptr, "\x11", QUParameter::In }
    };
    static const QUMethod slot_6 = {"addItem", 2, param_slot_6 };
    static const QUParameter param_slot_7[] = {
        { "item", &static_QUType_QString, 0, QUParameter::In }
    };
    static const QUMethod slot_7 = {"removeItem", 1, param_slot_7 };
    static const QUMethod slot_8 = {"clear", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "slotMakeCompletion(const QString&)", &slot_0, QMetaData::Public },
        { "slotPreviousMatch()", &slot_1, QMetaData::Public },
        { "slotNextMatch()", &slot_2, QMetaData::Public },
        { "insertItems(const QStringList&)", &slot_3, QMetaData::Public },
        { "setItems(const QStringList&)", &slot_4, QMetaData::Public },
        { "addItem(const QString&)", &slot_5, QMetaData::Public },
        { "addItem(const QString&,uint)", &slot_6, QMetaData::Public },
        { "removeItem(const QString&)", &slot_7, QMetaData::Public },
        { "clear()", &slot_8, QMetaData::Public }
    };
    static const QUParameter param_signal_0[] = {
        { "item", &static_QUType_QString, 0, QUParameter::In }
    };
    static const QUMethod signal_0 = {"match", 1, param_signal_0 };
    static const QUParameter param_signal_1[] = {
        { "matchlist", &static_QUType_varptr, "\x04", QUParameter::In }
    };
    static const QUMethod signal_1 = {"matches", 1, param_signal_1 };
    static const QUMethod signal_2 = {"multipleMatches", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "match(const QString&)", &signal_0, QMetaData::Public },
        { "matches(const QStringList&)", &signal_1, QMetaData::Public },
        { "multipleMatches()", &signal_2, QMetaData::Public }
    };

    static const QMetaProperty props_tbl[3] = {
        { "CompOrder","order", 0x0107, &KCompletion::metaObj, &enum_tbl[0], -1 },
        { "bool","ignoreCase", 0x12000103, &KCompletion::metaObj, 0, -1 },
        { "QStringList","items", 0x4000103, &KCompletion::metaObj, 0, -1 }
    };

    metaObj = QMetaObject::new_metaobject(
        "KCompletion", parentObject,
        slot_tbl, 9,
        signal_tbl, 3,

        props_tbl, 3,
        enum_tbl, 1,

        0, 0 );
    cleanUp_KCompletion.setMetaObject( metaObj );
    return metaObj;
}

void* KCompletion::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KCompletion" ) )
        return this;
    return QObject::qt_cast( clname );
}


void KCompletion::match( const QString& t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 0, t0 );
}





void KCompletion::matches( const QStringList& t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 1 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_varptr.set(o+1,&t0);
    activate_signal( clist, o );
}


void KCompletion::multipleMatches()
{
    activate_signal( staticMetaObject()->signalOffset() + 2 );
}

bool KCompletion::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotMakeCompletion((const QString&)static_QUType_QString.get(_o+1)); break;
    case 1: slotPreviousMatch(); break;
    case 2: slotNextMatch(); break;
    case 3: insertItems((const QStringList&)*((const QStringList*)static_QUType_ptr.get(_o+1))); break;
    case 4: setItems((const QStringList&)*((const QStringList*)static_QUType_ptr.get(_o+1))); break;
    case 5: addItem((const QString&)static_QUType_QString.get(_o+1)); break;
    case 6: addItem((const QString&)static_QUType_QString.get(_o+1),(uint)(*((uint*)static_QUType_ptr.get(_o+2)))); break;
    case 7: removeItem((const QString&)static_QUType_QString.get(_o+1)); break;
    case 8: clear(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KCompletion::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: match((const QString&)static_QUType_QString.get(_o+1)); break;
    case 1: matches((const QStringList&)*((const QStringList*)static_QUType_ptr.get(_o+1))); break;
    case 2: multipleMatches(); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KCompletion::qt_property( int id, int f, QVariant* v)
{
    switch ( id - staticMetaObject()->propertyOffset() ) {
    case 0: switch( f ) {
        case 0: setOrder((CompOrder&)v->asInt()); break;
        case 1: *v = QVariant( (int)this->order() ); break;
        case 3: case 4: case 5: break;
        default: return FALSE;
    } break;
    case 1: switch( f ) {
        case 0: setIgnoreCase(v->asBool()); break;
        case 1: *v = QVariant( this->ignoreCase(), 0 ); break;
        case 3: case 4: case 5: break;
        default: return FALSE;
    } break;
    case 2: switch( f ) {
        case 0: setItems(v->asStringList()); break;
        case 1: *v = QVariant( this->items() ); break;
        case 3: case 4: case 5: break;
        default: return FALSE;
    } break;
    default:
        return QObject::qt_property( id, f, v );
    }
    return TRUE;
}

bool KCompletion::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 891 "/coolo/prod/kdelibs/kdecore/kcompletion.cpp" 2
# 59 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp" 1
# 19 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 20 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp" 2



# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 24 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp" 2






# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 1 3 4
# 31 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp" 2







# 1 "/coolo/prod/kdelibs/kdecore/kaboutdata.h" 1
# 39 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp" 2











template class QAsciiDict<QCString>;
template class QPtrList<KCmdLineArgs>;

class KCmdLineParsedOptions : public QAsciiDict<QCString>
{
public:
   KCmdLineParsedOptions()
     : QAsciiDict<QCString>( 7 ) { }






   QDataStream& save( QDataStream &s) const
   { return QGDict::write(s); }

   QDataStream& load( QDataStream &s)
   { return QGDict::read(s); }

protected:
   virtual QDataStream& write( QDataStream &s, QPtrCollection::Item data) const
   {
      QCString *str = (QCString *) data;
      s << (*str);
      return s;
   }

   virtual QDataStream& read( QDataStream &s, QPtrCollection::Item &item)
   {
      QCString *str = new QCString;
      s >> (*str);
      item = (void *)str;
      return s;
   }

};

class KCmdLineParsedArgs : public QStrList
{
public:
   KCmdLineParsedArgs()
     : QStrList( true ) { }
   QDataStream& save( QDataStream &s) const
   { return QGList::write(s); }

   QDataStream& load( QDataStream &s)
   { return QGList::read(s); }
};


class KCmdLineArgsList: public QPtrList<KCmdLineArgs>
{
public:
   KCmdLineArgsList() { }
};

KCmdLineArgsList *KCmdLineArgs::argsList = 0;
int KCmdLineArgs::argc = 0;
char **KCmdLineArgs::argv = 0;
char *KCmdLineArgs::mCwd = 0;
static KStaticDeleter <char> mCwdd;
const KAboutData *KCmdLineArgs::about = 0;
bool KCmdLineArgs::parsed = false;
bool KCmdLineArgs::ignoreUnknown = false;





void
KCmdLineArgs::init(int _argc, char **_argv, const char *_appname, const char* programName,
                   const char *_description, const char *_version, bool noKApp)
{
   init(_argc, _argv,
        new KAboutData(_appname, programName, _version, _description),
        noKApp);
}

void
KCmdLineArgs::init(int _argc, char **_argv, const char *_appname,
                   const char *_description, const char *_version, bool noKApp)
{
   init(_argc, _argv,
        new KAboutData(_appname, _appname, _version, _description),
        noKApp);
}

void
KCmdLineArgs::initIgnore(int _argc, char **_argv, const char *_appname )
{
   init(_argc, _argv,
        new KAboutData(_appname, _appname, "unknown", "KDE Application", false));
   ignoreUnknown = true;
}

void
KCmdLineArgs::init(const KAboutData* ab)
{
   char **_argv = (char **) malloc(sizeof(char *));
   _argv[0] = (char *) ab->appName();
   init(1,_argv,ab, true);
}


void
KCmdLineArgs::init(int _argc, char **_argv, const KAboutData *_about, bool noKApp)
{
   (static_cast<void> ((argsList == 0) ? 0 : (__assert_fail ("argsList == 0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 159, __PRETTY_FUNCTION__), 0)));
   (static_cast<void> ((argc == 0) ? 0 : (__assert_fail ("argc == 0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 160, __PRETTY_FUNCTION__), 0)));
   (static_cast<void> ((argv == 0) ? 0 : (__assert_fail ("argv == 0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 161, __PRETTY_FUNCTION__), 0)));
   (static_cast<void> ((about == 0) ? 0 : (__assert_fail ("about == 0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 162, __PRETTY_FUNCTION__), 0)));
   argc = _argc;
   argv = _argv;

   if (!argv)
   {
      fprintf(stderr, "\n\nFAILURE (KCmdLineArgs):\n");
      fprintf(stderr, "Passing null-pointer to 'argv' is not allowed.\n\n");

      (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 171, __PRETTY_FUNCTION__), 0)));
      exit(255);
   }


   if (argc) {
     char *p = strrchr( argv[0], '/');
     if (p)
       argv[0] = p+1;
   }

   about = _about;
   parsed = false;
   mCwd = mCwdd.setObject(mCwd, new char [4096 +1], true);
   getcwd(mCwd, 4096);
   if (!noKApp)
      KApplication::addCmdLineOptions();
}

QString KCmdLineArgs::cwd()
{
   return QFile::decodeName(QCString(mCwd));
}

const char * KCmdLineArgs::appName()
{
   if (!argc) return 0;
   return argv[0];
}

void
KCmdLineArgs::addCmdLineOptions( const KCmdLineOptions *options, const char *name,
                                 const char *id, const char *afterId)
{
   if (!argsList)
      argsList = new KCmdLineArgsList();

   int pos = argsList->count();

   if (pos && id && argsList->last() && !argsList->last()->name)
      pos--;

   KCmdLineArgs *args;
   int i = 0;
   for(args = argsList->first(); args; args = argsList->next(), i++)
   {
      if (!id && !args->id)
         return;

      if (id && args->id && (::qstrcmp(id, args->id) == 0))
         return;

      if (afterId && args->id && (::qstrcmp(afterId, args->id) == 0))
         pos = i+1;
   }

   (static_cast<void> ((parsed == false) ? 0 : (__assert_fail ("parsed == false", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 227, __PRETTY_FUNCTION__), 0)));

   args = new KCmdLineArgs(options, name, id);
   argsList->insert(pos, args);
}

void
KCmdLineArgs::saveAppArgs( QDataStream &ds)
{
   if (!parsed)
      parseAllArgs();


   removeArgs("qt");
   removeArgs("kde");

   QCString qCwd = mCwd;
   ds << qCwd;

   uint count = argsList ? argsList->count() : 0;
   ds << count;

   if (!count) return;

   KCmdLineArgs *args;
   for(args = argsList->first(); args; args = argsList->next())
   {
      args->save(ds);
   }
}

void
KCmdLineArgs::loadAppArgs( QDataStream &ds)
{

   removeArgs("qt");
   removeArgs("kde");

   KCmdLineArgs *args;
   if (argsList)
   {
      for(args = argsList->first(); args; args = argsList->next())
      {
         args->clear();
      }
   }

   QCString qCwd;
   ds >> qCwd;
   if (mCwd)
      delete [] mCwd;

   mCwd = mCwdd.setObject(mCwd, new char[qCwd.length()+1], true);
   strncpy(mCwd, qCwd.data(), qCwd.length()+1);

   uint count;
   ds >> count;

   if (count == 0)
      return;

   if (!argsList || (count != argsList->count()))
   {
      fprintf(stderr, "loadAppArgs:: Unexpected number of command line sets "
                      "(%d instead of %d)\n", count, argsList ? argsList->count() : 0);
      return;
   }

   for(args = argsList->first(); args; args = argsList->next())
   {
      args->load(ds);
   }
}

KCmdLineArgs *KCmdLineArgs::parsedArgs(const char *id)
{
   KCmdLineArgs *args = argsList ? argsList->first() : 0;
   while(args)
   {
      if ((id && ::qstrcmp(args->id, id) == 0) || (!id && !args->id))
      {
          if (!parsed)
             parseAllArgs();
          return args;
      }
      args = argsList->next();
   }

   if (!args)
   {

      fprintf(stderr, "WARNING (KCmdLineArgs):\n");
      fprintf(stderr, "Application requests for parsedArgs(\"%s\") without a prior call\n", id?id:"null");
      fprintf(stderr, "to addCmdLineOptions( ..., \"%s\")\n\n", id?id:"null");

   }
   return args;
}

void KCmdLineArgs::removeArgs(const char *id)
{
   KCmdLineArgs *args = argsList ? argsList->first() : 0;
   while(args)
   {
      if (args->id && id && ::qstrcmp(args->id, id) == 0)
      {
          if (!parsed)
             parseAllArgs();
          break;
      }
      args = argsList->next();
   }

   if (args)
      delete args;
}
# 353 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp"
static int
findOption(const KCmdLineOptions *options, QCString &opt,
           const char *&opt_name, const char *&def, bool &enabled)
{
   int result;
   bool inverse;
   int len = opt.length();
   while(options && options->name)
   {
      result = 0;
      inverse = false;
      opt_name = options->name;
      if (opt_name[0] == '!')
      {
         opt_name++;
         result = 4;
      }
      if ((opt_name[0] == 'n') && (opt_name[1] == 'o'))
      {
         opt_name += 2;
         inverse = true;
      }
      if (strncmp(opt.data(), opt_name, len) == 0)
      {
         opt_name += len;
         if (!opt_name[0])
         {
            if (inverse)
               return result+2;

            if (!options->description)
            {
               options++;
               if (!options->name)
                  return result+0;
               QCString nextOption = options->name;
               int p = nextOption.find(' ');
               if (p > 0)
                  nextOption = nextOption.left(p);
               if (strncmp(nextOption.data(), "no", 2) == 0)
               {
                  nextOption = nextOption.mid(2);
                  enabled = !enabled;
               }
               result = findOption(options, nextOption, opt_name, def, enabled);
               (static_cast<void> ((result) ? 0 : (__assert_fail ("result", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 398, __PRETTY_FUNCTION__), 0)));
               opt = nextOption;
               return result;
            }

            return 1;
         }
         if (opt_name[0] == ' ')
         {
            opt_name++;
            def = options->def;
            return result+3;
         }
      }

      options++;
   }
   return 0;
}


void
KCmdLineArgs::findOption(const char *_opt, QCString opt, int &i, bool _enabled, bool &moreOptions)
{
   KCmdLineArgs *args = argsList->first();
   const char *opt_name;
   const char *def;
   QCString argument;
   int j = opt.find('=');
   if (j != -1)
   {
      argument = opt.mid(j+1);
      opt = opt.left(j);
   }

   bool enabled = true;
   int result = 0;
   while (args)
   {
      enabled = _enabled;
      result = ::findOption(args->options, opt, opt_name, def, enabled);
      if (result) break;
      args = argsList->next();
   }
   if (!args && (_opt[0] == '-') && _opt[1] && (_opt[1] != '-'))
   {


      int p = 1;
      while (true)
      {
         QCString singleCharOption = " ";
         singleCharOption[0] = _opt[p];
         args = argsList->first();
         while (args)
         {
            enabled = _enabled;
            result = ::findOption(args->options, singleCharOption, opt_name, def, enabled);
            if (result) break;
            args = argsList->next();
         }
         if (!args)
            break;

         p++;
         if (result == 1)
         {
            args->setOption(singleCharOption, enabled);
            if (_opt[p])
               continue;
            else
               return;
         }
         else if (result == 3)
         {
            if (argument.isEmpty())
            {
               argument = _opt+p;
            }
            args->setOption(singleCharOption, argument);
            return;
         }
         break;
      }
      args = 0;
      result = 0;
   }

   if (!args || !result)
   {
      if (ignoreUnknown)
         return;
      enable_i18n();
      usage( i18n("Unknown option '%1'.").arg(_opt));
   }

   if ((result & 4) != 0)
   {
      result &= ~4;
      moreOptions = false;
   }

   if (result == 3)
   {
      if (!enabled)
      {
         if (ignoreUnknown)
            return;
         enable_i18n();
         usage( i18n("Unknown option '%1'.").arg(_opt));
      }
      if (argument.isEmpty())
      {
         i++;
         if (i >= argc)
         {
            enable_i18n();
            usage( i18n("'%1' missing.").arg( opt_name));
         }
         argument = argv[i];
      }
      args->setOption(opt, argument);
   }
   else
   {
      args->setOption(opt, enabled);
   }
}

void
KCmdLineArgs::printQ(const QString &msg)
{
   QCString localMsg = msg.local8Bit();
   fprintf(stdout, "%s", localMsg.data());
}

void
KCmdLineArgs::parseAllArgs()
{
   bool allowArgs = false;
   bool inOptions = true;
   bool everythingAfterArgIsArgs = false;
   KCmdLineArgs *appOptions = argsList->last();
   if (!appOptions->id)
   {
     const KCmdLineOptions *option = appOptions->options;
     while(option && option->name)
     {
       if (option->name[0] == '+')
           allowArgs = true;
       if ( option->name[0] == '!' && option->name[1] == '+' )
       {
           allowArgs = true;
           everythingAfterArgIsArgs = true;
       }
       option++;
     }
   }
   for(int i = 1; i < argc; i++)
   {
      if (!argv[i])
         continue;

      if ((argv[i][0] == '-') && argv[i][1] && inOptions)
      {
         bool enabled = true;
         const char *option = &argv[i][1];
         const char *orig = argv[i];
         if (option[0] == '-')
         {
            option++;
            argv[i]++;
            if (!option[0])
            {
               inOptions = false;
               continue;
            }
         }
         if (::qstrcmp(option, "help") == 0)
         {
            usage(0);
         }
         else if (strncmp(option, "help-",5) == 0)
         {
            usage(option+5);
         }
         else if ( (::qstrcmp(option, "version") == 0) ||
                   (::qstrcmp(option, "v") == 0))
         {
            printQ( QString("Qt: %1\n").arg(qVersion()));
            printQ( QString("KDE: %1\n").arg("3.1.90 (CVS >= 20030827)"));
            printQ( QString("%1: %2\n").
                        arg(about->programName()).arg(about->version()));
            exit(0);
         } else if ( (::qstrcmp(option, "license") == 0) )
         {
            enable_i18n();
            printQ( about->license() );
            printQ( "\n" );
            exit(0);
         } else if ( ::qstrcmp( option, "author") == 0 ) {
             enable_i18n();
             if ( about ) {
                 const QValueList<KAboutPerson> authors = about->authors();
                 if ( !authors.isEmpty() ) {
                     QString authorlist;
                     for (QValueList<KAboutPerson>::ConstIterator it = authors.begin(); it != authors.end(); ++it ) {
                         QString email;
                         if ( !(*it).emailAddress().isEmpty() )
                                 email = " <" + (*it).emailAddress() + ">";
                         authorlist += QString("    ") + (*it).name() + email + "\n";
                     }
                     printQ( i18n("the 2nd argument is a list of name+address, one on each line","%1 was written by\n%2").arg ( QString(about->programName()) ).arg( authorlist ) );
                 }
             } else {
                 printQ( i18n("%1 was written by somebody who wants to remain anonymous.").arg(about->programName()) );
             }
             if (!about->bugAddress().isEmpty())
             {
                if (about->bugAddress() == "submit@bugs.kde.org")
                    printQ( i18n( "Please use http://bugs.kde.org to report bugs, do not mail the authors directly.\n" ) );
                else
                    printQ( i18n( "Please use %1 to report bugs, do not mail the authors directly.\n" ).arg(about->bugAddress()) );
             }
             exit(0);
         } else {
           if ((option[0] == 'n') && (option[1] == 'o'))
           {
              option += 2;
              enabled = false;
           }
           findOption(orig, option, i, enabled, inOptions);
         }
      }
      else
      {

         if (!allowArgs)
         {
            if (ignoreUnknown)
               continue;
            enable_i18n();
            usage( i18n("Unexpected argument '%1'.").arg( argv[i]));
         }
         else
         {
            appOptions->addArgument(argv[i]);
            if (everythingAfterArgIsArgs)
                inOptions = false;
         }
      }
   }
   parsed = true;
}






int *
KCmdLineArgs::qt_argc()
{
   if (!argsList)
      KApplication::addCmdLineOptions();

   KCmdLineArgs *args = parsedArgs("qt");

   (static_cast<void> ((args) ? 0 : (__assert_fail ("args", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 666, __PRETTY_FUNCTION__), 0)));
   if (!argv)
   {
      fprintf(stderr, "\n\nFAILURE (KCmdLineArgs):\n");
      fprintf(stderr, "Application has not called KCmdLineArgs::init(...).\n\n");

      (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 672, __PRETTY_FUNCTION__), 0)));
      exit(255);
   }

   (static_cast<void> ((argc >= (args->count()+1)) ? 0 : (__assert_fail ("argc >= (args->count()+1)", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 676, __PRETTY_FUNCTION__), 0)));
   argc = args->count() +1;
   return &argc;
}






char ***
KCmdLineArgs::qt_argv()
{
   if (!argsList)
      KApplication::addCmdLineOptions();

   KCmdLineArgs *args = parsedArgs("qt");
   (static_cast<void> ((args) ? 0 : (__assert_fail ("args", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 693, __PRETTY_FUNCTION__), 0)));
   if (!argv)
   {
      fprintf(stderr, "\n\nFAILURE (KCmdLineArgs):\n");
      fprintf(stderr, "Application has not called KCmdLineArgs::init(...).\n\n");

      (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 699, __PRETTY_FUNCTION__), 0)));
      exit(255);
   }

   int i = 0;
   for(; i < args->count(); i++)
   {
      argv[i+1] = (char *) args->arg(i);
   }
   argv[i+1] = 0;

   return &argv;
}

void
KCmdLineArgs::enable_i18n()
{

    if (KGlobal::_locale)
            return;

    if (!KGlobal::_instance) {
        KInstance *instance = new KInstance(about);
        (void) instance->config();

    }
}

void
KCmdLineArgs::usage(const QString &error)
{
    (static_cast<void> ((KGlobal::_locale) ? 0 : (__assert_fail ("KGlobal::_locale", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 730, __PRETTY_FUNCTION__), 0)));
    QCString localError = error.local8Bit();
    if (localError[error.length()-1] == '\n')
        localError = localError.left(error.length()-1);
    fprintf(stderr, "%s: %s\n", argv[0], localError.data());

    QString tmp = i18n("Use --help to get a list of available command line options.");
    localError = tmp.local8Bit();
    fprintf(stderr, "%s: %s\n", argv[0], localError.data());
    exit(254);
}

void
KCmdLineArgs::usage(const char *id)
{
   enable_i18n();
   (static_cast<void> ((argsList != 0) ? 0 : (__assert_fail ("argsList != 0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 746, __PRETTY_FUNCTION__), 0)));


   QString optionFormatString = "  %1 %2\n";
   QString optionFormatStringDef = "  %1 %2 [%3]\n";
   QString optionHeaderString = i18n("\n%1:\n");
   QString tmp;
   QString usage;

   KCmdLineArgs *args = argsList->last();

   if (!(args->id) && (args->options) &&
       (args->options->name) && (args->options->name[0] != '+'))
   {
      usage = i18n("[options] ")+usage;
   }

   while(args)
   {
      if (args->name)
      {
         usage = i18n("[%1-options]").arg(args->name)+" "+usage;
      }
      args = argsList->prev();
   }

   KCmdLineArgs *appOptions = argsList->last();
   if (!appOptions->id)
   {
     const KCmdLineOptions *option = appOptions->options;
     while(option && option->name)
     {
       if (option->name[0] == '+')
          usage = usage + (option->name+1) + " ";
       else if ( option->name[0] == '!' && option->name[1] == '+' )
          usage = usage + (option->name+2) + " ";

       option++;
     }
   }

   printQ(i18n("Usage: %1 %2\n").arg(argv[0]).arg(usage));
   printQ("\n"+about->shortDescription()+"\n");

   printQ(optionHeaderString.arg(i18n("Generic options")));
   printQ(optionFormatString.arg("--help", -25).arg(i18n("Show help about options")));

   args = argsList->first();
   while(args)
   {
      if (args->name && args->id)
      {
         QString option = QString("--help-%1").arg(args->id);
         QString desc = i18n("Show %1 specific options").arg(args->name);

         printQ(optionFormatString.arg(option, -25).arg(desc));
      }
      args = argsList->next();
   }

   printQ(optionFormatString.arg("--help-all",-25).arg(i18n("Show all options")));
   printQ(optionFormatString.arg("--author",-25).arg(i18n("Show author information")));
   printQ(optionFormatString.arg("-v, --version",-25).arg(i18n("Show version information")));
   printQ(optionFormatString.arg("--license",-25).arg(i18n("Show license information")));
   printQ(optionFormatString.arg("--", -25).arg(i18n("End of options")));

   args = argsList->first();

   bool showAll = id && (::qstrcmp(id, "all") == 0);

   if (!showAll)
   {
     while(args)
     {
       if (!id && !args->id) break;
       if (id && (::qstrcmp(args->id, id) == 0)) break;
       args = argsList->next();
     }
   }

   while(args)
   {
     bool hasArgs = false;
     bool hasOptions = false;
     while (args)
     {
       const KCmdLineOptions *option = args->options;
       QCString opt = "";

       while(option && option->name)
       {
         QString description;
         QString descriptionRest;
         QStringList dl;
         if (option->description)
         {
            description = i18n(option->description);
            dl = QStringList::split("\n", description, true);
            description = dl.first();
            dl.remove( dl.begin() );
         }
         QCString name = option->name;
         if (name[0] == '!')
             name = name.mid(1);

         if (name[0] == '+')
         {
            if (!hasArgs)
            {
               printQ(i18n("\nArguments:\n"));
               hasArgs = true;
            }

            name = name.mid(1);
            if ((name[0] == '[') && (name[name.length()-1] == ']'))
               name = name.mid(1, name.length()-2);
            printQ(optionFormatString.arg(name, -25)
                 .arg(description));
         }
         else
         {
            if (!hasOptions)
            {
               if (!args->name)
                  printQ(i18n("\nOptions:\n"));
               else if (args->name)
                  printQ(optionHeaderString.arg(i18n("%1 options").arg(QString::fromLatin1(args->name))));
               hasOptions = true;
            }

            if ((name.length() == 1) || (name[1] == ' '))
               name = "-"+name;
            else
               name = "--"+name;
            if (!option->description)
            {
               opt = name + ", ";
            }
            else
            {
               opt = opt + name;
               if (!option->def)
               {
                  printQ(optionFormatString.arg(opt, -25)
                         .arg(description));
               }
               else
               {
                  printQ(optionFormatStringDef.arg(opt, -25)
                         .arg(description).arg(option->def));
               }
               opt = "";
            }
         }
         for(QStringList::Iterator it = dl.begin();
             it != dl.end();
             ++it)
         {
            printQ(optionFormatString.arg("", -25).arg(*it));
         }

         option++;
       }
       args = argsList->next();
       if (!args || args->name || !args->id) break;
     }
     if (!showAll) break;
   }

   exit(254);
}
# 927 "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp"
KCmdLineArgs::KCmdLineArgs( const KCmdLineOptions *_options,
                            const char *_name, const char *_id)
  : options(_options), name(_name), id(_id)
{
  parsedOptionList = 0;
  parsedArgList = 0;
  isQt = (::qstrcmp(id, "qt") == 0);
}




KCmdLineArgs::~KCmdLineArgs()
{
  delete parsedOptionList;
  delete parsedArgList;
  if (argsList)
  {
     argsList->removeRef(this);
     if (argsList->count() == 0)
     {
        delete argsList;
        argsList = 0;
     }
  }
}

void
KCmdLineArgs::clear()
{
   delete parsedArgList;
   parsedArgList = 0;
   delete parsedOptionList;
   parsedOptionList = 0;
}

void
KCmdLineArgs::save( QDataStream &ds) const
{
   uint count = 0;
   if (parsedOptionList)
      parsedOptionList->save( ds );
   else
      ds << count;

   if (parsedArgList)
      parsedArgList->save( ds );
   else
      ds << count;
}

void
KCmdLineArgs::load( QDataStream &ds)
{
   if (!parsedOptionList) parsedOptionList = new KCmdLineParsedOptions;
   if (!parsedArgList) parsedArgList = new KCmdLineParsedArgs;

   parsedOptionList->load( ds );
   parsedArgList->load( ds );

   if (parsedOptionList->count() == 0)
   {
      delete parsedOptionList;
      parsedOptionList = 0;
   }
   if (parsedArgList->count() == 0)
   {
      delete parsedArgList;
      parsedArgList = 0;
   }
}

void
KCmdLineArgs::setOption(const QCString &opt, bool enabled)
{
   if (isQt)
   {

      QCString arg = "-";
      if( !enabled )
          arg += "no";
      arg += opt;
      addArgument(arg);
   }
   if (!parsedOptionList) {
        parsedOptionList = new KCmdLineParsedOptions;
        parsedOptionList->setAutoDelete(true);
   }

   if (enabled)
      parsedOptionList->replace( opt, new QCString("t") );
   else
      parsedOptionList->replace( opt, new QCString("f") );
}

void
KCmdLineArgs::setOption(const QCString &opt, const char *value)
{
   if (isQt)
   {

      QCString arg = "-";
      arg += opt;
      addArgument(arg);
      addArgument(value);


      if (arg == "-display")
      {
         setenv("DISPLAY", value, true);
      }
   }
   if (!parsedOptionList) {
        parsedOptionList = new KCmdLineParsedOptions;
        parsedOptionList->setAutoDelete(true);
   }

   parsedOptionList->insert( opt, new QCString(value) );
}

QCString
KCmdLineArgs::getOption(const char *_opt) const
{
   QCString *value = 0;
   if (parsedOptionList)
   {
      value = parsedOptionList->find(_opt);
   }

   if (value)
      return (*value);


   const char *opt_name;
   const char *def;
   bool dummy = true;
   QCString opt = _opt;
   int result = ::findOption( options, opt, opt_name, def, dummy) & ~4;

   if (result != 3)
   {
      fprintf(stderr, "\n\nFAILURE (KCmdLineArgs):\n");
      fprintf(stderr, "Application requests for getOption(\"%s\") but the \"%s\" option\n",
                      _opt, _opt);
      fprintf(stderr, "has never been specified via addCmdLineOptions( ... )\n\n");

      (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 1073, __PRETTY_FUNCTION__), 0)));
      exit(255);
   }
   return QCString(def);
}

QCStringList
KCmdLineArgs::getOptionList(const char *_opt) const
{
   QCStringList result;
   if (!parsedOptionList)
      return result;

   while(true)
   {
      QCString *value = parsedOptionList->take(_opt);
      if (!value)
         break;
      result.prepend(*value);
      delete value;
   }






   for(QCStringList::ConstIterator it=result.begin();
       it != result.end();
       ++it)
   {
      parsedOptionList->insert(_opt, new QCString(*it));
   }
   return result;
}

bool
KCmdLineArgs::isSet(const char *_opt) const
{

   const char *opt_name;
   const char *def;
   bool dummy = true;
   QCString opt = _opt;
   int result = ::findOption( options, opt, opt_name, def, dummy) & ~4;

   if (result == 0)
   {
      fprintf(stderr, "\n\nFAILURE (KCmdLineArgs):\n");
      fprintf(stderr, "Application requests for isSet(\"%s\") but the \"%s\" option\n",
                      _opt, _opt);
      fprintf(stderr, "has never been specified via addCmdLineOptions( ... )\n\n");

      (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 1126, __PRETTY_FUNCTION__), 0)));
      exit(255);
   }

   QCString *value = 0;
   if (parsedOptionList)
   {
      value = parsedOptionList->find(opt);
   }

   if (value)
   {
      if (result == 3)
         return true;
      else
         return ((*value)[0] == 't');
   }

   if (result == 3)
      return false;



   return (result == 2);
}

int
KCmdLineArgs::count() const
{
   if (!parsedArgList)
      return 0;
   return parsedArgList->count();
}

const char *
KCmdLineArgs::arg(int n) const
{
   if (!parsedArgList || (n >= (int) parsedArgList->count()))
   {
      fprintf(stderr, "\n\nFAILURE (KCmdLineArgs): Argument out of bounds\n");
      fprintf(stderr, "Application requests for arg(%d) without checking count() first.\n",
                      n);

      (static_cast<void> ((0) ? 0 : (__assert_fail ("0", "/coolo/prod/kdelibs/kdecore/kcmdlineargs.cpp", 1169, __PRETTY_FUNCTION__), 0)));
      exit(255);
   }

   return parsedArgList->at(n);
}

KURL
KCmdLineArgs::url(int n) const
{
   return makeURL( arg(n) );
}

KURL KCmdLineArgs::makeURL( const char *urlArg )
{
   if (*urlArg == '/')
   {
      KURL result;
      result.setPath(QFile::decodeName( urlArg));
      return result;
   }

   if ( !KURL::isRelativeURL( QString::fromLocal8Bit(urlArg) ) )
     return KURL(QString::fromLocal8Bit(urlArg));

   KURL result;
   result.setPath( cwd()+"/"+QFile::decodeName( urlArg ));
   result.cleanPath();
   return result;
}

void
KCmdLineArgs::addArgument(const char *argument)
{
   if (!parsedArgList)
      parsedArgList = new KCmdLineParsedArgs;

   parsedArgList->append(argument);
}
# 60 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaboutdata.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kaboutdata.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kaboutdata.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kaboutdata.cpp" 2




QString
KAboutPerson::name() const
{
   return QString::fromUtf8(mName);
}

QString
KAboutPerson::task() const
{
   if (mTask && *mTask)
      return i18n(mTask);
   else
      return QString::null;
}

QString
KAboutPerson::emailAddress() const
{
   return QString::fromUtf8(mEmailAddress);
}


QString
KAboutPerson::webAddress() const
{
   return QString::fromUtf8(mWebAddress);
}


KAboutTranslator::KAboutTranslator(const QString & name,
                const QString & emailAddress)
{
    mName=name;
    mEmail=emailAddress;
}

QString KAboutTranslator::name() const
{
    return mName;
}

QString KAboutTranslator::emailAddress() const
{
    return mEmail;
}

class KAboutDataPrivate
{
public:
    KAboutDataPrivate()
        : translatorName("_: NAME OF TRANSLATORS\nYour names")
        , translatorEmail("_: EMAIL OF TRANSLATORS\nYour emails")
        {};
    const char *translatorName;
    const char *translatorEmail;
};



KAboutData::KAboutData( const char *appName,
                        const char *programName,
                        const char *version,
                        const char *shortDescription,
                        int licenseType,
                        const char *copyrightStatement,
                        const char *text,
                        const char *homePageAddress,
                        const char *bugsEmailAddress
                        ) :
  mProgramName( programName ),
  mVersion( version ),
  mShortDescription( shortDescription ),
  mLicenseKey( licenseType ),
  mCopyrightStatement( copyrightStatement ),
  mOtherText( text ),
  mHomepageAddress( homePageAddress ),
  mBugEmailAddress( bugsEmailAddress )
{
   d = new KAboutDataPrivate;

   if( appName ) {
     const char *p = strrchr(appName, '/');
     if( p )
         mAppName = p+1;
     else
         mAppName = appName;
   } else
     mAppName = 0;
}

KAboutData::~KAboutData()
{
    delete d;
}

void
KAboutData::addAuthor( const char *name, const char *task,
                    const char *emailAddress, const char *webAddress )
{
  mAuthorList.append(KAboutPerson(name,task,emailAddress,webAddress));
}

void
KAboutData::addCredit( const char *name, const char *task,
                    const char *emailAddress, const char *webAddress )
{
  mCreditList.append(KAboutPerson(name,task,emailAddress,webAddress));
}

void
KAboutData::setTranslator( const char *name, const char *emailAddress)
{
  d->translatorName=name;
  d->translatorEmail=emailAddress;
}

void
KAboutData::setLicenseText( const char *licenseText )
{
  mLicenseText = licenseText;
  mLicenseKey = License_Custom;
}

void
KAboutData::setLicenseTextFile( const QString &file )
{
  mLicenseText = qstrdup(QFile::encodeName(file));
  mLicenseKey = License_File;
}


const char *
KAboutData::appName() const
{
   return mAppName;
}

QString
KAboutData::programName() const
{
   if (mProgramName && *mProgramName)
      return i18n(mProgramName);
   else
      return QString::null;
}

QString
KAboutData::version() const
{
   return QString::fromLatin1(mVersion);
}

QString
KAboutData::shortDescription() const
{
   if (mShortDescription && *mShortDescription)
      return i18n(mShortDescription);
   else
      return QString::null;
}

QString
KAboutData::homepage() const
{
   return QString::fromLatin1(mHomepageAddress);
}

QString
KAboutData::bugAddress() const
{
   return QString::fromLatin1(mBugEmailAddress);
}

const QValueList<KAboutPerson>
KAboutData::authors() const
{
   return mAuthorList;
}

const QValueList<KAboutPerson>
KAboutData::credits() const
{
   return mCreditList;
}

const QValueList<KAboutTranslator>
KAboutData::translators() const
{
    QValueList<KAboutTranslator> personList;

    if(d->translatorName == 0)
        return personList;

    QStringList nameList;
    QStringList emailList;

    QString names = i18n(d->translatorName);
    if(names != QString::fromUtf8(d->translatorName))
    {
        nameList = QStringList::split(',',names);
    }


    if(d->translatorEmail)
    {
        QString emails = i18n(d->translatorEmail);

        if(emails != QString::fromUtf8(d->translatorEmail))
        {
            emailList = QStringList::split(',',emails,true);
        }
    }


    QStringList::Iterator nit;
    QStringList::Iterator eit=emailList.begin();

    for(nit = nameList.begin(); nit != nameList.end(); ++nit)
    {
        QString email;
        if(eit != emailList.end())
        {
            email=*eit;
            ++eit;
        }

        QString name=*nit;

        personList.append(KAboutTranslator( name, email));
    }

    return personList;
}

QString
KAboutData::aboutTranslationTeam()
{
    return i18n("replace this with information about your translation team",
            "<p>KDE is translated into many languages thanks to the work "
            "of the translation teams all over the world.</p>"
            "<p>For more information on KDE internationalization "
            "visit http://i18n.kde.org</p>");
}

QString
KAboutData::otherText() const
{
   if (mOtherText && *mOtherText)
      return i18n(mOtherText);
   else
      return QString::null;
}


QString
KAboutData::license() const
{
  QString l;
  QString f;
  switch ( mLicenseKey )
  {
    case License_File:
       f = QFile::decodeName(mLicenseText);
       break;
    case License_GPL_V2:
       l = "GPL v2";
       f = locate("data", "LICENSES/GPL_V2");
       break;
    case License_LGPL_V2:
       l = "LGPL v2";
       f = locate("data", "LICENSES/LGPL_V2");
       break;
    case License_BSD:
       l = "BSD License";
       f = locate("data", "LICENSES/BSD");
       break;
    case License_Artistic:
       l = "Artistic License";
       f = locate("data", "LICENSES/ARTISTIC");
       break;
    case License_QPL_V1_0:
       l = "QPL v1.0";
       f = locate("data", "LICENSES/QPL_V1.0");
       break;
    case License_Custom:
       if (mLicenseText && *mLicenseText)
          return( i18n(mLicenseText) );

    default:
       return i18n("No licensing terms for this program have been specified.\n"
                   "Please check the documentation or the source for any\n"
                   "licensing terms.\n");
      }

  QString result;
  if (!l.isEmpty())
     result = i18n("This program is distributed under the terms of the %1.").arg( l );

  if (!f.isEmpty())
  {
     QFile file(f);
     if (file.open(0x0001))
     {
        result += '\n';
        result += '\n';
        QTextStream str(&file);
        result += str.read();
     }
  }

  return result;
}

QString
KAboutData::copyrightStatement() const
{
  if (mCopyrightStatement && *mCopyrightStatement)
     return i18n(mCopyrightStatement);
  else
     return QString::null;
}
# 61 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcompletionbase.cpp" 1
# 25 "/coolo/prod/kdelibs/kdecore/kcompletionbase.cpp"
KCompletionBase::KCompletionBase()
{
    m_delegate = 0L;

    m_iCompletionMode = KGlobalSettings::completionMode();



    useGlobalKeyBindings();




    setup( false, false, false );
}

KCompletionBase::~KCompletionBase()
{
    if( m_bAutoDelCompObj && m_pCompObj )
    {
        delete m_pCompObj;
    }
}

void KCompletionBase::setDelegate( KCompletionBase *delegate )
{
    m_delegate = delegate;

    if ( m_delegate ) {
        m_delegate->m_bAutoDelCompObj = m_bAutoDelCompObj;
        m_delegate->m_bHandleSignals = m_bHandleSignals;
        m_delegate->m_bEmitSignals = m_bEmitSignals;
        m_delegate->m_iCompletionMode = m_iCompletionMode;
        m_delegate->m_keyMap = m_keyMap;
    }
}

KCompletion* KCompletionBase::completionObject( bool hsig )
{
    if ( m_delegate )
        return m_delegate->completionObject( hsig );

    if ( !m_pCompObj )
    {
        setCompletionObject( new KCompletion(), hsig );
        m_bAutoDelCompObj = true;
    }
    return m_pCompObj;
}

void KCompletionBase::setCompletionObject( KCompletion* compObj, bool hsig )
{
    if ( m_delegate ) {
        m_delegate->setCompletionObject( compObj, hsig );
        return;
    }

    if ( m_bAutoDelCompObj && compObj != m_pCompObj )
        delete m_pCompObj;

    m_pCompObj = compObj;



    setup( false, hsig, !m_pCompObj.isNull() );
}


void KCompletionBase::setHandleSignals( bool handle )
{
    if ( m_delegate )
        m_delegate->setHandleSignals( handle );
    else
        m_bHandleSignals = handle;
}

void KCompletionBase::setCompletionMode( KGlobalSettings::Completion mode )
{
    if ( m_delegate ) {
        m_delegate->setCompletionMode( mode );
        return;
    }

    m_iCompletionMode = mode;


    if( m_pCompObj && m_iCompletionMode != KGlobalSettings::CompletionNone )
        m_pCompObj->setCompletionMode( m_iCompletionMode );
}

bool KCompletionBase::setKeyBinding( KeyBindingType item, const KShortcut& cut )
{
    if ( m_delegate )
        return m_delegate->setKeyBinding( item, cut );


    if( !cut.isNull() )
    {
        for( KeyBindingMap::Iterator it = m_keyMap.begin(); it != m_keyMap.end(); ++it )
            if( it.data() == cut ) return false;
    }
    m_keyMap.replace( item, cut );
    return true;
}

void KCompletionBase::useGlobalKeyBindings()
{
    if ( m_delegate ) {
        m_delegate->useGlobalKeyBindings();
        return;
    }

    m_keyMap.clear();
    m_keyMap.insert( TextCompletion, 0 );
    m_keyMap.insert( PrevCompletionMatch, 0 );
    m_keyMap.insert( NextCompletionMatch, 0 );
    m_keyMap.insert( SubstringCompletion, 0 );
}

void KCompletionBase::setup( bool autodel, bool hsig, bool esig )
{
    if ( m_delegate ) {
        m_delegate->setup( autodel, hsig, esig );
        return;
    }

    m_bAutoDelCompObj = autodel;
    m_bHandleSignals = hsig;
    m_bEmitSignals = esig;
}
# 62 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/knotifyclient.cpp" 1
# 24 "/coolo/prod/kdelibs/kdecore/knotifyclient.cpp"
# 1 "/coolo/prod/qt-copy/include/qptrstack.h" 1
# 39 "/coolo/prod/qt-copy/include/qptrstack.h"





template<class type>
class QPtrStack : protected QGList
{
public:
    QPtrStack() { }
    QPtrStack( const QPtrStack<type> &s ) : QGList( s ) { }
    ~QPtrStack() { clear(); }
    QPtrStack<type> &operator=(const QPtrStack<type> &s)
                        { return (QPtrStack<type>&)QGList::operator=(s); }
    bool autoDelete() const { return QPtrCollection::autoDelete(); }
    void setAutoDelete( bool del ) { QPtrCollection::setAutoDelete(del); }
    uint count() const { return QGList::count(); }
    bool isEmpty() const { return QGList::count() == 0; }
    void push( const type *d ) { QGList::insertAt(0,Item(d)); }
    type *pop() { return (type *)QGList::takeFirst(); }
    bool remove() { return QGList::removeFirst(); }
    void clear() { QGList::clear(); }
    type *top() const { return (type *)QGList::cfirst(); }
          operator type *() const { return (type *)QGList::cfirst(); }
    type *current() const { return (type *)QGList::cfirst(); }







private:
    void deleteItem( Item d );
};


template<> inline void QPtrStack<void>::deleteItem( QPtrCollection::Item )
{
}


template<class type> inline void QPtrStack<type>::deleteItem( QPtrCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}


# 25 "/coolo/prod/kdelibs/kdecore/knotifyclient.cpp" 2
# 34 "/coolo/prod/kdelibs/kdecore/knotifyclient.cpp"
static const char daemonName[] = "knotify";

static int sendNotifyEvent(const QString &message, const QString &text,
                            int present, int level, const QString &sound,
                            const QString &file, int winId )
{
  if (!KApplication::kApplication()) return 0;

  DCOPClient *client=KApplication::kApplication()->dcopClient();
  if (!client->isAttached())
  {
    client->attach();
    if (!client->isAttached())
      return 0;
  }

  int uniqueId = kMax( 1, KApplication::kApplication()->random() );

  QByteArray data;
  QDataStream ds(data, 0x0002);
  QString appname = KNotifyClient::instance()->instanceName();
 ds << message << appname << text << sound << file << present << level
    << winId << uniqueId;

  if ( !KNotifyClient::startDaemon() )
      return 0;

  if ( client->send(daemonName, "Notify", "notify(QString,QString,QString,QString,QString,int,int,int,int)", data) )
  {
      return uniqueId;
  }

  return 0;
}

int KNotifyClient::event( StandardEvent type, const QString& text )
{
    return event( 0, type, text );
}

int KNotifyClient::event(const QString &message, const QString &text)
{
    return event(0, message, text);
}

int KNotifyClient::userEvent(const QString &text, int present, int level,
                              const QString &sound, const QString &file)
{
    return userEvent( 0, text, present, level, sound, file );
}


int KNotifyClient::event( int winId, StandardEvent type, const QString& text )
{
    QString message;
    switch ( type ) {
    case cannotOpenFile:
        message = QString::fromLatin1("cannotopenfile");
        break;
    case warning:
        message = QString::fromLatin1("warning");
        break;
    case fatalError:
        message = QString::fromLatin1("fatalerror");
        break;
    case catastrophe:
        message = QString::fromLatin1("catastrophe");
        break;
    case notification:
    default:
        message = QString::fromLatin1("notification");
        break;
    }

    return sendNotifyEvent( message, text, Default, Default,
                            QString::null, QString::null, winId );
}

int KNotifyClient::event(int winId, const QString &message,
                          const QString &text)
{
  return sendNotifyEvent(message, text, Default, Default, QString::null, QString::null, winId);
}

int KNotifyClient::userEvent(int winId, const QString &text, int present,
                              int level,
                              const QString &sound, const QString &file)
{
  return sendNotifyEvent(QString::null, text, present, level, sound, file, winId);
}

int KNotifyClient::getPresentation(const QString &eventname)
{
        int present;
        if (eventname.isEmpty()) return Default;

        KConfig eventsfile( KNotifyClient::instance()->instanceName()+".eventsrc", true, false);
        eventsfile.setGroup(eventname);

        present=eventsfile.readNumEntry("presentation", -1);

        return present;
}

QString KNotifyClient::getFile(const QString &eventname, int present)
{
        if (eventname.isEmpty()) return QString::null;

        KConfig eventsfile( KNotifyClient::instance()->instanceName()+".eventsrc", true, false);
        eventsfile.setGroup(eventname);

        switch (present)
        {
        case (Sound):
                return eventsfile.readPathEntry("soundfile");
        case (Logfile):
                return eventsfile.readPathEntry("logfile");
        }

        return QString::null;
}

int KNotifyClient::getDefaultPresentation(const QString &eventname)
{
        int present;
        if (eventname.isEmpty()) return Default;

        KConfig eventsfile( KNotifyClient::instance()->instanceName()+"/eventsrc", true, false, "data");
        eventsfile.setGroup(eventname);

        present=eventsfile.readNumEntry("default_presentation", -1);

        return present;
}

QString KNotifyClient::getDefaultFile(const QString &eventname, int present)
{
        if (eventname.isEmpty()) return QString::null;

        KConfig eventsfile( KNotifyClient::instance()->instanceName()+"/eventsrc", true, false, "data");
        eventsfile.setGroup(eventname);

        switch (present)
        {
        case (Sound):
                return eventsfile.readPathEntry("default_sound");
        case (Logfile):
                return eventsfile.readPathEntry("default_logfile");
        }

        return QString::null;
}

bool KNotifyClient::startDaemon()
{
  static bool firstTry = true;
  if (firstTry && !KApplication::kApplication()->dcopClient()->isApplicationRegistered(daemonName)) {
    firstTry = false;
    return KApplication::startServiceByDesktopName(daemonName) == 0;
  }
  return true;
}


void KNotifyClient::beep(const QString& reason)
{
  if ( !KApplication::kApplication() || KNotifyClient::Instance::currentInstance()->useSystemBell() ) {
    QApplication::beep();
    return;
  }

  DCOPClient *client=KApplication::kApplication()->dcopClient();
  if (!client->isAttached())
  {
    client->attach();
    if (!client->isAttached() || !client->isApplicationRegistered(daemonName))
    {
      QApplication::beep();
      return;
    }
  }

  if ( client->isApplicationRegistered( "kaccess" ) )
  {
      QApplication::beep();
      return;
  }

  KNotifyClient::event(KNotifyClient::notification, reason);
}


KInstance * KNotifyClient::instance() {
    return KNotifyClient::Instance::current();
}


class KNotifyClient::InstanceStack
{
public:
        InstanceStack() { m_defaultInstance = 0; }
        virtual ~InstanceStack() { delete m_defaultInstance; }
        void push(Instance *instance) { m_instances.push(instance); }

        void pop(Instance *instance)
        {
                if (m_instances.top() == instance)
                        m_instances.pop();
                else if (!m_instances.isEmpty())
                {
                        kdWarning(160) << "Tried to remove an Instance that is not the current," << endl;
                        kdWarning(160) << "Resetting to the main KApplication." << endl;
                        m_instances.clear();
                }
                else
                        kdWarning(160) << "Tried to remove an Instance, but the stack was empty." << endl;
    }

        Instance *currentInstance()
        {
                if (m_instances.isEmpty())
                {
                        m_defaultInstance = new Instance(KApplication::kApplication());
                }
                return m_instances.top();
        }

private:
        QPtrStack<Instance> m_instances;
        Instance *m_defaultInstance;
};

KNotifyClient::InstanceStack * KNotifyClient::Instance::s_instances = 0L;
static KStaticDeleter<KNotifyClient::InstanceStack > instancesDeleter;

struct KNotifyClient::InstancePrivate
{
    KInstance *instance;
    bool useSystemBell;
};

KNotifyClient::Instance::Instance(KInstance *instance)
{
    d = new InstancePrivate;
    d->instance = instance;
    instances()->push(this);

    KConfig *config = instance->config();
    KConfigGroupSaver cs( config, "General" );
    d->useSystemBell = config->readBoolEntry( "UseSystemBell", false );
}

KNotifyClient::Instance::~Instance()
{
        if (s_instances)
                s_instances->pop(this);
        delete d;
}

KNotifyClient::InstanceStack *KNotifyClient::Instance::instances()
{
        if (!s_instances)
                instancesDeleter.setObject(s_instances, new InstanceStack);
        return s_instances;
}

bool KNotifyClient::Instance::useSystemBell() const
{
    return d->useSystemBell;
}
# 314 "/coolo/prod/kdelibs/kdecore/knotifyclient.cpp"
KNotifyClient::Instance * KNotifyClient::Instance::currentInstance()
{
        return instances()->currentInstance();
}

KInstance *KNotifyClient::Instance::current()
{
    return currentInstance()->d->instance;
}
# 63 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kaudioplayer.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kaudioplayer.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kaudioplayer.h" 1
# 24 "/coolo/prod/kdelibs/kdecore/kaudioplayer.h"



class KAudioPlayerPrivate;
# 55 "/coolo/prod/kdelibs/kdecore/kaudioplayer.h"
class KAudioPlayer : public QObject {
public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:







        KAudioPlayer( const QString& filename,
                        QObject* parent = 0, const char* name = 0 );




        ~KAudioPlayer();







        static void play(const QString &filename);

public :





        void play();
private:
        KAudioPlayerPrivate *d;
};
# 24 "/coolo/prod/kdelibs/kdecore/kaudioplayer.cpp" 2


class KAudioPlayerPrivate {
public:
        QString filename;

        KAudioPlayerPrivate(const QString &filename) : filename(filename) { };
};

KAudioPlayer::KAudioPlayer( const QString& filename,
                        QObject* parent, const char* name ) : QObject(parent,name)
{
        d = new KAudioPlayerPrivate(filename);
}

KAudioPlayer::~KAudioPlayer()
{
        delete d;
}

void KAudioPlayer::play(const QString &filename)
{
        KAudioPlayer ap(filename);
        ap.play();
}

void KAudioPlayer::play()
{
        KNotifyClient::userEvent("KAudioPlayer event",
                                                        KNotifyClient::Sound,KNotifyClient::Notification,d->filename);
}

# 1 "../kdecore/kaudioplayer.moc" 1
# 11 "../kdecore/kaudioplayer.moc"
# 1 "../../../prod/kdelibs/kdecore/kaudioplayer.h" 1
# 12 "../kdecore/kaudioplayer.moc" 2
# 22 "../kdecore/kaudioplayer.moc"
const char *KAudioPlayer::className() const
{
    return "KAudioPlayer";
}

QMetaObject *KAudioPlayer::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KAudioPlayer( "KAudioPlayer", &KAudioPlayer::staticMetaObject );
# 50 "../kdecore/kaudioplayer.moc"
QMetaObject* KAudioPlayer::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod slot_0 = {"play", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "play()", &slot_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KAudioPlayer", parentObject,
        slot_tbl, 1,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KAudioPlayer.setMetaObject( metaObj );
    return metaObj;
}

void* KAudioPlayer::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KAudioPlayer" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KAudioPlayer::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: play(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KAudioPlayer::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KAudioPlayer::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KAudioPlayer::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 57 "/coolo/prod/kdelibs/kdecore/kaudioplayer.cpp" 2
# 64 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.cpp" 1
# 20 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.h"





class KDCOPPropertyProxyPrivate;
# 38 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.h"
class KDCOPPropertyProxy
{
public:





  KDCOPPropertyProxy( QObject *object );



  ~KDCOPPropertyProxy();





  bool isPropertyRequest( const QCString &fun );





  bool processPropertyRequest( const QCString &fun, const QByteArray &data, QCString &replyType,
                               QByteArray &replyData );





  QValueList<QCString> functions();
# 80 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.h"
  static QValueList<QCString> functions( QObject *object );
# 89 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.h"
  static bool isPropertyRequest( const QCString &fun, QObject *object );





  static bool processPropertyRequest( const QCString &fun, const QByteArray &data, QCString &replyType,
                                      QByteArray &replyData, QObject *object );

private:
  static bool decodePropertyRequestInternal( const QCString &fun, QObject *object, bool &set,
                                             QCString &propName, QCString &arg );

  KDCOPPropertyProxyPrivate *d;
};
# 21 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.cpp" 2
# 36 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.cpp"
# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 37 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.cpp" 2

class KDCOPPropertyProxyPrivate
{
public:
  KDCOPPropertyProxyPrivate()
  {
  }
  ~KDCOPPropertyProxyPrivate()
  {
  }

  QObject *m_object;
};

KDCOPPropertyProxy::KDCOPPropertyProxy( QObject *object )
{
  d = new KDCOPPropertyProxyPrivate;
  d->m_object = object;
}

KDCOPPropertyProxy::~KDCOPPropertyProxy()
{
  delete d;
}

bool KDCOPPropertyProxy::isPropertyRequest( const QCString &fun )
{
  return isPropertyRequest( fun, d->m_object );
}

bool KDCOPPropertyProxy::processPropertyRequest( const QCString &fun, const QByteArray &data,
                                                 QCString &replyType, QByteArray &replyData )
{
  return processPropertyRequest( fun, data, replyType, replyData, d->m_object );
}

QValueList<QCString> KDCOPPropertyProxy::functions()
{
  return functions( d->m_object );
}

bool KDCOPPropertyProxy::isPropertyRequest( const QCString &fun, QObject *object )
{
  if ( fun == "property(QCString)" ||
       fun == "setProperty(QCString,QVariant)" ||
       fun == "propertyNames(bool)" )
    return true;

  bool set;
  QCString propName, arg;
  return decodePropertyRequestInternal( fun, object, set, propName, arg );
}

QValueList<QCString> KDCOPPropertyProxy::functions( QObject *object )
{
  QValueList<QCString> res;
  res << "QVariant property(QCString property)";
  res << "bool setProperty(QCString name,QVariant property)";
  res << "QValueList<QCString> propertyNames(bool super)";

  QMetaObject *metaObj = object->metaObject();
  QStrList properties = metaObj->propertyNames( true );
  QStrListIterator it( properties );
  for (; it.current(); ++it )
  {
    const QMetaProperty *metaProp = metaObj->property( metaObj->findProperty( it.current(), true ), true );

    (static_cast<void> ((metaProp) ? 0 : (__assert_fail ("metaProp", "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.cpp", 104, __PRETTY_FUNCTION__), 0)));

    QCString name = it.current();
    name.prepend( " " );
    name.prepend( metaProp->type() );
    name.append( "()" );
    res << name;

    if ( metaProp->writable() )
    {
      QCString setName = it.current();
      setName[ 0 ] = toupper( setName[ 0 ] );
      setName = "void set" + setName + "(" + metaProp->type() + " " + it.current() + ")";
      res << setName;
    }
  }

  return res;
}

bool KDCOPPropertyProxy::processPropertyRequest( const QCString &fun, const QByteArray &data,
                                                 QCString &replyType, QByteArray &replyData,
                                                 QObject *object )
{
  if ( fun == "property(QCString)" )
  {
    QCString propName;
    QDataStream stream( data, 0x0001 );
    stream >> propName;

    replyType = "QVariant";
    QDataStream reply( replyData, 0x0002 );
    reply << object->property( propName );
    return true;
  }

  if ( fun == "setProperty(QCString,QVariant)" )
  {
    QCString propName;
    QVariant propValue;
    QDataStream stream( data, 0x0001 );
    stream >> propName >> propValue;

    replyType = "bool";
    QDataStream reply( replyData, 0x0002 );
    reply << (Q_INT8)object->setProperty( propName, propValue );
    return true;
  }

  if ( fun == "propertyNames(bool)" )
  {
    Q_INT8 b;
    QDataStream stream( data, 0x0001 );
    stream >> b;

    QValueList<QCString> res;
    QStrList props = object->metaObject()->propertyNames( static_cast<bool>( b ) );
    QStrListIterator it( props );
    for (; it.current(); ++it )
      res.append( it.current() );

    replyType = "QValueList<QCString>";
    QDataStream reply( replyData, 0x0002 );
    reply << res;
    return true;
  }

  bool set;
  QCString propName, arg;

  bool res = decodePropertyRequestInternal( fun, object, set, propName, arg );
  if ( !res )
    return false;

  if ( set )
  {
    QVariant prop;
    QDataStream stream( data, 0x0001 );

    QVariant::Type type = QVariant::nameToType( arg );
    if ( type == QVariant::Invalid )
      return false;

# 196 "/coolo/prod/kdelibs/kdecore/kdcoppropertyproxy.cpp"
    typedef QValueList<QVariant> ListType;
    typedef QMap<QString,QVariant> MapType;

    switch ( type )
    {
      case QVariant::Cursor: { QCursor v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Bitmap: { QBitmap v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::PointArray: { QPointArray v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Region: { QRegion v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::List: { ListType v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Map: { MapType v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::String: { QString v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::CString: { QCString v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::StringList: { QStringList v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Font: { QFont v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Pixmap: { QPixmap v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Image: { QImage v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Brush: { QBrush v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Point: { QPoint v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Rect: { QRect v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Size: { QSize v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Color: { QColor v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Palette: { QPalette v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::ColorGroup: { QColorGroup v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::IconSet:
      {
        QPixmap val;
        stream >> val;
        prop = QVariant( QIconSet( val ) );
      }
      break;
      case QVariant::Int: { int v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::UInt: { uint v; stream >> v; prop = QVariant( v ); } break;
      case QVariant::Bool:
      {
        Q_INT8 v;
        stream >> v;
        prop = QVariant( static_cast<bool>( v ), 1 );
      }
        break;
      case QVariant::Double: { double v; stream >> v; prop = QVariant( v ); } break;
      default:
        return false;
    }

    replyType = "void";
    return object->setProperty( propName, prop );
  }
  else
  {
    QVariant prop = object->property( propName );

    if ( prop.type() == QVariant::Invalid )
      return false;

    replyType = prop.typeName();
    QDataStream reply( replyData, 0x0002 );





    switch ( prop.type() )
    {
      case QVariant::Cursor: reply << prop.toCursor(); break;
      case QVariant::Bitmap: reply << prop.toBitmap(); break;
      case QVariant::PointArray: reply << prop.toPointArray(); break;
      case QVariant::Region: reply << prop.toRegion(); break;
      case QVariant::List: reply << prop.toList(); break;
      case QVariant::Map: reply << prop.toMap(); break;
      case QVariant::String: reply << prop.toString(); break;
      case QVariant::CString: reply << prop.toCString(); break;
      case QVariant::StringList: reply << prop.toStringList(); break;
      case QVariant::Font: reply << prop.toFont(); break;
      case QVariant::Pixmap: reply << prop.toPixmap(); break;
      case QVariant::Image: reply << prop.toImage(); break;
      case QVariant::Brush: reply << prop.toBrush(); break;
      case QVariant::Point: reply << prop.toPoint(); break;
      case QVariant::Rect: reply << prop.toRect(); break;
      case QVariant::Size: reply << prop.toSize(); break;
      case QVariant::Color: reply << prop.toColor(); break;
      case QVariant::Palette: reply << prop.toPalette(); break;
      case QVariant::ColorGroup: reply << prop.toColorGroup(); break;
      case QVariant::IconSet:
        reply << prop.toIconSet().pixmap();
        break;
      case QVariant::Int: reply << prop.toInt(); break;
      case QVariant::UInt: reply << prop.toUInt(); break;
      case QVariant::Bool:
        reply << (Q_INT8)prop.toBool();
        break;
      case QVariant::Double: reply << prop.toDouble(); break;
      default:
        return false;
    }

#undef MARSHAL
#undef DEMARSHAL

    return true;
  }

  return false;
}

bool KDCOPPropertyProxy::decodePropertyRequestInternal( const QCString &fun, QObject *object, bool &set,
                                                        QCString &propName, QCString &arg )
{
  if ( fun.length() < 3 )
    return false;

  set = false;

  propName = fun;

  if ( propName.left( 3 ) == "set" )
  {
    propName.detach();
    set = true;
    propName = propName.mid( 3 );
    int p1 = propName.find( '(' );

    uint len = propName.length();

    if ( propName[ len - 1 ] != ')' )
      return false;

    arg = propName.mid( p1+1, len - p1 - 2 );
    propName.truncate( p1 );
    propName[ 0 ] = tolower( propName[ 0 ] );
  }
  else
    propName.truncate( propName.length() - 2 );

  if ( !object->metaObject()->propertyNames( true ).contains( propName ) )
    return false;

  return true;
}
# 65 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kextsock.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 2



# 1 "/usr/include/sys/times.h" 1 3 4
# 24 "/usr/include/sys/times.h" 3 4






extern "C" {


struct tms
  {
    clock_t tms_utime;
    clock_t tms_stime;

    clock_t tms_cutime;
    clock_t tms_cstime;
  };






extern clock_t times (struct tms *__buffer) throw ();

}
# 28 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 2
# 37 "/coolo/prod/kdelibs/kdecore/kextsock.cpp"
# 1 "/usr/include/errno.h" 1 3 4
# 38 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 2







# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 46 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 2



# 1 "/coolo/prod/qt-copy/include/qdns.h" 1
# 39 "/coolo/prod/qt-copy/include/qdns.h"



# 1 "/coolo/prod/qt-copy/include/qhostaddress.h" 1
# 39 "/coolo/prod/qt-copy/include/qhostaddress.h"
# 48 "/coolo/prod/qt-copy/include/qhostaddress.h"



class QHostAddressPrivate;

class QHostAddress
{
public:
    QHostAddress();
    QHostAddress( Q_UINT32 ip4Addr );
    QHostAddress( Q_UINT8 *ip6Addr );
    QHostAddress( const QHostAddress & );
    virtual ~QHostAddress();

    QHostAddress & operator=( const QHostAddress & );

    void setAddress( Q_UINT32 ip4Addr );
    void setAddress( Q_UINT8 *ip6Addr );

    bool setAddress( const QString& address );

    bool isIp4Addr() const;
    Q_UINT32 ip4Addr() const;

    QString toString() const;


    bool operator==( const QHostAddress & ) const;
    bool isNull() const;

private:
    QHostAddressPrivate* d;
};
# 44 "/coolo/prod/qt-copy/include/qdns.h" 2













class QDnsPrivate;

class QDns: public QObject {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    enum RecordType {
        None,
        A, Aaaa,
        Mx, Srv,
        Cname,
        Ptr,
        Txt
    };

    QDns();
    QDns( const QString & label, RecordType rr = A );
    QDns( const QHostAddress & address, RecordType rr = Ptr );
    virtual ~QDns();


    virtual void setLabel( const QString & label );
    virtual void setLabel( const QHostAddress & address );
    QString label() const { return l; }

    virtual void setRecordType( RecordType rr = A );
    RecordType recordType() const { return t; }


    bool isWorking() const;


    QValueList<QHostAddress> addresses() const;

    class MailServer {
    public:
        MailServer( const QString & n=QString::null, Q_UINT16 p=0 )
            :name(n), priority(p) {}
        QString name;
        Q_UINT16 priority;
       
    };
    QValueList<MailServer> mailServers() const;

    class Server {
    public:
        Server(const QString & n=QString::null, Q_UINT16 p=0, Q_UINT16 w=0, Q_UINT16 po=0 )
            : name(n), priority(p), weight(w), port(po) {}
        QString name;
        Q_UINT16 priority;
        Q_UINT16 weight;
        Q_UINT16 port;
       
    };
    QValueList<Server> servers() const;

    QStringList hostNames() const;

    QStringList texts() const;

    QString canonicalName() const;

    QStringList qualifiedNames() const { return n; }






protected:
    void resultsReady();

private :
    void startQuery();

private:
    void setStartQueryTimer();
    QString toInAddrArpaDomain( const QHostAddress &address );




    QString l;
    QStringList n;
    RecordType t;
    QDnsPrivate * d;

    friend class QDnsAnswer;
};




class QDnsSocket: public QObject {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

protected:
    QDnsSocket( QObject *, const char * );
    virtual ~QDnsSocket();

private :
    virtual void cleanCache();
    virtual void retransmit();
    virtual void answer();
};
# 50 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 2
# 65 "/coolo/prod/kdelibs/kdecore/kextsock.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kextsocklookup.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kextsocklookup.h"
# 39 "/coolo/prod/kdelibs/kdecore/kextsocklookup.h"
class KExtendedSocketLookup: public QObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
  QDns dnsIpv4, dnsIpv6;
  int workingCount;
  const QString& servname;
  addrinfo hint;

  KExtendedSocketLookup(const QString& hostname, const QString& servname, const addrinfo& hint) :
    dnsIpv4(KIDNA::toAscii(hostname), QDns::A), dnsIpv6(KIDNA::toAscii(hostname), QDns::Aaaa), workingCount(2),
    servname(servname), hint(hint)
  {
    connect(&dnsIpv4, "2""resultsReady()", this, "1""slotResultsReady()");
    connect(&dnsIpv6, "2""resultsReady()", this, "1""slotResultsReady()");
  }

  inline bool isWorking() const
  { return workingCount; }

  kde_addrinfo *results();
  static void freeresults(kde_addrinfo* res);

public :
  void slotResultsReady()
  {
    if (--workingCount == 0)
      resultsReady();
  }

protected:
  void resultsReady();

public:
  friend class KExtendedSocket;
};
# 66 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 2
# 82 "/coolo/prod/kdelibs/kdecore/kextsock.cpp"
#undef offsetof






class KExtendedSocketPrivate
{
public:
  int flags;
  int status;
  int syserror;

  timeval timeout;
  QString host;
  QString service;
  QString localhost;
  QString localservice;
  kde_addrinfo *resolution;
  kde_addrinfo *bindres;
  addrinfo *current;

  KSocketAddress *local;
  KSocketAddress *peer;

  QSocketNotifier *qsnIn, *qsnOut;
  int inMaxSize, outMaxSize;
  bool emitRead : 1, emitWrite : 1;
  mutable bool addressReusable : 1, ipv6only : 1;

  KExtendedSocketLookup *dns, *dnsLocal;

  KExtendedSocketPrivate() :
    flags(0), status(0), syserror(0),
    host(QString::null), service(QString::null), localhost(QString::null), localservice(QString::null),
    resolution(0), bindres(0), current(0), local(0), peer(0),
    qsnIn(0), qsnOut(0), inMaxSize(-1), outMaxSize(-1), emitRead(false), emitWrite(false),
    addressReusable(false), ipv6only(false), dns(0), dnsLocal(0)
  {
    timeout.tv_sec = timeout.tv_usec = 0;
  }
};

static bool process_flags(int flags, addrinfo &hint)
{
  switch (flags & (KExtendedSocket::streamSocket | KExtendedSocket::datagramSocket | KExtendedSocket::rawSocket))
    {
    case 0:


    case KExtendedSocket::streamSocket:

      hint.ai_socktype = SOCK_STREAM;
      break;

    case KExtendedSocket::datagramSocket:

      hint.ai_socktype = SOCK_DGRAM;
      break;

    case KExtendedSocket::rawSocket:

      hint.ai_socktype = SOCK_RAW;
      break;

    default:

      return false;
    }

  if ((flags & KExtendedSocket::unixSocket) == KExtendedSocket::unixSocket)
     hint.ai_family = 1;
  else if ((flags & KExtendedSocket::ipv4Socket) == KExtendedSocket::ipv4Socket)
     hint.ai_family = 2;

  else if ((flags & KExtendedSocket::ipv6Socket) == KExtendedSocket::ipv6Socket)
     hint.ai_family = 10;



  hint.ai_flags |= (flags & KExtendedSocket::passiveSocket ? 0x0001 : 0) |
    (flags & KExtendedSocket::canonName ? 0x0002 : 0) |
    (flags & KExtendedSocket::noResolve ? 0x0004 : 0);
  return true;
}

static bool valid_family(addrinfo *p, int flags)
{
  if (flags & KExtendedSocket::knownSocket)
    {
      if (p->ai_family == 2)
        {
          if (flags & 0x0e && (flags & 0x4) == 0)
            return false;
          if (flags & 0xf00 && (flags & 0x100) == 0)
            return false;
        }

      else if (p->ai_family == 10)
        {
          if (flags & 0x0e && (flags & 0x4) == 0)
            return false;
          if (flags & 0xf00 && (flags & 0x200) == 0)
            return false;
        }

      else if (p->ai_family == 1)
        {
          if (flags & 0x0e && (flags & 0x2) == 0)
            return false;
        }
      if (p->ai_family != 2 && p->ai_family != 1

          && p->ai_family != 10

          )
        return false;


    }
  return true;
}

static QString pretty_sock(addrinfo *p)
{
  KSocketAddress *sa;
  QString ret;

  sa = KSocketAddress::newAddress(p->ai_addr, p->ai_addrlen);
  if (sa == __null)
    return QString::fromLocal8Bit("<invalid>");

  switch (p->ai_family)
    {
    case 1:
      ret = QString::fromLocal8Bit("Unix ");
      break;

    case 2:
      ret = QString::fromLocal8Bit("Inet ");
      break;


    case 10:
      ret = QString::fromLocal8Bit("Inet6 ");
      break;


    default:
      ret = QString::fromLocal8Bit("<unknown> ");
      break;
    }

  ret += sa->pretty();
  return ret;
}





static int skipData(int fd, unsigned len)
{
  char buf[1024];
  unsigned skipped = 0;
  while (len)
    {
      int count = sizeof(buf);
      if ((unsigned)count > len)
        count = len;
      count = KSocks::self()->read(fd, buf, count);
      if (count == -1)
        return -1;
      else
        {
          len -= count;
          skipped += count;
        }
    }
  return skipped;
}




static void local_freeaddrinfo(kde_addrinfo *&p)
{
  if (p == __null)
    return;

  if (p->origin == 2)
    KExtendedSocketLookup::freeresults(p);
  else
    kde_freeaddrinfo(p);

  p = __null;
}




kde_addrinfo* KExtendedSocketLookup::results()
{
  QValueList<QHostAddress> v4 = dnsIpv4.addresses();

  QValueList<QHostAddress> v6 = dnsIpv6.addresses();

  addrinfo *p = __null;
  kde_addrinfo *res = new kde_addrinfo;
  res->origin = 2;
  QValueList<QHostAddress>::Iterator it;
  unsigned short port;

  QString canon = dnsIpv4.canonicalName();

  if (canon.isNull())
    canon = dnsIpv6.canonicalName();

  char* canonname;
  if (!canon.isNull())
    canonname = strdup(canon.latin1());
  else
    canonname = 0L;

  if (hint.ai_socktype == 0)
    hint.ai_socktype = SOCK_STREAM;
  if (hint.ai_protocol == 0)
    hint.ai_protocol = IPPROTO_TCP;

  {
    bool ok;
    port = htons(servname.toUShort(&ok));
    if (!ok)
      {
        struct servent *sent;
        sent = getservbyname(servname.latin1(),
                             hint.ai_protocol == SOCK_DGRAM ? "udp" : "tcp");
        if (sent == __null)
          port = 0;
        else
          port = sent->s_port;
      }
  }


  for (it = v6.begin(); it != v6.end(); ++it)
    {
      addrinfo *q = new addrinfo;
      sockaddr_in6 *sin6 = new sockaddr_in6;
      q->ai_flags = 0;
      q->ai_family = 10;
      q->ai_socktype = hint.ai_socktype;
      q->ai_protocol = hint.ai_protocol;
      q->ai_addrlen = sizeof(*sin6);
      q->ai_addr = (sockaddr*)sin6;
      q->ai_canonname = canonname;
      q->ai_next = p;

      memset(sin6, 0, sizeof(*sin6));



      sin6->sin6_family = 10;
      sin6->sin6_port = port;
      KInetSocketAddress::stringToAddr(10, (*it).toString().latin1(),
                                       (void*)&sin6->sin6_addr);

      p = q;
    }


  for (it = v4.begin(); it != v4.end(); ++it)
    {
      addrinfo *q = new addrinfo;
      sockaddr_in *sin = new sockaddr_in;
      q->ai_flags = 0;
      q->ai_family = 2;
      q->ai_socktype = hint.ai_socktype;
      q->ai_protocol = hint.ai_protocol;
      q->ai_addrlen = sizeof(*sin);
      q->ai_addr = (sockaddr*)sin;
      q->ai_canonname = canonname;
      q->ai_next = p;

      memset(sin, 0, sizeof(*sin));



      sin->sin_family = 2;
      sin->sin_port = port;
      *(Q_UINT32*)&sin->sin_addr = htonl((*it).ip4Addr());

      p = q;
    }

  res->data = p;
  return res;
}

void KExtendedSocketLookup::freeresults(kde_addrinfo *res)
{
  addrinfo *ai = res->data;
  if (ai == __null)
    return;

  if (ai->ai_canonname)
    free(ai->ai_canonname);
  while (ai)
    {
      struct addrinfo *ai2 = ai;

      if (ai->ai_addr != __null)
        delete ai->ai_addr;

      ai = ai->ai_next;
      delete ai2;
    }
  delete res;
}






KExtendedSocket::KExtendedSocket() :
  sockfd(-1), d(new KExtendedSocketPrivate)
{
}


KExtendedSocket::KExtendedSocket(const QString& host, int port, int flags) :
  sockfd(-1), d(new KExtendedSocketPrivate)
{
  setAddress(host, port);
  setSocketFlags(flags);
}


KExtendedSocket::KExtendedSocket(const QString& host, const QString& service, int flags) :
  sockfd(-1), d(new KExtendedSocketPrivate)
{
  setAddress(host, service);
  setSocketFlags(flags);
}


KExtendedSocket::~KExtendedSocket()
{
  closeNow();

  local_freeaddrinfo(d->resolution);
  local_freeaddrinfo(d->bindres);

  if (d->local != __null)
    delete d->local;
  if (d->peer != __null)
    delete d->peer;

  if (d->qsnIn != __null)
    delete d->qsnIn;
  if (d->qsnOut != __null)
    delete d->qsnOut;

  delete d;
}

void KExtendedSocket::reset()
{
  closeNow();
  release();
  d->current = 0;
  d->status = nothing;
  d->syserror = 0;
}

int KExtendedSocket::socketStatus() const
{
  return d->status;
}

void KExtendedSocket::setSocketStatus(int newstatus)
{
  d->status = newstatus;
}

void KExtendedSocket::setError(int errorcode, int syserror)
{
  setStatus(errorcode);
  d->syserror = syserror;
}

int KExtendedSocket::systemError() const
{
  return d->syserror;
}





int KExtendedSocket::setSocketFlags(int flags)
{
  if (d->status > nothing)
    return -1;

  return d->flags = flags;
}

int KExtendedSocket::socketFlags() const
{
  return d->flags;
}





bool KExtendedSocket::setHost(const QString& host)
{
  if (d->status > nothing)
    return false;

  d->host = host;
  return true;
}




QString KExtendedSocket::host() const
{
  return d->host;
}





bool KExtendedSocket::setPort(int port)
{
  return setPort(QString::number(port));
}

bool KExtendedSocket::setPort(const QString& service)
{
  if (d->status > nothing)
    return false;

  d->service = service;
  return true;
}




QString KExtendedSocket::port() const
{
  return d->service;
}




bool KExtendedSocket::setAddress(const QString& host, int port)
{
  return setHost(host) && setPort(port);
}




bool KExtendedSocket::setAddress(const QString& host, const QString& serv)
{
  return setHost(host) && setPort(serv);
}






bool KExtendedSocket::setBindHost(const QString& host)
{
  if (d->status > nothing || d->flags & passiveSocket)
    return false;

  d->localhost = host;
  return true;
}





bool KExtendedSocket::unsetBindHost()
{
  if (d->status > nothing || d->flags & passiveSocket)
    return false;

  d->localhost.truncate(0);
  return true;
}




QString KExtendedSocket::bindHost() const
{
  return d->localhost;
}





bool KExtendedSocket::setBindPort(int port)
{
  return setBindPort(QString::number(port));
}

bool KExtendedSocket::setBindPort(const QString& service)
{
  if (d->status > nothing || d->flags & passiveSocket)
    return false;

  d->localservice = service;
  return true;
}




bool KExtendedSocket::unsetBindPort()
{
  if (d->status > nothing || d->flags & passiveSocket)
    return false;

  d->localservice.truncate(0);
  return true;
}




QString KExtendedSocket::bindPort() const
{
  return d->localservice;
}




bool KExtendedSocket::setBindAddress(const QString& host, int port)
{
  return setBindHost(host) && setBindPort(port);
}




bool KExtendedSocket::setBindAddress(const QString& host, const QString& service)
{
  return setBindHost(host) && setBindPort(service);
}




bool KExtendedSocket::unsetBindAddress()
{
  return unsetBindHost() && unsetBindPort();
}




bool KExtendedSocket::setTimeout(int secs, int usecs)
{
  if (d->status >= connected)
    return false;

  d->timeout.tv_sec = secs;
  d->timeout.tv_usec = usecs;
  return true;
}




timeval KExtendedSocket::timeout() const
{
  return d->timeout;
}




bool KExtendedSocket::setBlockingMode(bool enable)
{
  cleanError();
  if (d->status < created)
    return false;

  if (sockfd == -1)
    return false;

  int fdflags = fcntl(sockfd, 3, 0);
  if (fdflags == -1)
    return false;

  if (!enable)
    fdflags |= 04000;
  else
    fdflags &= ~04000;

  if (fcntl(sockfd, 4, fdflags) == -1)
    {
      setError(8, (*__errno_location ()));
      return false;
    }
  return true;
}




bool KExtendedSocket::blockingMode()
{
  cleanError();
  if (d->status < created)
    return false;

  if (sockfd == -1)
    return false;

  int fdflags = fcntl(sockfd, 3, 0);
  if (fdflags == -1)
    {
      setError(8, (*__errno_location ()));
      return false;
    }
  return (fdflags & 04000) == 0;
}




bool KExtendedSocket::setAddressReusable(bool enable)
{
  cleanError();
  d->addressReusable = enable;
  if (d->status < created)
    return true;

  if (sockfd == -1)
    return true;

  if (!setAddressReusable(sockfd, enable))
    {
      setError(8, (*__errno_location ()));
      return false;
    }
  return true;
}

bool KExtendedSocket::setAddressReusable(int fd, bool enable)
{
  if (fd == -1)
    return false;

  int on = enable;

  if (setsockopt(fd, 1, 2, (char*)&on, sizeof(on)) == -1)
    return false;
  return true;
}




bool KExtendedSocket::addressReusable()
{
  cleanError();
  if (d->status < created)
    return d->addressReusable;

  if (sockfd == -1)
    return d->addressReusable;

  int on;
  socklen_t onsiz = sizeof(on);
  if (getsockopt(sockfd, 1, 2, (char*)&on, &onsiz) == -1)
    {
      setError(8, (*__errno_location ()));
      return false;
    }

  return on != 0;
}




bool KExtendedSocket::setIPv6Only(bool enable)
{
# 810 "/coolo/prod/kdelibs/kdecore/kextsock.cpp"
  d->ipv6only = enable;

  setError(8, 38);
  return false;

}




bool KExtendedSocket::isIPv6Only()
{
# 841 "/coolo/prod/kdelibs/kdecore/kextsock.cpp"
  setError(8, 38);
  return false;

}





bool KExtendedSocket::setBufferSize(int rsize, int wsize)
{
  cleanError();
  if (d->status < created)
    return false;

  if (sockfd == -1)
    return false;

  if (d->flags & passiveSocket)
    return false;

  if (rsize < -2)
    return false;

  if (wsize < -2)
    return false;






  if (d->qsnIn == __null)
    {
      d->qsnIn = new QSocketNotifier(sockfd, QSocketNotifier::Read);
      QObject::connect(d->qsnIn, "2""activated(int)", this, "1""socketActivityRead()");
      d->qsnIn->setEnabled(true);
    }

  if (rsize == 0 && d->flags & inputBufferedSocket)
    {

      d->flags &= ~inputBufferedSocket;

      consumeReadBuffer(readBufferSize(), __null, true);
      d->inMaxSize = 0;
    }
  else if (rsize != -2)
    {

      if (rsize)
        d->flags |= inputBufferedSocket;
      d->inMaxSize = rsize;

      if (rsize > 0 && (unsigned)rsize < readBufferSize())

        consumeReadBuffer(readBufferSize() - rsize, __null, true);

    }

  if (wsize == 0 && d->flags & outputBufferedSocket)
    {

      d->flags &= ~outputBufferedSocket;
      if (d->qsnOut && !d->emitWrite)
        d->qsnOut->setEnabled(false);
      consumeWriteBuffer(writeBufferSize());
      d->outMaxSize = 0;
    }
  else if (wsize != -2)
    {

      if (wsize)
        d->flags |= outputBufferedSocket;
      d->outMaxSize = wsize;

      if (wsize > 0 && (unsigned)wsize < writeBufferSize())

        consumeWriteBuffer(writeBufferSize() - wsize);

      if (d->qsnOut == __null)
        {
          d->qsnOut = new QSocketNotifier(sockfd, QSocketNotifier::Write);
          QObject::connect(d->qsnOut, "2""activated(int)", this, "1""socketActivityWrite()");



        }
    }



  setFlags((mode() & ~0x0040) | ((d->flags & bufferedSocket) ? 0 : 0x0040));


  if (d->emitWrite && d->qsnOut == __null)
    {
      d->qsnOut = new QSocketNotifier(sockfd, QSocketNotifier::Write);
      QObject::connect(d->qsnOut, "2""activated(int)", this, "1""socketActivityWrite()");
    }

  return true;
}






const KSocketAddress *KExtendedSocket::localAddress()
{
  if (d->local != __null)
    return d->local;
  if (d->status < bound)
    return __null;

  return d->local = localAddress(sockfd);
}






const KSocketAddress* KExtendedSocket::peerAddress()
{
  if (d->peer != __null)
    return d->peer;
  if (d->flags & passiveSocket || d->status < connected)
    return __null;

  return d->peer = peerAddress(sockfd);
}




int KExtendedSocket::lookup()
{
  cleanError();
  if (d->status >= lookupInProgress)
    return -1;

  addrinfo hint;

  memset(&hint, 0, sizeof(hint));
  hint.ai_family = 0;


  if (d->resolution == __null)
    {

      if (!process_flags(d->flags, hint))
        return -1;

      int err = doLookup(d->host, d->service, hint, &d->resolution);
      if (err != 0)
        {
          setError((8 +3), err);
          return err;
        }
    }

  if (d->bindres == __null && (d->localhost.length() > 0 || d->localservice.length() > 0))
    {

      hint.ai_flags |= 0x0001;

      int err = doLookup(d->localhost, d->localservice, hint, &d->bindres);
      if (err != 0)
        {
          setError((8 +3), err);
          return err;
        }
    }

  d->status = lookupDone;
  return 0;
}




int KExtendedSocket::startAsyncLookup()
{
  cleanError();
  if (d->status > lookupInProgress)
    return -1;
  if (d->status == lookupInProgress)

    return 0;

  addrinfo hint;
  memset(&hint, 0, sizeof(hint));
  hint.ai_family = 0;

  if (!process_flags(d->flags, hint))
    return -1;

  int n = 0;
  if (d->host.length() > 0)
    {
      if ((d->flags & noResolve) == 0)
        {
          d->dns = new KExtendedSocketLookup(d->host, d->service, hint);
          QObject::connect(d->dns, "2""resultsReady()", this, "1""dnsResultsReady()");
          n++;
        }
      else
        {
          int err = doLookup(d->host, d->service, hint, &d->resolution);
          if (err != 0)
            {
              setError((8 +3), err);
              return -1;
            }
        }
    }

  if (d->localhost.length() > 0)
    {
      if ((d->flags & noResolve) == 0)
        {
          hint.ai_flags |= 0x0001;
          d->dnsLocal = new KExtendedSocketLookup(d->localhost, d->localservice, hint);
          QObject::connect(d->dnsLocal, "2""resultsReady()", this, "1""dnsResultsReady()");
          n++;
        }
      else
        {
          int err = doLookup(d->localhost, d->localservice, hint, &d->bindres);
          if (err != 0)
            {

              setError((8 +3), err);
              if (d->dns != __null)
                {
                  delete d->dns;
                  d->dns = __null;
                }
              return -1;
            }
        }
    }


  if (n)
    d->status = lookupInProgress;
  else
    {
      d->status = lookupDone;
      lookupFinished(n);
    }
  return 0;
}

void KExtendedSocket::cancelAsyncLookup()
{
  cleanError();
  if (d->status != lookupInProgress)
    return;

  d->status = nothing;
  if (d->dns)
    {
      delete d->dns;
      d->dns = 0;
    }

  if (d->dnsLocal)
    {
      delete d->dnsLocal;
      d->dnsLocal = 0;
    }

  local_freeaddrinfo(d->resolution);
  local_freeaddrinfo(d->bindres);
}

int KExtendedSocket::listen(int N)
{
  cleanError();
  if ((d->flags & passiveSocket) == 0 || d->status >= listening)
    return -2;
  if (d->status < lookupDone)
    if (lookup() != 0)
      return -2;
  if (!d->resolution) return -2;

  addrinfo *p;


  for (p = d->resolution->data; p; p = p->ai_next)
    {

      if (!valid_family(p, d->flags))
        continue;


      sockfd = ::socket(p->ai_family, p->ai_socktype, p->ai_protocol);
      if (sockfd == -1)
        {

          kdDebug(170) << "Failed to create: " << perror << endl;
          continue;
        }

      if (d->addressReusable)
        setAddressReusable(sockfd, true);
      setIPv6Only(d->ipv6only);
      cleanError();
      if (KSocks::self()->bind(sockfd, p->ai_addr, p->ai_addrlen) == -1)
        {
          kdDebug(170) << "Failed to bind: " << perror << endl;
          ::close(sockfd);
          sockfd = -1;
          continue;
        }




      d->status = bound;
      break;
    }

  if (sockfd == -1)
    {
      setError((8 +1), (*__errno_location ()));
      kdDebug(170) << "Listen error - sockfd is -1 " << endl;
      return -1;
    }

  d->status = bound;
  setFlags(0x0200 | 0x0040 | 0x0003);

  int retval = KSocks::self()->listen(sockfd, N);
  if (retval == -1)
    setError((8 +1), (*__errno_location ()));
  else
    {
      d->status = listening;
      d->qsnIn = new QSocketNotifier(sockfd, QSocketNotifier::Read);
      QObject::connect(d->qsnIn, "2""activated(int)", this, "1""socketActivityRead()");
    }
  return retval == -1 ? -1 : 0;
}

int KExtendedSocket::accept(KExtendedSocket *&sock)
{
  cleanError();
  sock = __null;
  if ((d->flags & passiveSocket) == 0 || d->status >= accepting)
    return -2;
  if (d->status < listening)
    if (listen() < 0)
      return -2;




  bool block = blockingMode();
  struct sockaddr sa;
  ksocklen_t len = sizeof(sa);
  sock = __null;

  if (d->timeout.tv_sec > 0 || d->timeout.tv_usec > 0)
    {
      fd_set set;

      setBlockingMode(false);
      memset ((void*)&set, 0, sizeof(set));
      FD_SET(sockfd, &set);




      int retval = KSocks::self()->select(sockfd + 1, &set, __null, __null, &d->timeout);
      if (retval == -1)
        {
          setError(8, (*__errno_location ()));
          return -1;
        }
      else if (retval == 0 || !FD_ISSET (sockfd, &set))
        {
          setError(7, 0);
          return -3;
        }
    }


  int newfd = KSocks::self()->accept(sockfd, &sa, &len);

  if (newfd == -1)
    {
      setError((8 +2), (*__errno_location ()));
      kdWarning(170) << "Error accepting on socket " << sockfd << ":"
                     << perror << endl;
      return -1;
    }



  setBlockingMode(block);

  sock = new KExtendedSocket;
  sock->d->status = connected;
  sock->sockfd = newfd;
  sock->setFlags(0x0200 | 0x0040 | 0x0003 | 0x1000 | 0x0080);
  sock->setBufferSize(0, 0);

  return 0;
}







int KExtendedSocket::connect()
{
  cleanError();
  if (d->flags & passiveSocket || d->status >= connected)
    return -2;
  if (d->status < lookupDone)
    if (lookup() != 0)
      return -2;
  if (!d->resolution) return -2;

  addrinfo *p, *q;
  timeval end, now;






  bool doingtimeout = d->timeout.tv_sec > 0 || d->timeout.tv_usec > 0;
  if (doingtimeout)
    {
      gettimeofday(&end, __null);
      end.tv_usec += d->timeout.tv_usec;
      end.tv_sec += d->timeout.tv_sec;
      if (end.tv_usec > 1000*1000)
        {
          end.tv_usec -= 1000*1000;
          end.tv_sec++;
        }


    }

  if (d->bindres)
    q = d->bindres->data;
  else
    q = __null;
  for (p = d->resolution->data; p; p = p->ai_next)
    {

      if (!valid_family(p, d->flags))
        continue;


      if (q != __null)
        {

          if (q->ai_family != p->ai_family)

            for (q = d->bindres->data; q; q = q->ai_next)
              if (q->ai_family == p->ai_family)
                break;

          if (q == __null || q->ai_family != p->ai_family)
            {

              kdDebug(170) << "No matching family for bind socket\n";
              q = d->bindres->data;
              continue;
            }

          kdDebug(170) << "Binding on " << pretty_sock(q) << " before connect" << endl;
          (*__errno_location ()) = 0;
          sockfd = ::socket(p->ai_family, p->ai_socktype, p->ai_protocol);
          setError(5, (*__errno_location ()));
          if (sockfd == -1)
            continue;
          if (d->addressReusable)
            setAddressReusable(sockfd, true);
          setIPv6Only(d->ipv6only);
          cleanError();
          if (KSocks::self()->bind(sockfd, q->ai_addr, q->ai_addrlen) == -1)
            {
              kdDebug(170) << "Bind failed: " << perror << endl;
              ::close(sockfd);
              sockfd = -1;
              continue;
            }
        }
      else
        {

          sockfd = ::socket(p->ai_family, p->ai_socktype, p->ai_protocol);
          if (sockfd == -1)
            {
              setError(5, (*__errno_location ()));
              continue;
            }
          if (d->addressReusable)
            setAddressReusable(sockfd, true);
          setIPv6Only(d->ipv6only);
          cleanError();
        }


      d->status = created;


      if (doingtimeout && KSocks::self()->hasWorkingAsyncConnect())
        {
          fd_set rd, wr;

          setBlockingMode(false);


          if (KSocks::self()->connect(sockfd, p->ai_addr, p->ai_addrlen) == -1)
            {

              if ((*__errno_location ()) != 11 && (*__errno_location ()) != 115)
                {
                  kdDebug(170) << "Socket " << sockfd << " did not connect: " << perror << endl;
                  setError(5, (*__errno_location ()));
                  ::close(sockfd);
                  sockfd = -1;
                  continue;
                }

              memset ((void*)&rd, 0, sizeof(rd));
              memset ((void*)&wr, 0, sizeof(wr));
	      FD_SET (sockfd, &rd);
	      FD_SET (sockfd, &wr);

              int retval = KSocks::self()->select(sockfd + 1, &rd, &wr, __null, &d->timeout);
              if (retval == -1)
                {
                  setError(3, (*__errno_location ()));
                  continue;
                }
              else if (retval == 0)
                {
                  ::close(sockfd);
                  sockfd = -1;
                  kdDebug(170) << "Time out while trying to connect to " <<
                    pretty_sock(p) << endl;
                  d->status = lookupDone;
                  setError(7, 0);
                  return -3;
                }


              gettimeofday(&now, __null);
              d->timeout.tv_sec = end.tv_sec - now.tv_sec;
              d->timeout.tv_usec = end.tv_usec - now.tv_usec;
              if (d->timeout.tv_usec < 0)
                {
                  d->timeout.tv_usec += 1000*1000;
                  d->timeout.tv_sec--;
                }




              int errcode;
              socklen_t len = sizeof(errcode);
              retval = getsockopt(sockfd, 1, 4, (char*)&errcode,
                                  &len);
              if (retval == -1 || errcode != 0)
                {

                  kdDebug(170) << "Socket " << sockfd << " did not connect: "
                            << strerror(errcode) << endl;
                  ::close(sockfd);
                  sockfd = -1;


                  if (d->timeout.tv_sec == 0 && d->timeout.tv_usec == 0)
                    {
                      d->status = lookupDone;
                      setError(7, 0);
                      return -3;
                    }

                  setError(5, errcode);
                  continue;
                }
            }



          setBlockingMode(true);
          d->status = connected;
          setFlags(0x0200 | 0x0040 | 0x0003 | 0x1000 | 0x0080);
          setBufferSize(d->flags & inputBufferedSocket ? -1 : 0,
                        d->flags & outputBufferedSocket ? -1 : 0);
          connectionSuccess();

          return 0;
        }
      else
        {

          if (KSocks::self()->connect(sockfd, p->ai_addr, p->ai_addrlen) == -1)
            {
              kdDebug(170) << "Socket " << sockfd << " did not connect: " << perror << endl;
              setError(5, (*__errno_location ()));
              ::close(sockfd);
              sockfd = -1;
              continue;
            }

          d->status = connected;
          setFlags(0x0200 | 0x0040 | 0x0003 | 0x1000 | 0x0080);
          setBufferSize(d->flags & inputBufferedSocket ? -1 : 0,
                        d->flags & outputBufferedSocket ? -1 : 0);
          connectionSuccess();

          return 0;
        }
    }


  connectionFailed(d->syserror);
  kdDebug(170) << "Failed to connect\n";
  return -1;
}

int KExtendedSocket::startAsyncConnect()
{
  cleanError();

  if (d->status >= connected || d->flags & passiveSocket)
    return -2;

  if (d->status == connecting)

    return 0;




  if (d->status < lookupDone)
    {
      QObject::connect(this, "2""lookupFinished(int)", this, "1""startAsyncConnectSlot()");
      if (d->status < lookupInProgress)
        return startAsyncLookup();
      else
        return 0;
    }



  d->status = connecting;
  QGuardedPtr<QObject> p = this;
  connectionEvent();
  if (!p)
    return -1;
  if (d->status < connecting)
    return -1;
  return 0;
}

void KExtendedSocket::cancelAsyncConnect()
{
  if (d->status != connecting)
    return;

  if (sockfd != -1)
    {

      if (d->qsnIn)
        delete d->qsnIn;
      if (d->qsnOut)
        delete d->qsnOut;
      d->qsnIn = d->qsnOut = __null;

      ::close(sockfd);
      sockfd = -1;
    }
  d->status = lookupDone;
}

bool KExtendedSocket::open(int mode)
{
  if (mode != 0x0040 | 0x0003)
    return false;

  if (d->flags & passiveSocket)
    return listen() == 0;
  else if (d->status < connecting)
    return connect() == 0;
  else
    return false;
}

void KExtendedSocket::close()
{
  if (sockfd == -1 || d->status >= closing)
    return;


  if (d->flags & outputBufferedSocket && writeBufferSize() > 0)
    {

      d->status = closing;
      if (d->qsnIn)
        delete d->qsnIn;
      d->qsnIn = __null;


    }
  else
    {


      if (d->qsnIn)
        delete d->qsnIn;
      if (d->qsnOut)
        delete d->qsnOut;
      d->qsnIn = d->qsnOut = __null;

      ::close(sockfd);
      d->status = done;
      closed(readBufferSize() != 0 ? availRead : 0);
    }

}


void KExtendedSocket::closeNow()
{
  if (d->status >= done)
    return;


  delete d->qsnIn;
  delete d->qsnOut;
  d->qsnIn = d->qsnOut = __null;

  if (d->status > connecting && sockfd != -1)
    {
      ::close(sockfd);
      sockfd = -1;
    }
  else if (d->status == connecting)
    cancelAsyncConnect();
  else if (d->status == lookupInProgress)
    cancelAsyncLookup();

  d->status = done;

  closed(closedNow |
              (readBufferSize() != 0 ? availRead : 0) |
              (writeBufferSize() != 0 ? dirtyWrite : 0));
}

void KExtendedSocket::release()
{

  sockfd = -1;
  d->status = done;


  local_freeaddrinfo(d->resolution);
  local_freeaddrinfo(d->bindres);

  d->host = d->service = d->localhost = d->localservice = (const char *)0;

  if (d->local != __null)
    delete d->local;
  if (d->peer != __null)
    delete d->peer;

  d->peer = d->local = __null;

  if (d->qsnIn != __null)
    delete d->qsnIn;
  if (d->qsnOut != __null)
    delete d->qsnOut;

  d->qsnIn = d->qsnOut = __null;


  consumeReadBuffer(readBufferSize(), __null, true);
  consumeWriteBuffer(writeBufferSize());



}

void KExtendedSocket::flush()
{
  cleanError();
  if (d->status < connected || d->status >= done || d->flags & passiveSocket)
    return;

  if (sockfd == -1)
    return;

  if ((d->flags & outputBufferedSocket) == 0)
    return;



  unsigned written = 0;
  unsigned offset = outBufIndex;
  while (writeBufferSize() - written > 0)
    {





      QByteArray buf(16384);
      QByteArray *a = outBuf.first();
      unsigned count = 0;

      while (a && count + (a->size() - offset) < buf.size())
        {
          memcpy(buf.data() + count, a->data() + offset, a->size() - offset);
          offset = 0;
          count += a->size() - offset;
          a = outBuf.next();
        }


      int wrote = KSocks::self()->write(sockfd, buf, count);

      if (wrote == -1)
        {

          setError(2, (*__errno_location ()));
          break;
        }
      written += wrote;

      if ((unsigned)wrote != count)
        break;
    }
  if (written)
    {
      consumeWriteBuffer(written);
      bytesWritten(written);
    }


}


Q_LONG KExtendedSocket::readBlock(char *data, Q_ULONG maxlen)
{
  cleanError();
  if (d->status < connected || d->flags & passiveSocket)
    return -2;
  if (sockfd == -1)
    return -2;

  int retval;

  if ((d->flags & inputBufferedSocket) == 0)
    {



      if (data)
        retval = KSocks::self()->read(sockfd, data, maxlen);
      else
        retval = skipData(sockfd, maxlen);
      if (retval == -1)
        setError(1, (*__errno_location ()));
    }
  else
    {




      retval = consumeReadBuffer(maxlen, data);
      if (retval == 0)
        {


          setError(1, 11);
          retval = -1;
        }



    }
  return retval;
}

Q_LONG KExtendedSocket::writeBlock(const char *data, Q_ULONG len)
{
  cleanError();
  if (d->status < connected || d->status >= closing || d->flags & passiveSocket)
    return -2;
  if (sockfd == -1)
    return -2;

  if (len == 0)
    return 0;

  int retval;

  if ((d->flags & outputBufferedSocket) == 0)
    {

      retval = KSocks::self()->write(sockfd, data, len);
      if (retval == -1)
        setError(2, (*__errno_location ()));
      else
        bytesWritten(retval);
    }
  else
    {




      register unsigned wsize = writeBufferSize();
      if (d->outMaxSize == (int)wsize)
        {

          setError(2, 11);
          retval = -1;
        }
      else
        {
          if (d->outMaxSize != -1 && wsize + len > (unsigned)d->outMaxSize)

            len = d->outMaxSize - wsize;


          retval = feedWriteBuffer(len, data);
          if (wsize == 0 || d->emitWrite)

            d->qsnOut->setEnabled(true);
        }


    }

  return retval;
}

int KExtendedSocket::peekBlock(char *data, uint maxlen)
{
  if (d->status < connected || d->flags & passiveSocket)
    return -2;
  if (sockfd == -1)
    return -2;



  if (d->flags & inputBufferedSocket)
    return consumeReadBuffer(maxlen, data, false);

  return 0;
}

int KExtendedSocket::unreadBlock(const char *, uint)
{

  setError(1, 38);
  return -1;
}

int KExtendedSocket::bytesAvailable() const
{
  if (d->status < connected || d->status >= closing || d->flags & passiveSocket)
    return -2;



  if (d->flags & inputBufferedSocket)
    return KBufferedIO::bytesAvailable();

  return 0;
}

int KExtendedSocket::waitForMore(int msecs)
{
  cleanError();
  if (d->flags & passiveSocket || d->status < connected || d->status >= closing)
    return -2;
  if (sockfd == -1)
    return -2;

  fd_set rd;
  memset ((void*)&rd, 0, sizeof(rd));
  FD_SET (sockfd, &rd);
  timeval tv;
  tv.tv_sec = msecs / 1000;
  tv.tv_usec = (msecs % 1000) * 1000;

  int retval = KSocks::self()->select(sockfd + 1, &rd, __null, __null, &tv);
  if (retval == -1)
    {
      setError(3, (*__errno_location ()));
      return -1;
    }
  else if (retval != 0)
    socketActivityRead();

  return bytesAvailable();
}

int KExtendedSocket::getch()
{
  unsigned char c;
  int retval;
  retval = readBlock((char*)&c, sizeof(c));

  if (retval < 0)
    return retval;
  return c;
}

int KExtendedSocket::putch(int ch)
{
  unsigned char c = (char)ch;
  return writeBlock((char*)&c, sizeof(c));
}

int KExtendedSocket::doLookup(const QString &host, const QString &serv, addrinfo &hint,
                              kde_addrinfo** res)
{
  int err;

  QCString _host;
  QCString _serv;
  if (!host.isNull())
    _host = KIDNA::toAsciiCString(host);
  if (!serv.isNull())
    _serv = serv.latin1();


  err = kde_getaddrinfo(_host, _serv, &hint, res);


  if (err == -2 || err == -5 || err == -3)
    {




      __res_init();


      err = kde_getaddrinfo(_host, _serv, &hint, res);
    }


  return err;
}


void KExtendedSocket::enableRead(bool enable)
{




  if (!enable && (d->flags & inputBufferedSocket) == 0 && d->qsnIn)
    d->qsnIn->setEnabled(false);
  else if (enable && d->qsnIn)

    d->qsnIn->setEnabled(true);
  d->emitRead = enable;
}


void KExtendedSocket::enableWrite(bool enable)
{

  if (!enable && (d->flags & outputBufferedSocket) == 0 && d->qsnOut)
    d->qsnOut->setEnabled(false);
  else if (enable && d->qsnOut)

    d->qsnOut->setEnabled(true);
  d->emitWrite = enable;
}



void KExtendedSocket::socketActivityRead()
{
  if (d->flags & passiveSocket)
    {
      readyAccept();
      return;
    }
  if (d->status == connecting)
    {
      connectionEvent();
      return;
    }
  if (d->status != connected)
    return;


  if (d->flags & inputBufferedSocket)
    {

      QByteArray a;
      char buf[1024];
      int len, totalread = 0;



      unsigned cursize = readBufferSize();

      if (d->inMaxSize == -1 || cursize < (unsigned)d->inMaxSize)
        {
          do
            {

              if (d->inMaxSize != -1 && d->inMaxSize - (cursize + totalread) < sizeof(buf))


                len = d->inMaxSize - (cursize + totalread);
              else
                len = sizeof(buf);

              len = KSocks::self()->read(sockfd, buf, len);
              if (len > 0)
                {

                  a.resize(a.size() + len);
                  memcpy(a.data() + totalread, buf, len);
                  totalread += len;
                }
              else if (len == 0)
                {

                  ::close(sockfd);
                  sockfd = -1;
                  d->qsnIn->deleteLater();
                  delete d->qsnOut;
                  d->qsnIn = d->qsnOut = __null;
                  d->status = done;
                  closed(involuntary |
                              (readBufferSize() ? availRead : 0) |
                              (writeBufferSize() ? dirtyWrite : 0));
                  return;
                }
              else
                {

                  setError(1, (*__errno_location ()));
                  return;
                }

            }
          while (len == sizeof(buf));

          feedReadBuffer(a.size(), a.data());
        }


    }
  else
    {






      char c;
      int len = KSocks::self()->recv(sockfd, &c, sizeof(c), MSG_PEEK);
      if (len == 0)
        {

          d->qsnIn->setEnabled(false);
          ::close(sockfd);
          sockfd = -1;
          d->status = done;
          closed(involuntary);
          return;
        }
    }

  if (d->emitRead)
    readyRead();
}

void KExtendedSocket::socketActivityWrite()
{
  if (d->flags & passiveSocket)
    return;
  if (d->status == connecting)
    {
      connectionEvent();
      return;
    }
  if (d->status != connected && d->status != closing)
    return;

  flush();

  bool empty = writeBufferSize() == 0;

  if (d->emitWrite && empty)
    readyWrite();
  else if (!d->emitWrite)
    {

      d->qsnOut->setEnabled(!empty);
    }
  if (d->status == closing && empty)
    {

      d->status = done;

      delete d->qsnOut;
      ::close(sockfd);

      d->qsnOut = __null;
      sockfd = -1;
      closed(delayed | (readBufferSize() ? availRead : 0));
    }
}




void KExtendedSocket::connectionEvent()
{
  if (d->status != connecting)
    return;
  if (d->resolution == 0 || d->resolution->data == 0)
    {

      kdError(170) << "KExtendedSocket::connectionEvent() called but no data available!\n";
      return;
    }

  int errcode = 0;

  if (sockfd != -1)
    {


      int retval;
      socklen_t len = sizeof(errcode);
      retval = getsockopt(sockfd, 1, 4, (char*)&errcode, &len);

      if (retval == -1 || errcode != 0)
        {


          if (d->qsnIn)
            delete d->qsnIn;
          if (d->qsnOut)
            delete d->qsnOut;
          ::close(sockfd);

          sockfd = -1;
          d->qsnIn = d->qsnOut = __null;
          setError(5, errcode);
        }
      else
        {



          cleanError();
          d->status = connected;
          setBlockingMode(true);
          setFlags(0x0200 | 0x0040 | 0x0003 | 0x1000 | 0x0080);
          setBufferSize(d->flags & inputBufferedSocket ? -1 : 0,
                        d->flags & outputBufferedSocket ? -1 : 0);
          connectionSuccess();
          return;
        }
    }



  addrinfo *p, *q = __null;
  if (d->current == 0)
    p = d->current = d->resolution->data;
  else
    p = d->current->ai_next;
  if (d->bindres)
    q = d->bindres->data;
  for ( ; p; p = p->ai_next)
    {

      if (q != __null)
        {
          if (q->ai_family != d->current->ai_family)

            for (q = d->bindres->data; q; q = q->ai_next)
              if (q->ai_family == p->ai_family)
                break;

          if (q == __null || q->ai_family != p->ai_family)
            {

              q = d->bindres->data;
              continue;
            }

          (*__errno_location ()) = 0;
          sockfd = ::socket(p->ai_family, p->ai_socktype, p->ai_protocol);
          setError(5, (*__errno_location ()));
          errcode = (*__errno_location ());
          if (sockfd == -1)
            continue;
          if (d->addressReusable)
            setAddressReusable(sockfd, true);
          setIPv6Only(d->ipv6only);
          cleanError();
          if (KSocks::self()->bind(sockfd, q->ai_addr, q->ai_addrlen) == -1)
            {
              ::close(sockfd);
              sockfd = -1;
              continue;
            }
        }
      else
        {

          sockfd = ::socket(p->ai_family, p->ai_socktype, p->ai_protocol);
          if (sockfd == -1)
            {
              setError(5, (*__errno_location ()));
              errcode = (*__errno_location ());
              continue;
            }
          if (d->addressReusable)
            setAddressReusable(sockfd, true);
          setIPv6Only(d->ipv6only);
          cleanError();
        }

      if (KSocks::self()->hasWorkingAsyncConnect())
        setBlockingMode(false);
      if (KSocks::self()->connect(sockfd, p->ai_addr, p->ai_addrlen) == -1)
        {
          if ((*__errno_location ()) != 11 && (*__errno_location ()) != 115)
            {
              setError(5, (*__errno_location ()));
              ::close(sockfd);
              sockfd = -1;
              errcode = (*__errno_location ());
              continue;
            }



          d->qsnIn = new QSocketNotifier(sockfd, QSocketNotifier::Read);
          QObject::connect(d->qsnIn, "2""activated(int)", this, "1""socketActivityRead()");
          d->qsnOut = new QSocketNotifier(sockfd, QSocketNotifier::Write);
          QObject::connect(d->qsnOut, "2""activated(int)", this, "1""socketActivityWrite()");



          d->current = p;
          return;
        }





      cleanError();
      d->status = connected;
      setBlockingMode(true);
      setFlags(0x0200 | 0x0040 | 0x0003 | 0x1000 | 0x0080);
      setBufferSize(d->flags & inputBufferedSocket ? -1 : 0,
                    d->flags & outputBufferedSocket ? -1 : 0);
      connectionSuccess();
      return;
    }


  d->status = lookupDone;
  connectionFailed(errcode);
}

void KExtendedSocket::dnsResultsReady()
{

  if (d->status != lookupInProgress)
    return;


  if ((d->dns != __null && d->dns->isWorking()) ||
      (d->dnsLocal != __null && d->dnsLocal->isWorking()))

    return;



  int n = 0;
  addrinfo *p;

  if (d->dns)
    {
      d->resolution = d->dns->results();
      for (p = d->resolution->data; p; p = p->ai_next)
        n++;
    }

  if (d->dnsLocal)
    {
      d->bindres = d->dnsLocal->results();
      for (p = d->bindres->data; p; p = p->ai_next)
        n++;
    }

  if (n)
    {
      d->status = lookupDone;
      cleanError();
    }
  else
    {
      d->status = nothing;
      setError((8 +3), -5);
    }

  lookupFinished(n);

  return;
}

void KExtendedSocket::startAsyncConnectSlot()
{
  QObject::disconnect(this, "2""lookupFinished(int)", this, "1""startAsyncConnectSlot()");

  if (d->status == lookupDone)
    startAsyncConnect();
}

int KExtendedSocket::resolve(sockaddr *sock, ksocklen_t len, QString &host,
                             QString &port, int flags)
{
  int err;
  char h[1025], s[32];

  h[0] = s[0] = '\0';

  err = getnameinfo(sock, len, h, sizeof(h) - 1, s, sizeof(s) - 1, flags);
  host = QString::fromUtf8(h);
  port = QString::fromUtf8(s);

  return err;
}

int KExtendedSocket::resolve(KSocketAddress *sock, QString &host, QString &port,
                             int flags)
{
  return resolve(sock->data, sock->datasize, host, port, flags);
}

QPtrList<KAddressInfo> KExtendedSocket::lookup(const QString& host, const QString& port,
                                            int flags, int *error)
{
  int err;
  addrinfo hint, *p;
  kde_addrinfo *res;
  QPtrList<KAddressInfo> l;

  memset(&hint, 0, sizeof(hint));
  if (!process_flags(flags, hint))
    {
      if (error)
        *error = -1;
      return l;
    }


  err = doLookup(host, port, hint, &res);
  if (err)
    {
      if (error)
        *error = err;
      return l;
    }

  for (p = res->data; p; p = p->ai_next)
    if (valid_family(p, flags))
      {
        KAddressInfo *ai = new KAddressInfo(p);


        l.append(ai);
      }

  if ( error )
      *error = 0;

  kde_freeaddrinfo(res);
  return l;
}

KSocketAddress *KExtendedSocket::localAddress(int fd)
{
  KSocketAddress *local;
  struct sockaddr static_sa, *sa = &static_sa;
  ksocklen_t len = sizeof(static_sa);





  if (KSocks::self()->getsockname(fd, sa, &len) == -1)
    return __null;


  if (len > sizeof(static_sa)



      )
    {







      sa = (sockaddr*)malloc(len);
      if (sa == __null)
        return __null;

      if (KSocks::self()->getsockname(fd, sa, &len) == -1)
        {
          free(sa);
          return __null;
        }

      local = KSocketAddress::newAddress(sa, len);
      free(sa);
    }
  else
    local = KSocketAddress::newAddress(sa, len);

  return local;
}



KSocketAddress *KExtendedSocket::peerAddress(int fd)
{
  KSocketAddress *peer;
  struct sockaddr static_sa, *sa = &static_sa;
  ksocklen_t len = sizeof(static_sa);





  if (KSocks::self()->getpeername(fd, sa, &len) == -1)
    return __null;


  if (len > sizeof(static_sa)



      )
    {







      sa = (sockaddr*)malloc(len);
      if (sa == __null)
        return __null;

      if (KSocks::self()->getpeername(fd, sa, &len) == -1)
        {
          free(sa);
          return __null;
        }

      peer = KSocketAddress::newAddress(sa, len);
      free(sa);
    }
  else
    peer = KSocketAddress::newAddress(sa, len);

  return peer;
}

QString KExtendedSocket::strError(int code, int syserr)
{
  const char * msg;
  if (code == (8 +3))
    msg = gai_strerror(syserr);
  else
    msg = strerror(syserr);

  return QString::fromLocal8Bit(msg);
}


QSocketNotifier *KExtendedSocket::readNotifier() { return d->qsnIn; }
QSocketNotifier *KExtendedSocket::writeNotifier() { return d->qsnOut; }





KAddressInfo::KAddressInfo(addrinfo *p)
{
   ai = (addrinfo *) malloc(sizeof(addrinfo));
   memcpy(ai, p, sizeof(addrinfo));
   ai->ai_next = __null;
   if (p->ai_canonname)
   {
      ai->ai_canonname = (char *) malloc(strlen(p->ai_canonname)+1);
      strcpy(ai->ai_canonname, p->ai_canonname);
   }
   if (p->ai_addr && p->ai_addrlen)
   {
      ai->ai_addr = (struct sockaddr *) malloc(p->ai_addrlen);
      memcpy(ai->ai_addr, p->ai_addr, p->ai_addrlen);
   }
   else
   {
      ai->ai_addr = 0;
      ai->ai_addrlen = 0;
   }

   addr = KSocketAddress::newAddress(ai->ai_addr, ai->ai_addrlen);
}

KAddressInfo::~KAddressInfo()
{
  if (ai && ai->ai_canonname)
    free(ai->ai_canonname);

  if (ai && ai->ai_addr)
    free(ai->ai_addr);

  if (ai)
    free(ai);
  delete addr;
}

int KAddressInfo::flags() const
{
  return ai->ai_flags;
}

int KAddressInfo::family() const
{
  return ai->ai_family;
}

int KAddressInfo::socktype() const
{
  return ai->ai_socktype;
}

int KAddressInfo::protocol() const
{
  return ai->ai_protocol;
}

const char* KAddressInfo::canonname() const
{
  return ai->ai_canonname;
}

void KExtendedSocket::virtual_hook( int id, void* data )
{ KBufferedIO::virtual_hook( id, data ); }

# 1 "../kdecore/kextsock.moc" 1
# 11 "../kdecore/kextsock.moc"
# 1 "../../../prod/kdelibs/kdecore/kextsock.h" 1
# 12 "../kdecore/kextsock.moc" 2
# 22 "../kdecore/kextsock.moc"
const char *KExtendedSocket::className() const
{
    return "KExtendedSocket";
}

QMetaObject *KExtendedSocket::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KExtendedSocket( "KExtendedSocket", &KExtendedSocket::staticMetaObject );
# 50 "../kdecore/kextsock.moc"
QMetaObject* KExtendedSocket::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KBufferedIO::staticMetaObject();
    static const QUMethod slot_0 = {"socketActivityRead", 0, 0 };
    static const QUMethod slot_1 = {"socketActivityWrite", 0, 0 };
    static const QUMethod slot_2 = {"dnsResultsReady", 0, 0 };
    static const QUMethod slot_3 = {"startAsyncConnectSlot", 0, 0 };
    static const QUMethod slot_4 = {"connectionEvent", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "socketActivityRead()", &slot_0, QMetaData::Protected },
        { "socketActivityWrite()", &slot_1, QMetaData::Protected },
        { "dnsResultsReady()", &slot_2, QMetaData::Protected },
        { "startAsyncConnectSlot()", &slot_3, QMetaData::Protected },
        { "connectionEvent()", &slot_4, QMetaData::Protected }
    };
    static const QUParameter param_signal_0[] = {
        { "count", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_0 = {"lookupFinished", 1, param_signal_0 };
    static const QUMethod signal_1 = {"connectionSuccess", 0, 0 };
    static const QUParameter param_signal_2[] = {
        { "error", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_2 = {"connectionFailed", 1, param_signal_2 };
    static const QUMethod signal_3 = {"readyAccept", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "lookupFinished(int)", &signal_0, QMetaData::Public },
        { "connectionSuccess()", &signal_1, QMetaData::Public },
        { "connectionFailed(int)", &signal_2, QMetaData::Public },
        { "readyAccept()", &signal_3, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KExtendedSocket", parentObject,
        slot_tbl, 5,
        signal_tbl, 4,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KExtendedSocket.setMetaObject( metaObj );
    return metaObj;
}

void* KExtendedSocket::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KExtendedSocket" ) )
        return this;
    return KBufferedIO::qt_cast( clname );
}


void KExtendedSocket::lookupFinished( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 0, t0 );
}


void KExtendedSocket::connectionSuccess()
{
    activate_signal( staticMetaObject()->signalOffset() + 1 );
}


void KExtendedSocket::connectionFailed( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 2, t0 );
}


void KExtendedSocket::readyAccept()
{
    activate_signal( staticMetaObject()->signalOffset() + 3 );
}

bool KExtendedSocket::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: socketActivityRead(); break;
    case 1: socketActivityWrite(); break;
    case 2: dnsResultsReady(); break;
    case 3: startAsyncConnectSlot(); break;
    case 4: connectionEvent(); break;
    default:
        return KBufferedIO::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KExtendedSocket::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: lookupFinished((int)static_QUType_int.get(_o+1)); break;
    case 1: connectionSuccess(); break;
    case 2: connectionFailed((int)static_QUType_int.get(_o+1)); break;
    case 3: readyAccept(); break;
    default:
        return KBufferedIO::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KExtendedSocket::qt_property( int id, int f, QVariant* v)
{
    return KBufferedIO::qt_property( id, f, v);
}

bool KExtendedSocket::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 2530 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 2
# 1 "../kdecore/kextsocklookup.moc" 1
# 11 "../kdecore/kextsocklookup.moc"
# 1 "../../../prod/kdelibs/kdecore/kextsocklookup.h" 1
# 12 "../kdecore/kextsocklookup.moc" 2
# 22 "../kdecore/kextsocklookup.moc"
const char *KExtendedSocketLookup::className() const
{
    return "KExtendedSocketLookup";
}

QMetaObject *KExtendedSocketLookup::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KExtendedSocketLookup( "KExtendedSocketLookup", &KExtendedSocketLookup::staticMetaObject );
# 50 "../kdecore/kextsocklookup.moc"
QMetaObject* KExtendedSocketLookup::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod slot_0 = {"slotResultsReady", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "slotResultsReady()", &slot_0, QMetaData::Public }
    };
    static const QUMethod signal_0 = {"resultsReady", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "resultsReady()", &signal_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KExtendedSocketLookup", parentObject,
        slot_tbl, 1,
        signal_tbl, 1,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KExtendedSocketLookup.setMetaObject( metaObj );
    return metaObj;
}

void* KExtendedSocketLookup::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KExtendedSocketLookup" ) )
        return this;
    return QObject::qt_cast( clname );
}


void KExtendedSocketLookup::resultsReady()
{
    activate_signal( staticMetaObject()->signalOffset() + 0 );
}

bool KExtendedSocketLookup::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotResultsReady(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KExtendedSocketLookup::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: resultsReady(); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KExtendedSocketLookup::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KExtendedSocketLookup::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 2531 "/coolo/prod/kdelibs/kdecore/kextsock.cpp" 2
# 66 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksockaddr.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/ksockaddr.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/ksockaddr.cpp" 2






# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 1 3 4
# 31 "/coolo/prod/kdelibs/kdecore/ksockaddr.cpp" 2





# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 37 "/coolo/prod/kdelibs/kdecore/ksockaddr.cpp" 2
# 52 "/coolo/prod/kdelibs/kdecore/ksockaddr.cpp"













#undef offsetof

# 83 "/coolo/prod/kdelibs/kdecore/ksockaddr.cpp"
KSocketAddress::KSocketAddress(const sockaddr* sa, ksocklen_t size)
{
    if ( !sa )
        init();
    else {
        data = (sockaddr*)malloc(size);
        if (data == __null)
            return;
        memcpy(data, sa, size);
        datasize = size;
        owndata = true;
    }
}

void KSocketAddress::init()
{
  data = __null;
  datasize = 0;
  owndata = false;
}

KSocketAddress::~KSocketAddress()
{
  if (owndata && data != __null)
    free(data);
}

QString KSocketAddress::pretty() const
{
  return i18n("<unknown socket>");
}

int KSocketAddress::family() const
{
  if (data != __null)
    return data->sa_family;
  return 0;
}


KSocketAddress* KSocketAddress::newAddress(const struct sockaddr* sa, ksocklen_t size)
{
  if (size == 0)
    {
      kdWarning() << "KSocketAddress::newAddress called with size = 0!\n";
      return __null;
    }


  if (size < (((size_t) &((sockaddr *)0)->sa_family) + sizeof(((sockaddr*)0)->sa_family)))
    {
      kdWarning() << "KSocketAddress::newAddress called with invalid size\n";
      return __null;
    }

  switch (sa->sa_family)
    {
    case 2:
      if (size >= sizeof(sockaddr_in))
        return new KInetSocketAddress((const sockaddr_in*)sa, size);
      return __null;


    case 10:
      if (size >= (((size_t) &((sockaddr_in6 *)0)->sin6_addr) + sizeof(((sockaddr_in6*)0)->sin6_addr)))
        return new KInetSocketAddress((const sockaddr_in6*)sa, size);
      return __null;


    case 1:
      return new KUnixSocketAddress((const sockaddr_un*)sa, size);
    }

  return new KSocketAddress(sa, size);
}

bool KSocketAddress::isEqual(const KSocketAddress& other) const
{
  switch(family())
  {
     case 2:
        return KInetSocketAddress::areEqualInet(*this, other, false);

     case 10:
        return KInetSocketAddress::areEqualInet6(*this, other, false);

     case 1:
        return KUnixSocketAddress::areEqualUnix(*this, other, false);
  }


  if (other.datasize != datasize)
    return false;
  return memcmp(data, other.data, datasize) == 0;
}

bool KSocketAddress::isCoreEqual(const KSocketAddress& other) const
{
  switch(family())
  {
     case 2:
        return KInetSocketAddress::areEqualInet(*this, other, true);

     case 10:
        return KInetSocketAddress::areEqualInet6(*this, other, true);

     case 1:
        return KUnixSocketAddress::areEqualUnix(*this, other, true);
  }

  return false;
}

QString KSocketAddress::nodeName() const
{
  return QString::null;
}

QString KSocketAddress::serviceName() const
{
  return QString::null;
}

int KSocketAddress::ianaFamily(int af)
{
  switch (af)
    {
    case 2:
      return 1;

    case 10:
      return 2;

    default:
      return 0;
    }
}

int KSocketAddress::fromIanaFamily(int iana)
{
  switch (iana)
    {
    case 1:
      return 2;

    case 2:
      return 10;

    default:
      return 0;
    }
}




class KInetSocketAddressPrivate
{
public:
  int sockfamily;
  sockaddr_in sin;

  sockaddr_in6 sin6;


  KInetSocketAddressPrivate() :
    sockfamily(0)
  {
    sin.sin_family = 2;
    sin.sin_port = 0;




    sin6.sin6_family = 10;
    sin6.sin6_port = 0;
    sin6.sin6_flowinfo = 0;

    sin6.sin6_scope_id = 0;





  }

};

KInetSocketAddress::KInetSocketAddress() :
  d(new KInetSocketAddressPrivate)
{
}

KInetSocketAddress::KInetSocketAddress(const KInetSocketAddress &other) :
  KSocketAddress(), d(new KInetSocketAddressPrivate)
{
  setAddress(other);
}

KInetSocketAddress::KInetSocketAddress(const sockaddr_in* sin, ksocklen_t len) :
  d(new KInetSocketAddressPrivate)
{
  setAddress(sin, len);
}

KInetSocketAddress::KInetSocketAddress(const sockaddr_in6* sin6, ksocklen_t len) :
  d(new KInetSocketAddressPrivate)
{
  setAddress(sin6, len);
}

KInetSocketAddress::KInetSocketAddress(const in_addr& addr, unsigned short port) :
  d(new KInetSocketAddressPrivate)
{
  setAddress(addr, port);
}

KInetSocketAddress::KInetSocketAddress(const in6_addr& addr, unsigned short port) :
  d(new KInetSocketAddressPrivate)
{
  setAddress(addr, port);
}

KInetSocketAddress::KInetSocketAddress(const QString& addr, unsigned short port, int family) :
  d(new KInetSocketAddressPrivate)
{
  setAddress(addr, port, family);
}

KInetSocketAddress::~KInetSocketAddress()
{
  delete d;


}

bool KInetSocketAddress::setAddress(const KInetSocketAddress &other)
{
  if (other.family() == 2)
    return setAddress(other.addressV4(), other.size());

  else if (other.family() == 10)
    return setAddress(other.addressV6(), other.size());

  return false;
}

bool KInetSocketAddress::setAddress(const sockaddr_in* sin, ksocklen_t len)
{

  if ((len < sizeof(sockaddr_in)) || (sin->sin_family != 2))
    {
      kdWarning() << "KInetSocketAddress::setAddress(sockaddr_in*) called with invalid sockaddr_in\n";
      return false;
    }

  return setHost(sin->sin_addr) && setPort(ntohs(sin->sin_port));
}

bool KInetSocketAddress::setAddress(const sockaddr_in6* sin6, ksocklen_t len)
{


  if ((len < (((size_t) &((sockaddr_in6 *)0)->sin6_addr) + sizeof(((sockaddr_in6*)0)->sin6_addr))) || (sin6->sin6_family != 10))
    {
      kdWarning() << "KInetSocketAddress::setAddress(sockaddr_in6*) called with invalid sockaddr_in6\n";
      return 0;
    }

  memset(&d->sin6, 0, sizeof(d->sin6));
  if (len > sizeof(d->sin6))
    len = sizeof(d->sin6);
  memcpy(&d->sin6, sin6, len);


  d->sockfamily = d->sin6.sin6_family = 10;




  fromV6();
  return true;



}

bool KInetSocketAddress::setAddress(const in_addr& addr, unsigned short port)
{
  return setHost(addr) && setPort(port);
}

bool KInetSocketAddress::setAddress(const in6_addr& addr, unsigned short port)
{
  return setHost(addr) && setPort(port);
}

bool KInetSocketAddress::setAddress(const QString& addr, unsigned short port, int family)
{
  return setHost(addr, family) && setPort(port);
}

bool KInetSocketAddress::setHost(const in_addr& addr)
{
  d->sockfamily = 2;
  d->sin.sin_addr = addr;
  fromV4();
  return true;
}

bool KInetSocketAddress::setHost(const in6_addr& addr)
{

  d->sockfamily = 10;
  d->sin6.sin6_addr = addr;
  fromV6();
  return true;



}

bool KInetSocketAddress::setHost(const QString& addr, int family)
{

  if ((family != -1) && (family != 2)

      && (family != 10)

      )
    {
      kdWarning() << "KInetSocketAddress::setHost(QString, int) called with unknown family address\n";
      return false;
    }

  if (family == -1)
    {




      if (addr.find(':') != -1)
        family = 10;
      else
        family = 2;





    }




  if (family == 2)
    {
      inet_pton(family, addr.latin1(), (void*)&(d->sin.sin_addr));
      fromV4();
    }

  else
    {
      inet_pton(family, addr.latin1(), (void*)&(d->sin6.sin6_addr));
      fromV6();
    }

  d->sockfamily = family;
  return true;
}

bool KInetSocketAddress::setPort(unsigned short port)
{

  d->sin.sin_port = htons(port);

  d->sin6.sin6_port = htons(port);


  return true;
}

bool KInetSocketAddress::setFamily(int _family)
{
  if (_family != 2

      && _family != 10

      )
    {
      kdWarning() << "KInetSocketAddress::setFamily(int) called with unknown family\n";
      return false;
    }

  d->sockfamily = _family;
  if (_family == 2)
    fromV4();

  else if (_family == 10)
    fromV6();


  return true;
}

bool KInetSocketAddress::setFlowinfo(Q_UINT32 flowinfo)
{

  if (d->sockfamily == 10)
    {
      d->sin6.sin6_flowinfo = flowinfo;
      return true;
    }

  return false;
}

bool KInetSocketAddress::setScopeId(int scopeid)
{

  if (d->sockfamily == 10)
    {
      d->sin6.sin6_scope_id = scopeid;
      return true;
    }

  (void)scopeid;
  return false;
}

const sockaddr_in* KInetSocketAddress::addressV4() const
{
  if (d->sockfamily == 2)
    return &d->sin;

  else if (d->sockfamily == 10)
    {

      if ((((((Q_UINT32 *) (&d->sin6.sin6_addr))[0] == 0) && (((Q_UINT32 *) (&d->sin6.sin6_addr))[1] == 0) && (((Q_UINT32 *) (&d->sin6.sin6_addr))[2] == htonl (0xffff))) || ((((Q_UINT32 *) (&d->sin6.sin6_addr))[0] == 0) && (((Q_UINT32 *) (&d->sin6.sin6_addr))[1] == 0) && (((Q_UINT32 *) (&d->sin6.sin6_addr))[2] == 0) && (ntohl (((Q_UINT32 *) (&d->sin6.sin6_addr))[3]) > 1))))
        return &d->sin;
      else
        return __null;
    }


  kdWarning() << "KInetSocketAddress::addressV4() called on uninitialized socket\n";
  return __null;
}

const sockaddr_in6* KInetSocketAddress::addressV6() const
{

  return &d->sin6;



}

in_addr KInetSocketAddress::hostV4() const
{

  return d->sin.sin_addr;
}







in6_addr KInetSocketAddress::hostV6() const
{
  return d->sin6.sin6_addr;
}


QString KInetSocketAddress::pretty() const
{
  if (d->sockfamily != 2

      && d->sockfamily != 10

      )
    {
      kdWarning() << "KInetSocketAddress::pretty() called on uninitialized class\n";
      return i18n("<empty>");
    }

  return i18n("1: hostname, 2: port number", "%1 port %2").arg(nodeName()).arg(serviceName());
}

QString KInetSocketAddress::nodeName() const
{
  char buf[46];

  if (d->sockfamily == 2)
    inet_ntop(d->sockfamily, (void*)&d->sin.sin_addr, buf, sizeof(buf));

  else if (d->sockfamily == 10)
    inet_ntop(d->sockfamily, (void*)&d->sin6.sin6_addr, buf, sizeof(buf));

  else
    {
      kdWarning() << "KInetSocketAddress::nodeName() called on uninitialized class\n";
      return i18n("<empty>");
    }

  return QString::fromLatin1(buf);
}

QString KInetSocketAddress::serviceName() const
{
  return QString::number(port());
}

unsigned short KInetSocketAddress::port() const
{


  return ntohs(d->sin6.sin6_port);



}

Q_UINT32 KInetSocketAddress::flowinfo() const
{

  if (d->sockfamily == 10)
    return (Q_UINT32)d->sin6.sin6_flowinfo;

  return 0;
}

ksocklen_t KInetSocketAddress::size() const
{
  if (d->sockfamily == 2)
    return sizeof(d->sin);

  else if (d->sockfamily == 10)
    return sizeof(d->sin6);

  else
    return 0;
}

bool KInetSocketAddress::areEqualInet(const KSocketAddress &s1, const KSocketAddress &s2, bool coreOnly)
{
   if (s1.family() != s2.family())
      return false;
   if ((s1.size() < sizeof(sockaddr_in)) || (s2.size() < sizeof(sockaddr_in)))
      return false;

   struct sockaddr_in *sin1 = (sockaddr_in *) s1.address();
   struct sockaddr_in *sin2 = (sockaddr_in *) s2.address();

   if (coreOnly)
      return (memcmp(&sin1->sin_addr, &sin2->sin_addr, sizeof(struct in_addr)) == 0);
   else
      return (sin1->sin_port == sin2->sin_port) &&
             (memcmp(&sin1->sin_addr, &sin2->sin_addr, sizeof(struct in_addr)) == 0);
}

bool KInetSocketAddress::areEqualInet6(const KSocketAddress &s1, const KSocketAddress &s2, bool coreOnly)
{

   if (s1.family() != s2.family())
      return false;

   if ((s1.size() < sizeof(sockaddr_in6)) || (s2.size() < sizeof(sockaddr_in6)))
      return false;

   struct sockaddr_in6 *sin1 = (sockaddr_in6 *) s1.address();
   struct sockaddr_in6 *sin2 = (sockaddr_in6 *) s2.address();

   if (coreOnly)
     return (memcmp(&sin1->sin6_addr, &sin2->sin6_addr, sizeof(struct in6_addr)) == 0);
   else
     return (sin1->sin6_port == sin2->sin6_port) &&
            (sin1->sin6_flowinfo == sin2->sin6_flowinfo) &&

            (sin1->sin6_scope_id == sin2->sin6_scope_id) &&

            (memcmp(&sin1->sin6_addr, &sin2->sin6_addr, sizeof(struct in6_addr)) == 0);



}

void KInetSocketAddress::fromV4()
{



  d->sin6.sin6_port = d->sin.sin_port;


  ((Q_UINT32*)&d->sin6.sin6_addr)[0] = ((Q_UINT32*)&d->sin6.sin6_addr)[1] = 0;
  ((Q_UINT32*)&d->sin6.sin6_addr)[2] = htonl(0xffff);
  ((Q_UINT32*)&d->sin6.sin6_addr)[3] = *(Q_UINT32*)&d->sin.sin_addr;


  d->sin6.sin6_flowinfo = 0;

  d->sin6.sin6_scope_id = 0;




  data = (sockaddr*)&d->sin;
  datasize = sizeof( sockaddr_in );
}

void KInetSocketAddress::fromV6()
{


  if ((((((Q_UINT32 *) (&d->sin6.sin6_addr))[0] == 0) && (((Q_UINT32 *) (&d->sin6.sin6_addr))[1] == 0) && (((Q_UINT32 *) (&d->sin6.sin6_addr))[2] == htonl (0xffff))) || ((((Q_UINT32 *) (&d->sin6.sin6_addr))[0] == 0) && (((Q_UINT32 *) (&d->sin6.sin6_addr))[1] == 0) && (((Q_UINT32 *) (&d->sin6.sin6_addr))[2] == 0) && (ntohl (((Q_UINT32 *) (&d->sin6.sin6_addr))[3]) > 1))))
    {
      d->sin.sin_port = d->sin6.sin6_port;
      *(Q_UINT32*)&d->sin.sin_addr = ((Q_UINT32*)&d->sin6.sin6_addr)[3];
    }
  else
    {
      d->sin.sin_port = 0;
      memset(&d->sin.sin_addr, 0, sizeof(d->sin.sin_addr));
    }

  data = (sockaddr*)&d->sin6;
  datasize = sizeof( d->sin6 );

}

QString KInetSocketAddress::addrToString(int family, const void* addr)
{
  char buf[46 +1];

  return QString::fromLatin1(inet_ntop(family, addr, buf, 46));
}

bool KInetSocketAddress::stringToAddr(int family, const char *text, void *dest)
{
  return inet_pton(family, text, dest) != 0;
}





class KUnixSocketAddressPrivate
{
public:
  sockaddr_un *m_sun;

  KUnixSocketAddressPrivate() : m_sun(__null)
  { }
};

KUnixSocketAddress::KUnixSocketAddress() :
  d(new KUnixSocketAddressPrivate)
{
}

KUnixSocketAddress::KUnixSocketAddress(const sockaddr_un* _sun, ksocklen_t size) :
  d(new KUnixSocketAddressPrivate)
{
  setAddress(_sun, size);
}

KUnixSocketAddress::KUnixSocketAddress(QCString pathname) :
  d(new KUnixSocketAddressPrivate)
{
  setAddress(pathname);
}

KUnixSocketAddress::~KUnixSocketAddress()
{
  delete d;
}

bool KUnixSocketAddress::setAddress(const sockaddr_un* _sun, ksocklen_t _size)
{
  if (_sun->sun_family != 1)
    {
      kdWarning() << "KUnixSocketAddress::setAddress called with invalid socket\n";
      return false;
    }

  if (owndata && (d->m_sun != __null) && (datasize >= _size))
    {

      memcpy(d->m_sun, _sun, _size);
    }
  else
    {
      if (owndata && (d->m_sun != __null))
        free(d->m_sun);

      d->m_sun = (sockaddr_un*)malloc(_size);

      if (d->m_sun == __null)
        {

          owndata = false;
          return false;
        }

      memcpy(d->m_sun, _sun, _size);
    }

  datasize = _size;
  data = (sockaddr*)d->m_sun;
  owndata = true;



  return 1;
}

bool KUnixSocketAddress::setAddress(QCString path)
{

  ksocklen_t newsize = ((size_t) &((sockaddr_un *)0)->sun_path) + path.length() + 1;

  if (owndata && (d->m_sun != __null) && (datasize >= newsize))
    {

      strcpy(d->m_sun->sun_path, path);



      return true;
    }


  if (owndata && (d->m_sun != __null))
    free(d->m_sun);

  d->m_sun = (sockaddr_un*) malloc(newsize);
  if (d->m_sun == __null)
    {
      owndata = false;
      return false;
    }

  d->m_sun->sun_family = 1;
  strcpy(d->m_sun->sun_path, path);
  data = (sockaddr*)d->m_sun;
  datasize = newsize;



  return 1;
}

QCString KUnixSocketAddress::pathname() const
{
  if (d->m_sun != __null)
    {
      if (datasize > ((size_t) &((sockaddr_un *)0)->sun_path))
        return d->m_sun->sun_path;
      return "";
    }
  return QCString(0);
}

QString KUnixSocketAddress::pretty() const
{
  QCString pname = pathname();
  if (pname.isEmpty())
    return i18n("<empty UNIX socket>");
  return QFile::decodeName(pathname());
}

QString KUnixSocketAddress::serviceName() const
{
  return QString::fromUtf8(pathname());
}

const sockaddr_un* KUnixSocketAddress::address() const
{
  return d->m_sun;
}

bool KUnixSocketAddress::areEqualUnix(const KSocketAddress &s1, const KSocketAddress &s2, bool )
{
   if (s1.family() != s2.family())
      return false;

   if ((s1.size() < (((size_t) &((sockaddr *)0)->sa_family) + sizeof(((sockaddr*)0)->sa_family))) || (s2.size() < (((size_t) &((sockaddr *)0)->sa_family) + sizeof(((sockaddr*)0)->sa_family))))
      return false;

   struct sockaddr_un *sun1 = (sockaddr_un *) s1.address();
   struct sockaddr_un *sun2 = (sockaddr_un *) s2.address();

   if (s1.size() == (((size_t) &((sockaddr *)0)->sa_family) + sizeof(((sockaddr*)0)->sa_family)) && s2.size() == (((size_t) &((sockaddr *)0)->sa_family) + sizeof(((sockaddr*)0)->sa_family)))
     return true;

   return (strcmp(sun1->sun_path, sun2->sun_path) == 0);
}

void KSocketAddress::virtual_hook( int, void* )
{ }

void KInetSocketAddress::virtual_hook( int id, void* data )
{ KSocketAddress::virtual_hook( id, data ); }

void KUnixSocketAddress::virtual_hook( int id, void* data )
{ KSocketAddress::virtual_hook( id, data ); }


# 1 "../kdecore/ksockaddr.moc" 1
# 11 "../kdecore/ksockaddr.moc"
# 1 "../../../prod/kdelibs/kdecore/ksockaddr.h" 1
# 12 "../kdecore/ksockaddr.moc" 2
# 22 "../kdecore/ksockaddr.moc"
const char *KSocketAddress::className() const
{
    return "KSocketAddress";
}

QMetaObject *KSocketAddress::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KSocketAddress( "KSocketAddress", &KSocketAddress::staticMetaObject );
# 50 "../kdecore/ksockaddr.moc"
QMetaObject* KSocketAddress::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KSocketAddress", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KSocketAddress.setMetaObject( metaObj );
    return metaObj;
}

void* KSocketAddress::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KSocketAddress" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KSocketAddress::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KSocketAddress::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KSocketAddress::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KSocketAddress::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }



const char *KInetSocketAddress::className() const
{
    return "KInetSocketAddress";
}

QMetaObject *KInetSocketAddress::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KInetSocketAddress( "KInetSocketAddress", &KInetSocketAddress::staticMetaObject );
# 123 "../kdecore/ksockaddr.moc"
QMetaObject* KInetSocketAddress::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KSocketAddress::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KInetSocketAddress", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KInetSocketAddress.setMetaObject( metaObj );
    return metaObj;
}

void* KInetSocketAddress::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KInetSocketAddress" ) )
        return this;
    return KSocketAddress::qt_cast( clname );
}

bool KInetSocketAddress::qt_invoke( int _id, QUObject* _o )
{
    return KSocketAddress::qt_invoke(_id,_o);
}

bool KInetSocketAddress::qt_emit( int _id, QUObject* _o )
{
    return KSocketAddress::qt_emit(_id,_o);
}


bool KInetSocketAddress::qt_property( int id, int f, QVariant* v)
{
    return KSocketAddress::qt_property( id, f, v);
}

bool KInetSocketAddress::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }



const char *KUnixSocketAddress::className() const
{
    return "KUnixSocketAddress";
}

QMetaObject *KUnixSocketAddress::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KUnixSocketAddress( "KUnixSocketAddress", &KUnixSocketAddress::staticMetaObject );
# 196 "../kdecore/ksockaddr.moc"
QMetaObject* KUnixSocketAddress::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KSocketAddress::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KUnixSocketAddress", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KUnixSocketAddress.setMetaObject( metaObj );
    return metaObj;
}

void* KUnixSocketAddress::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KUnixSocketAddress" ) )
        return this;
    return KSocketAddress::qt_cast( clname );
}

bool KUnixSocketAddress::qt_invoke( int _id, QUObject* _o )
{
    return KSocketAddress::qt_invoke(_id,_o);
}

bool KUnixSocketAddress::qt_emit( int _id, QUObject* _o )
{
    return KSocketAddress::qt_emit(_id,_o);
}


bool KUnixSocketAddress::qt_property( int id, int f, QVariant* v)
{
    return KSocketAddress::qt_property( id, f, v);
}

bool KUnixSocketAddress::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 895 "/coolo/prod/kdelibs/kdecore/ksockaddr.cpp" 2
# 67 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/netsupp.cpp" 1
# 29 "/coolo/prod/kdelibs/kdecore/netsupp.cpp"
# 1 "/usr/include/errno.h" 1 3 4
# 30 "/coolo/prod/kdelibs/kdecore/netsupp.cpp" 2



# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 34 "/coolo/prod/kdelibs/kdecore/netsupp.cpp" 2






# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 41 "/coolo/prod/kdelibs/kdecore/netsupp.cpp" 2
# 62 "/coolo/prod/kdelibs/kdecore/netsupp.cpp"



#undef offsetof









static void dofreeaddrinfo(struct addrinfo *ai)
{
  while (ai)
    {
      struct addrinfo *ai2 = ai;
      if (ai->ai_canonname != __null)
        free(ai->ai_canonname);

      if (ai->ai_addr != __null)
        free(ai->ai_addr);

      ai = ai->ai_next;
      free(ai2);
    }
}

void kde_freeaddrinfo(struct kde_addrinfo *ai)
{
  if (ai->origin == 1)
    {
      struct addrinfo *p, *last = __null;


      for (p = ai->data; p; p = p->ai_next)
        {
          if (p->ai_family == 1)
            {
              if (last)
                {
                  last->ai_next = __null;
                  freeaddrinfo(ai->data);
                }
              dofreeaddrinfo(p);
              break;
            }
          last = p;
        }
    }
  else
    freeaddrinfo(ai->data);

  free(ai);
}

static struct addrinfo*
make_unix(const char *name, const char *serv)
{
  const char *buf;
  struct addrinfo *p;
  struct sockaddr_un *_sun;
  int len;

  p = (addrinfo*)malloc(sizeof(*p));
  if (p == __null)
    return __null;
  memset(p, 0, sizeof(*p));

  if (name != __null)
    buf = name;
  else
    buf = serv;


  len = strlen(buf) + ((size_t) &((struct sockaddr_un *)0)->sun_path) + 1;
  if (*buf != '/')
    len += 5;

  _sun = (sockaddr_un*)malloc(len);
  if (_sun == __null)
    {

      free(p);
      return __null;
    }

  _sun->sun_family = 1;



  if (*buf == '/')
    *_sun->sun_path = '\0';
  else
    strcpy(_sun->sun_path, "/tmp/");
  strcat(_sun->sun_path, buf);


  p->ai_family = 1;
  p->ai_addrlen = len;
  p->ai_addr = (sockaddr*)_sun;
  p->ai_canonname = strdup(buf);

  return p;
}
# 186 "/coolo/prod/kdelibs/kdecore/netsupp.cpp"
static int check_ipv6_stack()
{



  int fd = ::socket(10, SOCK_STREAM, 0);
  if (fd == -1)
     return 2;

  ::close(fd);
  return 1;

}
# 228 "/coolo/prod/kdelibs/kdecore/netsupp.cpp"
int kde_getaddrinfo(const char *name, const char *service,
                    const struct addrinfo* hint,
                    struct kde_addrinfo** result)
{
  struct kde_addrinfo* res;
  struct addrinfo* p;
  int err = -8;


  static int ipv6_stack = 0;



  res = (kde_addrinfo*)malloc(sizeof(*res));
  if (res == __null)
    return -10;
  res->data = __null;
  res->origin = 0;

  struct addrinfo* last = __null;


  if (hint && (hint->ai_family == 1))
  {
     if (service == __null || *service == '\0')
       goto out;




     if (name != __null && !(name[0] == '\0' || (name[0] == '*' && name[1] == '\0') ||
                strcmp("localhost", name) == 0))
       goto out;

     goto do_unix;
  }




  if (ipv6_stack == 0)
    ipv6_stack = check_ipv6_stack();

  if (ipv6_stack == 2)
    {



      struct addrinfo our_hint;
      if (hint != __null)
        {
          memcpy(&our_hint, hint, sizeof(our_hint));
          if (our_hint.ai_family == 0)
            our_hint.ai_family = 2;
        }
      else
        {
          memset(&our_hint, 0, sizeof(our_hint));
          our_hint.ai_family = 2;
        }


      err = getaddrinfo(name, service, &our_hint, &res->data);

    }
  else




      err = getaddrinfo(name, service, hint, &res->data);




  if (service == __null || *service == '\0')
    goto out;




  if (name != __null && !(name[0] == '\0' || (name[0] == '*' && name[1] == '\0') ||
                        strcmp("localhost", name) == 0))
    goto out;



  if (hint != __null && (hint->ai_family != 0 && hint->ai_family != 1))
    goto out;





  if (err == 0)
    for (p = res->data; p; p = p->ai_next)
      {
        last = p;
        if (p->ai_family == 1)

          goto out;
      }

 do_unix:

  p = make_unix(__null, service);
  if (p == __null)
    {
      err = -10;
      goto out;
    }
  if (hint != __null)
    p->ai_socktype = hint->ai_socktype;
  if (p->ai_socktype == 0)
    p->ai_socktype = SOCK_STREAM;

  if (last)
    last->ai_next = p;
  else
    res->data = p;
  res->origin = 1;
  *result = res;
  return 0;

 out:

  if (err == 0)
    *result = res;
  else
    {
      if (res->data != __null)
        freeaddrinfo(res->data);
      free(res);
    }
  return err;
}



# 1126 "/coolo/prod/kdelibs/kdecore/netsupp.cpp"
# 1227 "/coolo/prod/kdelibs/kdecore/netsupp.cpp"








namespace KDE
{

  extern const int resolverFlags = 0 | 0 | 0x01 | 0 | 0;
}
# 68 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kprocio.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/kprocio.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 23 "/coolo/prod/kdelibs/kdecore/kprocio.cpp" 2




# 1 "/coolo/prod/kdelibs/kdecore/kprocio.h" 1
# 19 "/coolo/prod/kdelibs/kdecore/kprocio.h"






class KProcIOPrivate;
class QTextCodec;
# 51 "/coolo/prod/kdelibs/kdecore/kprocio.h"
class KProcIO : public KProcess
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:



  KProcIO ( QTextCodec *codec = 0 );




  ~KProcIO();
# 73 "/coolo/prod/kdelibs/kdecore/kprocio.h"
  void setComm (Communication comm);
# 89 "/coolo/prod/kdelibs/kdecore/kprocio.h"
  bool start (RunMode runmode = NotifyOnExit, bool includeStderr = false);







  bool writeStdin(const QString &line, bool appendnewline=true);







  bool writeStdin(const QCString &line, bool appendnewline);






  bool writeStdin(const QByteArray &data);
# 124 "/coolo/prod/kdelibs/kdecore/kprocio.h"
   bool fputs (const QString &line, bool AppendNewLine=true)
    { return writeStdin(line, AppendNewLine); }




  void closeWhenDone();
# 153 "/coolo/prod/kdelibs/kdecore/kprocio.h"
  int readln (QString &line, bool autoAck=true, bool *partial=0);
# 162 "/coolo/prod/kdelibs/kdecore/kprocio.h"
  int fgets (QString &line, bool autoAck=false)
    { return readln (line, autoAck); }




  void resetAll ();
# 179 "/coolo/prod/kdelibs/kdecore/kprocio.h"
  void ackRead ();







  void enableReadSignals (bool enable);

protected:





  void readReady(KProcIO *pio);

protected:
  QPtrList<QByteArray> outbuffer;
  QCString recvbuffer;
  QTextCodec *codec;
  int rbi;
  bool needreadsignal, readsignalon, writeready;

  void controlledEmission ();

protected :
  void received (KProcess *proc, char *buffer, int buflen);
  void sent (KProcess *);

protected:
  virtual void virtual_hook( int id, void* data );
private:
  KProcIOPrivate *d;
};
# 28 "/coolo/prod/kdelibs/kdecore/kprocio.cpp" 2




class KProcIOPrivate {
public:
  KProcIOPrivate() : comm(KProcess::All) {}
  KProcess::Communication comm;
};

KProcIO::KProcIO ( QTextCodec *_codec)
  : codec(_codec), d(new KProcIOPrivate)
{
  rbi=0;
  readsignalon=writeready=TRUE;
  outbuffer.setAutoDelete(true);

  if (!codec)
  {
     codec = QTextCodec::codecForName("ISO 8859-1");
     if (!codec)
     {
        kdError(174) << "Can't create ISO 8859-1 codec!" << endl;
     }
  }
}

KProcIO::~KProcIO()
{
  delete d;
}

void
KProcIO::resetAll ()
{
  if (isRunning())
     kill();

  clearArguments();
  rbi=0;
  readsignalon=writeready=TRUE;

  disconnect (this, "2""receivedStdout (KProcess *, char *, int)",
           this, "1""received (KProcess *, char *, int)");

  disconnect (this, "2""receivedStderr (KProcess *, char *, int)",
           this, "1""received (KProcess *, char *, int)");

  disconnect (this, "2""wroteStdin(KProcess *)",
           this, "1""sent (KProcess *)");

  outbuffer.clear();

}

void KProcIO::setComm (Communication comm)
{
  d->comm = comm;
}

bool KProcIO::start (RunMode runmode, bool includeStderr)
{
  connect (this, "2""receivedStdout (KProcess *, char *, int)",
           this, "1""received (KProcess *, char *, int)");

  if (includeStderr)
  {
     connect (this, "2""receivedStderr (KProcess *, char *, int)",
              this, "1""received (KProcess *, char *, int)");
  }

  connect (this, "2""wroteStdin(KProcess *)",
           this, "1""sent (KProcess *)");

  return KProcess::start (runmode, d->comm);
}

bool KProcIO::writeStdin (const QString &line, bool appendnewline)
{
  return writeStdin(codec->fromUnicode(line), appendnewline);
}

bool KProcIO::writeStdin (const QCString &line, bool appendnewline)
{
  QCString *qs = new QCString(line);

  if (appendnewline)
  {
     *qs += '\n';
  }

  int l = qs->length();
  if (!l)
  {
     delete qs;
     return true;
  }

  QByteArray *b = (QByteArray *) qs;
  b->truncate(l);

  outbuffer.append(b);

  if (writeready)
  {
     writeready=FALSE;
     return KProcess::writeStdin( b->data(), b->size() );
  }
  return true;
}

bool KProcIO::writeStdin(const QByteArray &data)
{
  if (!data.size())
     return true;
  QByteArray *b = new QByteArray(data);
  outbuffer.append(b);

  if (writeready)
  {
     writeready=FALSE;
     return KProcess::writeStdin( b->data(), b->size() );
  }
  return true;
}

void KProcIO::closeWhenDone()
{
  if (writeready)
  {
     closeStdin();
     return;
  }
  outbuffer.append(0);

  return;
}

void KProcIO::sent(KProcess *)
{
  outbuffer.removeFirst();

  if (outbuffer.count()==0)
  {
     kdDebug(174) << "Empty" << endl;
     writeready=TRUE;
  }
  else
  {
     QByteArray *b = outbuffer.first();
     if (!b)
     {
        kdDebug(174) << "Closing" << endl;
        closeStdin();
     }
     else
     {
        kdDebug(174) << "Sending [" << b->size() << "]" << endl;
        KProcess::writeStdin(b->data(), b->size());
     }
  }

}

void KProcIO::received (KProcess *, char *buffer, int buflen)
{
  recvbuffer += QCString(buffer, buflen+1);

  controlledEmission();
}

void KProcIO::ackRead ()
{
  readsignalon=TRUE;
  if (needreadsignal || recvbuffer.length()!=0)
     controlledEmission();
}

void KProcIO::controlledEmission ()
{
  if (readsignalon)
  {
     needreadsignal=FALSE;
     readsignalon=FALSE;
     readReady (this);
  }
  else
  {
    needreadsignal=TRUE;
  }
}

void KProcIO::enableReadSignals (bool enable)
{
  readsignalon=enable;

  if (enable && needreadsignal)
     readReady (this);
}

int KProcIO::readln (QString &line, bool autoAck, bool *partial)
{
  int len;

  if (autoAck)
     readsignalon=TRUE;



  len=recvbuffer.find ('\n',rbi)-rbi;




  if ((len<0) &&
      ((unsigned int)rbi<recvbuffer.length()))
  {
     recvbuffer=recvbuffer.mid (rbi);
     rbi=0;
     if (partial)
     {
        len = recvbuffer.length();
        line = recvbuffer;
        recvbuffer = "";
        *partial = true;
        return len;
     }
     return -1;
  }

  if (len>=0)
  {
     line = codec->toUnicode(recvbuffer.mid(rbi,len), len);
     rbi += len+1;
     if (partial)
        *partial = false;
     return len;
  }

  recvbuffer="";
  rbi=0;


  return -1;

}

void KProcIO::virtual_hook( int id, void* data )
{ KProcess::virtual_hook( id, data ); }

# 1 "../kdecore/kprocio.moc" 1
# 11 "../kdecore/kprocio.moc"
# 1 "../../../prod/kdelibs/kdecore/kprocio.h" 1
# 12 "../kdecore/kprocio.moc" 2
# 22 "../kdecore/kprocio.moc"
const char *KProcIO::className() const
{
    return "KProcIO";
}

QMetaObject *KProcIO::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KProcIO( "KProcIO", &KProcIO::staticMetaObject );
# 50 "../kdecore/kprocio.moc"
QMetaObject* KProcIO::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KProcess::staticMetaObject();
    static const QUParameter param_slot_0[] = {
        { "proc", &static_QUType_ptr, "KProcess", QUParameter::In },
        { "buffer", &static_QUType_charstar, 0, QUParameter::In },
        { "buflen", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod slot_0 = {"received", 3, param_slot_0 };
    static const QUParameter param_slot_1[] = {
        { 0, &static_QUType_ptr, "KProcess", QUParameter::In }
    };
    static const QUMethod slot_1 = {"sent", 1, param_slot_1 };
    static const QMetaData slot_tbl[] = {
        { "received(KProcess*,char*,int)", &slot_0, QMetaData::Protected },
        { "sent(KProcess*)", &slot_1, QMetaData::Protected }
    };
    static const QUParameter param_signal_0[] = {
        { "pio", &static_QUType_ptr, "KProcIO", QUParameter::In }
    };
    static const QUMethod signal_0 = {"readReady", 1, param_signal_0 };
    static const QMetaData signal_tbl[] = {
        { "readReady(KProcIO*)", &signal_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KProcIO", parentObject,
        slot_tbl, 2,
        signal_tbl, 1,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KProcIO.setMetaObject( metaObj );
    return metaObj;
}

void* KProcIO::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KProcIO" ) )
        return this;
    return KProcess::qt_cast( clname );
}





void KProcIO::readReady( KProcIO* t0 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 0 );
    if ( !clist )
        return;
    QUObject o[2];
    static_QUType_ptr.set(o+1,t0);
    activate_signal( clist, o );
}

bool KProcIO::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: received((KProcess*)static_QUType_ptr.get(_o+1),(char*)static_QUType_charstar.get(_o+2),(int)static_QUType_int.get(_o+3)); break;
    case 1: sent((KProcess*)static_QUType_ptr.get(_o+1)); break;
    default:
        return KProcess::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KProcIO::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: readReady((KProcIO*)static_QUType_ptr.get(_o+1)); break;
    default:
        return KProcess::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KProcIO::qt_property( int id, int f, QVariant* v)
{
    return KProcess::qt_property( id, f, v);
}

bool KProcIO::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 279 "/coolo/prod/kdelibs/kdecore/kprocio.cpp" 2
# 69 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kbufferedio.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kbufferedio.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/kbufferedio.cpp" 2
# 89 "/coolo/prod/kdelibs/kdecore/kbufferedio.cpp"
KBufferedIO::KBufferedIO() :
  inBufIndex(0), outBufIndex(0)
{
  inBuf.setAutoDelete(true);
  outBuf.setAutoDelete(true);
}


KBufferedIO::~KBufferedIO()
{
}




bool KBufferedIO::setBufferSize(int rsize, int wsize )
{
  if (wsize != -2 && wsize != -1)
    return false;
  if (rsize != -2 && rsize != -1)
    return false;

  return true;
}

int KBufferedIO::bytesAvailable() const
{
  return readBufferSize();
}

int KBufferedIO::bytesToWrite() const
{
  return writeBufferSize();
}


bool KBufferedIO::canReadLine() const
{
  if (bytesAvailable() == 0)
    return false;

  QByteArray* buf;


  QPtrList<QByteArray> &buflist = ((KBufferedIO*)this)->inBuf;
  buf = buflist.first();
  char *p = buf->data() + inBufIndex;
  int n = buf->size() - inBufIndex;
  while (buf != __null)
    {
      while (n--)
        if (*p++ == '\n')
          return true;
      buf = buflist.next();
      if (buf != __null)
        {
          p = buf->data();
          n = buf->size();
        }
    }

  return false;
}



int KBufferedIO::unreadBlock(const char *data, uint len)
{
  return feedReadBuffer(len, data, true);
}





unsigned KBufferedIO::consumeReadBuffer(unsigned nbytes, char *destbuffer, bool discard)
{
  {
    register unsigned u = readBufferSize();
    if (nbytes > u)
      nbytes = u;
  }

  QByteArray *buf;
  unsigned copied = 0;
  unsigned index = inBufIndex;

  buf = inBuf.first();
  while (nbytes && buf)
    {

      unsigned to_copy = buf->size() - index;
      if (to_copy > nbytes)
        to_copy = nbytes;

      if (destbuffer)
        memcpy(destbuffer + copied, buf->data() + index, to_copy);
      nbytes -= to_copy;
      copied += to_copy;

      if (buf->size() - index > to_copy)
        {
          index += to_copy;
          break;

        }
      else
        {
          index = 0;
          if (discard)
            {
              inBuf.remove();
              buf = inBuf.first();
            }
          else
            buf = inBuf.next();
        }
    }

  if (discard)
    inBufIndex = index;

  return copied;
}

void KBufferedIO::consumeWriteBuffer(unsigned nbytes)
{
  QByteArray *buf = outBuf.first();
  if (buf == __null)
    return;

  if (nbytes < buf->size() - outBufIndex)

    outBufIndex += nbytes;
  else
    {
      nbytes -= buf->size() - outBufIndex;
      outBufIndex = 0;
      outBuf.remove();

      while ((buf = outBuf.current()) != __null)
        if (buf->size() <= nbytes)
          {
            nbytes -= buf->size();
            outBuf.remove();
          }
        else
          {
            outBufIndex = nbytes;
            break;
          }
    }
}

unsigned KBufferedIO::feedReadBuffer(unsigned nbytes, const char *buffer, bool atBeginning)
{
  if (nbytes == 0)
    return 0;

  QByteArray *a = new QByteArray(nbytes);
  a->duplicate(buffer, nbytes);

  if (atBeginning)
    inBuf.prepend(a);
  else
    inBuf.append(a);

  return nbytes;
}

unsigned KBufferedIO::feedWriteBuffer(unsigned nbytes, const char *buffer)
{
  if (nbytes == 0)
    return 0;

  QByteArray *a = new QByteArray(nbytes);
  a->duplicate(buffer, nbytes);
  outBuf.append(a);
  return nbytes;
}

unsigned KBufferedIO::readBufferSize() const
{
  unsigned count = 0;
  QByteArray *buf = ((KBufferedIO*)this)->inBuf.first();
  while (buf != __null)
    {
      count += buf->size();
      buf = ((KBufferedIO*)this)->inBuf.next();
    }

  return count - inBufIndex;
}

unsigned KBufferedIO::writeBufferSize() const
{
  unsigned count = 0;
  QByteArray *buf = ((KBufferedIO*)this)->outBuf.first();
  while (buf != __null)
    {
      count += buf->size();
      buf = (const_cast<KBufferedIO*>(this))->outBuf.next();
    }

  return count - outBufIndex;
}

void KBufferedIO::virtual_hook( int id, void* data )
{ KAsyncIO::virtual_hook( id, data ); }

# 1 "../kdecore/kbufferedio.moc" 1
# 11 "../kdecore/kbufferedio.moc"
# 1 "../../../prod/kdelibs/kdecore/kbufferedio.h" 1
# 12 "../kdecore/kbufferedio.moc" 2
# 22 "../kdecore/kbufferedio.moc"
const char *KBufferedIO::className() const
{
    return "KBufferedIO";
}

QMetaObject *KBufferedIO::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KBufferedIO( "KBufferedIO", &KBufferedIO::staticMetaObject );
# 50 "../kdecore/kbufferedio.moc"
QMetaObject* KBufferedIO::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = KAsyncIO::staticMetaObject();
    static const QUParameter param_signal_0[] = {
        { "nbytes", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_0 = {"bytesWritten", 1, param_signal_0 };
    static const QUParameter param_signal_1[] = {
        { "state", &static_QUType_int, 0, QUParameter::In }
    };
    static const QUMethod signal_1 = {"closed", 1, param_signal_1 };
    static const QMetaData signal_tbl[] = {
        { "bytesWritten(int)", &signal_0, QMetaData::Public },
        { "closed(int)", &signal_1, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KBufferedIO", parentObject,
        0, 0,
        signal_tbl, 2,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KBufferedIO.setMetaObject( metaObj );
    return metaObj;
}

void* KBufferedIO::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KBufferedIO" ) )
        return this;
    return KAsyncIO::qt_cast( clname );
}


void KBufferedIO::bytesWritten( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 0, t0 );
}


void KBufferedIO::closed( int t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 1, t0 );
}

bool KBufferedIO::qt_invoke( int _id, QUObject* _o )
{
    return KAsyncIO::qt_invoke(_id,_o);
}

bool KBufferedIO::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: bytesWritten((int)static_QUType_int.get(_o+1)); break;
    case 1: closed((int)static_QUType_int.get(_o+1)); break;
    default:
        return KAsyncIO::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KBufferedIO::qt_property( int id, int f, QVariant* v)
{
    return KAsyncIO::qt_property( id, f, v);
}

bool KBufferedIO::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 300 "/coolo/prod/kdelibs/kdecore/kbufferedio.cpp" 2
# 70 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kpixmapprovider.cpp" 1
# 21 "/coolo/prod/kdelibs/kdecore/kpixmapprovider.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kpixmapprovider.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kpixmapprovider.h"
# 37 "/coolo/prod/kdelibs/kdecore/kpixmapprovider.h"
class KPixmapProvider
{
public:
    virtual ~KPixmapProvider();







    virtual QPixmap pixmapFor( const QString& text, int size = 0 ) = 0;
protected:
    virtual void virtual_hook( int id, void* data );
};
# 22 "/coolo/prod/kdelibs/kdecore/kpixmapprovider.cpp" 2

KPixmapProvider::~KPixmapProvider() {}

void KPixmapProvider::virtual_hook( int , void* )
{ }
# 71 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kurldrag.cpp" 1
# 20 "/coolo/prod/kdelibs/kdecore/kurldrag.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kurldrag.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kurldrag.h"


# 1 "/coolo/prod/qt-copy/include/qdragobject.h" 1
# 37 "/coolo/prod/qt-copy/include/qdragobject.h"

class QWidget;
class QTextDragPrivate;
class QDragObjectData;
class QStoredDragData;
class QImageDragData;
# 54 "/coolo/prod/qt-copy/include/qdragobject.h"
class QDragObject: public QObject, public QMimeSource {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QDragObject( QWidget * dragSource = 0, const char * name = 0 );
    virtual ~QDragObject();


    bool drag();
    bool dragMove();
    void dragCopy();
    void dragLink();

    virtual void setPixmap(QPixmap);
    virtual void setPixmap(QPixmap, const QPoint& hotspot);
    QPixmap pixmap() const;
    QPoint pixmapHotSpot() const;


    QWidget * source();
    static QWidget * target();

    static void setTarget(QWidget*);


    enum DragMode { DragDefault, DragCopy, DragMove, DragLink, DragCopyOrMove };

protected:
    virtual bool drag(DragMode);


private:
    QDragObjectData * d;

    QDragObject( const QDragObject & );
    QDragObject &operator=( const QDragObject & );

};

class QStoredDrag: public QDragObject {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    QStoredDragData * d;

public:
    QStoredDrag( const char * mimeType,
                 QWidget * dragSource = 0, const char * name = 0 );
    ~QStoredDrag();

    virtual void setEncodedData( const QByteArray & );

    const char * format(int i) const;
    virtual QByteArray encodedData(const char*) const;

private:

    QStoredDrag( const QStoredDrag & );
    QStoredDrag &operator=( const QStoredDrag & );

};

class QTextDrag: public QDragObject {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    QTextDragPrivate* d;
public:
    QTextDrag( const QString &,
               QWidget * dragSource = 0, const char * name = 0 );
    QTextDrag( QWidget * dragSource = 0, const char * name = 0 );
    ~QTextDrag();

    virtual void setText( const QString &);
    virtual void setSubtype( const QCString &);

    const char * format(int i) const;
    virtual QByteArray encodedData(const char*) const;

    static bool canDecode( const QMimeSource* e );
    static bool decode( const QMimeSource* e, QString& s );
    static bool decode( const QMimeSource* e, QString& s, QCString& subtype );

private:

    QTextDrag( const QTextDrag & );
    QTextDrag &operator=( const QTextDrag & );

};

class QImageDrag: public QDragObject {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    QImage img;
    QStrList ofmts;
    QImageDragData* d;

public:
    QImageDrag( QImage image, QWidget * dragSource = 0, const char * name = 0 );
    QImageDrag( QWidget * dragSource = 0, const char * name = 0 );
    ~QImageDrag();

    virtual void setImage( QImage image );

    const char * format(int i) const;
    virtual QByteArray encodedData(const char*) const;

    static bool canDecode( const QMimeSource* e );
    static bool decode( const QMimeSource* e, QImage& i );
    static bool decode( const QMimeSource* e, QPixmap& i );

private:

    QImageDrag( const QImageDrag & );
    QImageDrag &operator=( const QImageDrag & );

};


class QUriDrag: public QStoredDrag {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:
    QUriDrag( QStrList uris, QWidget * dragSource = 0, const char * name = 0 );
    QUriDrag( QWidget * dragSource = 0, const char * name = 0 );
    ~QUriDrag();

    void setFilenames( const QStringList & fnames ) { setFileNames( fnames ); }
    void setFileNames( const QStringList & fnames );
    void setUnicodeUris( const QStringList & uuris );
    virtual void setUris( QStrList uris );

    static QString uriToLocalFile(const char*);
    static QCString localFileToUri(const QString&);
    static QString uriToUnicodeUri(const char*);
    static QCString unicodeUriToUri(const QString&);
    static bool canDecode( const QMimeSource* e );
    static bool decode( const QMimeSource* e, QStrList& i );
    static bool decodeToUnicodeUris( const QMimeSource* e, QStringList& i );
    static bool decodeLocalFiles( const QMimeSource* e, QStringList& i );

private:

    QUriDrag( const QUriDrag & );
    QUriDrag &operator=( const QUriDrag & );

};

class QColorDrag : public QStoredDrag
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    QColor color;

public:
    QColorDrag( const QColor &col, QWidget *dragsource = 0, const char *name = 0 );
    QColorDrag( QWidget * dragSource = 0, const char * name = 0 );
    void setColor( const QColor &col );

    static bool canDecode( QMimeSource * );
    static bool decode( QMimeSource *, QColor &col );

private:

    QColorDrag( const QColorDrag & );
    QColorDrag &operator=( const QColorDrag & );

};


typedef QUriDrag QUrlDrag;
# 227 "/coolo/prod/qt-copy/include/qdragobject.h"
class QDragManager: public QObject {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

private:
    QDragManager();
    ~QDragManager();

    friend class QDragObject;
    friend class QDragMoveEvent;
    friend class QDropEvent;
    friend class QApplication;

    bool eventFilter( QObject *, QEvent * );
    void timerEvent( QTimerEvent* );

    bool drag( QDragObject *, QDragObject::DragMode );

    void cancel( bool deleteSource = TRUE );
    void move( const QPoint & );
    void drop();
    void updatePixmap();

private:
    QDragObject * object;
    void updateMode( ButtonState newstate );
    void updateCursor();

    QWidget * dragSource;
    QWidget * dropWidget;
    bool beingCancelled;
    bool restoreCursor;
    bool willDrop;

    QPixmap *pm_cursor;
    int n_cursor;

    QDragManager( const QDragManager & );
    QDragManager &operator=( const QDragManager & );

};
# 25 "/coolo/prod/kdelibs/kdecore/kurldrag.h" 2


class QMimeSource;

class KURLDragPrivate;
# 44 "/coolo/prod/kdelibs/kdecore/kurldrag.h"
class KURLDrag : public QUriDrag
{
public:
# 57 "/coolo/prod/kdelibs/kdecore/kurldrag.h"
  KURLDrag( const KURL::List &urls, QWidget* dragSource = 0, const char * name = 0 );
# 68 "/coolo/prod/kdelibs/kdecore/kurldrag.h"
  KURLDrag( const KURL::List &urls, const QMap<QString, QString>& metaData,
            QWidget* dragSource = 0, const char * name = 0 );

  virtual ~KURLDrag();




  static KURLDrag * newDrag( const KURL::List &urls, QWidget* dragSource = 0, const char * name = 0 ) ;




  static KURLDrag * newDrag( const KURL::List &urls, const QMap<QString, QString>& metaData,
                             QWidget* dragSource = 0, const char * name = 0 ) __attribute__ ((deprecated));
# 91 "/coolo/prod/kdelibs/kdecore/kurldrag.h"
  QMap<QString, QString> &metaData() { return m_metaData; }
# 101 "/coolo/prod/kdelibs/kdecore/kurldrag.h"
  static bool decode( const QMimeSource *e, KURL::List &urls );
# 113 "/coolo/prod/kdelibs/kdecore/kurldrag.h"
  static bool decode( const QMimeSource *e, KURL::List &urls, QMap<QString,QString>& metaData );





  static QString urlToString(const KURL &url);





  static KURL stringToUrl(const QCString &s);
# 136 "/coolo/prod/kdelibs/kdecore/kurldrag.h"
protected:



  KURLDrag( const QStrList & urls, const QMap<QString,QString>& metaData,
            QWidget * dragSource, const char* name ) __attribute__ ((deprecated));

  virtual const char * format( int i ) const;
  virtual QByteArray encodedData( const char* mime ) const;

private:
  void init(const KURL::List &urls);

  QStrList m_urls;
  QMap<QString,QString> m_metaData;
  KURLDragPrivate* d;
};
# 21 "/coolo/prod/kdelibs/kdecore/kurldrag.cpp" 2
# 30 "/coolo/prod/kdelibs/kdecore/kurldrag.cpp"
KURLDrag::KURLDrag( const KURL::List &urls, QWidget* dragSource, const char * name )
    : QUriDrag(dragSource, name), m_metaData()
{
    init(urls);
}

KURLDrag::KURLDrag( const KURL::List &urls, const QMap<QString,QString>& metaData,
                    QWidget* dragSource, const char * name )
    : QUriDrag(dragSource, name), m_metaData(metaData)
{
    init(urls);
}

KURLDrag::~KURLDrag()
{
}

void KURLDrag::init(const KURL::List &urls)
{
    KURL::List::ConstIterator uit = urls.begin();
    KURL::List::ConstIterator uEnd = urls.end();


    for ( ; uit != uEnd ; ++uit )
    {
        m_urls.append( urlToString(*uit).latin1() );
    }
    setUris(m_urls);
}

KURLDrag * KURLDrag::newDrag( const KURL::List &urls, QWidget* dragSource, const char * name )
{
    return new KURLDrag( urls, QMap<QString, QString>(), dragSource, name );
}

KURLDrag * KURLDrag::newDrag( const KURL::List &urls, const QMap<QString, QString>& metaData,
                              QWidget* dragSource, const char * name )
{
    return new KURLDrag( urls, metaData, dragSource, name );
}

bool KURLDrag::decode( const QMimeSource *e, KURL::List &uris )
{
    QStrList lst;
    QUriDrag::decode( e, lst );
    for (QStrListIterator it(lst); *it; ++it)
    {
      KURL url = stringToUrl( *it );
      if ( !url.isValid() )
      {
        uris.clear();
        break;
      }
      uris.append( url );
    }
    return !uris.isEmpty();
}

bool KURLDrag::decode( const QMimeSource *e, KURL::List &uris, QMap<QString,QString>& metaData )
{
    if ( decode( e, uris ) )
    {
        QByteArray ba = e->encodedData( "application/x-kio-metadata" );
        if ( ba.size() )
        {
            QString s = ba.data();
            QStringList l = QStringList::split( "$@@$", s );
            QStringList::ConstIterator it = l.begin();
            bool readingKey = true;
            QString key;
            for ( ; it != l.end(); ++it ) {
                if ( readingKey )
                    key = *it;
                else
                    metaData.replace( key, *it );
                readingKey = !readingKey;
            }
            ((readingKey) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","readingKey","/coolo/prod/kdelibs/kdecore/kurldrag.cpp",107));
        }
        return true;
    }
    return false;
}
# 133 "/coolo/prod/kdelibs/kdecore/kurldrag.cpp"
const char * KURLDrag::format( int i ) const
{
    if ( i == 0 )
        return "text/uri-list";
    else if ( i == 1 )
        return "text/plain";
    else if ( i == 2 )
        return "application/x-kio-metadata";
    else if ( i == 3 )
        return "text/plain;charset=ISO-8859-1";
    else if ( i == 4 )
        return "text/plain;charset=UTF-8";
    else return 0;
}

QByteArray KURLDrag::encodedData( const char* mime ) const
{
    QByteArray a;
    QCString mimetype( mime );
    if ( mimetype == "text/uri-list" )
        return QUriDrag::encodedData( mime );
    else if ( mimetype == "text/plain" )
    {
        QStringList uris;
        for (QStrListIterator it(m_urls); *it; ++it)
           uris.append(stringToUrl(*it).prettyURL());

        QCString s = uris.join( "\n" ).local8Bit();
        if( uris.count() > 1 )
            s.append( "\n" );
        a.resize( s.length());
        memcpy( a.data(), s.data(), s.length());
    }
    else if ( mimetype.lower() == "text/plain;charset=iso-8859-1")
    {
        QStringList uris;
        for (QStrListIterator it(m_urls); *it; ++it)
        for (QStrListIterator it(m_urls); *it; ++it)
           uris.append(stringToUrl(*it).url(0, 4));

        QCString s = uris.join( "\n" ).latin1();
        if( uris.count() > 1 )
            s.append( "\n" );
        a.resize( s.length());
        memcpy( a.data(), s.data(), s.length());
    }
    else if ( mimetype.lower() == "text/plain;charset=utf-8")
    {
        QStringList uris;
        for (QStrListIterator it(m_urls); *it; ++it)
           uris.append(stringToUrl(*it).prettyURL());

        QCString s = uris.join( "\n" ).utf8();
        if( uris.count() > 1 )
            s.append( "\n" );
        a.resize( s.length());
        memcpy( a.data(), s.data(), s.length());
    }
    else if ( mimetype == "application/x-kio-metadata" )
    {
        if ( !m_metaData.isEmpty() )
        {
            QString s;
            QMap<QString,QString>::ConstIterator it;
            for( it = m_metaData.begin(); it != m_metaData.end(); ++it )
            {
                s += it.key();
                s += "$@@$";
                s += it.data();
                s += "$@@$";
            }
            a.resize( s.length() + 1 );
            memcpy( a.data(), s.latin1(), a.size() );
        }
    }
    return a;
}

KURL KURLDrag::stringToUrl(const QCString &s)
{
    if (strncmp(s.data(), "file:", 5) == 0)
       return KURL(s, KGlobal::locale()->fileEncodingMib());

    return KURL(s, 106);
}

QString KURLDrag::urlToString(const KURL &url)
{
    if (url.isLocalFile())
    {

        return url.url(0, KGlobal::locale()->fileEncodingMib());
# 240 "/coolo/prod/kdelibs/kdecore/kurldrag.cpp"
    }

    return url.url(0, 106);
}


KURLDrag::KURLDrag( const QStrList & urls, const QMap<QString,QString>& metaData,
                    QWidget * dragSource, const char* name ) :
QUriDrag( urls, dragSource, name ), m_urls( urls ), m_metaData( metaData ) {}
# 72 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kmdcodec.cpp" 1
# 34 "/coolo/prod/kdelibs/kdecore/kmdcodec.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 35 "/coolo/prod/kdelibs/kdecore/kmdcodec.cpp" 2






# 1 "/coolo/prod/kdelibs/kdecore/kmdcodec.h" 1
# 35 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 40 "/coolo/prod/kdelibs/kdecore/kmdcodec.h" 2
# 73 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
class KCodecs
{
public:
# 86 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString quotedPrintableEncode(const QByteArray & in,
                                        bool useCRLF = true);
# 101 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString quotedPrintableEncode(const QCString & str,
                                        bool useCRLF = true);
# 123 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static void quotedPrintableEncode(const QByteArray & in, QByteArray& out,
                                    bool useCRLF);
# 134 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString quotedPrintableDecode(const QByteArray & in);
# 145 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString quotedPrintableDecode(const QCString & str);
# 166 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static void quotedPrintableDecode(const QByteArray & in, QByteArray& out);
# 180 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString uuencode( const QByteArray& in );
# 191 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString uuencode( const QCString& str );
# 208 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static void uuencode( const QByteArray& in, QByteArray& out );
# 220 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString uudecode( const QByteArray& in );
# 231 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString uudecode( const QCString& str );
# 252 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static void uudecode( const QByteArray& in, QByteArray& out );
# 268 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString base64Encode( const QByteArray& in, bool insertLFs = false);
# 280 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString base64Encode( const QCString& str, bool insertLFs = false );
# 303 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static void base64Encode( const QByteArray& in, QByteArray& out,
                            bool insertLFs = false );
# 313 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString base64Decode( const QByteArray& in );
# 324 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static QCString base64Decode( const QCString& str );
# 343 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  static void base64Decode( const QByteArray& in, QByteArray& out );


private:
  KCodecs();

private:
  static const char UUEncMap[64];
  static const char UUDecMap[128];
  static const char Base64EncMap[64];
  static const char Base64DecMap[128];
  static const char hexChars[16];
  static const unsigned int maxQPLineLength;
};

class KMD5Private;
# 406 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
class KMD5
{
public:

  typedef unsigned char Digest[16];

  KMD5();
# 422 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  KMD5(const char* in, int len = -1);






  KMD5(const QByteArray& a );






  KMD5(const QCString& a );
# 446 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  void update(const char* in, int len = -1) { update(reinterpret_cast<const unsigned char*>(in), len); }




  void update(const unsigned char* in, int len = -1);






  void update(const QByteArray& in );






  void update(const QCString& in );
# 478 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  bool update(QIODevice& file);






  void reset();




  const Digest& rawDigest ();
# 501 "/coolo/prod/kdelibs/kdecore/kmdcodec.h"
  void rawDigest( KMD5::Digest& bin );





  QCString hexDigest ();




  void hexDigest(QCString&);





  QCString base64Digest ();





  bool verify( const KMD5::Digest& digest);




  bool verify(const QCString&);

protected:




  void transform( const unsigned char buffer[64] );




  void finalize();

private:
  KMD5(const KMD5& u);
  KMD5& operator=(const KMD5& md);

  void init();
  void encode( unsigned char* output, Q_UINT32 *in, Q_UINT32 len );
  void decode( Q_UINT32 *output, const unsigned char* in, Q_UINT32 len );

  Q_UINT32 rotate_left( Q_UINT32 x, Q_UINT32 n );
  Q_UINT32 F( Q_UINT32 x, Q_UINT32 y, Q_UINT32 z );
  Q_UINT32 G( Q_UINT32 x, Q_UINT32 y, Q_UINT32 z );
  Q_UINT32 H( Q_UINT32 x, Q_UINT32 y, Q_UINT32 z );
  Q_UINT32 I( Q_UINT32 x, Q_UINT32 y, Q_UINT32 z );
  void FF( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d, Q_UINT32 x,
               Q_UINT32 s, Q_UINT32 ac );
  void GG( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d, Q_UINT32 x,
                Q_UINT32 s, Q_UINT32 ac );
  void HH( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d, Q_UINT32 x,
                Q_UINT32 s, Q_UINT32 ac );
  void II( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d, Q_UINT32 x,
             Q_UINT32 s, Q_UINT32 ac );

private:
  Q_UINT32 m_state[4];
  Q_UINT32 m_count[2];
  Q_UINT8 m_buffer[64];
  Digest m_digest;
  bool m_finalized;

  KMD5Private* d;
};
# 42 "/coolo/prod/kdelibs/kdecore/kmdcodec.cpp" 2


const char KCodecs::Base64EncMap[64] =
{
  0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
  0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
  0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
  0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
  0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
  0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
  0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,
  0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F
};

const char KCodecs::Base64DecMap[128] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x3F,
  0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,
  0x3C, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
  0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
  0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
  0x17, 0x18, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
  0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
  0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
  0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00
};

const char KCodecs::UUEncMap[64] =
{
  0x60, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
  0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
  0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F
};

const char KCodecs::UUDecMap[128] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const char KCodecs::hexChars[16] =
{
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

const unsigned int KCodecs::maxQPLineLength = 70;




static int rikFindChar(register const char * _s, const char c)
{
  register const char * s = _s;

  while (true)
  {
    if ((0 == *s) || (c == *s)) break; ++s;
    if ((0 == *s) || (c == *s)) break; ++s;
    if ((0 == *s) || (c == *s)) break; ++s;
    if ((0 == *s) || (c == *s)) break; ++s;
  }

  return s - _s;
}

QCString KCodecs::quotedPrintableEncode(const QByteArray& in, bool useCRLF)
{
  QByteArray out;
  quotedPrintableEncode (in, out, useCRLF);
  return QCString (out.data(), out.size()+1);
}

QCString KCodecs::quotedPrintableEncode(const QCString& str, bool useCRLF)
{
  if (str.isEmpty())
    return "";

  QByteArray in (str.length());
  memcpy (in.data(), str.data(), str.length());
  return quotedPrintableEncode(in, useCRLF);
}

void KCodecs::quotedPrintableEncode(const QByteArray& in, QByteArray& out, bool useCRLF)
{
  out.resize (0);
  if (in.isEmpty())
    return;

  char *cursor;
  const char *data;
  unsigned int lineLength;
  unsigned int pos;

  const unsigned int length = in.size();
  const unsigned int end = length - 1;






  out.resize ((length*12)/10);
  cursor = out.data();
  data = in.data();
  lineLength = 0;
  pos = 0;

  for (unsigned int i = 0; i < length; i++)
  {
    unsigned char c (data[i]);



    pos = cursor-out.data();
    if (out.size()-pos < 16) {
      out.resize(out.size()+4096);
      cursor = out.data()+pos;
    }



    if ((c >= 33) && (c <= 126) && ('=' != c))
    {
      *cursor++ = c;
      ++lineLength;
    }



    else if (' ' == c)
    {
      if
        (
         (i >= length)
         ||
         ((i < end) && ((useCRLF && ('\r' == data[i + 1]) && ('\n' == data[i + 2]))
                        ||
                        (!useCRLF && ('\n' == data[i + 1]))))
        )
      {
        *cursor++ = '=';
        *cursor++ = '2';
        *cursor++ = '0';

        lineLength += 3;
      }
      else
      {
        *cursor++ = ' ';
        ++lineLength;
      }
    }

    else if ((useCRLF && ('\r' == c) && (i < end) && ('\n' == data[i + 1])) ||
             (!useCRLF && ('\n' == c)))
    {
      lineLength = 0;

      if (useCRLF) {
        *cursor++ = '\r';
        *cursor++ = '\n';
        ++i;
      } else {
        *cursor++ = '\n';
      }
    }



    else
    {
      *cursor++ = '=';
      *cursor++ = hexChars[c / 16];
      *cursor++ = hexChars[c % 16];

      lineLength += 3;
    }



    if ((lineLength > maxQPLineLength) && (i < end))
    {
      if (useCRLF) {
        *cursor++ = '=';
        *cursor++ = '\r';
        *cursor++ = '\n';
      } else {
        *cursor++ = '=';
        *cursor++ = '\n';
      }

      lineLength = 0;
    }
  }

  out.truncate(cursor - out.data());
}

QCString KCodecs::quotedPrintableDecode(const QByteArray & in)
{
  QByteArray out;
  quotedPrintableDecode (in, out);
  return QCString (out.data(), out.size()+1);
}

QCString KCodecs::quotedPrintableDecode(const QCString & str)
{
  if (str.isEmpty())
    return "";

  QByteArray in (str.length());
  memcpy (in.data(), str.data(), str.length());
  return quotedPrintableDecode (in);
}

void KCodecs::quotedPrintableDecode(const QByteArray& in, QByteArray& out)
{

  out.resize (0);
  if (in.isEmpty())
      return;

  char *cursor;
  const char *data;
  const unsigned int length = in.size();

  data = in.data();
  out.resize (length);
  cursor = out.data();

  for (unsigned int i = 0; i < length; i++)
  {
    char c(in[i]);

    if ('=' == c)
    {
      if (i < length - 2)
      {
        char c1 = in[i + 1];
        char c2 = in[i + 2];

        if (('\n' == c1) || ('\r' == c1 && '\n' == c2))
        {

          if ('\r' == c1)
            i += 2;
          else
            i += 1;
        }
        else
        {


          int hexChar0 = rikFindChar(hexChars, c1);
          int hexChar1 = rikFindChar(hexChars, c2);

          if (hexChar0 < 16 && hexChar1 < 16)
          {
            *cursor++ = char((hexChar0 * 16) | hexChar1);
            i += 2;
          }
        }
      }
    }
    else
    {
      *cursor++ = c;
    }
  }

  out.truncate(cursor - out.data());
}

QCString KCodecs::base64Encode( const QCString& str, bool insertLFs )
{
    if ( str.isEmpty() )
        return "";

    QByteArray in (str.length());
    memcpy( in.data(), str.data(), str.length() );
    return base64Encode( in, insertLFs );
}

QCString KCodecs::base64Encode( const QByteArray& in, bool insertLFs )
{
    QByteArray out;
    base64Encode( in, out, insertLFs );
    return QCString( out.data(), out.size()+1 );
}

void KCodecs::base64Encode( const QByteArray& in, QByteArray& out,
                            bool insertLFs )
{

    out.resize (0);
    if ( in.isEmpty() )
        return;

    unsigned int sidx = 0;
    unsigned int didx = 0;
    const char* data = in.data();
    const unsigned int len = in.size();

    unsigned int out_len = ((len+2)/3)*4;




    insertLFs = (insertLFs && out_len > 76);
    if ( insertLFs )
      out_len += ((out_len-1)/76);

    int count = 0;
    out.resize( out_len );


    if ( len > 1 )
    {
        while (sidx < len-2)
        {
            if ( insertLFs )
            {
                if ( count && (count%76) == 0 )
                    out[didx++] = '\n';
                count += 4;
            }
            out[didx++] = Base64EncMap[(data[sidx] >> 2) & 077];
            out[didx++] = Base64EncMap[(data[sidx+1] >> 4) & 017 |
                                       (data[sidx] << 4) & 077];
            out[didx++] = Base64EncMap[(data[sidx+2] >> 6) & 003 |
                                       (data[sidx+1] << 2) & 077];
            out[didx++] = Base64EncMap[data[sidx+2] & 077];
            sidx += 3;
        }
    }

    if (sidx < len)
    {
        if ( insertLFs && (count > 0) && (count%76) == 0 )
           out[didx++] = '\n';

        out[didx++] = Base64EncMap[(data[sidx] >> 2) & 077];
        if (sidx < len-1)
        {
            out[didx++] = Base64EncMap[(data[sidx+1] >> 4) & 017 |
                                       (data[sidx] << 4) & 077];
            out[didx++] = Base64EncMap[(data[sidx+1] << 2) & 077];
        }
        else
        {
            out[didx++] = Base64EncMap[(data[sidx] << 4) & 077];
        }
    }


    while (didx < out.size())
    {
        out[didx] = '=';
        didx++;
    }
}

QCString KCodecs::base64Decode( const QCString& str )
{
    if ( str.isEmpty() )
        return "";

    QByteArray in( str.length() );
    memcpy( in.data(), str.data(), str.length() );
    return base64Decode( in );
}

QCString KCodecs::base64Decode( const QByteArray& in )
{
    QByteArray out;
    base64Decode( in, out );
    return QCString( out.data(), out.size()+1 );
}

void KCodecs::base64Decode( const QByteArray& in, QByteArray& out )
{
    out.resize(0);
    if ( in.isEmpty() )
        return;

    unsigned int count = 0;
    unsigned int len = in.size(), tail = len;
    const char* data = in.data();


    while ( count < len && (data[count] == '\n' || data[count] == '\r' ||
            data[count] == '\t' || data[count] == ' ') )
        count++;

    if ( strncasecmp(data+count, "begin", 5) == 0 )
    {
        count += 5;
        while ( count < len && data[count] != '\n' && data[count] != '\r' )
            count++;

        while ( count < len && (data[count] == '\n' || data[count] == '\r') )
            count ++;

        data += count;
        tail = (len -= count);
    }



    while ( data[tail-1] == '=' || data[tail-1] == '\n' ||
            data[tail-1] == '\r' )
        if ( data[--tail] != '=' ) len = tail;

    unsigned int outIdx = 0;
    out.resize( (count=len) );
    for (unsigned int idx = 0; idx < count; idx++)
    {


        unsigned char ch = data[idx];
        if ((ch > 47 && ch < 58) || (ch > 64 && ch < 91) ||
            (ch > 96 && ch < 123) || ch == '+' || ch == '/' || ch == '=')
        {
            out[outIdx++] = Base64DecMap[ch];
        }
        else
        {
            len--;
            tail--;
        }
    }




    len = (tail>(len/4)) ? tail-(len/4) : 0;
    unsigned int sidx = 0, didx = 0;
    if ( len > 1 )
    {
      while (didx < len-2)
      {
          out[didx] = (((out[sidx] << 2) & 255) | ((out[sidx+1] >> 4) & 003));
          out[didx+1] = (((out[sidx+1] << 4) & 255) | ((out[sidx+2] >> 2) & 017));
          out[didx+2] = (((out[sidx+2] << 6) & 255) | (out[sidx+3] & 077));
          sidx += 4;
          didx += 3;
      }
    }

    if (didx < len)
        out[didx] = (((out[sidx] << 2) & 255) | ((out[sidx+1] >> 4) & 003));

    if (++didx < len )
        out[didx] = (((out[sidx+1] << 4) & 255) | ((out[sidx+2] >> 2) & 017));


    if ( len == 0 || len < out.size() )
      out.resize(len);
}

QCString KCodecs::uuencode( const QCString& str )
{
    if ( str.isEmpty() )
        return "";

    QByteArray in;
    in.resize( str.length() );
    memcpy( in.data(), str.data(), str.length() );
    return uuencode( in );
}

QCString KCodecs::uuencode( const QByteArray& in )
{
    QByteArray out;
    uuencode( in, out );
    return QCString( out.data(), out.size()+1 );
}

void KCodecs::uuencode( const QByteArray& in, QByteArray& out )
{
    out.resize( 0 );
    if( in.isEmpty() )
        return;

    unsigned int sidx = 0;
    unsigned int didx = 0;
    unsigned int line_len = 45;

    const char nl[] = "\n";
    const char* data = in.data();
    const unsigned int nl_len = strlen(nl);
    const unsigned int len = in.size();

    out.resize( (len+2)/3*4 + ((len+line_len-1)/line_len)*(nl_len+1) );

    while (sidx+line_len < len)
    {

        out[didx++] = UUEncMap[line_len];


        for (unsigned int end = sidx+line_len; sidx < end; sidx += 3)
        {
            out[didx++] = UUEncMap[(data[sidx] >> 2) & 077];
            out[didx++] = UUEncMap[(data[sidx+1] >> 4) & 017 |
                                   (data[sidx] << 4) & 077];
            out[didx++] = UUEncMap[(data[sidx+2] >> 6) & 003 |
                                (data[sidx+1] << 2) & 077];
            out[didx++] = UUEncMap[data[sidx+2] & 077];
        }




        memcpy(out.data()+didx, nl, nl_len);
        didx += nl_len;
    }


    out[didx++] = UUEncMap[len-sidx];

    while (sidx+2 < len)
    {
        out[didx++] = UUEncMap[(data[sidx] >> 2) & 077];
        out[didx++] = UUEncMap[(data[sidx+1] >> 4) & 017 |
                               (data[sidx] << 4) & 077];
        out[didx++] = UUEncMap[(data[sidx+2] >> 6) & 003 |
                               (data[sidx+1] << 2) & 077];
        out[didx++] = UUEncMap[data[sidx+2] & 077];
        sidx += 3;
    }

    if (sidx < len-1)
    {
        out[didx++] = UUEncMap[(data[sidx] >> 2) & 077];
        out[didx++] = UUEncMap[(data[sidx+1] >> 4) & 017 |
                               (data[sidx] << 4) & 077];
        out[didx++] = UUEncMap[(data[sidx+1] << 2) & 077];
        out[didx++] = UUEncMap[0];
    }
    else if (sidx < len)
    {
        out[didx++] = UUEncMap[(data[sidx] >> 2) & 077];
        out[didx++] = UUEncMap[(data[sidx] << 4) & 077];
        out[didx++] = UUEncMap[0];
        out[didx++] = UUEncMap[0];
    }


    memcpy(out.data()+didx, nl, nl_len);
    didx += nl_len;


    if ( didx != out.size() )
        out.resize( 0 );
}

QCString KCodecs::uudecode( const QCString& str )
{
    if ( str.isEmpty() )
        return "";

    QByteArray in;
    in.resize( str.length() );
    memcpy( in.data(), str.data(), str.length() );
    return uudecode( in );
}

QCString KCodecs::uudecode( const QByteArray& in )
{
    QByteArray out;
    uudecode( in, out );
    return QCString( out.data(), out.size()+1 );
}

void KCodecs::uudecode( const QByteArray& in, QByteArray& out )
{
    out.resize( 0 );
    if( in.isEmpty() )
        return;

    unsigned int sidx = 0;
    unsigned int didx = 0;
    unsigned int len = in.size();
    unsigned int line_len, end;
    const char* data = in.data();


    unsigned int count = 0;
    while ( count < len && (data[count] == '\n' || data[count] == '\r' ||
            data[count] == '\t' || data[count] == ' ') )
        count ++;

    bool hasLF = false;
    if ( strncasecmp( data+count, "begin", 5) == 0 )
    {
        count += 5;
        while ( count < len && data[count] != '\n' && data[count] != '\r' )
            count ++;

        while ( count < len && (data[count] == '\n' || data[count] == '\r') )
            count ++;

        data += count;
        len -= count;
        hasLF = true;
    }

    out.resize( len/4*3 );
    while ( sidx < len )
    {

        line_len = UUDecMap[ (unsigned char) data[sidx++]];

        end = didx+line_len;
        char A, B, C, D;
        if (end > 2) {
          while (didx < end-2)
          {
             A = UUDecMap[(unsigned char) data[sidx]];
             B = UUDecMap[(unsigned char) data[sidx+1]];
             C = UUDecMap[(unsigned char) data[sidx+2]];
             D = UUDecMap[(unsigned char) data[sidx+3]];
             out[didx++] = ( ((A << 2) & 255) | ((B >> 4) & 003) );
             out[didx++] = ( ((B << 4) & 255) | ((C >> 2) & 017) );
             out[didx++] = ( ((C << 6) & 255) | (D & 077) );
             sidx += 4;
          }
        }

        if (didx < end)
        {
            A = UUDecMap[(unsigned char) data[sidx]];
            B = UUDecMap[(unsigned char) data[sidx+1]];
            out[didx++] = ( ((A << 2) & 255) | ((B >> 4) & 003) );
        }

        if (didx < end)
        {
            B = UUDecMap[(unsigned char) data[sidx+1]];
            C = UUDecMap[(unsigned char) data[sidx+2]];
            out[didx++] = ( ((B << 4) & 255) | ((C >> 2) & 017) );
        }


        while (sidx < len && data[sidx] != '\n' && data[sidx] != '\r')
            sidx++;


        while (sidx < len && (data[sidx] == '\n' || data[sidx] == '\r'))
            sidx++;


        if ( hasLF && strncasecmp( data+sidx, "end", 3) == 0 )
            break;
    }

    if ( didx < out.size() )
        out.resize( didx );
}


KMD5::KMD5()
{
    init();
}

KMD5::KMD5(const char *in, int len)
{
    init();
    update(in, len);
}

KMD5::KMD5(const QByteArray& in)
{
    init();
    update( in );
}

KMD5::KMD5(const QCString& in)
{
    init();
    update( in );
}

void KMD5::update(const QByteArray& in)
{
    update(in.data(), int(in.size()));
}

void KMD5::update(const QCString& in)
{
    update(in.data(), int(in.length()));
}

void KMD5::update(const unsigned char* in, int len)
{
    if (len < 0)
        len = qstrlen(reinterpret_cast<const char*>(in));

    if (!len)
        return;

    if (m_finalized) {
        kdWarning() << "KMD5::update called after state was finalized!" << endl;
        return;
    }

    Q_UINT32 in_index;
    Q_UINT32 buffer_index;
    Q_UINT32 buffer_space;
    Q_UINT32 in_length = static_cast<Q_UINT32>( len );

    buffer_index = static_cast<Q_UINT32>((m_count[0] >> 3) & 0x3F);

    if ( (m_count[0] += (in_length << 3))<(in_length << 3) )
        m_count[1]++;

    m_count[1] += (in_length >> 29);
    buffer_space = 64 - buffer_index;

    if (in_length >= buffer_space)
    {
        memcpy (m_buffer + buffer_index, in, buffer_space);
        transform (m_buffer);

        for (in_index = buffer_space; in_index + 63 < in_length;
             in_index += 64)
            transform (reinterpret_cast<const unsigned char*>(in+in_index));

        buffer_index = 0;
    }
    else
        in_index=0;

    memcpy(m_buffer+buffer_index, in+in_index, in_length-in_index);
}

bool KMD5::update(QIODevice& file)
{
    char buffer[1024];
    int len;

    while ((len=file.readBlock(reinterpret_cast<char*>(buffer), sizeof(buffer))) > 0)
        update(buffer, len);

    return file.atEnd();
}

void KMD5::finalize ()
{
    if (m_finalized) return;

    Q_UINT8 bits[8];
    Q_UINT32 index, padLen;
    static unsigned char PADDING[64]=
    {
        0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    encode (bits, m_count, 8);



    index = static_cast<Q_UINT32>((m_count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    update (reinterpret_cast<const char*>(PADDING), padLen);


    update (reinterpret_cast<const char*>(bits), 8);


    encode (m_digest, m_state, 16);



    memset ( (void *)m_buffer, 0, sizeof(*m_buffer));

    m_finalized = true;
}


bool KMD5::verify( const KMD5::Digest& digest)
{
    finalize();
    return (0 == memcmp(rawDigest(), digest, sizeof(KMD5::Digest)));
}

bool KMD5::verify( const QCString& hexdigest)
{
    finalize();
    return (0 == strcmp(hexDigest().data(), hexdigest));
}

const KMD5::Digest& KMD5::rawDigest()
{
    finalize();
    return m_digest;
}

void KMD5::rawDigest( KMD5::Digest& bin )
{
    finalize();
    memcpy( bin, m_digest, 16 );
}


QCString KMD5::hexDigest()
{
    QCString s(33);

    finalize();
    sprintf(s.data(), "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
            m_digest[0], m_digest[1], m_digest[2], m_digest[3], m_digest[4], m_digest[5],
            m_digest[6], m_digest[7], m_digest[8], m_digest[9], m_digest[10], m_digest[11],
            m_digest[12], m_digest[13], m_digest[14], m_digest[15]);

    return s;
}

void KMD5::hexDigest(QCString& s)
{
    finalize();
    s.resize(33);
    sprintf(s.data(), "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
            m_digest[0], m_digest[1], m_digest[2], m_digest[3], m_digest[4], m_digest[5],
            m_digest[6], m_digest[7], m_digest[8], m_digest[9], m_digest[10], m_digest[11],
            m_digest[12], m_digest[13], m_digest[14], m_digest[15]);
}

QCString KMD5::base64Digest()
{
    QByteArray ba(16);

    finalize();
    memcpy(ba.data(), m_digest, 16);
    return KCodecs::base64Encode(ba);
}


void KMD5::init()
{
    d = 0;
    reset();
}

void KMD5::reset()
{
    m_finalized = false;

    m_count[0] = 0;
    m_count[1] = 0;

    m_state[0] = 0x67452301;
    m_state[1] = 0xefcdab89;
    m_state[2] = 0x98badcfe;
    m_state[3] = 0x10325476;

    memset ( m_buffer, 0, sizeof(*m_buffer));
    memset ( m_digest, 0, sizeof(*m_digest));
}

void KMD5::transform( const unsigned char block[64] )
{

    Q_UINT32 a = m_state[0], b = m_state[1], c = m_state[2], d = m_state[3], x[16];

    decode (x, block, 64);


    ((!m_finalized) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","!m_finalized","/coolo/prod/kdelibs/kdecore/kmdcodec.cpp",958));


    FF (a, b, c, d, x[ 0], 7, 0xd76aa478);
    FF (d, a, b, c, x[ 1], 12, 0xe8c7b756);
    FF (c, d, a, b, x[ 2], 17, 0x242070db);
    FF (b, c, d, a, x[ 3], 22, 0xc1bdceee);
    FF (a, b, c, d, x[ 4], 7, 0xf57c0faf);
    FF (d, a, b, c, x[ 5], 12, 0x4787c62a);
    FF (c, d, a, b, x[ 6], 17, 0xa8304613);
    FF (b, c, d, a, x[ 7], 22, 0xfd469501);
    FF (a, b, c, d, x[ 8], 7, 0x698098d8);
    FF (d, a, b, c, x[ 9], 12, 0x8b44f7af);
    FF (c, d, a, b, x[10], 17, 0xffff5bb1);
    FF (b, c, d, a, x[11], 22, 0x895cd7be);
    FF (a, b, c, d, x[12], 7, 0x6b901122);
    FF (d, a, b, c, x[13], 12, 0xfd987193);
    FF (c, d, a, b, x[14], 17, 0xa679438e);
    FF (b, c, d, a, x[15], 22, 0x49b40821);


    GG (a, b, c, d, x[ 1], 5, 0xf61e2562);
    GG (d, a, b, c, x[ 6], 9, 0xc040b340);
    GG (c, d, a, b, x[11], 14, 0x265e5a51);
    GG (b, c, d, a, x[ 0], 20, 0xe9b6c7aa);
    GG (a, b, c, d, x[ 5], 5, 0xd62f105d);
    GG (d, a, b, c, x[10], 9, 0x2441453);
    GG (c, d, a, b, x[15], 14, 0xd8a1e681);
    GG (b, c, d, a, x[ 4], 20, 0xe7d3fbc8);
    GG (a, b, c, d, x[ 9], 5, 0x21e1cde6);
    GG (d, a, b, c, x[14], 9, 0xc33707d6);
    GG (c, d, a, b, x[ 3], 14, 0xf4d50d87);
    GG (b, c, d, a, x[ 8], 20, 0x455a14ed);
    GG (a, b, c, d, x[13], 5, 0xa9e3e905);
    GG (d, a, b, c, x[ 2], 9, 0xfcefa3f8);
    GG (c, d, a, b, x[ 7], 14, 0x676f02d9);
    GG (b, c, d, a, x[12], 20, 0x8d2a4c8a);


    HH (a, b, c, d, x[ 5], 4, 0xfffa3942);
    HH (d, a, b, c, x[ 8], 11, 0x8771f681);
    HH (c, d, a, b, x[11], 16, 0x6d9d6122);
    HH (b, c, d, a, x[14], 23, 0xfde5380c);
    HH (a, b, c, d, x[ 1], 4, 0xa4beea44);
    HH (d, a, b, c, x[ 4], 11, 0x4bdecfa9);
    HH (c, d, a, b, x[ 7], 16, 0xf6bb4b60);
    HH (b, c, d, a, x[10], 23, 0xbebfbc70);
    HH (a, b, c, d, x[13], 4, 0x289b7ec6);
    HH (d, a, b, c, x[ 0], 11, 0xeaa127fa);
    HH (c, d, a, b, x[ 3], 16, 0xd4ef3085);
    HH (b, c, d, a, x[ 6], 23, 0x4881d05);
    HH (a, b, c, d, x[ 9], 4, 0xd9d4d039);
    HH (d, a, b, c, x[12], 11, 0xe6db99e5);
    HH (c, d, a, b, x[15], 16, 0x1fa27cf8);
    HH (b, c, d, a, x[ 2], 23, 0xc4ac5665);


    II (a, b, c, d, x[ 0], 6, 0xf4292244);
    II (d, a, b, c, x[ 7], 10, 0x432aff97);
    II (c, d, a, b, x[14], 15, 0xab9423a7);
    II (b, c, d, a, x[ 5], 21, 0xfc93a039);
    II (a, b, c, d, x[12], 6, 0x655b59c3);
    II (d, a, b, c, x[ 3], 10, 0x8f0ccc92);
    II (c, d, a, b, x[10], 15, 0xffeff47d);
    II (b, c, d, a, x[ 1], 21, 0x85845dd1);
    II (a, b, c, d, x[ 8], 6, 0x6fa87e4f);
    II (d, a, b, c, x[15], 10, 0xfe2ce6e0);
    II (c, d, a, b, x[ 6], 15, 0xa3014314);
    II (b, c, d, a, x[13], 21, 0x4e0811a1);
    II (a, b, c, d, x[ 4], 6, 0xf7537e82);
    II (d, a, b, c, x[11], 10, 0xbd3af235);
    II (c, d, a, b, x[ 2], 15, 0x2ad7d2bb);
    II (b, c, d, a, x[ 9], 21, 0xeb86d391);

    m_state[0] += a;
    m_state[1] += b;
    m_state[2] += c;
    m_state[3] += d;

    memset ( static_cast<void *>(x), 0, sizeof(x) );
}

inline Q_UINT32 KMD5::rotate_left (Q_UINT32 x, Q_UINT32 n)
{
    return (x << n) | (x >> (32-n)) ;
}

inline Q_UINT32 KMD5::F (Q_UINT32 x, Q_UINT32 y, Q_UINT32 z)
{
    return (x & y) | (~x & z);
}

inline Q_UINT32 KMD5::G (Q_UINT32 x, Q_UINT32 y, Q_UINT32 z)
{
    return (x & z) | (y & ~z);
}

inline Q_UINT32 KMD5::H (Q_UINT32 x, Q_UINT32 y, Q_UINT32 z)
{
    return x ^ y ^ z;
}

inline Q_UINT32 KMD5::I (Q_UINT32 x, Q_UINT32 y, Q_UINT32 z)
{
    return y ^ (x | ~z);
}

void KMD5::FF ( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d,
                       Q_UINT32 x, Q_UINT32 s, Q_UINT32 ac )
{
    a += F(b, c, d) + x + ac;
    a = rotate_left (a, s) +b;
}

void KMD5::GG ( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d,
                 Q_UINT32 x, Q_UINT32 s, Q_UINT32 ac)
{
    a += G(b, c, d) + x + ac;
    a = rotate_left (a, s) +b;
}

void KMD5::HH ( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d,
                 Q_UINT32 x, Q_UINT32 s, Q_UINT32 ac )
{
    a += H(b, c, d) + x + ac;
    a = rotate_left (a, s) +b;
}

void KMD5::II ( Q_UINT32& a, Q_UINT32 b, Q_UINT32 c, Q_UINT32 d,
                 Q_UINT32 x, Q_UINT32 s, Q_UINT32 ac )
{
    a += I(b, c, d) + x + ac;
    a = rotate_left (a, s) +b;
}


void KMD5::encode ( unsigned char* output, Q_UINT32 *in, Q_UINT32 len )
{

    memcpy(output, in, len);
# 1109 "/coolo/prod/kdelibs/kdecore/kmdcodec.cpp"
}



void KMD5::decode (Q_UINT32 *output, const unsigned char* in, Q_UINT32 len)
{

    memcpy(output, in, len);
# 1126 "/coolo/prod/kdelibs/kdecore/kmdcodec.cpp"
}
# 73 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksocks.cpp" 1
# 19 "/coolo/prod/kdelibs/kdecore/ksocks.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 20 "/coolo/prod/kdelibs/kdecore/ksocks.cpp" 2
# 43 "/coolo/prod/kdelibs/kdecore/ksocks.cpp"
enum SymbolKeys {
      S_SOCKSinit = 0,
      S_connect = 1,
      S_read = 2,
      S_write = 3,
      S_recvfrom = 4,
      S_sendto = 5,
      S_recv = 6,
      S_send = 7,
      S_getsockname = 8,
      S_getpeername = 9,
      S_accept = 10,
      S_select = 11,
      S_listen = 12,
      S_bind = 13
     };


extern "C" {

static int (*F_SOCKSinit) (char *) = 0L;
static int (*F_connect) (int, const struct sockaddr *, ksocklen_t) = 0L;
static signed long int (*F_read) (int, void *, unsigned long int) = 0L;
static signed long int (*F_write) (int, const void *, unsigned long int) = 0L;
static int (*F_recvfrom) (int, void *, unsigned long int, int, struct sockaddr *,
                                 ksocklen_t *) = 0L;
static int (*F_sendto) (int, const void *, unsigned long int, int,
                                 const struct sockaddr *, ksocklen_t) = 0L;
static int (*F_recv) (int, void *, unsigned long int, int) = 0L;
static int (*F_send) (int, const void *, unsigned long int, int) = 0L;
static int (*F_getsockname) (int, struct sockaddr *, ksocklen_t *) = 0L;
static int (*F_getpeername) (int, struct sockaddr *, ksocklen_t *) = 0L;
static int (*F_accept) (int, struct sockaddr *, ksocklen_t *) = 0L;
static int (*F_select) (int, fd_set *, fd_set *, fd_set *,
                                                     struct timeval *) = 0L;
static int (*F_listen) (int, int) = 0L;
static int (*F_bind) (int, const struct sockaddr *, ksocklen_t) = 0L;
}


class KSocksTable {
 public:
   KSocksTable();


   QMap<SymbolKeys,QString> symbols;

   QString myname;
   bool hasWorkingAsyncConnect;
};


KSocksTable::KSocksTable() : myname("Unknown"), hasWorkingAsyncConnect(true) {
}
# 123 "/coolo/prod/kdelibs/kdecore/ksocks.cpp"
class KNECSocksTable : public KSocksTable {
  public:
    KNECSocksTable();
    virtual ~KNECSocksTable();
};


KNECSocksTable::KNECSocksTable() : KSocksTable() {
  myname = i18n("NEC SOCKS client");
  symbols.insert(S_SOCKSinit, "SOCKSinit");
  symbols.insert(S_connect, "connect");
  symbols.insert(S_read, "read");
  symbols.insert(S_write, "write");
  symbols.insert(S_recvfrom, "recvfrom");
  symbols.insert(S_sendto, "sendto");
  symbols.insert(S_recv, "recv");
  symbols.insert(S_send, "send");
  symbols.insert(S_getsockname, "getsockname");
  symbols.insert(S_getpeername, "getpeername");
  symbols.insert(S_accept, "accept");
  symbols.insert(S_select, "select");
  symbols.insert(S_listen, "listen");
  symbols.insert(S_bind, "bind");
}

KNECSocksTable::~KNECSocksTable() {
}
# 158 "/coolo/prod/kdelibs/kdecore/ksocks.cpp"
class KDanteSocksTable : public KSocksTable {
  public:
    KDanteSocksTable();
    virtual ~KDanteSocksTable();
};

KDanteSocksTable::KDanteSocksTable() : KSocksTable() {
  hasWorkingAsyncConnect = false;
  myname = i18n("Dante SOCKS client");
  symbols.insert(S_SOCKSinit, "SOCKSinit");
  symbols.insert(S_connect, "Rconnect");
  symbols.insert(S_read, "Rread");
  symbols.insert(S_write, "Rwrite");
  symbols.insert(S_recvfrom, "Rrecvfrom");
  symbols.insert(S_sendto, "Rsendto");
  symbols.insert(S_recv, "Rrecv");
  symbols.insert(S_send, "Rsend");
  symbols.insert(S_getsockname, "Rgetsockname");
  symbols.insert(S_getpeername, "Rgetpeername");
  symbols.insert(S_accept, "Raccept");
  symbols.insert(S_select, "Rselect");
  symbols.insert(S_listen, "Rlisten");
  symbols.insert(S_bind, "Rbind");
}


KDanteSocksTable::~KDanteSocksTable() {
}
# 194 "/coolo/prod/kdelibs/kdecore/ksocks.cpp"
KSocks *KSocks::_me = 0;
bool KSocks::_disabled = false;

void KSocks::disable()
{
   if (!_me)
      _disabled = true;
}

KSocks *KSocks::self() {

  if (!_me) {
     if (KApplication::kApplication()) {
        KConfigGroup cfg(KApplication::kApplication()->config(), "Socks");
        _me = new KSocks(&cfg);
     } else {
        _disabled = true;
        _me = new KSocks(0);
     }
  }
  return _me;
}

void KSocks::setConfig(KConfigBase *config)
{


  if (_me && _disabled) {
     delete _me;
     _me = 0;
     _disabled = false;
  }
  if (!_me)
    _me = new KSocks(config);
}

bool KSocks::activated() { return (_me != 0L); }


KSocks::KSocks(KConfigBase *config) : _socksLib(0L), _st(0L) {
   _hasSocks = false;
   _useSocks = false;

   if (!config)
      return;

   if (!(config->readBoolEntry("SOCKS_enable", false))) {
      _disabled = true;
   }

   if (_disabled)
      return;

   _libPaths << ""
             << "/usr/lib/"
             << "/usr/local/lib/"
             << "/usr/local/socks5/lib/"
             << "/opt/socks5/lib/";
   _libNames << "libsocks.so"
             << "libsocks5.so"
             << "libsocks5_sh.so";


   QStringList newlibs = config->readListEntry("SOCKS_lib_path");

   for (QStringList::Iterator it = newlibs.begin();
                              it != newlibs.end();
                              ++it) {
      QString thisone = *it;
      if (thisone[thisone.length()-1] != '/') thisone += "/";
      _libPaths << thisone;
      kdDebug(171) << "KSocks added a new library path: " << thisone << endl;
   }


   KLibLoader *ll = KLibLoader::self();


   int _meth = config->readNumEntry("SOCKS_method", 1);





   if (_meth == 4) {
      _socksLib = ll->library(config->readPathEntry("SOCKS_lib").latin1());
      if (_socksLib && _socksLib->symbol("Rconnect")) {
         _st = new KDanteSocksTable;
         _useSocks = true;
         _hasSocks = true;
      } else if (_socksLib && _socksLib->symbol("connect")) {
         _st = new KNECSocksTable;
         _useSocks = true;
         _hasSocks = true;
      } else if (_socksLib) {
         _socksLib->unload();
         _socksLib = 0L;
      }
   } else
   for (QStringList::Iterator pit = _libPaths.begin();
                              !_hasSocks && pit != _libPaths.end();
                              ++pit)
   for (QStringList::Iterator it = _libNames.begin();
                              it != _libNames.end();
                              ++it) {
      _socksLib = ll->library((*pit + *it).latin1());
      if (_socksLib) {
         if ((_meth == 1 || _meth == 2) &&
             _socksLib->symbol("S5LogShowThreadIDS") != 0L) {
            kdDebug(171) << "Found NEC SOCKS" << endl;
            _st = new KNECSocksTable;
            _useSocks = true;
            _hasSocks = true;
            break;
         } else if ((_meth == 1 || _meth == 3) &&
                    _socksLib->symbol("sockaddr2ruleaddress") != 0L) {
            kdDebug(171) << "Found Dante SOCKS" << endl;
            _st = new KDanteSocksTable;
            _useSocks = true;
            _hasSocks = true;
            break;
         } else {
           _socksLib->unload();
           _socksLib = 0L;
         }
      }
   }


   if (_st) {
      for (QMap<SymbolKeys,QString>::Iterator it = _st->symbols.begin();
                                              it != _st->symbols.end();
                                              ++it) {
         switch(it.key()) {
         case S_SOCKSinit:
           F_SOCKSinit = (int (*)(char *))
                         _socksLib->symbol(it.data().latin1());
          break;
         case S_connect:
           F_connect = (int (*)(int, const struct sockaddr *, ksocklen_t))
                       _socksLib->symbol(it.data().latin1());
          break;
         case S_read:
           F_read = (signed long int (*)(int, void *, unsigned long int))
                    _socksLib->symbol(it.data().latin1());
          break;
         case S_write:
           F_write = (signed long int (*)(int, const void *, unsigned long int))
                     _socksLib->symbol(it.data().latin1());
          break;
         case S_recvfrom:
           F_recvfrom = (int (*)(int, void *, unsigned long int, int,
                                 struct sockaddr *, ksocklen_t *))
                        _socksLib->symbol(it.data().latin1());
          break;
         case S_sendto:
           F_sendto = (int (*)(int, const void *, unsigned long int, int,
                               const struct sockaddr *, ksocklen_t))
                      _socksLib->symbol(it.data().latin1());
          break;
         case S_recv:
           F_recv = (int (*)(int, void *, unsigned long int, int))
                    _socksLib->symbol(it.data().latin1());
          break;
         case S_send:
           F_send = (int (*)(int, const void *, unsigned long int, int))
                    _socksLib->symbol(it.data().latin1());
          break;
         case S_getsockname:
           F_getsockname = (int (*)(int, struct sockaddr *, ksocklen_t *))
                           _socksLib->symbol(it.data().latin1());
          break;
         case S_getpeername:
           F_getpeername = (int (*)(int, struct sockaddr *, ksocklen_t *))
                           _socksLib->symbol(it.data().latin1());
          break;
         case S_accept:
           F_accept = (int (*)(int, struct sockaddr *, ksocklen_t *))
                      _socksLib->symbol(it.data().latin1());
          break;
         case S_select:
           F_select = (int (*)(int, fd_set *, fd_set *, fd_set *, struct timeval *))
                      _socksLib->symbol(it.data().latin1());
          break;
         case S_listen:
           F_listen = (int (*)(int, int))
                      _socksLib->symbol(it.data().latin1());
          break;
         case S_bind:
           F_bind = (int (*)(int, const struct sockaddr *, ksocklen_t))
                    _socksLib->symbol(it.data().latin1());
          break;
         default:
          kdDebug(171) << "KSocks got a symbol it doesn't know about!" << endl;
          break;
         }
      }


      if (F_SOCKSinit) {
         int rc = (*F_SOCKSinit)((char *)"KDE");
         if (rc != 0)
            stopSocks();
         else kdDebug(171) << "SOCKS has been activated!" << endl;
      } else {
         stopSocks();
      }
   }
}


KSocks::~KSocks() {
   stopSocks();
   _me = 0;
}

void KSocks::die() {
   if (_me == this) {
      _me = 0;
      delete this;
   }
}

void KSocks::stopSocks() {
   if (_hasSocks) {


      _useSocks = false;
      _hasSocks = false;
      if (_socksLib) {
         _socksLib->unload();
         _socksLib = 0L;
      }
      delete _st;
      _st = 0L;
   }
}


bool KSocks::usingSocks() {
   return _useSocks;
}


bool KSocks::hasSocks() {
   return _hasSocks;
}


void KSocks::disableSocks() {
   _useSocks = false;
}


void KSocks::enableSocks() {
   if (_hasSocks)
      _useSocks = true;
}

bool KSocks::hasWorkingAsyncConnect()
{
   return (_useSocks && _st) ? _st->hasWorkingAsyncConnect : true;
}







int KSocks::connect (int sockfd, const sockaddr *serv_addr,
                                                   ksocklen_t addrlen) {
   if (_useSocks && F_connect)
      return (*F_connect)(sockfd, serv_addr, addrlen);
   else return ::connect(sockfd, (sockaddr*) serv_addr, (socklen_t)addrlen);
}


signed long int KSocks::read (int fd, void *buf, unsigned long int count) {
   if (_useSocks && F_read)
      return (*F_read)(fd, buf, count);
   else return ::read(fd, buf, count);
}


signed long int KSocks::write (int fd, const void *buf, unsigned long int count) {
   if (_useSocks && F_write)
      return (*F_write)(fd, buf, count);
   else return ::write(fd, buf, count);
}


int KSocks::recvfrom (int s, void *buf, unsigned long int len, int flags,
                                sockaddr *from, ksocklen_t *fromlen) {
   if (_useSocks && F_recvfrom) {
      return (*F_recvfrom)(s, buf, len, flags, from, fromlen);
   } else {
      socklen_t casted_len = (socklen_t) *fromlen;
      int rc = ::recvfrom(s, (char*) buf, len, flags, from, &casted_len);
      *fromlen = casted_len;
      return rc;
   }
}


int KSocks::sendto (int s, const void *msg, unsigned long int len, int flags,
                             const sockaddr *to, ksocklen_t tolen) {
   if (_useSocks && F_sendto)
      return (*F_sendto)(s, msg, len, flags, to, tolen);
   else return ::sendto(s, (char*) msg, len, flags, to, (socklen_t)tolen);
}


int KSocks::recv (int s, void *buf, unsigned long int len, int flags) {
   if (_useSocks && F_recv)
      return (*F_recv)(s, buf, len, flags);
   else return ::recv(s, (char*) buf, len, flags);
}


int KSocks::send (int s, const void *msg, unsigned long int len, int flags) {
   if (_useSocks && F_send)
      return (*F_send)(s, msg, len, flags);
   else return ::send(s, (char*) msg, len, flags);
}


int KSocks::getsockname (int s, sockaddr *name, ksocklen_t *namelen) {
   if (_useSocks && F_getsockname) {
      return (*F_getsockname)(s, name, namelen);
   } else {
     socklen_t casted_len = *namelen;
     int rc = ::getsockname(s, name, &casted_len);
     *namelen = casted_len;
     return rc;
   }
}


int KSocks::getpeername (int s, sockaddr *name, ksocklen_t *namelen) {
   if (_useSocks && F_getpeername) {
      return (*F_getpeername)(s, name, namelen);
   } else {
      socklen_t casted_len = *namelen;
      int rc = ::getpeername(s, name, &casted_len);
      *namelen = casted_len;
      return rc;
   }
}


int KSocks::accept (int s, sockaddr *addr, ksocklen_t *addrlen) {
   if (_useSocks && F_accept) {
     return (*F_accept)(s, addr, addrlen);
   } else {
      socklen_t casted_len = *addrlen;
      int rc = ::accept(s, addr, &casted_len);
      *addrlen = casted_len;
      return rc;
   }
}


int KSocks::select (int n, fd_set *readfds, fd_set *writefds,
                                fd_set *exceptfds, struct timeval *timeout) {
   if (_useSocks && F_select)
      return (*F_select)(n, readfds, writefds, exceptfds, timeout);
   else return ::select(n, readfds, writefds, exceptfds, timeout);
}


int KSocks::listen (int s, int backlog) {
   if (_useSocks && F_listen)
      return (*F_listen)(s, backlog);
   else return ::listen(s, backlog);
}


int KSocks::bind (int sockfd, const sockaddr *my_addr, ksocklen_t addrlen) {
   if (_useSocks && F_bind)
      return (*F_bind)(sockfd, my_addr, addrlen);
   else return ::bind(sockfd, my_addr, (socklen_t)addrlen);
}

int KSocks::bind (int sockfd, sockaddr *my_addr, ksocklen_t addrlen) {
   if (_useSocks && F_bind)
      return (*F_bind)(sockfd, my_addr, addrlen);
   else return ::bind(sockfd, my_addr, (socklen_t)addrlen);
}
# 74 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp" 1
# 19 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 20 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp" 2

# 1 "/coolo/prod/kdelibs/kdecore/ksycoca.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/ksycoca.h"






class QDataStream;
class KSycocaPrivate;
class KSycocaFactory;
class KSycocaFactoryList;











class KSycoca : public QObject, public DCOPObject
{
  public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
  public: virtual bool process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData); QCStringList functions(); QCStringList interfaces(); private:

protected:




   KSycoca( bool );

public:




   KSycoca();




   static KSycoca *self();

   virtual ~KSycoca();

   static int version();





   QDataStream *findEntry(int offset, KSycocaType &type);



   QDataStream *findFactory( KSycocaFactoryId id);



   QString kfsstnd_prefixes();



   QString language();







   Q_UINT32 timeStamp();
# 106 "/coolo/prod/kdelibs/kdecore/ksycoca.h"
   Q_UINT32 updateSignature();





   QStringList allResourceDirs();




   void addFactory( KSycocaFactory * );





   virtual bool isBuilding() { return false; }




   void disableAutoRebuild();




   static QString determineRelativePath( const QString & _fullpath, const char *_resource );






   static bool isChanged(const char *type);




   static void flagError();




   static bool readError();

public:



   void notifyDatabaseChanged(const QStringList &);

protected:




   void databaseChanged();

protected:
   bool checkVersion(bool abortOnError=true);
   bool openDatabase(bool openDummyIfNotFound=true);
   void closeDatabase();
   KSycocaFactoryList *m_lstFactories;
   QDataStream *m_str;
   bool bNoDatabase;
   size_t m_sycoca_size;
   const char *m_sycoca_mmap;
   Q_UINT32 m_timeStamp;

public:
   static KSycoca *_self;

protected:
  virtual void virtual_hook( int id, void* data );
private:
   KSycocaPrivate *d;
};
# 22 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp" 2

# 1 "/coolo/prod/kdelibs/kdecore/ksycocafactory.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/ksycocafactory.h"






class KSycoca;
class QStringList;
class QString;
class KSycocaDict;
class KSycocaResourceList;

typedef QDict<KSycocaEntry::Ptr> KSycocaEntryDict;





class KSycocaFactory
{
public:
   virtual KSycocaFactoryId factoryId() const = 0;

protected:




   KSycocaFactory( KSycocaFactoryId factory_id );

public:
   virtual ~KSycocaFactory();




   int offset() { return mOffset; }




   KSycocaEntryDict * entryDict() { return m_entryDict; }





   virtual KSycocaEntry *createEntry(const QString &file, const char *resource) = 0;




   virtual void addEntry(KSycocaEntry *newEntry, const char *resource);




   virtual KSycocaEntry *createEntry(int offset)=0;




   KSycocaEntry::List allEntries();
# 96 "/coolo/prod/kdelibs/kdecore/ksycocafactory.h"
   virtual void save(QDataStream &str);
# 105 "/coolo/prod/kdelibs/kdecore/ksycocafactory.h"
   virtual void saveHeader(QDataStream &str);




   virtual const KSycocaResourceList * resourceList() const { return m_resourceList; }

private:
   int mOffset;

protected:
   int m_sycocaDictOffset;
   int m_beginEntryOffset;
   int m_endEntryOffset;
   QDataStream *m_str;

   KSycocaResourceList *m_resourceList;
   KSycocaEntryDict *m_entryDict;
   KSycocaDict *m_sycocaDict;
protected:
   virtual void virtual_hook( int id, void* data );
};




class KSycocaFactoryList : public QPtrList<KSycocaFactory>
{
public:
   KSycocaFactoryList() { }
};
# 24 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp" 2



# 1 "/coolo/prod/qt-copy/include/qbuffer.h" 1
# 39 "/coolo/prod/qt-copy/include/qbuffer.h"







class QBuffer : public QIODevice
{
public:
    QBuffer();
    QBuffer( QByteArray );
   ~QBuffer();

    QByteArray buffer() const;
    bool setBuffer( QByteArray );

    bool open( int );
    void close();
    void flush();

    Offset size() const;
    Offset at() const;
    bool at( Offset );

    Q_LONG readBlock( char *p, Q_ULONG );
    Q_LONG writeBlock( const char *p, Q_ULONG );
    Q_LONG writeBlock( const QByteArray& data )
              { return QIODevice::writeBlock(data); }
    Q_LONG readLine( char *p, Q_ULONG );

    int getch();
    int putch( int );
    int ungetch( int );

protected:
    QByteArray a;

private:
    uint a_len;
    uint a_inc;

private:

    QBuffer( const QBuffer & );
    QBuffer &operator=( const QBuffer & );

};


inline QByteArray QBuffer::buffer() const
{ return a; }

inline QIODevice::Offset QBuffer::size() const
{ return (Offset)a.size(); }

inline QIODevice::Offset QBuffer::at() const
{ return ioIndex; }
# 28 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp" 2
# 36 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp"
# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 37 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp" 2
# 49 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp"
template class QPtrList<KSycocaFactory>;
# 59 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp"
struct KSycocaPrivate {
    KSycocaPrivate() {
        database = 0;
        readError = false;
        updateSig = 0;
        autoRebuild = true;
    }
    QFile *database;
    QStringList changeList;
    QString language;
    bool readError;
    bool autoRebuild;
    Q_UINT32 updateSig;
    QStringList allResourceDirs;
};

int KSycoca::version()
{
   return 68;
}


KSycoca::KSycoca()
  : DCOPObject("ksycoca"), m_lstFactories(0), m_str(0), bNoDatabase(false),
    m_sycoca_size(0), m_sycoca_mmap(0), m_timeStamp(0)
{
   d = new KSycocaPrivate;

   if (KApplication::kApplication() && !KApplication::kApplication()->dcopClient()->isAttached())
   {
      KApplication::kApplication()->dcopClient()->attach();
   }




   openDatabase();
   _self = this;
}

bool KSycoca::openDatabase( bool openDummyIfNotFound )
{
   bool result = true;

   m_sycoca_mmap = 0;
   m_str = 0;
   QString path;
   QCString ksycoca_env = getenv("KDESYCOCA");
   if (ksycoca_env.isEmpty())
      path = KGlobal::dirs()->saveLocation("cache") + "ksycoca";
   else
      path = QFile::decodeName(ksycoca_env);

   kdDebug(7011) << "Trying to open ksycoca from " << path << endl;
   QFile *database = new QFile(path);
   bool bOpen = database->open( 0x0001 );
   if (!bOpen)
   {
     path = locate("services", "ksycoca");
     if (!path.isEmpty())
     {
       kdDebug(7011) << "Trying to open global ksycoca from " << path << endl;
       delete database;
       database = new QFile(path);
       bOpen = database->open( 0x0001 );
     }
   }

   if (bOpen)
   {
     fcntl(database->handle(), 2, 1);
     m_sycoca_size = database->size();

     m_sycoca_mmap = (const char *) mmap(0, m_sycoca_size,
                                0x1, 0x01,
                                database->handle(), 0);


     if (m_sycoca_mmap == (const char*) ((void *) -1) || m_sycoca_mmap == 0)
     {
        kdDebug(7011) << "mmap failed. (length = " << m_sycoca_size << ")" << endl;

        m_str = new QDataStream(database);

     }
     else
     {
        QByteArray b_array;
        b_array.setRawData(m_sycoca_mmap, m_sycoca_size);
        QBuffer *buffer = new QBuffer( b_array );
        buffer->open(0x0003);
        m_str = new QDataStream( buffer);
     }

     bNoDatabase = false;
   }
   else
   {
     kdDebug(7011) << "Could not open ksycoca" << endl;


     delete database;
     database = 0;

     bNoDatabase = true;
     if (openDummyIfNotFound)
     {


        QBuffer *buffer = new QBuffer( QByteArray() );
        buffer->open(0x0003);
        m_str = new QDataStream( buffer);
        (*m_str) << (Q_INT32) 68;
        (*m_str) << (Q_INT32) 0;
     }
     else
     {
        result = false;
     }
   }
   m_lstFactories = new KSycocaFactoryList();
   m_lstFactories->setAutoDelete( true );
   d->database = database;
   return result;
}


KSycoca::KSycoca( bool )
  : DCOPObject("ksycoca_building"), m_lstFactories(0), m_str(0), bNoDatabase(false),
    m_sycoca_size(0), m_sycoca_mmap(0)
{
   d = new KSycocaPrivate;
   m_lstFactories = new KSycocaFactoryList();
   m_lstFactories->setAutoDelete( true );
   _self = this;
}

static void delete_ksycoca_self() {
  delete KSycoca::_self;
}

KSycoca * KSycoca::self()
{
    if (!_self) {
        qAddPostRoutine(delete_ksycoca_self);
        _self = new KSycoca();
    }
  return _self;
}

KSycoca::~KSycoca()
{
   closeDatabase();
   delete d;
   _self = 0L;
}

void KSycoca::closeDatabase()
{
   QIODevice *device = 0;
   if (m_str)
      device = m_str->device();

   if (device && m_sycoca_mmap)
   {
      QBuffer *buf = (QBuffer *) device;
      buf->buffer().resetRawData(m_sycoca_mmap, m_sycoca_size);


      munmap((char*) m_sycoca_mmap, m_sycoca_size);
      m_sycoca_mmap = 0;
   }


   delete m_str;
   m_str = 0;
   delete device;
   if (d->database != device)
      delete d->database;
   device = 0;
   d->database = 0;


   delete m_lstFactories;
   m_lstFactories = 0L;
}

void KSycoca::addFactory( KSycocaFactory *factory )
{
   (static_cast<void> ((m_lstFactories) ? 0 : (__assert_fail ("m_lstFactories", "/coolo/prod/kdelibs/kdecore/ksycoca.cpp", 248, __PRETTY_FUNCTION__), 0)));
   m_lstFactories->append(factory);
}

bool KSycoca::isChanged(const char *type)
{
    return self()->d->changeList.contains(type);
}

void KSycoca::notifyDatabaseChanged(const QStringList &changeList)
{
    d->changeList = changeList;





    closeDatabase();


    databaseChanged();
}

QDataStream * KSycoca::findEntry(int offset, KSycocaType &type)
{
   if ( !m_str )
      openDatabase();

   m_str->device()->at(offset);
   Q_INT32 aType;
   (*m_str) >> aType;
   type = (KSycocaType) aType;

   return m_str;
}

bool KSycoca::checkVersion(bool abortOnError)
{
   if ( !m_str )
   {
      if( !openDatabase(false ) )
        return false;


      (static_cast<void> ((m_str) ? 0 : (__assert_fail ("m_str", "/coolo/prod/kdelibs/kdecore/ksycoca.cpp", 292, __PRETTY_FUNCTION__), 0)));
   }
   m_str->device()->at(0);
   Q_INT32 aVersion;
   (*m_str) >> aVersion;
   if ( aVersion < 68 )
   {
      kdWarning(7011) << "Found version " << aVersion << ", expecting version " << 68 << " or higher." << endl;
      if (!abortOnError) return false;
      kdError(7011) << "Outdated database ! Stop kded and restart it !" << endl;
      abort();
   }
   return true;
}

QDataStream * KSycoca::findFactory(KSycocaFactoryId id)
{

   if (bNoDatabase)
   {
      closeDatabase();

      if ( !openDatabase(false ) )
      {
         static bool triedLaunchingKdeinit = false;
         if (!triedLaunchingKdeinit)
         {
           triedLaunchingKdeinit = true;
           kdDebug(7011) << "findFactory: we have no database.... launching kdeinit" << endl;
           KApplication::startKdeinit();

         }
         if (!openDatabase(false))
            return 0L;
      }
   }

   if (!checkVersion(false))
   {
     kdWarning(7011) << "Outdated database found" << endl;
     return 0L;
   }
   Q_INT32 aId;
   Q_INT32 aOffset;
   while(true)
   {
      (*m_str) >> aId;

      if (aId == 0)
      {
         kdError(7011) << "Error, KSycocaFactory (id = " << int(id) << ") not found!" << endl;
         break;
      }
      (*m_str) >> aOffset;
      if (aId == id)
      {

         m_str->device()->at(aOffset);
         return m_str;
      }
   }
   return 0;
}

QString KSycoca::kfsstnd_prefixes()
{
   if (bNoDatabase) return "";
   if (!checkVersion(false)) return "";
   Q_INT32 aId;
   Q_INT32 aOffset;

   while(true)
   {
      (*m_str) >> aId;
      if ( aId )
        (*m_str) >> aOffset;
      else
        break;
   }

   QString prefixes;
   KSycocaEntry::read(*m_str, prefixes);
   (*m_str) >> m_timeStamp;
   KSycocaEntry::read(*m_str, d->language);
   (*m_str) >> d->updateSig;
   KSycocaEntry::read(*m_str, d->allResourceDirs);
   return prefixes;
}

Q_UINT32 KSycoca::timeStamp()
{
   if (!m_timeStamp)
      (void) kfsstnd_prefixes();
   return m_timeStamp;
}

Q_UINT32 KSycoca::updateSignature()
{
   if (!m_timeStamp)
      (void) kfsstnd_prefixes();
   return d->updateSig;
}

QString KSycoca::language()
{
   if (d->language.isEmpty())
      (void) kfsstnd_prefixes();
   return d->language;
}

QStringList KSycoca::allResourceDirs()
{
   if (!m_timeStamp)
      (void) kfsstnd_prefixes();
   return d->allResourceDirs;
}

QString KSycoca::determineRelativePath( const QString & _fullpath, const char *_resource )
{
  QString sRelativeFilePath;
  QStringList dirs = KGlobal::dirs()->resourceDirs( _resource );
  QStringList::ConstIterator dirsit = dirs.begin();
  for ( ; dirsit != dirs.end() && sRelativeFilePath.isEmpty(); ++dirsit ) {

    if ( _fullpath.find( *dirsit ) == 0 )
      sRelativeFilePath = _fullpath.mid( (*dirsit).length() );
  }
  if ( sRelativeFilePath.isEmpty() )
    kdFatal(7011) << QString("Couldn't find %1 in any %2 dir !!!").arg( _fullpath ).arg( _resource) << endl;



  return sRelativeFilePath;
}

KSycoca * KSycoca::_self = 0L;

void KSycoca::flagError()
{
   qWarning("ERROR: KSycoca database corruption!");
   if (_self)
   {
      if (_self->d->readError)
         return;
      _self->d->readError = true;
      if (_self->d->autoRebuild)
         system("kbuildsycoca");
   }
}

void KSycoca::disableAutoRebuild()
{
   d->autoRebuild = false;
}

bool KSycoca::readError()
{
   bool b = false;
   if (_self)
   {
      b = _self->d->readError;
      _self->d->readError = false;
   }
   return b;
}

void KSycocaEntry::read( QDataStream &s, QString &str )
{
  Q_UINT32 bytes;
  s >> bytes;
  if ( bytes > 8192 ) {
      if (bytes != 0xffffffff)
         KSycoca::flagError();
      str = QString::null;
  }
  else if ( bytes > 0 ) {
      int bt = bytes/2;
      str.setLength( bt );
      QChar* ch = (QChar *) str.unicode();
      char t[8192];
      char *b = t;
      s.readRawBytes( b, bytes );
      while ( bt-- ) {
          *ch++ = (ushort) (((ushort)b[0])<<8) | (uchar)b[1];
          b += 2;
      }
  } else {
      str = "";
  }
}

void KSycocaEntry::read( QDataStream &s, QStringList &list )
{
  list.clear();
  Q_UINT32 count;
  s >> count;
  if (count >= 1024)
  {
     KSycoca::flagError();
     return;
  }
  for(Q_UINT32 i = 0; i < count; i++)
  {
     QString str;
     read(s, str);
     list.append( str );
     if (s.atEnd())
     {
        KSycoca::flagError();
        return;
     }
  }
}

void KSycoca::virtual_hook( int id, void* data )
{ DCOPObject::virtual_hook( id, data ); }

void KSycocaEntry::virtual_hook( int, void* )
{ }

# 1 "../kdecore/ksycoca.moc" 1
# 11 "../kdecore/ksycoca.moc"
# 1 "../../../prod/kdelibs/kdecore/ksycoca.h" 1
# 12 "../kdecore/ksycoca.moc" 2
# 22 "../kdecore/ksycoca.moc"
const char *KSycoca::className() const
{
    return "KSycoca";
}

QMetaObject *KSycoca::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KSycoca( "KSycoca", &KSycoca::staticMetaObject );
# 50 "../kdecore/ksycoca.moc"
QMetaObject* KSycoca::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod signal_0 = {"databaseChanged", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "databaseChanged()", &signal_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KSycoca", parentObject,
        0, 0,
        signal_tbl, 1,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KSycoca.setMetaObject( metaObj );
    return metaObj;
}

void* KSycoca::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KSycoca" ) )
        return this;
    if ( !qstrcmp( clname, "DCOPObject" ) )
        return (DCOPObject*)this;
    return QObject::qt_cast( clname );
}


void KSycoca::databaseChanged()
{
    activate_signal( staticMetaObject()->signalOffset() + 0 );
}

bool KSycoca::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KSycoca::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: databaseChanged(); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KSycoca::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KSycoca::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 513 "/coolo/prod/kdelibs/kdecore/ksycoca.cpp" 2
# 75 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksycocadict.cpp" 1
# 19 "/coolo/prod/kdelibs/kdecore/ksycocadict.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/ksycocadict.h" 1
# 20 "/coolo/prod/kdelibs/kdecore/ksycocadict.h"





class KSycocaEntry;
class KSycocaDictStringList;





class KSycocaDict
{
public:



   KSycocaDict();



   KSycocaDict(QDataStream *str, int offset);

   ~KSycocaDict();







   void add(const QString &key, KSycocaEntry *payload);
# 67 "/coolo/prod/kdelibs/kdecore/ksycocadict.h"
   int find_string(const QString &key );






   uint count();






   void clear();
# 103 "/coolo/prod/kdelibs/kdecore/ksycocadict.h"
   void save(QDataStream &str);

protected:
   Q_UINT32 hashKey( const QString &);
private:
   KSycocaDictStringList *d;
   QDataStream *mStr;
   Q_INT32 mOffset;
   Q_UINT32 mHashTableSize;
   QValueList<Q_INT32> mHashList;
};
# 20 "/coolo/prod/kdelibs/kdecore/ksycocadict.cpp" 2
# 28 "/coolo/prod/kdelibs/kdecore/ksycocadict.cpp"
struct string_entry {
  string_entry(QString _key, KSycocaEntry *_payload)
  { keyStr = _key; key = keyStr.unicode(); length = keyStr.length(); payload = _payload; hash = 0; }
  uint hash;
  int length;
  const QChar *key;
  QString keyStr;
  KSycocaEntry *payload;
};

template class QPtrList<string_entry>;

class KSycocaDictStringList : public QPtrList<string_entry>
{
public:
   KSycocaDictStringList();
};

KSycocaDictStringList::KSycocaDictStringList()
{
   setAutoDelete(true);
}

KSycocaDict::KSycocaDict()
  : d(0), mStr(0), mOffset(0)
{
}

KSycocaDict::KSycocaDict(QDataStream *str, int offset)
  : d(0), mStr(str), mOffset(offset)
{
   Q_UINT32 test1, test2;
   str->device()->at(offset);
   (*str) >> test1 >> test2;
   if ((test1 > 0x000fffff) || (test2 > 1024))
   {
       KSycoca::flagError();
       mHashTableSize = 0;
       mOffset = 0;
       return;
   }

   str->device()->at(offset);
   (*str) >> mHashTableSize;
   (*str) >> mHashList;
   mOffset = str->device()->at();
}

KSycocaDict::~KSycocaDict()
{
   delete d;
}

void
KSycocaDict::add(const QString &key, KSycocaEntry *payload)
{
   if (key.isEmpty()) return;
   if (!payload) return;
   if (!d)
   {
       d = new KSycocaDictStringList();
   }

   string_entry *entry= new string_entry(key, payload);
   d->append(entry);
}

int
KSycocaDict::find_string(const QString &key )
{


   if (!mStr || !mOffset)
   {
      kdError(7011) << "No database available!" << endl;
      return 0;
   }

   if (mHashTableSize == 0)
      return 0;


   uint hash = hashKey(key) % mHashTableSize;


   uint off = mOffset+sizeof(Q_INT32)*hash;

   mStr->device()->at( off );

   Q_INT32 offset;
   (*mStr) >> offset;


   if (offset == 0)
      return 0;

   if (offset > 0)
      return offset;


   offset = -offset;

   mStr->device()->at(offset);


   while(true)
   {
       (*mStr) >> offset;
       if (offset == 0) break;
       QString dupkey;
       (*mStr) >> dupkey;

       if (dupkey == key) return offset;
   }


   return 0;
}

uint
KSycocaDict::count()
{
   if (!d) return 0;

   return d->count();
}

void
KSycocaDict::clear()
{
   delete d;
   d = 0;
}

uint
KSycocaDict::hashKey( const QString &key)
{
   int l = key.length();
   register uint h = 0;

   for(uint i = 0; i < mHashList.count(); i++)
   {
      int pos = mHashList[i];
      if (pos < 0)
      {
         pos = -pos-1;
         if (pos < l)
            h = ((h * 13) + (key[l-pos].cell() % 29)) & 0x3ffffff;
      }
      else
      {
         pos = pos-1;
         if (pos < l)
            h = ((h * 13) + (key[pos].cell() % 29)) & 0x3ffffff;
      }
   }
   return h;
}



static int
calcDiversity(KSycocaDictStringList *d, int pos, int sz)
{
   if (pos == 0) return 0;
   bool *matrix = (bool *) calloc(sz, sizeof(bool));
   uint usz = sz;

   if (pos < 0)
   {
      pos = -pos-1;
      for(string_entry *entry=d->first(); entry; entry = d->next())
      {
        register int l = entry->length;
         if (pos < l && pos != 0)
         {
           register uint hash = ((entry->hash * 13) + (entry->key[l-pos].cell() % 29)) & 0x3ffffff;
           matrix[ hash % usz ] = true;
         }
      }
   }
   else
   {
      pos = pos-1;
      for(string_entry *entry=d->first(); entry; entry = d->next())
      {
         if (pos < entry->length)
         {
            register uint hash = ((entry->hash * 13) + (entry->key[pos].cell() % 29)) & 0x3ffffff;
            matrix[ hash % usz ] = true;
         }
      }
   }
   int diversity = 0;
   for(int i=0;i< sz;i++)
      if (matrix[i]) diversity++;

   free((void *) matrix);

   return diversity;
}



static void
addDiversity(KSycocaDictStringList *d, int pos)
{
   if (pos == 0) return;
   if (pos < 0)
   {
      pos = -pos-1;
      for(string_entry *entry=d->first(); entry; entry = d->next())
      {
         register int l = entry->length;
         if (pos < l)
            entry->hash = ((entry->hash * 13) + (entry->key[l-pos].cell() % 29)) & 0x3fffffff;
      }
   }
   else
   {
      pos = pos - 1;
      for(string_entry *entry=d->first(); entry; entry = d->next())
      {
         if (pos < entry->length)
            entry->hash = ((entry->hash * 13) + (entry->key[pos].cell() % 29)) & 0x3fffffff;
      }
   }
}


void
KSycocaDict::save(QDataStream &str)
{
   if (count() == 0)
   {
      mHashTableSize = 0;
      mHashList.clear();
      str << mHashTableSize;
      str << mHashList;
      return;
   }

   mOffset = str.device()->at();





   int maxLength = 0;

   for(string_entry *entry=d->first(); entry; entry = d->next())
   {
      entry->hash = 0;
      if (entry->length > maxLength)
         maxLength = entry->length;
   }






   register unsigned int sz = count()*4 + 1;
   while(!(((sz % 3) && (sz % 5) && (sz % 7) && (sz % 11) && (sz % 13)))) sz+=2;

   int maxDiv = 0;
   int maxPos = 0;
   int lastDiv = 0;

   mHashList.clear();



   int *oldvec=new int[maxLength*2+1];
   for (int i=0; i<(maxLength*2+1); i++) oldvec[i]=0;
   int mindiv=0;

   while(true)
   {
      int divsum=0,divnum=0;

      maxDiv = 0;
      maxPos = 0;
      for(int pos=-maxLength; pos <= maxLength; pos++)
      {

         if (oldvec[pos+maxLength]<mindiv)
         { oldvec[pos+maxLength]=0; continue; }

         int diversity = calcDiversity(d, pos, sz);
         if (diversity > maxDiv)
         {
            maxDiv = diversity;
            maxPos = pos;
         }
         oldvec[pos+maxLength]=diversity;
         divsum+=diversity; divnum++;
      }

      if (divnum)
         mindiv=(3*divsum)/(4*divnum);

      if (maxDiv <= lastDiv)
         break;

      lastDiv = maxDiv;
      addDiversity(d, maxPos);
      mHashList.append(maxPos);
   }

   delete [] oldvec;

   for(string_entry *entry=d->first(); entry; entry = d->next())
   {
      entry->hash = hashKey(entry->keyStr);
   }


   mHashTableSize = sz;

   struct hashtable_entry {
      string_entry *entry;
      QPtrList<string_entry> *duplicates;
      int duplicate_offset;
   };

   hashtable_entry *hashTable = new hashtable_entry[ sz ];


   for (unsigned int i=0; i < sz; i++)
   {
      hashTable[i].entry = 0;
      hashTable[i].duplicates = 0;
   }


   for(string_entry *entry=d->first(); entry; entry = d->next())
   {
      int hash = entry->hash % sz;
      if (!hashTable[hash].entry)
      {
         hashTable[hash].entry = entry;
      }
      else
      {
         if (!hashTable[hash].duplicates)
         {
            hashTable[hash].duplicates = new QPtrList<string_entry>();
            hashTable[hash].duplicates->append(hashTable[hash].entry);
            hashTable[hash].duplicate_offset = 0;
         }
         hashTable[hash].duplicates->append(entry);
      }
   }

   str << mHashTableSize;
   str << mHashList;

   mOffset = str.device()->at();


   for(int pass = 1; pass <= 2; pass++)
   {
      str.device()->at(mOffset);

      for(uint i=0; i < mHashTableSize; i++)
      {
         Q_INT32 tmpid;
         if (!hashTable[i].entry)
            tmpid = (Q_INT32) 0;
         else if (!hashTable[i].duplicates)
            tmpid = (Q_INT32) hashTable[i].entry->payload->offset();
         else
            tmpid = (Q_INT32) -hashTable[i].duplicate_offset;
         str << tmpid;

      }



      for(uint i=0; i < mHashTableSize; i++)
      {
         if (hashTable[i].duplicates)
         {
            QPtrList<string_entry> *dups = hashTable[i].duplicates;
            hashTable[i].duplicate_offset = str.device()->at();



            for(string_entry *dup = dups->first(); dup; dup=dups->next())
            {
               str << (Q_INT32) dup->payload->offset();
               str << dup->keyStr;
            }
            str << (Q_INT32) 0;
         }
      }

   }


   for(uint i=0; i < mHashTableSize; i++)
   {
      delete hashTable[i].duplicates;
   }
   delete [] hashTable;
}
# 76 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ksycocafactory.cpp" 1
# 28 "/coolo/prod/kdelibs/kdecore/ksycocafactory.cpp"
template class QDict<KSycocaEntry>;
template class QDict<KSharedPtr<KSycocaEntry> >;

KSycocaFactory::KSycocaFactory(KSycocaFactoryId factory_id)
 : m_resourceList(0), m_entryDict(0), m_sycocaDict(0)
{
  if (!KSycoca::self()->isBuilding())
  {
      m_str = KSycoca::self()->findFactory( factory_id );

      if (m_str)
      {

          Q_INT32 i;
          (*m_str) >> i;
          m_sycocaDictOffset = i;
          (*m_str) >> i;
          m_beginEntryOffset = i;
          (*m_str) >> i;
          m_endEntryOffset = i;

          int saveOffset = m_str->device()->at();

          m_sycocaDict = new KSycocaDict(m_str, m_sycocaDictOffset);
          saveOffset = m_str->device()->at(saveOffset);
      }
   }
   else
   {

      m_str = 0;
      m_resourceList = 0;
      m_entryDict = new KSycocaEntryDict(977);
      m_entryDict->setAutoDelete(true);
      m_sycocaDict = new KSycocaDict();
      m_beginEntryOffset = 0;
      m_endEntryOffset = 0;


   }
   KSycoca::self()->addFactory(this);
}

KSycocaFactory::~KSycocaFactory()
{
   delete m_entryDict;
   delete m_sycocaDict;
}

void
KSycocaFactory::saveHeader(QDataStream &str)
{

   str.device()->at(mOffset);
   str << (Q_INT32) m_sycocaDictOffset;
   str << (Q_INT32) m_beginEntryOffset;
   str << (Q_INT32) m_endEntryOffset;
}

void
KSycocaFactory::save(QDataStream &str)
{
   if (!m_entryDict) return;

   if (!m_sycocaDict) return;

   mOffset = str.device()->at();
   m_sycocaDictOffset = 0;


   saveHeader(str);

   m_beginEntryOffset = str.device()->at();


   int entryCount = 0;
   for(QDictIterator<KSycocaEntry::Ptr> it ( *m_entryDict );
       it.current();
       ++it)
   {
      KSycocaEntry *entry = (*it.current());
      entry->save(str);
      entryCount++;
   }

   m_endEntryOffset = str.device()->at();



   str << (Q_INT32) entryCount;
   for(QDictIterator<KSycocaEntry::Ptr> it ( *m_entryDict );
       it.current();
       ++it)
   {
      KSycocaEntry *entry = (*it.current());
      str << (Q_INT32) entry->offset();
   }


   m_sycocaDictOffset = str.device()->at();
   m_sycocaDict->save(str);

   int endOfFactoryData = str.device()->at();


   saveHeader(str);


   str.device()->at(endOfFactoryData);
}

void
KSycocaFactory::addEntry(KSycocaEntry *newEntry, const char *)
{
   if (!m_entryDict) return;


   if (!m_sycocaDict) return;

   QString name = newEntry->name();
   m_entryDict->insert( name, new KSycocaEntry::Ptr(newEntry) );
   m_sycocaDict->add( name, newEntry );
}

KSycocaEntry::List KSycocaFactory::allEntries()
{
   KSycocaEntry::List list;
   if (!m_str) return list;



   m_str->device()->at(m_endEntryOffset);
   Q_INT32 entryCount;
   (*m_str) >> entryCount;

   if (entryCount > 8192)
   {
      KSycoca::flagError();
      return list;
   }

   Q_INT32 *offsetList = new Q_INT32[entryCount];
   for(int i = 0; i < entryCount; i++)
   {
      (*m_str) >> offsetList[i];
   }

   for(int i = 0; i < entryCount; i++)
   {
      KSycocaEntry *newEntry = createEntry(offsetList[i]);
      if (newEntry)
      {
         list.append( KSycocaEntry::Ptr( newEntry ) );
      }
   }
   delete [] offsetList;
   return list;
}

void KSycocaFactory::virtual_hook( int, void* )
{ }
# 77 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kxmessages.cpp" 1
# 27 "/coolo/prod/kdelibs/kdecore/kxmessages.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kxmessages.h" 1
# 28 "/coolo/prod/kdelibs/kdecore/kxmessages.h"







class QString;

class KXMessagesPrivate;
# 48 "/coolo/prod/kdelibs/kdecore/kxmessages.h"
class KXMessages
    : public QWidget
    {
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
    public:
# 61 "/coolo/prod/kdelibs/kdecore/kxmessages.h"
        KXMessages( const char* accept_broadcast = __null, QWidget* parent = __null );
        virtual ~KXMessages();
# 71 "/coolo/prod/kdelibs/kdecore/kxmessages.h"
        void sendMessage( WId w, const char* msg_type, const QString& message );





        void broadcastMessage( const char* msg_type, const QString& message );
# 90 "/coolo/prod/kdelibs/kdecore/kxmessages.h"
        static bool sendMessageX( Display* disp, WId w, const char* msg_type,
            const QString& message );
# 102 "/coolo/prod/kdelibs/kdecore/kxmessages.h"
        static bool broadcastMessageX( Display* disp, const char* msg_type,
            const QString& message );
    protected:




        void gotMessage( const QString& message );
    protected:



        virtual bool x11Event( XEvent* ev );
    private:
        static void send_message_internal( WId w_P, const QString& msg_P, long mask_P,
            Display* disp, Atom atom_P, Window handle_P );
        QWidget* handle;
        Atom cached_atom;
        QCString cached_atom_name;
        Atom accept_atom;
        QMap< WId, QCString > incoming_messages;
        KXMessagesPrivate* d;
    };
# 28 "/coolo/prod/kdelibs/kdecore/kxmessages.cpp" 2
# 37 "/coolo/prod/kdelibs/kdecore/kxmessages.cpp"
const long BROADCAST_MASK = (1L<<22);


KXMessages::KXMessages( const char* accept_broadcast_P, QWidget* parent_P )
    : QWidget( parent_P )
    {
    if( accept_broadcast_P != __null )
        {
        ( void ) KApplication::kApplication()->desktop();
        KApplication::kApplication()->installX11EventFilter( this );
        accept_atom = XInternAtom( qt_xdisplay(), accept_broadcast_P, false );
        cached_atom_name = accept_broadcast_P;
        cached_atom = accept_atom;
        }
    else
        {
        accept_atom = None;
        cached_atom_name = "";
        }
    handle = new QWidget( this );
    }

KXMessages::~KXMessages()
    {

    }

void KXMessages::broadcastMessage( const char* msg_type_P, const QString& message_P )
    {
    if( cached_atom_name != msg_type_P )
        {
        cached_atom = XInternAtom( qt_xdisplay(), msg_type_P, false );
        cached_atom_name = msg_type_P;
        }
    send_message_internal( qt_xrootwin(), message_P, BROADCAST_MASK, qt_xdisplay(),
        cached_atom, handle->winId());
    }

void KXMessages::sendMessage( WId w_P, const char* msg_type_P, const QString& message_P )
    {
    if( cached_atom_name != msg_type_P )
        {
        cached_atom = XInternAtom( qt_xdisplay(), msg_type_P, false );
        cached_atom_name = msg_type_P;
        }
    send_message_internal( w_P, message_P, 0, qt_xdisplay(), cached_atom, handle->winId());
    }

bool KXMessages::broadcastMessageX( Display* disp, const char* msg_type_P,
    const QString& message_P )
    {
    if( disp == __null )
        return false;
    Atom atom = XInternAtom( disp, msg_type_P, false );
    Window win = XCreateSimpleWindow( disp, ((&((_XPrivDisplay)disp)->screens[(((_XPrivDisplay)disp)->default_screen)])->root), 0, 0, 1, 1,
        0, (((&((_XPrivDisplay)disp)->screens[(((_XPrivDisplay)disp)->default_screen)]))->black_pixel),
        (((&((_XPrivDisplay)disp)->screens[(((_XPrivDisplay)disp)->default_screen)]))->black_pixel));
    send_message_internal( ((&((_XPrivDisplay)disp)->screens[(((_XPrivDisplay)disp)->default_screen)])->root), message_P, BROADCAST_MASK, disp,
        atom, win );
    XDestroyWindow( disp, win );
    return true;
    }

bool KXMessages::sendMessageX( Display* disp, WId w_P, const char* msg_type_P,
    const QString& message_P )
    {
    if( disp == __null )
        return false;
    Atom atom = XInternAtom( disp, msg_type_P, false );
    Window win = XCreateSimpleWindow( disp, ((&((_XPrivDisplay)disp)->screens[(((_XPrivDisplay)disp)->default_screen)])->root), 0, 0, 1, 1,
        0, (((&((_XPrivDisplay)disp)->screens[(((_XPrivDisplay)disp)->default_screen)]))->black_pixel),
        (((&((_XPrivDisplay)disp)->screens[(((_XPrivDisplay)disp)->default_screen)]))->black_pixel));
    send_message_internal( w_P, message_P, 0, disp, atom, win );
    XDestroyWindow( disp, win );
    return true;
    }

void KXMessages::send_message_internal( WId w_P, const QString& msg_P, long mask_P,
    Display* disp, Atom atom_P, Window handle_P )
    {
    unsigned int pos = 0;
    QCString msg = msg_P.utf8();
    unsigned int len = strlen( msg );
    XEvent e;
    e.xclient.type = 33;
    e.xclient.message_type = atom_P;
    e.xclient.display = disp;
    e.xclient.window = handle_P;
    e.xclient.format = 8;
    do
        {
        unsigned int i;
        for( i = 0;
             i < 20 && i + pos <= len;
             ++i )
            e.xclient.data.b[ i ] = msg[ i + pos ];
        XSendEvent( disp, w_P, false, mask_P, &e );
        pos += i;
        } while( pos <= len );
    XFlush( disp );
    }

bool KXMessages::x11Event( XEvent* ev_P )
    {
    if( ev_P->type != 33 || ev_P->xclient.message_type != accept_atom
        || ev_P->xclient.format != 8 )
        return QWidget::x11Event( ev_P );
    char buf[ 21 ];
    int i;
    for( i = 0;
         i < 20 && ev_P->xclient.data.b[ i ] != '\0';
         ++i )
        buf[ i ] = ev_P->xclient.data.b[ i ];
    buf[ i ] = '\0';
    if( incoming_messages.contains( ev_P->xclient.window ))
        incoming_messages[ ev_P->xclient.window ] += buf;
    else
        incoming_messages[ ev_P->xclient.window ] = buf;
    if( i < 20 )
        {
        gotMessage( QString::fromUtf8( incoming_messages[ ev_P->xclient.window ] ));
        incoming_messages.remove( ev_P->xclient.window );
        }
    return false;
    }

# 1 "../kdecore/kxmessages.moc" 1
# 11 "../kdecore/kxmessages.moc"
# 1 "../../../prod/kdelibs/kdecore/kxmessages.h" 1
# 12 "../kdecore/kxmessages.moc" 2
# 22 "../kdecore/kxmessages.moc"
const char *KXMessages::className() const
{
    return "KXMessages";
}

QMetaObject *KXMessages::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KXMessages( "KXMessages", &KXMessages::staticMetaObject );
# 50 "../kdecore/kxmessages.moc"
QMetaObject* KXMessages::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QWidget::staticMetaObject();
    static const QUParameter param_signal_0[] = {
        { "message", &static_QUType_QString, 0, QUParameter::In }
    };
    static const QUMethod signal_0 = {"gotMessage", 1, param_signal_0 };
    static const QMetaData signal_tbl[] = {
        { "gotMessage(const QString&)", &signal_0, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KXMessages", parentObject,
        0, 0,
        signal_tbl, 1,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KXMessages.setMetaObject( metaObj );
    return metaObj;
}

void* KXMessages::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KXMessages" ) )
        return this;
    return QWidget::qt_cast( clname );
}


void KXMessages::gotMessage( const QString& t0 )
{
    activate_signal( staticMetaObject()->signalOffset() + 0, t0 );
}

bool KXMessages::qt_invoke( int _id, QUObject* _o )
{
    return QWidget::qt_invoke(_id,_o);
}

bool KXMessages::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: gotMessage((const QString&)static_QUType_QString.get(_o+1)); break;
    default:
        return QWidget::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KXMessages::qt_property( int id, int f, QVariant* v)
{
    return QWidget::qt_property( id, f, v);
}

bool KXMessages::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 164 "/coolo/prod/kdelibs/kdecore/kxmessages.cpp" 2
# 78 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kstartupinfo.cpp" 1
# 34 "/coolo/prod/kdelibs/kdecore/kstartupinfo.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 35 "/coolo/prod/kdelibs/kdecore/kstartupinfo.cpp" 2


# 1 "/coolo/prod/qt-copy/include/qglobal.h" 1
# 1071 "/coolo/prod/qt-copy/include/qglobal.h"
# 38 "/coolo/prod/kdelibs/kdecore/kstartupinfo.cpp" 2

# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 40 "/coolo/prod/kdelibs/kdecore/kstartupinfo.cpp" 2
# 64 "/coolo/prod/kdelibs/kdecore/kstartupinfo.cpp"
static const char* const KDE_STARTUP_INFO = "_KDE_STARTUP_INFO";
static const char* const KDE_STARTUP_ID = "_KDE_STARTUP_ID";

static const char* const KDE_STARTUP_ENV = "KDE_STARTUP_ENV";


static const char* const KDE_STARTUP_INFO_2 = "KDE_STARTUP_INFO";
static const char* const KDE_STARTUP_ID_2 = "KDE_STARTUP_ID";

static long get_num( const QString& item_P );
static unsigned long get_unum( const QString& item_P );
static QString get_str( const QString& item_P );
static QCString get_cstr( const QString& item_P );
static QStringList get_fields( const QString& txt_P );
static QString escape_str( const QString& str_P );

class KStartupInfo::Data
    : public KStartupInfoData
    {
    public:
        Data() {};
        Data( const QString& txt_P )
            : KStartupInfoData( txt_P ), age( 0 ) {};
        unsigned int age;
    };

struct KStartupInfoPrivate
    {
    public:
        QMap< KStartupInfoId, KStartupInfo::Data > startups;

        QMap< KStartupInfoId, KStartupInfo::Data > silent_startups;

        KWinModule* wm_module;
        KXMessages msgs;
        KXMessages msgs_2;

        QTimer* cleanup;
        int flags;
        KStartupInfoPrivate( int flags_P )
            :

            msgs( KDE_STARTUP_INFO ), msgs_2( KDE_STARTUP_INFO_2 ),

              flags( flags_P ) {}
    };

KStartupInfo::KStartupInfo( int flags_P, QObject* parent_P, const char* name_P )
    : QObject( parent_P, name_P ),
        timeout( 60 ), d( __null )
    {
    init( flags_P );
    }

KStartupInfo::KStartupInfo( bool clean_on_cantdetect_P, QObject* parent_P, const char* name_P )
    : QObject( parent_P, name_P ),
        timeout( 60 ), d( __null )
    {
    init( clean_on_cantdetect_P ? CleanOnCantDetect : 0 );
    }

void KStartupInfo::init( int flags_P )
    {

    if (!KApplication::kApplication()) return;
    if (!KApplication::kApplication()->getDisplay()) return;

    d = new KStartupInfoPrivate( flags_P );

    if( !( d->flags & DisableKWinModule ))
        {
        d->wm_module = new KWinModule( this );
        connect( d->wm_module, "2""windowAdded( WId )", "1""slot_window_added( WId )");
        connect( d->wm_module, "2""systemTrayWindowAdded( WId )", "1""slot_window_added( WId )");
        }
    else
        d->wm_module = __null;
    connect( &d->msgs, "2""gotMessage( const QString& )", "1""got_message( const QString& )");
    connect( &d->msgs_2, "2""gotMessage( const QString& )", "1""got_message( const QString& )");

    d->cleanup = new QTimer( this );
    connect( d->cleanup, "2""timeout()", "1""startups_cleanup()");
    }

KStartupInfo::~KStartupInfo()
    {
    delete d;
    }

void KStartupInfo::got_message( const QString& msg_P )
    {
    kdDebug( 172 ) << "got:" << msg_P << endl;
    QString msg = msg_P.stripWhiteSpace();
    if( msg.startsWith( "new:" ))
        got_startup_info( msg.mid( 4 ), false );
    else if( msg.startsWith( "change:" ))
        got_startup_info( msg.mid( 7 ), true );
    else if( msg.startsWith( "remove:" ))
        got_remove_startup_info( msg.mid( 7 ));
    }






namespace
{
class DelayedWindowEvent
    : public QCustomEvent
    {
    public:
        DelayedWindowEvent( WId w_P )
            : QCustomEvent( QEvent::User + 15 ), w( w_P ) {}
        Window w;
    };
}

void KStartupInfo::slot_window_added( WId w_P )
    {
    KApplication::kApplication()->postEvent( this, new DelayedWindowEvent( w_P ));
    }

void KStartupInfo::customEvent( QCustomEvent* e_P )
    {
    if( e_P->type() == QEvent::User + 15 )
        window_added( static_cast< DelayedWindowEvent* >( e_P )->w );
    else
        QObject::customEvent( e_P );
    }

void KStartupInfo::window_added( WId w_P )
    {
    KStartupInfoId id;
    KStartupInfoData data;
    startup_t ret = check_startup_internal( w_P, &id, &data, false );
    switch( ret )
        {
        case Match:
            kdDebug( 172 ) << "new window match" << endl;




            if( data.silent() != KStartupInfoData::Yes )
                remove_startup_info_internal( id );
          break;
        case NoMatch:
          break;
        case CantDetect:
            if( d->flags & CleanOnCantDetect )
                clean_all_noncompliant();
          break;
        }
    }

void KStartupInfo::got_startup_info( const QString& msg_P, bool update_only_P )
    {
    KStartupInfoId id( msg_P );
    if( id.none())
        return;
    KStartupInfo::Data data( msg_P );
    new_startup_info_internal( id, data, update_only_P );
    }

void KStartupInfo::new_startup_info_internal( const KStartupInfoId& id_P,
    Data& data_P, bool update_only_P )
    {
    if (!d) return;
    if( id_P.none())
        return;
    if( d->startups.contains( id_P ))
        {
        d->startups[ id_P ].update( data_P );
        d->startups[ id_P ].age = 0;
        kdDebug( 172 ) << "updating" << endl;
        if( d->startups[ id_P ].silent() == Data::Yes
            && !( d->flags & AnnounceSilenceChanges ))
            {
            d->silent_startups[ id_P ] = d->startups[ id_P ];
            d->startups.remove( id_P );
            gotRemoveStartup( id_P, d->silent_startups[ id_P ] );
            return;
            }
        gotStartupChange( id_P, d->startups[ id_P ] );
        return;
        }
    if( d->silent_startups.contains( id_P ))
        {
        d->silent_startups[ id_P ].update( data_P );
        d->silent_startups[ id_P ].age = 0;
        kdDebug( 172 ) << "updating silenced" << endl;
        if( d->silent_startups[ id_P ].silent() != Data::Yes )
            {
            d->startups[ id_P ] = d->silent_startups[ id_P ];
            d->silent_startups.remove( id_P );
            gotNewStartup( id_P, d->startups[ id_P ] );
            return;
            }
        gotStartupChange( id_P, d->startups[ id_P ] );
        return;
        }
    if( update_only_P )
        return;
    if( data_P.silent() != Data::Yes || d->flags & AnnounceSilenceChanges )
        {
        kdDebug( 172 ) << "adding" << endl;
        d->startups.insert( id_P, data_P );
        gotNewStartup( id_P, data_P );
        }
    else
        {
        kdDebug( 172 ) << "adding silent" << endl;
        d->silent_startups.insert( id_P, data_P );
        }
    d->cleanup->start( 1000 );
    }

void KStartupInfo::got_remove_startup_info( const QString& msg_P )
    {
    KStartupInfoId id( msg_P );
    KStartupInfoData data( msg_P );
    if( data.pids().count() > 0 )
        {
        if( !id.none())
            remove_startup_pids( id, data );
        else
            remove_startup_pids( data );
        return;
        }
    remove_startup_info_internal( id );
    }

void KStartupInfo::remove_startup_info_internal( const KStartupInfoId& id_P )
    {
    if (!d) return;
    if( d->startups.contains( id_P ))
        {
        kdDebug( 172 ) << "removing" << endl;
        gotRemoveStartup( id_P, d->startups[ id_P ]);
        d->startups.remove( id_P );
        }
    else if( d->silent_startups.contains( id_P ))
        {
        kdDebug( 172 ) << "removing silent" << endl;
        d->silent_startups.remove( id_P );
        }
    return;
    }

void KStartupInfo::remove_startup_pids( const KStartupInfoData& data_P )
    {
    if (!d) return;
    for( QMap< KStartupInfoId, Data >::Iterator it = d->startups.begin();
         it != d->startups.end();
         ++it )
        {
        if( ( *it ).hostname() != data_P.hostname())
            continue;
        if( !( *it ).is_pid( data_P.pids().first()))
            continue;
        remove_startup_pids( it.key(), data_P );
        break;
        }
    }

void KStartupInfo::remove_startup_pids( const KStartupInfoId& id_P,
    const KStartupInfoData& data_P )
    {
    if (!d) return;
    kdFatal( data_P.pids().count() == 0, 172 );
    Data* data = __null;
    if( d->startups.contains( id_P ))
        data = &d->startups[ id_P ];
    else if( d->silent_startups.contains( id_P ))
        data = &d->silent_startups[ id_P ];
    else
        return;
    for( QValueList< pid_t >::ConstIterator it2 = data_P.pids().begin();
         it2 != data_P.pids().end();
         ++it2 )
        data->remove_pid( *it2 );
    if( data->pids().count() == 0 )
        remove_startup_info_internal( id_P );
    }

bool KStartupInfo::sendStartup( const KStartupInfoId& id_P, const KStartupInfoData& data_P )
    {
    if( id_P.none())
        return false;
    KXMessages msgs;
    QString msg = QString::fromLatin1( "new: %1 %2" )
        .arg( id_P.to_text()).arg( data_P.to_text());
    kdDebug( 172 ) << "sending " << msg << endl;
    msgs.broadcastMessage( KDE_STARTUP_INFO, msg );
    return true;
    }

bool KStartupInfo::sendStartupX( Display* disp_P, const KStartupInfoId& id_P,
    const KStartupInfoData& data_P )
    {
    if( id_P.none())
        return false;
    QString msg = QString::fromLatin1( "new: %1 %2" )
        .arg( id_P.to_text()).arg( data_P.to_text());



    return KXMessages::broadcastMessageX( disp_P, KDE_STARTUP_INFO, msg );
    }

bool KStartupInfo::sendChange( const KStartupInfoId& id_P, const KStartupInfoData& data_P )
    {
    if( id_P.none())
        return false;
    KXMessages msgs;
    QString msg = QString::fromLatin1( "change: %1 %2" )
        .arg( id_P.to_text()).arg( data_P.to_text());
    kdDebug( 172 ) << "sending " << msg << endl;
    msgs.broadcastMessage( KDE_STARTUP_INFO, msg );
    return true;
    }

bool KStartupInfo::sendChangeX( Display* disp_P, const KStartupInfoId& id_P,
    const KStartupInfoData& data_P )
    {
    if( id_P.none())
        return false;
    QString msg = QString::fromLatin1( "change: %1 %2" )
        .arg( id_P.to_text()).arg( data_P.to_text());



    return KXMessages::broadcastMessageX( disp_P, KDE_STARTUP_INFO, msg );
    }

bool KStartupInfo::sendFinish( const KStartupInfoId& id_P )
    {
    if( id_P.none())
        return false;
    KXMessages msgs;
    QString msg = QString::fromLatin1( "remove: %1" ).arg( id_P.to_text());
    kdDebug( 172 ) << "sending " << msg << endl;
    msgs.broadcastMessage( KDE_STARTUP_INFO, msg );
    return true;
    }

bool KStartupInfo::sendFinishX( Display* disp_P, const KStartupInfoId& id_P )
    {
    if( id_P.none())
        return false;
    QString msg = QString::fromLatin1( "remove: %1" ).arg( id_P.to_text());



    return KXMessages::broadcastMessageX( disp_P, KDE_STARTUP_INFO, msg );
    }

bool KStartupInfo::sendFinish( const KStartupInfoId& id_P, const KStartupInfoData& data_P )
    {


    KXMessages msgs;
    QString msg = QString::fromLatin1( "remove: %1 %2" )
        .arg( id_P.to_text()).arg( data_P.to_text());
    kdDebug( 172 ) << "sending " << msg << endl;
    msgs.broadcastMessage( KDE_STARTUP_INFO, msg );
    return true;
    }

bool KStartupInfo::sendFinishX( Display* disp_P, const KStartupInfoId& id_P,
    const KStartupInfoData& data_P )
    {


    QString msg = QString::fromLatin1( "remove: %1 %2" )
        .arg( id_P.to_text()).arg( data_P.to_text());



    return KXMessages::broadcastMessageX( disp_P, KDE_STARTUP_INFO, msg );
    }

void KStartupInfo::appStarted()
    {
    if( KApplication::kApplication() != __null )
        {
        KStartupInfoId id;
        id.initId( KApplication::kApplication()->startupId());
        if( !id.none())
            KStartupInfo::sendFinish( id );
        }
    else if( getenv( "DISPLAY" ) != __null )
        {
        KStartupInfoId id = KStartupInfo::currentStartupIdEnv();
        if( !id.none())
            {

            Display* disp = XOpenDisplay( __null );
            if( disp != __null )
                {
                KStartupInfo::sendFinishX( disp, id );
                XCloseDisplay( disp );
                }

            }
        }
    }

KStartupInfo::startup_t KStartupInfo::checkStartup( WId w_P, KStartupInfoId& id_O,
    KStartupInfoData& data_O )
    {
    return check_startup_internal( w_P, &id_O, &data_O, true );
    }

KStartupInfo::startup_t KStartupInfo::checkStartup( WId w_P, KStartupInfoId& id_O )
    {
    return check_startup_internal( w_P, &id_O, __null, true );
    }

KStartupInfo::startup_t KStartupInfo::checkStartup( WId w_P, KStartupInfoData& data_O )
    {
    return check_startup_internal( w_P, __null, &data_O, true );
    }

KStartupInfo::startup_t KStartupInfo::checkStartup( WId w_P )
    {
    return check_startup_internal( w_P, __null, __null, true );
    }

KStartupInfo::startup_t KStartupInfo::check_startup_internal( WId w_P, KStartupInfoId* id_O,
    KStartupInfoData* data_O, bool remove_P )
    {
    if (!d) return NoMatch;
    if( d->startups.count() == 0 )
        return NoMatch;

    NETWinInfo info( qt_xdisplay(), w_P, qt_xrootwin(),
        NET::WMWindowType | NET::WMPid | NET::WMState );

    NET::WindowType type = info.windowType( NET::NormalMask | NET::DesktopMask
        | NET::DockMask | NET::ToolbarMask | NET::MenuMask | NET::DialogMask
        | NET::OverrideMask | NET::TopMenuMask | NET::UtilityMask | NET::SplashMask );
    if( type != NET::Normal
        && type != NET::Override
        && type != NET::Unknown
        && type != NET::Dialog
        && type != NET::Utility )

        return NoMatch;

    Window transient_for;
    if( XGetTransientForHint( qt_xdisplay(), static_cast< Window >( w_P ), &transient_for )
        && static_cast< WId >( transient_for ) != qt_xrootwin()
        && transient_for != None )
        return NoMatch;
# 528 "/coolo/prod/kdelibs/kdecore/kstartupinfo.cpp"
    kdDebug( 172 ) << "check_startup" << endl;
    QCString id = windowStartupId( w_P );
    if( !id.isNull())
        {
        if( id.isEmpty() || id == "0" )
            {
            kdDebug( 172 ) << "ignore" << endl;
            return NoMatch;
            }
        return find_id( id, id_O, data_O, remove_P ) ? Match : NoMatch;
        }


    pid_t pid = info.pid();
    if( pid > 0 )
        {
        QCString hostname = get_window_hostname( w_P );
        if( !hostname.isEmpty()
            && find_pid( pid, hostname, id_O, data_O, remove_P ))
            return Match;

        }

    XClassHint hint;
    if( XGetClassHint( qt_xdisplay(), w_P, &hint ) != 0 )
        {
        if( find_wclass( hint.res_name, hint.res_class, id_O, data_O, remove_P ))
            return Match;
        }

    kdDebug( 172 ) << "check_startup:cantdetect" << endl;
    return CantDetect;
    }

bool KStartupInfo::find_id( const QCString& id_P, KStartupInfoId* id_O,
    KStartupInfoData* data_O, bool remove_P )
    {
    if (!d) return false;
    kdDebug( 172 ) << "find_id:" << id_P << endl;
    KStartupInfoId id;
    id.initId( id_P );
    if( d->startups.contains( id ))
        {
        if( id_O != __null )
            *id_O = id;
        if( data_O != __null )
            *data_O = d->startups[ id ];
        if( remove_P
            && d->startups[ id ].silent() != Data::Yes )
            d->startups.remove( id );
        kdDebug( 172 ) << "check_startup_id:match" << endl;
        return true;
        }
    return false;
    }

bool KStartupInfo::find_pid( pid_t pid_P, const QCString& hostname_P,
    KStartupInfoId* id_O, KStartupInfoData* data_O, bool remove_P )
    {
    if (!d) return false;
    kdDebug( 172 ) << "find_pid:" << pid_P << endl;
    for( QMap< KStartupInfoId, Data >::Iterator it = d->startups.begin();
         it != d->startups.end();
         ++it )
        {
        if( ( *it ).is_pid( pid_P ) && ( *it ).hostname() == hostname_P )
            {
            if( id_O != __null )
                *id_O = it.key();
            if( data_O != __null )
                *data_O = *it;
            if( remove_P
                && ( *it ).silent() != Data::Yes )
                d->startups.remove( it );
            kdDebug( 172 ) << "check_startup_pid:match" << endl;
            return true;
            }
        }
    return false;
    }

bool KStartupInfo::find_wclass( QCString res_name, QCString res_class,
    KStartupInfoId* id_O, KStartupInfoData* data_O, bool remove_P )
    {
    if (!d) return false;
    res_name = res_name.lower();
    res_class = res_class.lower();
    kdDebug( 172 ) << "find_wclass:" << res_name << ":" << res_class << endl;
    for( QMap< KStartupInfoId, Data >::Iterator it = d->startups.begin();
         it != d->startups.end();
         ++it )
        {
        const QCString wmclass = ( *it ).findWMClass();
        if( wmclass.lower() == res_name || wmclass.lower() == res_class )
            {
            if( id_O != __null )
                *id_O = it.key();
            if( data_O != __null )
                *data_O = *it;
            if( remove_P
                && ( *it ).silent() != Data::Yes )
                d->startups.remove( it );
            kdDebug( 172 ) << "check_startup_wclass:match" << endl;
            return true;
            }
        }
    return false;
    }


static Atom kde_startup_atom = None;
static Atom kde_startup_atom_2 = None;


QCString KStartupInfo::windowStartupId( WId w_P )
    {

    if( kde_startup_atom == None )
        kde_startup_atom = XInternAtom( qt_xdisplay(), KDE_STARTUP_ID, 0 );
    if( kde_startup_atom_2 == None )
        kde_startup_atom_2 = XInternAtom( qt_xdisplay(), KDE_STARTUP_ID_2, 0 );
    unsigned char *name_ret;
    QCString ret;
    Atom type_ret;
    int format_ret;
    unsigned long nitems_ret = 0, after_ret = 0;
    if( XGetWindowProperty( qt_xdisplay(), w_P, kde_startup_atom, 0l, 4096,
            0, ((Atom) 31), &type_ret, &format_ret, &nitems_ret, &after_ret, &name_ret )
            == Success )
        {
        if( type_ret == ((Atom) 31) && format_ret == 8 && name_ret != __null )
            ret = reinterpret_cast< char* >( name_ret );
        if ( name_ret != __null )
            XFree( name_ret );
        }
    if( ret.isNull() && XGetWindowProperty( qt_xdisplay(), w_P, kde_startup_atom_2, 0l, 4096,
            0, ((Atom) 31), &type_ret, &format_ret, &nitems_ret, &after_ret, &name_ret )
            == Success )
        {
        if( type_ret == ((Atom) 31) && format_ret == 8 && name_ret != __null )
            ret = reinterpret_cast< char* >( name_ret );
        if ( name_ret != __null )
            XFree( name_ret );
        }
    return ret;



    }

void KStartupInfo::setWindowStartupId( WId w_P, const QCString& id_P )
    {

    if( id_P.isNull())
        return;
    if( kde_startup_atom == None )
        kde_startup_atom = XInternAtom( qt_xdisplay(), KDE_STARTUP_ID, 0 );
    XChangeProperty( qt_xdisplay(), w_P, kde_startup_atom, ((Atom) 31), 8,
        0, reinterpret_cast< unsigned char* >( id_P.data()), id_P.length());

    }

QCString KStartupInfo::get_window_hostname( WId w_P )
    {

    XTextProperty tp;
    char** hh;
    int cnt;
    if( XGetWMClientMachine( qt_xdisplay(), w_P, &tp ) != 0
        && XTextPropertyToStringList( &tp, &hh, &cnt ) != 0 )
        {
        if( cnt == 1 )
            {
            QCString hostname = hh[ 0 ];
            XFreeStringList( hh );
            return hostname;
            }
        XFreeStringList( hh );
        }


    return QCString();
    }

void KStartupInfo::setTimeout( unsigned int secs_P )
    {
    timeout = secs_P;

    QTimer::singleShot( 0, this, "1""startups_cleanup_no_age()");
    }

void KStartupInfo::startups_cleanup_no_age()
    {
    startups_cleanup_internal( false );
    }

void KStartupInfo::startups_cleanup()
    {
    if (!d) return;
    if( d->startups.count() == 0 && d->silent_startups.count() == 0 )
        {
        d->cleanup->stop();
        return;
        }
    startups_cleanup_internal( true );
    }

void KStartupInfo::startups_cleanup_internal( bool age_P )
    {
    if (!d) return;
    for( QMap< KStartupInfoId, Data >::Iterator it = d->startups.begin();
         it != d->startups.end();
         )
        {
        if( age_P )
            ( *it ).age++;
        int tout = timeout;
        if( ( *it ).silent() == Data::Yes )
            tout *= 20;
        if( ( *it ).age >= timeout )
            {
            const KStartupInfoId& key = it.key();
            ++it;
            kdDebug( 172 ) << "entry timeout:" << key.id() << endl;
            remove_startup_info_internal( key );
            }
        else
            ++it;
        }
    for( QMap< KStartupInfoId, Data >::Iterator it = d->silent_startups.begin();
         it != d->silent_startups.end();
         )
        {
        if( age_P )
            ( *it ).age++;
        int tout = timeout;
        if( ( *it ).silent() == Data::Yes )
            tout *= 20;
        if( ( *it ).age >= timeout )
            {
            const KStartupInfoId& key = it.key();
            ++it;
            kdDebug( 172 ) << "entry timeout:" << key.id() << endl;
            remove_startup_info_internal( key );
            }
        else
            ++it;
        }
    }

void KStartupInfo::clean_all_noncompliant()
    {
    if (!d) return;
    for( QMap< KStartupInfoId, Data >::Iterator it = d->startups.begin();
         it != d->startups.end();
         )
        {
        if( ( *it ).WMClass() != "0" )
            {
            ++it;
            continue;
            }
        const KStartupInfoId& key = it.key();
        ++it;
        kdDebug( 172 ) << "entry cleaning:" << key.id() << endl;
        remove_startup_info_internal( key );
        }
    }

struct KStartupInfoIdPrivate
    {
    KStartupInfoIdPrivate() : id( "" ) {};
    QCString id;
    };

const QCString& KStartupInfoId::id() const
    {
    return d->id;
    }


QString KStartupInfoId::to_text() const
    {
    return QString::fromLatin1( " ID=\"%1\" " ).arg( escape_str( id()));
    }

KStartupInfoId::KStartupInfoId( const QString& txt_P )
    {
    d = new KStartupInfoIdPrivate;
    QStringList items = get_fields( txt_P );
    const QString id_str = QString::fromLatin1( "ID=" );
    for( QStringList::Iterator it = items.begin();
         it != items.end();
         ++it )
        {
        if( ( *it ).startsWith( id_str ))
            d->id = get_cstr( *it );
        }
    }

void KStartupInfoId::initId( const QCString& id_P )
    {
    if( !id_P.isEmpty())
        {
        d->id = id_P;



        return;
        }
    const char* startup_env = getenv( KDE_STARTUP_ENV );
    if( startup_env != __null && *startup_env != '\0' )
        {
        d->id = startup_env;



        return;
        }



    struct timeval tm;
    gettimeofday( &tm, __null );
    char hostname[ 256 ];
    hostname[ 0 ] = '\0';
    if (!gethostname( hostname, 255 ))
        hostname[sizeof(hostname)-1] = '\0';
    d->id = QString( "%1;%2;%3;%4" ).arg( hostname ).arg( tm.tv_sec )
        .arg( tm.tv_usec ).arg( getpid()).latin1();



    }

bool KStartupInfoId::setupStartupEnv() const
    {
    if( id().isEmpty())
        {
        unsetenv( KDE_STARTUP_ENV );
        return false;
        }
    return setenv( KDE_STARTUP_ENV, id(), true ) == 0;
    }

KStartupInfoId KStartupInfo::currentStartupIdEnv()
    {
    const char* startup_env = getenv( KDE_STARTUP_ENV );
    KStartupInfoId id;
    if( startup_env != __null && *startup_env != '\0' )
        id.d->id = startup_env;
    else
        id.d->id = "0";
    return id;
    }

void KStartupInfo::resetStartupEnv()
    {
    unsetenv( KDE_STARTUP_ENV );
    }

KStartupInfoId::KStartupInfoId()
    {
    d = new KStartupInfoIdPrivate;
    }

KStartupInfoId::~KStartupInfoId()
    {
    delete d;
    }

KStartupInfoId::KStartupInfoId( const KStartupInfoId& id_P )
    {
    d = new KStartupInfoIdPrivate( *id_P.d );
    }

KStartupInfoId& KStartupInfoId::operator=( const KStartupInfoId& id_P )
    {
    if( &id_P == this )
        return *this;
    delete d;
    d = new KStartupInfoIdPrivate( *id_P.d );
    return *this;
    }

bool KStartupInfoId::operator==( const KStartupInfoId& id_P ) const
    {
    return id() == id_P.id();
    }

bool KStartupInfoId::operator!=( const KStartupInfoId& id_P ) const
    {
    return !(*this == id_P );
    }


bool KStartupInfoId::operator<( const KStartupInfoId& id_P ) const
    {
    return id() < id_P.id();
    }

bool KStartupInfoId::none() const
    {
    return d->id.isEmpty() || d->id == "0";
    }

struct KStartupInfoDataPrivate
    {
    KStartupInfoDataPrivate() : desktop( 0 ), wmclass( "" ), hostname( "" ),
        silent( KStartupInfoData::Unknown ), timestamp( -1U ) {};
    QString bin;
    QString name;
    QString icon;
    int desktop;
    QValueList< pid_t > pids;
    QCString wmclass;
    QCString hostname;
    KStartupInfoData::TriState silent;
    unsigned long timestamp;
    };

QString KStartupInfoData::to_text() const
    {
    QString ret = "";
    if( !d->bin.isEmpty())
        ret += QString::fromLatin1( " BIN=\"%1\"" ).arg( escape_str( d->bin ));
    if( !d->name.isEmpty())
        ret += QString::fromLatin1( " NAME=\"%1\"" ).arg( escape_str( d->name ));
    if( !d->icon.isEmpty())
        ret += QString::fromLatin1( " ICON=%1" ).arg( d->icon );
    if( d->desktop != 0 )
        ret += QString::fromLatin1( " DESKTOP=%1" ).arg( d->desktop );
    if( !d->wmclass.isEmpty())
        ret += QString::fromLatin1( " WMCLASS=%1" ).arg( d->wmclass );
    if( !d->hostname.isEmpty())
        ret += QString::fromLatin1( " HOSTNAME=%1" ).arg( d->hostname );
    for( QValueList< pid_t >::ConstIterator it = d->pids.begin();
         it != d->pids.end();
         ++it )
        ret += QString::fromLatin1( " PID=%1" ).arg( *it );
    if( d->silent != Unknown )
        ret += QString::fromLatin1( " SILENT=%1" ).arg( d->silent == Yes ? 1 : 0 );
    if( d->timestamp != -1U )
        ret += QString::fromLatin1( " TIMESTAMP=%1" ).arg( d->timestamp );
    return ret;
    }

KStartupInfoData::KStartupInfoData( const QString& txt_P )
    {
    d = new KStartupInfoDataPrivate;
    QStringList items = get_fields( txt_P );
    const QString bin_str = QString::fromLatin1( "BIN=" );
    const QString name_str = QString::fromLatin1( "NAME=" );
    const QString icon_str = QString::fromLatin1( "ICON=" );
    const QString desktop_str = QString::fromLatin1( "DESKTOP=" );
    const QString wmclass_str = QString::fromLatin1( "WMCLASS=" );
    const QString hostname_str = QString::fromLatin1( "HOSTNAME=" );
    const QString pid_str = QString::fromLatin1( "PID=" );
    const QString silent_str = QString::fromLatin1( "SILENT=" );
    const QString timestamp_str = QString::fromLatin1( "TIMESTAMP=" );
    for( QStringList::Iterator it = items.begin();
         it != items.end();
         ++it )
        {
        if( ( *it ).startsWith( bin_str ))
            d->bin = get_str( *it );
        else if( ( *it ).startsWith( name_str ))
            d->name = get_str( *it );
        else if( ( *it ).startsWith( icon_str ))
            d->icon = get_str( *it );
        else if( ( *it ).startsWith( desktop_str ))
            d->desktop = get_num( *it );
        else if( ( *it ).startsWith( wmclass_str ))
            d->wmclass = get_cstr( *it );
        else if( ( *it ).startsWith( hostname_str ))
            d->hostname = get_cstr( *it );
        else if( ( *it ).startsWith( pid_str ))
            addPid( get_num( *it ));
        else if( ( *it ).startsWith( silent_str ))
            d->silent = get_num( *it ) != 0 ? Yes : No;
        else if( ( *it ).startsWith( timestamp_str ))
            d->timestamp = get_unum( *it );
        }
    }

KStartupInfoData::KStartupInfoData( const KStartupInfoData& data )
{
    d = new KStartupInfoDataPrivate( *data.d );
}

KStartupInfoData& KStartupInfoData::operator=( const KStartupInfoData& data )
{
    if( &data == this )
        return *this;
    delete d;
    d = new KStartupInfoDataPrivate( *data.d );
    return *this;
}

void KStartupInfoData::update( const KStartupInfoData& data_P )
    {
    if( !data_P.bin().isEmpty())
        d->bin = data_P.bin();
    if( !data_P.name().isEmpty() && name().isEmpty())
        d->name = data_P.name();
    if( !data_P.icon().isEmpty() && icon().isEmpty())
        d->icon = data_P.icon();
    if( data_P.desktop() != 0 && desktop() == 0 )
        d->desktop = data_P.desktop();
    if( !data_P.d->wmclass.isEmpty())
        d->wmclass = data_P.d->wmclass;
    if( !data_P.d->hostname.isEmpty())
        d->hostname = data_P.d->hostname;
    for( QValueList< pid_t >::ConstIterator it = data_P.d->pids.begin();
         it != data_P.d->pids.end();
         ++it )
        addPid( *it );
    if( data_P.silent() != Unknown )
        d->silent = data_P.silent();
    if( data_P.timestamp() != -1U && timestamp() == -1U )
        d->timestamp = data_P.timestamp();
    }

KStartupInfoData::KStartupInfoData()
{
    d = new KStartupInfoDataPrivate;
}

KStartupInfoData::~KStartupInfoData()
{
    delete d;
}

void KStartupInfoData::setBin( const QString& bin_P )
    {
    d->bin = bin_P;
    }

const QString& KStartupInfoData::bin() const
    {
    return d->bin;
    }

void KStartupInfoData::setName( const QString& name_P )
    {
    d->name = name_P;
    }

const QString& KStartupInfoData::findName() const
    {
    if( !name().isEmpty())
        return name();
    return bin();
    }

const QString& KStartupInfoData::name() const
    {
    return d->name;
    }

void KStartupInfoData::setIcon( const QString& icon_P )
    {
    d->icon = icon_P;
    }

const QString& KStartupInfoData::findIcon() const
    {
    if( !icon().isEmpty())
        return icon();
    return bin();
    }

const QString& KStartupInfoData::icon() const
    {
    return d->icon;
    }

void KStartupInfoData::setDesktop( int desktop_P )
    {
    d->desktop = desktop_P;
    }

int KStartupInfoData::desktop() const
    {
    return d->desktop;
    }

void KStartupInfoData::setWMClass( const QCString& wmclass_P )
    {
    d->wmclass = wmclass_P;
    }

const QCString KStartupInfoData::findWMClass() const
    {
    if( !WMClass().isEmpty() && WMClass() != "0" )
        return WMClass();
    return bin().latin1();
    }

const QCString& KStartupInfoData::WMClass() const
    {
    return d->wmclass;
    }

void KStartupInfoData::setHostname( const QCString& hostname_P )
    {
    if( !hostname_P.isNull())
        d->hostname = hostname_P;
    else
        {
        char tmp[ 256 ];
        tmp[ 0 ] = '\0';
        if (!gethostname( tmp, 255 ))
            tmp[sizeof(tmp)-1] = '\0';
        d->hostname = tmp;
        }
    }

const QCString& KStartupInfoData::hostname() const
    {
    return d->hostname;
    }

void KStartupInfoData::addPid( pid_t pid_P )
    {
    if( !d->pids.contains( pid_P ))
        d->pids.append( pid_P );
    }

void KStartupInfoData::remove_pid( pid_t pid_P )
    {
    d->pids.remove( pid_P );
    }

const QValueList< pid_t >& KStartupInfoData::pids() const
    {
    return d->pids;
    }

bool KStartupInfoData::is_pid( pid_t pid_P ) const
    {
    return d->pids.contains( pid_P );
    }

void KStartupInfoData::setSilent( TriState state_P )
    {
    d->silent = state_P;
    }

KStartupInfoData::TriState KStartupInfoData::silent() const
    {
    return d->silent;
    }

void KStartupInfoData::setTimestamp( unsigned long time )
    {
    d->timestamp = time;
    }

unsigned long KStartupInfoData::timestamp() const
    {
    return d->timestamp;
    }

static
long get_num( const QString& item_P )
    {
    unsigned int pos = item_P.find( '=' );
    return item_P.mid( pos + 1 ).toLong();
    }

static
unsigned long get_unum( const QString& item_P )
    {
    unsigned int pos = item_P.find( '=' );
    return item_P.mid( pos + 1 ).toULong();
    }

static
QString get_str( const QString& item_P )
    {
    unsigned int pos = item_P.find( '=' );
    if( item_P.length() > pos + 2 && item_P[ pos + 1 ] == '\"' )
        {
        int pos2 = item_P.left( pos + 2 ).find( '\"' );
        if( pos2 < 0 )
            return QString::null;
        return item_P.mid( pos + 2, pos2 - 2 - pos );
        }
    return item_P.mid( pos + 1 );
    }

static
QCString get_cstr( const QString& item_P )
    {
    return get_str( item_P ).latin1();
    }

static
QStringList get_fields( const QString& txt_P )
    {
    QString txt = txt_P.simplifyWhiteSpace();
    QStringList ret;
    QString item = "";
    bool in = false;
    bool escape = false;
    for( unsigned int pos = 0;
         pos < txt.length();
         ++pos )
        {
        if( escape )
            {
            item += txt[ pos ];
            escape = false;
            }
        else if( txt[ pos ] == '\\' )
            escape = true;
        else if( txt[ pos ] == '\"' )
            in = !in;
        else if( txt[ pos ] == ' ' && !in )
            {
            ret.append( item );
            item = "";
            }
        else
            item += txt[ pos ];
        }
    ret.append( item );
    return ret;
    }

static QString escape_str( const QString& str_P )
    {
    QString ret = "";
    for( unsigned int pos = 0;
         pos < str_P.length();
         ++pos )
        {
        if( str_P[ pos ] == '\\'
            || str_P[ pos ] == '"' )
            ret += '\\';
        ret += str_P[ pos ];
        }
    return ret;
    }

# 1 "../kdecore/kstartupinfo.moc" 1
# 11 "../kdecore/kstartupinfo.moc"
# 1 "../../../prod/kdelibs/kdecore/kstartupinfo.h" 1
# 12 "../kdecore/kstartupinfo.moc" 2
# 22 "../kdecore/kstartupinfo.moc"
const char *KStartupInfo::className() const
{
    return "KStartupInfo";
}

QMetaObject *KStartupInfo::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KStartupInfo( "KStartupInfo", &KStartupInfo::staticMetaObject );
# 50 "../kdecore/kstartupinfo.moc"
QMetaObject* KStartupInfo::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod slot_0 = {"startups_cleanup", 0, 0 };
    static const QUMethod slot_1 = {"startups_cleanup_no_age", 0, 0 };
    static const QUParameter param_slot_2[] = {
        { "msg", &static_QUType_QString, 0, QUParameter::In }
    };
    static const QUMethod slot_2 = {"got_message", 1, param_slot_2 };
    static const QUParameter param_slot_3[] = {
        { "w", &static_QUType_ptr, "WId", QUParameter::In }
    };
    static const QUMethod slot_3 = {"window_added", 1, param_slot_3 };
    static const QUParameter param_slot_4[] = {
        { "w", &static_QUType_ptr, "WId", QUParameter::In }
    };
    static const QUMethod slot_4 = {"slot_window_added", 1, param_slot_4 };
    static const QMetaData slot_tbl[] = {
        { "startups_cleanup()", &slot_0, QMetaData::Private },
        { "startups_cleanup_no_age()", &slot_1, QMetaData::Private },
        { "got_message(const QString&)", &slot_2, QMetaData::Private },
        { "window_added(WId)", &slot_3, QMetaData::Private },
        { "slot_window_added(WId)", &slot_4, QMetaData::Private }
    };
    static const QUParameter param_signal_0[] = {
        { "id", &static_QUType_ptr, "KStartupInfoId", QUParameter::In },
        { "data", &static_QUType_ptr, "KStartupInfoData", QUParameter::In }
    };
    static const QUMethod signal_0 = {"gotNewStartup", 2, param_signal_0 };
    static const QUParameter param_signal_1[] = {
        { "id", &static_QUType_ptr, "KStartupInfoId", QUParameter::In },
        { "data", &static_QUType_ptr, "KStartupInfoData", QUParameter::In }
    };
    static const QUMethod signal_1 = {"gotStartupChange", 2, param_signal_1 };
    static const QUParameter param_signal_2[] = {
        { "id", &static_QUType_ptr, "KStartupInfoId", QUParameter::In },
        { "data", &static_QUType_ptr, "KStartupInfoData", QUParameter::In }
    };
    static const QUMethod signal_2 = {"gotRemoveStartup", 2, param_signal_2 };
    static const QMetaData signal_tbl[] = {
        { "gotNewStartup(const KStartupInfoId&,const KStartupInfoData&)", &signal_0, QMetaData::Public },
        { "gotStartupChange(const KStartupInfoId&,const KStartupInfoData&)", &signal_1, QMetaData::Public },
        { "gotRemoveStartup(const KStartupInfoId&,const KStartupInfoData&)", &signal_2, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KStartupInfo", parentObject,
        slot_tbl, 5,
        signal_tbl, 3,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KStartupInfo.setMetaObject( metaObj );
    return metaObj;
}

void* KStartupInfo::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KStartupInfo" ) )
        return this;
    return QObject::qt_cast( clname );
}





void KStartupInfo::gotNewStartup( const KStartupInfoId& t0, const KStartupInfoData& t1 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 0 );
    if ( !clist )
        return;
    QUObject o[3];
    static_QUType_ptr.set(o+1,&t0);
    static_QUType_ptr.set(o+2,&t1);
    activate_signal( clist, o );
}


void KStartupInfo::gotStartupChange( const KStartupInfoId& t0, const KStartupInfoData& t1 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 1 );
    if ( !clist )
        return;
    QUObject o[3];
    static_QUType_ptr.set(o+1,&t0);
    static_QUType_ptr.set(o+2,&t1);
    activate_signal( clist, o );
}


void KStartupInfo::gotRemoveStartup( const KStartupInfoId& t0, const KStartupInfoData& t1 )
{
    if ( signalsBlocked() )
        return;
    QConnectionList *clist = receivers( staticMetaObject()->signalOffset() + 2 );
    if ( !clist )
        return;
    QUObject o[3];
    static_QUType_ptr.set(o+1,&t0);
    static_QUType_ptr.set(o+2,&t1);
    activate_signal( clist, o );
}

bool KStartupInfo::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: startups_cleanup(); break;
    case 1: startups_cleanup_no_age(); break;
    case 2: got_message((const QString&)static_QUType_QString.get(_o+1)); break;
    case 3: window_added((WId)(*((WId*)static_QUType_ptr.get(_o+1)))); break;
    case 4: slot_window_added((WId)(*((WId*)static_QUType_ptr.get(_o+1)))); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KStartupInfo::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: gotNewStartup((const KStartupInfoId&)*((const KStartupInfoId*)static_QUType_ptr.get(_o+1)),(const KStartupInfoData&)*((const KStartupInfoData*)static_QUType_ptr.get(_o+2))); break;
    case 1: gotStartupChange((const KStartupInfoId&)*((const KStartupInfoId*)static_QUType_ptr.get(_o+1)),(const KStartupInfoData&)*((const KStartupInfoData*)static_QUType_ptr.get(_o+2))); break;
    case 2: gotRemoveStartup((const KStartupInfoId&)*((const KStartupInfoId*)static_QUType_ptr.get(_o+1)),(const KStartupInfoData&)*((const KStartupInfoData*)static_QUType_ptr.get(_o+2))); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KStartupInfo::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KStartupInfo::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 1275 "/coolo/prod/kdelibs/kdecore/kstartupinfo.cpp" 2
# 79 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcatalogue.cpp" 1
# 20 "/coolo/prod/kdelibs/kdecore/kcatalogue.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 21 "/coolo/prod/kdelibs/kdecore/kcatalogue.cpp" 2







char *k_nl_find_msg(struct kde_loaded_l10nfile *domain_file,
               const char *msgid);
void k_nl_unload_domain (struct loaded_domain *domain);
# 44 "/coolo/prod/kdelibs/kdecore/kcatalogue.cpp"
class KCataloguePrivate
{
public:
  QString name;

  kde_loaded_l10nfile domain;
};

KCatalogue::KCatalogue(const QString & name)
  : d( new KCataloguePrivate )
{
  d->name = name;
}

KCatalogue::KCatalogue(const KCatalogue & rhs)
  : d( new KCataloguePrivate )
{
  *this = rhs;
}

KCatalogue & KCatalogue::operator=(const KCatalogue & rhs)
{
  d->name = rhs.d->name;
  setFileName( rhs.fileName() );

  return *this;
}

KCatalogue::~KCatalogue()
{
  doUnload();

  delete d;
}

QString KCatalogue::name() const
{
  return d->name;
}

void KCatalogue::setFileName( const QString & fileName )
{

  if ( this->fileName() == fileName ) return;

  doUnload();

  QCString newFileName = QFile::encodeName( fileName );

  if ( !fileName.isEmpty() )
    {

      char *filename = new char[ newFileName.length() + 1 ];
      ::qstrcpy( filename, newFileName );
      d->domain.filename = filename;
    }
}

QString KCatalogue::fileName() const
{
  return QFile::decodeName( d->domain.filename );
}

const char * KCatalogue::translate(const char * msgid) const
{
  return ::k_nl_find_msg( &d->domain, msgid );
}

void KCatalogue::doUnload()
{

  if ( d->domain.data )
    ::k_nl_unload_domain( (struct loaded_domain *)d->domain.data );
  d->domain.data = 0;


  delete [] const_cast<char *>(d->domain.filename);
  d->domain.filename = 0;

  d->domain.decided = 0;
}
# 80 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kasyncio.cpp" 1
# 26 "/coolo/prod/kdelibs/kdecore/kasyncio.cpp"
void KAsyncIO::virtual_hook( int, void* )
{ }

# 1 "../kdecore/kasyncio.moc" 1
# 11 "../kdecore/kasyncio.moc"
# 1 "../../../prod/kdelibs/kdecore/kasyncio.h" 1
# 12 "../kdecore/kasyncio.moc" 2
# 22 "../kdecore/kasyncio.moc"
const char *KAsyncIO::className() const
{
    return "KAsyncIO";
}

QMetaObject *KAsyncIO::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KAsyncIO( "KAsyncIO", &KAsyncIO::staticMetaObject );
# 50 "../kdecore/kasyncio.moc"
QMetaObject* KAsyncIO::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod signal_0 = {"readyRead", 0, 0 };
    static const QUMethod signal_1 = {"readyWrite", 0, 0 };
    static const QMetaData signal_tbl[] = {
        { "readyRead()", &signal_0, QMetaData::Public },
        { "readyWrite()", &signal_1, QMetaData::Public }
    };
    metaObj = QMetaObject::new_metaobject(
        "KAsyncIO", parentObject,
        0, 0,
        signal_tbl, 2,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KAsyncIO.setMetaObject( metaObj );
    return metaObj;
}

void* KAsyncIO::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KAsyncIO" ) )
        return this;
    if ( !qstrcmp( clname, "QIODevice" ) )
        return (QIODevice*)this;
    return QObject::qt_cast( clname );
}


void KAsyncIO::readyRead()
{
    activate_signal( staticMetaObject()->signalOffset() + 0 );
}


void KAsyncIO::readyWrite()
{
    activate_signal( staticMetaObject()->signalOffset() + 1 );
}

bool KAsyncIO::qt_invoke( int _id, QUObject* _o )
{
    return QObject::qt_invoke(_id,_o);
}

bool KAsyncIO::qt_emit( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->signalOffset() ) {
    case 0: readyRead(); break;
    case 1: readyWrite(); break;
    default:
        return QObject::qt_emit(_id,_o);
    }
    return TRUE;
}


bool KAsyncIO::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KAsyncIO::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 30 "/coolo/prod/kdelibs/kdecore/kasyncio.cpp" 2
# 81 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kmultipledrag.cpp" 1
# 20 "/coolo/prod/kdelibs/kdecore/kmultipledrag.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kmultipledrag.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kmultipledrag.h"






class KMultipleDragPrivate;
# 53 "/coolo/prod/kdelibs/kdecore/kmultipledrag.h"
class KMultipleDrag : public QDragObject
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

public:






    KMultipleDrag( QWidget *dragSource = 0L, const char *name = 0L );
# 73 "/coolo/prod/kdelibs/kdecore/kmultipledrag.h"
    void addDragObject( QDragObject *dragObject );

protected:






    virtual QByteArray encodedData( const char *mime ) const;






    virtual const char* format( int i ) const;

    QPtrList<QDragObject> m_dragObjects;
    QValueList<int> m_numberFormats;
protected:
    virtual void virtual_hook( int id, void* data );
private:
    KMultipleDragPrivate* d;
};
# 21 "/coolo/prod/kdelibs/kdecore/kmultipledrag.cpp" 2




KMultipleDrag::KMultipleDrag( QWidget *dragSource, const char *name )
    : QDragObject( dragSource, name )
{
    m_dragObjects.setAutoDelete( true );
}

void KMultipleDrag::addDragObject( QDragObject *dragObject )
{

    m_dragObjects.append( dragObject );

    int i = 0;
    while ( dragObject->format( i ) )
        ++i;
    m_numberFormats.append( i );
}

QByteArray KMultipleDrag::encodedData( const char *mime ) const
{


    QPtrListIterator<QDragObject> it( m_dragObjects );
    for ( ; it.current(); ++it )
    {
        for ( int i = 0; it.current()->format( i ); ++i )
        {
            if ( ::qstrcmp( it.current()->format( i ), mime ) == 0 )
                return it.current()->encodedData( mime );
        }
    }
    return QByteArray();
}

const char* KMultipleDrag::format( int i ) const
{







    QValueList<int>::ConstIterator nit = m_numberFormats.begin();
    QValueList<int>::ConstIterator nend = m_numberFormats.end();
    QPtrListIterator<QDragObject> it( m_dragObjects );
    for ( ; nit != nend && i >= *nit ; ++nit, ++it )
        i -= *nit;
    if ( it.current() )
        return it.current()->format( i );
    return 0;
}

void KMultipleDrag::virtual_hook( int, void* )
{ }

# 1 "../kdecore/kmultipledrag.moc" 1
# 11 "../kdecore/kmultipledrag.moc"
# 1 "../../../prod/kdelibs/kdecore/kmultipledrag.h" 1
# 12 "../kdecore/kmultipledrag.moc" 2
# 22 "../kdecore/kmultipledrag.moc"
const char *KMultipleDrag::className() const
{
    return "KMultipleDrag";
}

QMetaObject *KMultipleDrag::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KMultipleDrag( "KMultipleDrag", &KMultipleDrag::staticMetaObject );
# 50 "../kdecore/kmultipledrag.moc"
QMetaObject* KMultipleDrag::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QDragObject::staticMetaObject();
    metaObj = QMetaObject::new_metaobject(
        "KMultipleDrag", parentObject,
        0, 0,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KMultipleDrag.setMetaObject( metaObj );
    return metaObj;
}

void* KMultipleDrag::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KMultipleDrag" ) )
        return this;
    return QDragObject::qt_cast( clname );
}

bool KMultipleDrag::qt_invoke( int _id, QUObject* _o )
{
    return QDragObject::qt_invoke(_id,_o);
}

bool KMultipleDrag::qt_emit( int _id, QUObject* _o )
{
    return QDragObject::qt_emit(_id,_o);
}


bool KMultipleDrag::qt_property( int id, int f, QVariant* v)
{
    return QDragObject::qt_property( id, f, v);
}

bool KMultipleDrag::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 81 "/coolo/prod/kdelibs/kdecore/kmultipledrag.cpp" 2
# 82 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kstaticdeleter.cpp" 1






void KStaticDeleterBase::destructObject()
{
}
# 83 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kappdcopiface.cpp" 1
# 25 "/coolo/prod/kdelibs/kdecore/kappdcopiface.cpp"
KAppDCOPInterface::KAppDCOPInterface(KApplication * theKApp)
        : DCOPObject( "MainApplication-Interface")
{
        m_KApplication = theKApp;
}

KAppDCOPInterface::~KAppDCOPInterface()
{
}

void KAppDCOPInterface::disableSessionManagement()
{

}

QCString KAppDCOPInterface::startupId()
{
        return "";
}

QCString KAppDCOPInterface::caption()
{
        return "";
}

void KAppDCOPInterface::quit()
{
        m_KApplication->quit();
}
# 84 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kclipboard.cpp" 1
# 41 "/coolo/prod/kdelibs/kdecore/kclipboard.cpp"
class KClipboardSynchronizer::MimeSource : public QMimeSource
{
public:
    MimeSource( const QMimeSource * src )
        : QMimeSource(),
          m_formats( true )
    {
        m_formats.setAutoDelete( true );
        m_data.setAutoDelete( true );

        if ( src )
        {
            QByteArray *byteArray;
            const char *format;
            int i = 0;
            while ( (format = src->format( i++ )) )
            {
                byteArray = new QByteArray();
                *byteArray = src->encodedData( format ).copy();
                m_data.append( byteArray );
                m_formats.append( format );
            }
        }
    }

    ~MimeSource() {}

    virtual const char *format( int i ) const {
        if ( i < (int) m_formats.count() )
            return m_formats.at( i );
        else
            return 0L;
    }
    virtual bool provides( const char *mimeType ) const {
        return ( m_formats.find( mimeType ) > -1 );
    }
    virtual QByteArray encodedData( const char *format ) const
    {
        int index = m_formats.find( format );
        if ( index > -1 )
            return *(m_data.at( index ));

        return QByteArray();
    }

private:
    mutable QStrList m_formats;
    mutable QPtrList<QByteArray> m_data;
};


KClipboardSynchronizer * KClipboardSynchronizer::s_self = 0L;
bool KClipboardSynchronizer::s_sync = false;
bool KClipboardSynchronizer::s_reverse_sync = false;
bool KClipboardSynchronizer::s_blocked = false;

KClipboardSynchronizer * KClipboardSynchronizer::self()
{
    if ( !s_self )
        s_self = new KClipboardSynchronizer( KApplication::kApplication(), "KDE Clipboard" );

    return s_self;
}

KClipboardSynchronizer::KClipboardSynchronizer( QObject *parent, const char *name )
    : QObject( parent, name )
{
    s_self = this;

    KConfigGroup config( KGlobal::config(), "General" );
    s_sync = config.readBoolEntry( "SynchronizeClipboardAndSelection", s_sync);
    s_reverse_sync = config.readBoolEntry( "ClipboardSetSelection",
                                                s_reverse_sync );

    setupSignals();
}

KClipboardSynchronizer::~KClipboardSynchronizer()
{
    if ( s_self == this )
        s_self = 0L;
}

void KClipboardSynchronizer::setupSignals()
{
    QClipboard *clip = QApplication::clipboard();
    disconnect( clip, __null, this, __null );
    if( s_sync )
        connect( clip, "2""selectionChanged()",
                 "1""slotSelectionChanged()");
    if( s_reverse_sync )
        connect( clip, "2""dataChanged()",
                 "1""slotClipboardChanged()");
}

void KClipboardSynchronizer::slotSelectionChanged()
{
    QClipboard *clip = QApplication::clipboard();


    if ( s_blocked || !clip->ownsSelection() )
        return;

    setClipboard( new MimeSource( clip->data( QClipboard::Selection) ),
                  QClipboard::Clipboard );
}

void KClipboardSynchronizer::slotClipboardChanged()
{
    QClipboard *clip = QApplication::clipboard();


    if ( s_blocked || !clip->ownsClipboard() )
        return;

    setClipboard( new MimeSource( clip->data( QClipboard::Clipboard ) ),
                  QClipboard::Selection );
}

void KClipboardSynchronizer::setClipboard( QMimeSource *data, QClipboard::Mode mode )
{


    QClipboard *clip = QApplication::clipboard();

    s_blocked = true;

    if ( mode == QClipboard::Clipboard )
    {
        clip->setData( data, QClipboard::Clipboard );
    }
    else if ( mode == QClipboard::Selection )
    {
        clip->setData( data, QClipboard::Selection );
    }

    s_blocked = false;
}

void KClipboardSynchronizer::setSynchronizing( bool sync )
{
    s_sync = sync;
    self()->setupSignals();
}

void KClipboardSynchronizer::setReverseSynchronizing( bool enable )
{
    s_reverse_sync = enable;
    self()->setupSignals();
}


void KClipboardSynchronizer::newConfiguration( int config )
{
    s_sync = (config & Synchronize);
    self()->setupSignals();
}

# 1 "../kdecore/kclipboard.moc" 1
# 11 "../kdecore/kclipboard.moc"
# 1 "../../../prod/kdelibs/kdecore/kclipboard.h" 1
# 12 "../kdecore/kclipboard.moc" 2
# 22 "../kdecore/kclipboard.moc"
const char *KClipboardSynchronizer::className() const
{
    return "KClipboardSynchronizer";
}

QMetaObject *KClipboardSynchronizer::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KClipboardSynchronizer( "KClipboardSynchronizer", &KClipboardSynchronizer::staticMetaObject );
# 50 "../kdecore/kclipboard.moc"
QMetaObject* KClipboardSynchronizer::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod slot_0 = {"slotSelectionChanged", 0, 0 };
    static const QUMethod slot_1 = {"slotClipboardChanged", 0, 0 };
    static const QMetaData slot_tbl[] = {
        { "slotSelectionChanged()", &slot_0, QMetaData::Private },
        { "slotClipboardChanged()", &slot_1, QMetaData::Private }
    };
    metaObj = QMetaObject::new_metaobject(
        "KClipboardSynchronizer", parentObject,
        slot_tbl, 2,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KClipboardSynchronizer.setMetaObject( metaObj );
    return metaObj;
}

void* KClipboardSynchronizer::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KClipboardSynchronizer" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KClipboardSynchronizer::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: slotSelectionChanged(); break;
    case 1: slotClipboardChanged(); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KClipboardSynchronizer::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KClipboardSynchronizer::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KClipboardSynchronizer::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 200 "/coolo/prod/kdelibs/kdecore/kclipboard.cpp" 2
# 85 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp"


# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 27 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp" 2






# 1 "/coolo/prod/qt-copy/include/qlayout.h" 1
# 39 "/coolo/prod/qt-copy/include/qlayout.h"







# 1 "/usr/lib/gcc-lib/i486-suse-linux/3.3/include/limits.h" 1 3 4
# 48 "/coolo/prod/qt-copy/include/qlayout.h" 2







static const int QLAYOUTSIZE_MAX = 2147483647/256/16;

class QGridLayoutBox;
class QGridLayoutData;
class QLayout;
class QLayoutItem;
struct QLayoutData;
class QMenuBar;
class QSpacerItem;
class QWidget;

class QGLayoutIterator : public QShared
{
public:
    virtual ~QGLayoutIterator();
    virtual QLayoutItem *next() = 0;
    virtual QLayoutItem *current() = 0;
    virtual QLayoutItem *takeCurrent() = 0;
};

class QLayoutIterator
{
public:
    QLayoutIterator( QGLayoutIterator *i ) : it( i ) { }
    QLayoutIterator( const QLayoutIterator &i ) : it( i.it ) {
        if ( it )
            it->ref();
    }
    ~QLayoutIterator() { if ( it && it->deref() ) delete it; }
    QLayoutIterator &operator=( const QLayoutIterator &i ) {
        if ( i.it )
            i.it->ref();
        if ( it && it->deref() )
            delete it;
        it = i.it;
        return *this;
    }
    QLayoutItem *operator++() { return it ? it->next() : 0; }
    QLayoutItem *current() { return it ? it->current() : 0; }
    QLayoutItem *takeCurrent() { return it ? it->takeCurrent() : 0; }
    void deleteCurrent();

private:
    QGLayoutIterator *it;
};

class QLayoutItem
{
public:
    QLayoutItem( int alignment = 0 ) : align( alignment ) { }
    virtual ~QLayoutItem();
    virtual QSize sizeHint() const = 0;
    virtual QSize minimumSize() const = 0;
    virtual QSize maximumSize() const = 0;
    virtual QSizePolicy::ExpandData expanding() const = 0;
    virtual void setGeometry( const QRect& ) = 0;
    virtual QRect geometry() const = 0;
    virtual bool isEmpty() const = 0;
    virtual bool hasHeightForWidth() const;
    virtual int heightForWidth( int ) const;

    virtual void invalidate();

    virtual QWidget *widget();
    virtual QLayoutIterator iterator();
    virtual QLayout *layout();
    virtual QSpacerItem *spacerItem();

    int alignment() const { return align; }
    virtual void setAlignment( int a );

protected:
    int align;
};

class QSpacerItem : public QLayoutItem
{
public:
    QSpacerItem( int w, int h,
                 QSizePolicy::SizeType hData = QSizePolicy::Minimum,
                 QSizePolicy::SizeType vData = QSizePolicy::Minimum )
        : width( w ), height( h ), sizeP( hData, vData ) { }
    void changeSize( int w, int h,
                     QSizePolicy::SizeType hData = QSizePolicy::Minimum,
                     QSizePolicy::SizeType vData = QSizePolicy::Minimum );
    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    QSizePolicy::ExpandData expanding() const;
    bool isEmpty() const;
    void setGeometry( const QRect& );
    QRect geometry() const;
    QSpacerItem *spacerItem();

private:
    int width;
    int height;
    QSizePolicy sizeP;
    QRect rect;
};

class QWidgetItem : public QLayoutItem
{
public:
    QWidgetItem( QWidget *w ) : wid( w ) { }
    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    QSizePolicy::ExpandData expanding() const;
    bool isEmpty() const;
    void setGeometry( const QRect& );
    QRect geometry() const;
    virtual QWidget *widget();

    bool hasHeightForWidth() const;
    int heightForWidth( int ) const;

private:
    QWidget *wid;
};

class QLayout : public QObject, public QLayoutItem
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   

public:

    enum ResizeMode { FreeResize, Minimum, Fixed, Auto };

    QLayout( QWidget *parent, int margin = 0, int spacing = -1,
             const char *name = 0 );
    QLayout( QLayout *parentLayout, int spacing = -1, const char *name = 0 );
    QLayout( int spacing = -1, const char *name = 0 );
    ~QLayout();

    int margin() const { return outsideBorder; }
    int spacing() const { return insideSpacing; }

    virtual void setMargin( int );
    virtual void setSpacing( int );

    int defaultBorder() const { return insideSpacing; }
    void freeze( int w, int h );
    void freeze() { setResizeMode( Fixed ); }

    void setResizeMode( ResizeMode );
    ResizeMode resizeMode() const;


    virtual void setMenuBar( QMenuBar *w );
    QMenuBar *menuBar() const { return menubar; }


    QWidget *mainWidget();
    bool isTopLevel() const { return topLevel; }

    virtual void setAutoAdd( bool );
    bool autoAdd() const { return autoNewChild; }

    void invalidate();
    QRect geometry() const;
    bool activate();

    void add( QWidget *w ) { addItem( new QWidgetItem(w) ); }
    virtual void addItem( QLayoutItem * ) = 0;

    void remove( QWidget *w );
    void removeItem( QLayoutItem * );

    QSizePolicy::ExpandData expanding() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    void setGeometry( const QRect& ) = 0;
    QLayoutIterator iterator() = 0;
    bool isEmpty() const;

    int totalHeightForWidth( int w ) const;
    QSize totalMinimumSize() const;
    QSize totalMaximumSize() const;
    QSize totalSizeHint() const;
    QLayout *layout();

    bool supportsMargin() const { return marginImpl; }

    void setEnabled( bool );
    bool isEnabled() const;

protected:
    bool eventFilter( QObject *, QEvent * );
    void childEvent( QChildEvent *e );
    void addChildLayout( QLayout *l );
    void deleteAllItems();

    void setSupportsMargin( bool );
    QRect alignmentRect( const QRect& ) const;

private:
    void setWidgetLayout( QWidget *, QLayout * );
    void init();
    int insideSpacing;
    int outsideBorder;
    uint topLevel : 1;
    uint enabled : 1;
    uint autoNewChild : 1;
    uint frozen : 1;
    uint activated : 1;
    uint marginImpl : 1;
    uint autoMinimum : 1;
    uint autoResizeMode : 1;
    QRect rect;
    QLayoutData *extraData;

    QMenuBar *menubar;


private:

    QLayout( const QLayout & );
    QLayout &operator=( const QLayout & );


    static void propagateSpacing( QLayout *layout );
};

inline void QLayoutIterator::deleteCurrent()
{
    delete takeCurrent();
}

class QGridLayout : public QLayout
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QGridLayout( QWidget *parent, int nRows = 1, int nCols = 1, int border = 0,
                 int spacing = -1, const char *name = 0 );
    QGridLayout( int nRows = 1, int nCols = 1, int spacing = -1,
                 const char *name = 0 );
    QGridLayout( QLayout *parentLayout, int nRows = 1, int nCols = 1,
                 int spacing = -1, const char *name = 0 );
    ~QGridLayout();

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;


    virtual void setRowStretch( int row, int stretch );
    virtual void setColStretch( int col, int stretch );
    int rowStretch( int row ) const;
    int colStretch( int col ) const;

    void setRowSpacing( int row, int minSize );
    void setColSpacing( int col, int minSize );
    int rowSpacing( int row ) const;
    int colSpacing( int col ) const;

    int numRows() const;
    int numCols() const;
    QRect cellGeometry( int row, int col ) const;

    bool hasHeightForWidth() const;
    int heightForWidth( int ) const;
    int minimumHeightForWidth( int ) const;

    QSizePolicy::ExpandData expanding() const;
    void invalidate();

    void addItem( QLayoutItem * );
    void addItem( QLayoutItem *item, int row, int col );
    void addMultiCell( QLayoutItem *, int fromRow, int toRow,
                               int fromCol, int toCol, int align = 0 );

    void addWidget( QWidget *, int row, int col, int align = 0 );
    void addMultiCellWidget( QWidget *, int fromRow, int toRow,
                             int fromCol, int toCol, int align = 0 );
    void addLayout( QLayout *layout, int row, int col);
    void addMultiCellLayout( QLayout *layout, int fromRow, int toRow,
                             int fromCol, int toCol, int align = 0 );
    void addRowSpacing( int row, int minsize );
    void addColSpacing( int col, int minsize );

    void expand( int rows, int cols );

    enum Corner { TopLeft, TopRight, BottomLeft, BottomRight };
    void setOrigin( Corner );
    Corner origin() const;
    QLayoutIterator iterator();
    void setGeometry( const QRect& );

protected:
    bool findWidget( QWidget* w, int *r, int *c );
    void add( QLayoutItem*, int row, int col );

private:

    QGridLayout( const QGridLayout & );
    QGridLayout &operator=( const QGridLayout & );


    void init( int rows, int cols );
    QGridLayoutData *data;
};

class QBoxLayoutData;
class QDockWindow;

class QBoxLayout : public QLayout
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    enum Direction { LeftToRight, RightToLeft, TopToBottom, BottomToTop,
                     Down = TopToBottom, Up = BottomToTop };

    QBoxLayout( QWidget *parent, Direction, int border = 0, int spacing = -1,
                const char *name = 0 );
    QBoxLayout( QLayout *parentLayout, Direction, int spacing = -1,
                const char *name = 0 );
    QBoxLayout( Direction, int spacing = -1, const char *name = 0 );
    ~QBoxLayout();

    void addItem( QLayoutItem * );

    Direction direction() const { return dir; }
    void setDirection( Direction );

    void addSpacing( int size );
    void addStretch( int stretch = 0 );
    void addWidget( QWidget *, int stretch = 0, int alignment = 0 );
    void addLayout( QLayout *layout, int stretch = 0 );
    void addStrut( int );

    void insertSpacing( int index, int size );
    void insertStretch( int index, int stretch = 0 );
    void insertWidget( int index, QWidget *widget, int stretch = 0,
                       int alignment = 0 );
    void insertLayout( int index, QLayout *layout, int stretch = 0 );

    bool setStretchFactor( QWidget*, int stretch );
    bool setStretchFactor( QLayout *l, int stretch );

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;

    bool hasHeightForWidth() const;
    int heightForWidth( int ) const;
    int minimumHeightForWidth( int ) const;

    QSizePolicy::ExpandData expanding() const;
    void invalidate();
    QLayoutIterator iterator();
    void setGeometry( const QRect& );

    int findWidget( QWidget* w );

protected:
    void insertItem( int index, QLayoutItem * );

private:
    friend class QDockWindow;

    QBoxLayout( const QBoxLayout & );
    QBoxLayout &operator=( const QBoxLayout & );


    void setupGeom();
    void calcHfw( int );
    QBoxLayoutData *data;
    Direction dir;
    QBoxLayout *createTmpCopy();
};

class QHBoxLayout : public QBoxLayout
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QHBoxLayout( QWidget *parent, int border = 0,
                 int spacing = -1, const char *name = 0 );
    QHBoxLayout( QLayout *parentLayout,
                 int spacing = -1, const char *name = 0 );
    QHBoxLayout( int spacing = -1, const char *name = 0 );

    ~QHBoxLayout();

private:

    QHBoxLayout( const QHBoxLayout & );
    QHBoxLayout &operator=( const QHBoxLayout & );

};

class QVBoxLayout : public QBoxLayout
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
public:
    QVBoxLayout( QWidget *parent, int border = 0,
                 int spacing = -1, const char *name = 0 );
    QVBoxLayout( QLayout *parentLayout,
                 int spacing = -1, const char *name = 0 );
    QVBoxLayout( int spacing = -1, const char *name = 0 );

    ~QVBoxLayout();

private:

    QVBoxLayout( const QVBoxLayout & );
    QVBoxLayout &operator=( const QVBoxLayout & );

};
# 34 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp" 2
# 1 "/coolo/prod/qt-copy/include/qtextview.h" 1
# 39 "/coolo/prod/qt-copy/include/qtextview.h"







class QTextView : public QTextEdit
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   

public:
    QTextView( const QString& text, const QString& context = QString::null,
               QWidget* parent=0, const char* name=0);
    QTextView( QWidget* parent=0, const char* name=0 );

    virtual ~QTextView();

private:

    QTextView( const QTextView & );
    QTextView &operator=( const QTextView & );

};
# 35 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp" 2



# 1 "/coolo/prod/qt-copy/include/qpushbutton.h" 1
# 39 "/coolo/prod/qt-copy/include/qpushbutton.h"


# 1 "/coolo/prod/qt-copy/include/qbutton.h" 1
# 39 "/coolo/prod/qt-copy/include/qbutton.h"
# 49 "/coolo/prod/qt-copy/include/qbutton.h"
class QButtonGroup;
class QToolBar;
class QButtonData;

class QButton : public QWidget
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   
   
   
   
   
   
   
   
   
   

public:
    QButton( QWidget* parent=0, const char* name=0, WFlags f=0 );
    ~QButton();

    QString text() const;
    virtual void setText( const QString &);
    const QPixmap *pixmap() const;
    virtual void setPixmap( const QPixmap & );


    QKeySequence accel() const;
    virtual void setAccel( const QKeySequence& );


    bool isToggleButton() const;

    enum ToggleType { SingleShot, Toggle, Tristate };
    ToggleType toggleType() const;

    virtual void setDown( bool );
    bool isDown() const;

    bool isOn() const;

    enum ToggleState { Off, NoChange, On };
    ToggleState state() const;


    bool autoResize() const;
    void setAutoResize( bool );


    bool autoRepeat() const;
    virtual void setAutoRepeat( bool );
    bool isExclusiveToggle() const;

    QButtonGroup *group() const;

public :
    void animateClick();
    void toggle();

protected:
    void pressed();
    void released();
    void clicked();
    void toggled( bool );
    void stateChanged( int );

protected:
    void setToggleButton( bool );
    virtual void setToggleType( ToggleType );
    void setOn( bool );
    virtual void setState( ToggleState );

    virtual bool hitButton( const QPoint &pos ) const;
    virtual void drawButton( QPainter * );
    virtual void drawButtonLabel( QPainter * );

    void keyPressEvent( QKeyEvent *);
    void keyReleaseEvent( QKeyEvent *);
    void mousePressEvent( QMouseEvent * );
    void mouseReleaseEvent( QMouseEvent * );
    void mouseMoveEvent( QMouseEvent * );
    void paintEvent( QPaintEvent * );
    void focusInEvent( QFocusEvent * );
    void focusOutEvent( QFocusEvent * );

    void enabledChange( bool );

private :
    void animateTimeout();
    void autoRepeatTimeout();
    void emulateClick();

private:
    QString btext;
    QPixmap *bpixmap;
    uint toggleTyp : 2;
    uint buttonDown : 1;
    uint stat : 2;
    uint mlbDown : 1;
    uint autoresize : 1;
    uint animation : 1;
    uint repeat : 1;
    QButtonData *d;

    friend class QButtonGroup;
    friend class QToolBar;
    void ensureData();
    virtual void setGroup( QButtonGroup* );
    QTimer *timer();
    void nextState();

private:

    QButton( const QButton & );
    QButton &operator=( const QButton & );

};


inline QString QButton::text() const
{
    return btext;
}

inline const QPixmap *QButton::pixmap() const
{
    return bpixmap;
}

inline bool QButton::isToggleButton() const
{
    return toggleTyp != SingleShot;
}

inline bool QButton::isDown() const
{
    return buttonDown;
}

inline bool QButton::isOn() const
{
    return stat != Off;
}


inline bool QButton::autoResize() const
{
    return autoresize;
}


inline bool QButton::autoRepeat() const
{
    return repeat;
}

inline QButton::ToggleState QButton::state() const
{
    return ToggleState(stat);
}

inline void QButton::setToggleButton( bool b )
{
    setToggleType( b ? Toggle : SingleShot );
}

inline void QButton::setOn( bool y )
{
    setState( y ? On : Off );
}

inline QButton::ToggleType QButton::toggleType() const
{
    return ToggleType(toggleTyp);
}
# 43 "/coolo/prod/qt-copy/include/qpushbutton.h" 2




class QPushButtonPrivate;
class QPopupMenu;

class QPushButton : public QButton
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;

   
   
   
   
   
   
   
   

public:
    QPushButton( QWidget *parent, const char* name=0 );
    QPushButton( const QString &text, QWidget *parent, const char* name=0 );

    QPushButton( const QIconSet& icon, const QString &text, QWidget *parent, const char* name=0 );

    ~QPushButton();

    QSize sizeHint() const;

    void move( int x, int y );
    void move( const QPoint &p );
    void resize( int w, int h );
    void resize( const QSize & );
    void setGeometry( int x, int y, int w, int h );

    void setGeometry( const QRect & );

    void setToggleButton( bool );

    bool autoDefault() const { return autoDefButton; }
    virtual void setAutoDefault( bool autoDef );
    bool isDefault() const { return defButton; }
    virtual void setDefault( bool def );

    virtual void setIsMenuButton( bool enable ) {
        if ( (bool)hasMenuArrow == enable )
            return;
        hasMenuArrow = enable ? 1 : 0;
        update();
        updateGeometry();
    }
    bool isMenuButton() const { return hasMenuArrow; }


    void setPopup( QPopupMenu* popup );
    QPopupMenu* popup() const;


    void setIconSet( const QIconSet& );
    QIconSet* iconSet() const;

    void setFlat( bool );
    bool isFlat() const;

public :
    virtual void setOn( bool );

protected:
    void drawButton( QPainter * );
    void drawButtonLabel( QPainter * );
    void focusInEvent( QFocusEvent * );
    void focusOutEvent( QFocusEvent * );
    void resizeEvent( QResizeEvent * );
    void updateMask();
private :

    void popupPressed();

private:
    void init();

    uint autoDefButton : 1;
    uint defButton : 1;
    uint flt : 1;
    uint reserved : 1;
    uint lastEnabled : 1;
    uint hasMenuArrow : 1;

    QPushButtonPrivate* d;

    friend class QDialog;

private:

    QPushButton( const QPushButton & );
    QPushButton &operator=( const QPushButton & );

};
# 39 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp" 2

# 1 "/coolo/prod/qt-copy/include/qcheckbox.h" 1
# 39 "/coolo/prod/qt-copy/include/qcheckbox.h"







class QCheckBox : public QButton
{
    public: virtual QMetaObject *metaObject() const { return staticMetaObject(); } virtual const char *className() const; virtual void* qt_cast( const char* ); virtual bool qt_invoke( int, QUObject* ); virtual bool qt_emit( int, QUObject* ); virtual bool qt_property( int id, int f, QVariant* v); static bool qt_static_property( QObject* , int, int, QVariant* ); static QMetaObject* staticMetaObject(); QObject* qObject() { return (QObject*)this; } static QString tr( const char *, const char * = 0 ); static QString trUtf8( const char *, const char * = 0 ); private: static QMetaObject *metaObj;
   
   
   

public:
    QCheckBox( QWidget *parent, const char* name=0 );
    QCheckBox( const QString &text, QWidget *parent, const char* name=0 );

    bool isChecked() const;

    void setNoChange();

    void setTristate(bool y=TRUE);
    bool isTristate() const;

    QSize sizeHint() const;

public :
    void setChecked( bool check );

protected:
    void resizeEvent( QResizeEvent* );
    void drawButton( QPainter * );
    void drawButtonLabel( QPainter * );
    void updateMask();
    bool hitButton( const QPoint &pos ) const;
private:

    QCheckBox( const QCheckBox & );
    QCheckBox &operator=( const QCheckBox & );

};


inline bool QCheckBox::isChecked() const
{ return isOn(); }

inline void QCheckBox::setChecked( bool check )
{ setOn( check ); }
# 41 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp" 2
# 79 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp"
KCheckAccelerators::KCheckAccelerators( QObject* parent )
    : QObject( parent, "kapp_accel_filter" ), block( false ), drklash(0)
{
    parent->installEventFilter( this );
    KConfigGroupSaver saver( KGlobal::config(), "Development" );
    QString sKey = KGlobal::config()->readEntry( "CheckAccelerators", "F12" ).stripWhiteSpace();
    if( !sKey.isEmpty() ) {
      KShortcut cuts( sKey );
      if( cuts.count() > 0 )
        key = int(cuts.seq(0).qt());
    }
    alwaysShow = KGlobal::config()->readBoolEntry( "AlwaysShowCheckAccelerators", true );
    autoCheck = KGlobal::config()->readBoolEntry( "AutoCheckAccelerators", true );
    connect( &autoCheckTimer, "2""timeout()", "1""autoCheckSlot()");
}

bool KCheckAccelerators::eventFilter( QObject * , QEvent * e) {
    if ( block )
        return false;
    if ( e->type() == QEvent::Accel ) {
        if ( static_cast<QKeyEvent *>(e)->key() == key ) {
            block = true;
            checkAccelerators( false );
            block = false;
            static_cast<QKeyEvent *>(e)->accept();
            return true;
        }
    }
    if( autoCheck
        && ( e->type() == QEvent::ChildInserted ||
             e->type() == QEvent::ChildRemoved ))
    {
        autoCheckTimer.start( 100, true );
    }
    return false;
}

void KCheckAccelerators::autoCheckSlot()
{
    if( block || QWidget::mouseGrabber() ||
        QWidget::keyboardGrabber() ||
        QApplication::activePopupWidget())
    {
        autoCheckTimer.start( 100, true );
        return;
    }
    block = true;
    checkAccelerators( true );
    block = false;
}

void KCheckAccelerators::createDialog(QWidget *actWin, bool automatic)
{
    if ( drklash )
        return;

    drklash = new QDialog( actWin, "kapp_accel_check_dlg", false, Qt::WDestructiveClose);
    drklash->setCaption( i18n( "Dr. Klash' Accelerator Diagnosis" ));
    drklash->resize( 500, 460 );
    QVBoxLayout* layout = new QVBoxLayout( drklash, 11, 6 );
    layout->setAutoAdd( TRUE );
    drklash_view = new QTextView( drklash );
    QCheckBox* disableAutoCheck = __null;
    if( automatic ) {
        disableAutoCheck = new QCheckBox( i18n( "&Disable automatic checking" ), drklash );
        connect(disableAutoCheck, "2""toggled(bool)", "1""slotDisableCheck(bool)");
    }
    QPushButton* btnClose = new QPushButton( i18n( "&Close" ), drklash );
    btnClose->setDefault( true );
    connect( btnClose, "2""clicked()", drklash, "1""close()" );
    if (disableAutoCheck)
        disableAutoCheck->setFocus();
    else
        drklash_view->setFocus();
}

void KCheckAccelerators::slotDisableCheck(bool on)
{
    autoCheck = !on;
    if (!on)
        autoCheckSlot();
}

void KCheckAccelerators::checkAccelerators( bool automatic ) {
    QWidget* actWin = qApp->activeWindow();
    if ( !actWin )
        return;

    KAcceleratorManager::manage(actWin);
    QString a, c, r;
    KAcceleratorManager::last_manage(a, c, r);
    if (c.isEmpty() && r.isEmpty() && (automatic || a.isEmpty()))
        return;

    QString s;

    if ( ! c.isEmpty() ) {
        s += i18n("<h2>Accelerators changed</h2>");
        s += "<table border><tr><th><b>Old Text</b></th><th><b>New Text</b></th></tr>"
             + c + "</table>";
    }

    if ( ! r.isEmpty() ) {
        s += i18n("<h2>Accelerators removed</h2>");
        s += "<table border><tr><th><b>Old Text</b></th></tr>" + r + "</table>";
    }

    if ( ! a.isEmpty() ) {
        s += i18n("<h2>Accelerators added (just for your info)</h2>");
        s += "<table border><tr><th><b>New Text</b></th></tr>" + a + "</table>";
    }

    createDialog(actWin, automatic);
    drklash_view->setText(s);
    drklash->show();
    drklash->raise();


}

# 1 "../kdecore/kcheckaccelerators.moc" 1
# 11 "../kdecore/kcheckaccelerators.moc"
# 1 "../../../prod/kdelibs/kdecore/kcheckaccelerators.h" 1
# 12 "../kdecore/kcheckaccelerators.moc" 2
# 22 "../kdecore/kcheckaccelerators.moc"
const char *KCheckAccelerators::className() const
{
    return "KCheckAccelerators";
}

QMetaObject *KCheckAccelerators::metaObj = 0;
static QMetaObjectCleanUp cleanUp_KCheckAccelerators( "KCheckAccelerators", &KCheckAccelerators::staticMetaObject );
# 50 "../kdecore/kcheckaccelerators.moc"
QMetaObject* KCheckAccelerators::staticMetaObject()
{
    if ( metaObj )
        return metaObj;
    QMetaObject* parentObject = QObject::staticMetaObject();
    static const QUMethod slot_0 = {"autoCheckSlot", 0, 0 };
    static const QUParameter param_slot_1[] = {
        { 0, &static_QUType_bool, 0, QUParameter::In }
    };
    static const QUMethod slot_1 = {"slotDisableCheck", 1, param_slot_1 };
    static const QMetaData slot_tbl[] = {
        { "autoCheckSlot()", &slot_0, QMetaData::Private },
        { "slotDisableCheck(bool)", &slot_1, QMetaData::Private }
    };
    metaObj = QMetaObject::new_metaobject(
        "KCheckAccelerators", parentObject,
        slot_tbl, 2,
        0, 0,

        0, 0,
        0, 0,

        0, 0 );
    cleanUp_KCheckAccelerators.setMetaObject( metaObj );
    return metaObj;
}

void* KCheckAccelerators::qt_cast( const char* clname )
{
    if ( !qstrcmp( clname, "KCheckAccelerators" ) )
        return this;
    return QObject::qt_cast( clname );
}

bool KCheckAccelerators::qt_invoke( int _id, QUObject* _o )
{
    switch ( _id - staticMetaObject()->slotOffset() ) {
    case 0: autoCheckSlot(); break;
    case 1: slotDisableCheck((bool)static_QUType_bool.get(_o+1)); break;
    default:
        return QObject::qt_invoke( _id, _o );
    }
    return TRUE;
}

bool KCheckAccelerators::qt_emit( int _id, QUObject* _o )
{
    return QObject::qt_emit(_id,_o);
}


bool KCheckAccelerators::qt_property( int id, int f, QVariant* v)
{
    return QObject::qt_property( id, f, v);
}

bool KCheckAccelerators::qt_static_property( QObject* , int , int , QVariant* ){ return FALSE; }
# 200 "/coolo/prod/kdelibs/kdecore/kcheckaccelerators.cpp" 2
# 86 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kdeversion.cpp" 1
# 22 "/coolo/prod/kdelibs/kdecore/kdeversion.cpp"
unsigned int KDE::version()
{
    return (((3) << 16) | ((1) << 8) | (90));
}

unsigned int KDE::versionMajor()
{
    return 3;
}

unsigned int KDE::versionMinor()
{
    return 1;
}

unsigned int KDE::versionRelease()
{
    return 90;
}

const char *KDE::versionString()
{
    return "3.1.90 (CVS >= 20030827)";
}
# 87 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kdebugdcopiface.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kdebugdcopiface.cpp"
KDebugDCOPIface::KDebugDCOPIface() : DCOPObject("KDebug")
{
}

KDebugDCOPIface::~KDebugDCOPIface()
{
}

void KDebugDCOPIface::notifyKDebugConfigChanged()
{
 kdClearDebugConfig();
}
# 88 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.cpp" 1
# 29 "/coolo/prod/kdelibs/kdecore/kcalendarsystem.cpp"
class KCalendarSystemPrivate
{
public:
  const KLocale * locale;
};

KCalendarSystem::KCalendarSystem(const KLocale * locale)
  : d(new KCalendarSystemPrivate)
{
  d->locale = locale;
}

KCalendarSystem::~KCalendarSystem()
{
  delete d;
}

const KLocale * KCalendarSystem::locale() const
{
  if ( d->locale )
    return d->locale;

  return KGlobal::locale();
}

QString KCalendarSystem::dayString(const QDate & pDate, bool bShort) const
{
  QString sResult;

  sResult.setNum(day(pDate));
  if (!bShort && sResult.length() == 1 )
    sResult.prepend('0');

  return sResult;
}

QString KCalendarSystem::monthString(const QDate & pDate, bool bShort) const
{
  QString sResult;

  sResult.setNum(month(pDate));
  if (!bShort && sResult.length() == 1 )
    sResult.prepend('0');

  return sResult;
}

QString KCalendarSystem::yearString(const QDate & pDate, bool bShort) const
{
  QString sResult;

  sResult.setNum(year(pDate));
  if (!bShort && sResult.length() == 1 )
    sResult.prepend('0');

  return sResult;
}

static int stringToInteger(const QString & sNum, int & iLength)
{
  int iPos = 0;

  int result = 0;
  for (; sNum.length() > iPos && sNum.at(iPos).isDigit(); iPos++)
    {
      result *= 10;
      result += sNum.at(iPos).digitValue();
    }

  iLength = iPos;
  return result;
}


int KCalendarSystem::dayStringToInteger(const QString & sNum, int & iLength) const
{
  return stringToInteger(sNum, iLength);
}

int KCalendarSystem::monthStringToInteger(const QString & sNum, int & iLength) const
{
  return stringToInteger(sNum, iLength);
}

int KCalendarSystem::yearStringToInteger(const QString & sNum, int & iLength) const
{
  return stringToInteger(sNum, iLength);
}
# 89 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemgregorian.cpp" 1
# 30 "/coolo/prod/kdelibs/kdecore/kcalendarsystemgregorian.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemgregorian.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kcalendarsystemgregorian.h"






class KCalendarSystemGregorianPrivate;
# 45 "/coolo/prod/kdelibs/kdecore/kcalendarsystemgregorian.h"
class KCalendarSystemGregorian: public KCalendarSystem
{
public:
  KCalendarSystemGregorian (const KLocale * locale = 0);
  virtual ~KCalendarSystemGregorian ();

  virtual int year (const QDate & date) const;
  virtual int month (const QDate & date) const;
  virtual int day (const QDate & date) const;
  virtual int dayOfWeek (const QDate & date) const;
  virtual int dayOfYear (const QDate & date) const;

  virtual bool setYMD(QDate & date, int y, int m, int d) const;

  virtual QDate addYears(const QDate & date, int nyears) const;
  virtual QDate addMonths(const QDate & date, int nmonths) const;
  virtual QDate addDays(const QDate & date, int ndays) const;

  virtual int monthsInYear (const QDate & date) const;

  virtual int daysInYear (const QDate & date) const;
  virtual int daysInMonth (const QDate & date) const;
  virtual int weeksInYear(int year) const;
  virtual int weekNumber(const QDate& date, int * yearNum = 0) const;

  virtual int yearStringToInteger(const QString & sNum, int & iLength) const;

  virtual QString yearLiteral (int year) const;
  virtual QString yearLiteral (const QDate & date) const;
  virtual QString monthName (int month, int year, bool shortName = false) const;
  virtual QString monthName (const QDate & date, bool shortName = false ) const;
  virtual QString monthNamePossessive(int month, int year, bool shortName = false) const;
  virtual QString monthNamePossessive(const QDate & date, bool shortName = false ) const;
  virtual QString weekDayName (int weekDay, bool shortName = false) const;
  virtual QString weekDayName (const QDate & date, bool shortName = false) const;

  virtual int minValidYear () const;
  virtual int maxValidYear () const;
  virtual int weekDayOfPray () const;

  virtual QString calendarName() const;

  virtual bool isLunar() const;
  virtual bool isLunisolar() const;
  virtual bool isSolar() const;

private:
  KCalendarSystemGregorianPrivate * d;
};
# 31 "/coolo/prod/kdelibs/kdecore/kcalendarsystemgregorian.cpp" 2

KCalendarSystemGregorian::KCalendarSystemGregorian(const KLocale * locale)
  : KCalendarSystem(locale)
{
  kdDebug(5400) << "\nCreated gregorian calendar" << endl;
}

KCalendarSystemGregorian::~KCalendarSystemGregorian()
{
}

int KCalendarSystemGregorian::year(const QDate& date) const
{
  kdDebug(5400) << "Gregorian year..." << endl;
  return date.year();
}

int KCalendarSystemGregorian::monthsInYear( const QDate & date ) const
{
  (void)date;

  kdDebug(5400) << "Gregorian monthsInYear" << endl;

  return 12;
}

int KCalendarSystemGregorian::weeksInYear(int year) const
{
  QDate temp;
  temp.setYMD(year, 12, 31);



  if ( temp.weekNumber() == 1 )
    temp = temp.addDays(-7);

  return temp.weekNumber();
}

int KCalendarSystemGregorian::weekNumber(const QDate& date,
                                         int * yearNum) const
{
  return date.weekNumber(yearNum);
}

QString KCalendarSystemGregorian::monthName(const QDate& date,
                                            bool shortName) const
{
  return monthName(month(date), shortName);
}

QString KCalendarSystemGregorian::monthNamePossessive(const QDate& date, bool shortName) const
{
  return monthNamePossessive(month(date), shortName);
}

QString KCalendarSystemGregorian::monthName(int month, int year, bool shortName) const
{
  kdDebug(5400) << "Gregorian getMonthName" << endl;
  (void)year;;

  if ( shortName )
    switch ( month )
      {
      case 1:
        return locale()->translate("January", "Jan");
      case 2:
        return locale()->translate("February", "Feb");
      case 3:
        return locale()->translate("March", "Mar");
      case 4:
        return locale()->translate("April", "Apr");
      case 5:
        return locale()->translate("May short", "May");
      case 6:
        return locale()->translate("June", "Jun");
      case 7:
        return locale()->translate("July", "Jul");
      case 8:
        return locale()->translate("August", "Aug");
      case 9:
        return locale()->translate("September", "Sep");
      case 10:
        return locale()->translate("October", "Oct");
      case 11:
        return locale()->translate("November", "Nov");
      case 12:
        return locale()->translate("December", "Dec");
      }
  else
    switch ( month )
      {
      case 1:
        return locale()->translate("January");
      case 2:
        return locale()->translate("February");
      case 3:
        return locale()->translate("March");
      case 4:
        return locale()->translate("April");
      case 5:
        return locale()->translate("May long", "May");
      case 6:
        return locale()->translate("June");
      case 7:
        return locale()->translate("July");
      case 8:
        return locale()->translate("August");
      case 9:
        return locale()->translate("September");
      case 10:
        return locale()->translate("October");
      case 11:
        return locale()->translate("November");
      case 12:
        return locale()->translate("December");
      }

  return QString::null;
}

QString KCalendarSystemGregorian::monthNamePossessive(int month, int year,
                                                      bool shortName) const
{
  kdDebug(5400) << "Gregorian getMonthName" << endl;
  (void)year;;

  if ( shortName )
    switch ( month )
      {
      case 1:
        return locale()->translate("of January", "of Jan");
      case 2:
        return locale()->translate("of February", "of Feb");
      case 3:
        return locale()->translate("of March", "of Mar");
      case 4:
        return locale()->translate("of April", "of Apr");
      case 5:
        return locale()->translate("of May short", "of May");
      case 6:
        return locale()->translate("of June", "of Jun");
      case 7:
        return locale()->translate("of July", "of Jul");
      case 8:
        return locale()->translate("of August", "of Aug");
      case 9:
        return locale()->translate("of September", "of Sep");
      case 10:
        return locale()->translate("of October", "of Oct");
      case 11:
       return locale()->translate("of November", "of Nov");
      case 12:
        return locale()->translate("of December", "of Dec");
      }
  else
    switch ( month )
      {
      case 1:
        return locale()->translate("of January");
      case 2:
        return locale()->translate("of February");
      case 3:
        return locale()->translate("of March");
      case 4:
        return locale()->translate("of April");
      case 5:
        return locale()->translate("of May long", "of May");
      case 6:
        return locale()->translate("of June");
      case 7:
        return locale()->translate("of July");
      case 8:
        return locale()->translate("of August");
      case 9:
        return locale()->translate("of September");
      case 10:
        return locale()->translate("of October");
      case 11:
        return locale()->translate("of November");
      case 12:
        return locale()->translate("of December");
      }

  return QString::null;
}

bool KCalendarSystemGregorian::setYMD(QDate & date, int y, int m, int d) const
{

  if ( y >= 0 && y <= 99 )
    return false;


  return date.setYMD(y, m, d);
}

QDate KCalendarSystemGregorian::addYears(const QDate & date, int nyears) const
{
  return date.addYears(nyears);
}

QDate KCalendarSystemGregorian::addMonths(const QDate & date, int nmonths) const
{
  return date.addMonths(nmonths);
}

QDate KCalendarSystemGregorian::addDays(const QDate & date, int ndays) const
{
  return date.addDays(ndays);
}

QString KCalendarSystemGregorian::weekDayName(int col, bool shortName) const
{




  return locale()->weekDayName(col, shortName);
}

QString KCalendarSystemGregorian::weekDayName(const QDate& date, bool shortName) const
{
  return weekDayName(dayOfWeek(date), shortName);
}


int KCalendarSystemGregorian::dayOfWeek(const QDate& date) const
{
  return date.dayOfWeek();
}

int KCalendarSystemGregorian::dayOfYear(const QDate & date) const
{
  return date.dayOfYear();
}

int KCalendarSystemGregorian::daysInMonth(const QDate& date) const
{
  kdDebug(5400) << "Gregorian daysInMonth" << endl;
  return date.daysInMonth();
}

int KCalendarSystemGregorian::minValidYear() const
{
  return 1753;
}

int KCalendarSystemGregorian::maxValidYear() const
{
  return 8000;
}

int KCalendarSystemGregorian::day(const QDate& date) const
{
  return date.day();
}

int KCalendarSystemGregorian::month(const QDate& date) const
{
  return date.month();
}

int KCalendarSystemGregorian::daysInYear(const QDate& date) const
{
  return date.daysInYear();
}

int KCalendarSystemGregorian::weekDayOfPray() const
{
  return 7;
}

QString KCalendarSystemGregorian::calendarName() const
{
  return QString::fromLatin1("gregorian");
}

bool KCalendarSystemGregorian::isLunar() const
{
  return false;
}

bool KCalendarSystemGregorian::isLunisolar() const
{
  return false;
}

bool KCalendarSystemGregorian::isSolar() const
{
  return true;
}

QString KCalendarSystemGregorian::yearLiteral (int year) const
{
   return QString::number(year);
}

QString KCalendarSystemGregorian::yearLiteral (const QDate & date) const
{
   return QString::number(date.year());
}


int KCalendarSystemGregorian::yearStringToInteger(const QString & sNum, int & iLength) const
{
  int iYear;
  iYear = KCalendarSystem::yearStringToInteger(sNum, iLength);



  if (iYear < 69)
    iYear += 2000;
  else if (iYear < 100)
    iYear += 1900;

  return iYear;
}
# 90 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhijri.cpp" 1
# 29 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhijri.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhijri.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhijri.h"






class KCalendarSystemHijriPrivate;
# 45 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhijri.h"
class KCalendarSystemHijri : public KCalendarSystem
{
public:
  KCalendarSystemHijri(const KLocale * locale = 0);
  virtual ~KCalendarSystemHijri();

  virtual int year (const QDate & date) const;
  virtual int month (const QDate & date) const;
  virtual int day (const QDate & date) const;
  virtual int dayOfWeek (const QDate & date) const;
  virtual int dayOfYear (const QDate & date) const;

  virtual bool setYMD(QDate & date, int y, int m, int d) const;

  virtual QDate addYears(const QDate & date, int nyears) const;
  virtual QDate addMonths(const QDate & date, int nmonths) const;
  virtual QDate addDays(const QDate & date, int ndays) const;

  virtual int monthsInYear (const QDate & date) const;
  virtual int daysInYear (const QDate & date) const;
  virtual int daysInMonth (const QDate & date) const;
  virtual int weeksInYear(int year) const;
  virtual int weekNumber(const QDate& date, int * yearNum = 0) const;

  virtual QString yearLiteral (int year) const;
  virtual QString yearLiteral (const QDate & date) const;
  virtual QString monthName (int month, int year, bool shortName = false) const;
  virtual QString monthName (const QDate & date, bool shortName = false ) const;
  virtual QString monthNamePossessive(int month, int year, bool shortName = false) const;
  virtual QString monthNamePossessive(const QDate & date, bool shortName = false ) const;
  virtual QString weekDayName (int weekDay, bool shortName = false) const;
  virtual QString weekDayName (const QDate & date, bool shortName = false) const;

  virtual int minValidYear () const;
  virtual int maxValidYear () const;
  virtual int weekDayOfPray () const;

  virtual QString calendarName() const;

  virtual bool isLunar() const;
  virtual bool isLunisolar() const;
  virtual bool isSolar() const;

  private:







  int hndays(int month, int year) const;

  KCalendarSystemHijriPrivate * d;
};
# 30 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhijri.cpp" 2
# 43 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhijri.cpp"
static int lastDayOfGregorianMonth(int month, int year) {


  switch (month) {
  case 2:
    if ((((year % 4) == 0) && ((year % 100) != 0))
        || ((year % 400) == 0))
      return 29;
    else
      return 28;
  case 4:
  case 6:
  case 9:
  case 11: return 30;
  default: return 31;
  }
}

class GregorianDate {
private:
  int year;
  int month;
  int day;

public:
  GregorianDate(int m, int d, int y) { month = m; day = d; year = y; }

  GregorianDate(int d) {


    year = d/366;
    while (d >= GregorianDate(1,1,year+1))
      year++;

    month = 1;
    while (d > GregorianDate(month, lastDayOfGregorianMonth(month,year), year))
      month++;
    day = d - GregorianDate(month,1,year) + 1;
  }

  operator int() {
    int N = day;
    for (int m = month - 1; m > 0; m--)
      N = N + lastDayOfGregorianMonth(m, year);
    return
      (N
       + 365 * (year - 1)
       + (year - 1)/4
       - (year - 1)/100
       + (year - 1)/400);
  }

  int getMonth() { return month; }
  int getDay() { return day; }
  int getYear() { return year; }

};

static int IslamicLeapYear(int year) {


  if ((((11 * year) + 14) % 30) < 11)
    return 1;
  else
    return 0;
}

static const int IslamicEpoch = 227014;


static int lastDayOfIslamicMonth(int month, int year) {


  if (((month % 2) == 1) || ((month == 12) && IslamicLeapYear(year)))
    return 30;
  else
    return 29;
}

class IslamicDate {
private:
  int year;
  int month;
  int day;

public:
  IslamicDate(int m, int d, int y) { month = m; day = d; year = y; }

  IslamicDate(int d) {
    if (d <= IslamicEpoch) {
      month = 0;
      day = 0;
      year = 0;
    }
    else {

      year = (d - IslamicEpoch) / 355;
      while (d >= IslamicDate(1,1,year+1))
        year++;

      month = 1;
      while (d > IslamicDate(month, lastDayOfIslamicMonth(month,year), year))
        month++;
      day = d - IslamicDate(month,1,year) + 1;
    }
  }

  operator int() {
    return (day
            + 29 * (month - 1)
            + month/2
            + 354 * (year - 1)
            + (3 + (11 * year)) / 30
            + IslamicEpoch);
  }

  int getMonth() { return month; }
  int getDay() { return day; }
  int getYear() { return year; }

};

static void gregorianToHijri(const QDate & date, int * pYear, int * pMonth,
   int * pDay)
{
  GregorianDate gregorian(date.month(),date.day(),date.year());
  int absolute = gregorian;

  IslamicDate islamic(absolute);

  if (pYear)
    *pYear = islamic.getYear();
  if (pMonth)
    *pMonth = islamic.getMonth();
  if (pDay)
    *pDay = islamic.getDay();
}

KCalendarSystemHijri::KCalendarSystemHijri(const KLocale * locale)
  : KCalendarSystem(locale)
{
}

KCalendarSystemHijri::~KCalendarSystemHijri()
{
}

int KCalendarSystemHijri::year(const QDate& date) const
{
  int y;
  gregorianToHijri(date, &y, 0, 0);
  return y;
}

int KCalendarSystemHijri::month(const QDate& date) const
{
  int m;
  gregorianToHijri(date, 0, &m, 0);
  return m;
}

int KCalendarSystemHijri::day(const QDate& date) const
{
  int d;
  gregorianToHijri(date, 0, 0, &d);
  return d;
}

int KCalendarSystemHijri::monthsInYear( const QDate & date ) const
{
  (void)date;

  return 12;
}

int KCalendarSystemHijri::weeksInYear(int year) const
{
  QDate temp;
  setYMD(temp, year, 12, lastDayOfIslamicMonth(12, year));



  if ( weekNumber(temp) == 1 )
    temp = addDays(temp, -7);

  return weekNumber(temp);
}

int KCalendarSystemHijri::weekNumber(const QDate& date, int * yearNum) const
{
  QDate firstDayWeek1, lastDayOfYear;
  int y = year(date);
  int week;
  int weekDay1, dayOfWeek1InYear;


  setYMD(firstDayWeek1, y, 1, 1);
  weekDay1 = dayOfWeek(firstDayWeek1);



  if (weekDay1 > 4 )
    firstDayWeek1 = addDays(firstDayWeek1 , 7 - weekDay1 + 1);

  dayOfWeek1InYear = dayOfYear(firstDayWeek1);

  if ( dayOfYear(date) < dayOfWeek1InYear )
  {
    if ( yearNum )
      *yearNum = y - 1;
    return weeksInYear(y - 1);
  }


  setYMD(lastDayOfYear, y, 12, lastDayOfIslamicMonth(12, y));
  if ( (dayOfYear(date) >= daysInYear(date) - dayOfWeek(lastDayOfYear) + 1)

       && dayOfWeek(lastDayOfYear) < 4)
    {
      if ( yearNum )
        *yearNum = y + 1;
      week = 1;
    }
  else
  {
    if ( weekDay1 < 5 )
      firstDayWeek1 = addDays(firstDayWeek1, - (weekDay1 - 1));

    week = firstDayWeek1.daysTo(date) / 7 + 1;
  }

  return week;
}

QString KCalendarSystemHijri::monthName(const QDate& date,
                                        bool shortName) const
{
  return monthName(month(date), shortName);
}

QString KCalendarSystemHijri::monthNamePossessive(const QDate& date,
                                                  bool shortName) const
{
  return monthNamePossessive(month(date), shortName);
}

QString KCalendarSystemHijri::monthName(int month, int year, bool shortName)
  const {

  (void)year;;

  if (shortName)
    switch ( month )
      {
      case 1:
        return locale()->translate("Muharram");
      case 2:
        return locale()->translate("Safar");
      case 3:
        return locale()->translate("R. Awal");
      case 4:
        return locale()->translate("R. Thaani");
      case 5:
        return locale()->translate("J. Awal");
      case 6:
        return locale()->translate("J. Thaani");
      case 7:
        return locale()->translate("Rajab");
      case 8:
        return locale()->translate("Sha`ban");
      case 9:
        return locale()->translate("Ramadan");
      case 10:
        return locale()->translate("Shawwal");
      case 11:
        return locale()->translate("Qi`dah");
      case 12:
        return locale()->translate("Hijjah");
    }
  else
    switch ( month )
      {
      case 1:
        return locale()->translate("Muharram");
      case 2:
        return locale()->translate("Safar");
      case 3:
        return locale()->translate("Rabi` al-Awal");
      case 4:
        return locale()->translate("Rabi` al-Thaani");
      case 5:
        return locale()->translate("Jumaada al-Awal");
      case 6:
        return locale()->translate("Jumaada al-Thaani");
      case 7:
        return locale()->translate("Rajab");
      case 8:
        return locale()->translate("Sha`ban");
      case 9:
        return locale()->translate("Ramadan");
      case 10:
        return locale()->translate("Shawwal");
      case 11:
        return locale()->translate("Thu al-Qi`dah");
      case 12:
        return locale()->translate("Thu al-Hijjah");
      }

  return QString::null;
}

QString KCalendarSystemHijri::monthNamePossessive(int month, int year,
                                                  bool shortName) const
{
  (void)year;;

  if (shortName)
    switch ( month )
      {
      case 1:
        return locale()->translate("of Muharram");
      case 2:
        return locale()->translate("of Safar");
      case 3:
        return locale()->translate("of R. Awal");
      case 4:
        return locale()->translate("of R. Thaani");
      case 5:
        return locale()->translate("of J. Awal");
      case 6:
        return locale()->translate("of J. Thaani");
      case 7:
        return locale()->translate("of Rajab");
      case 8:
        return locale()->translate("of Sha`ban");
      case 9:
        return locale()->translate("of Ramadan");
      case 10:
        return locale()->translate("of Shawwal");
      case 11:
        return locale()->translate("of Qi`dah");
      case 12:
        return locale()->translate("of Hijjah");
    }
  else
    switch ( month )
      {
      case 1:
        return locale()->translate("of Muharram");
      case 2:
        return locale()->translate("of Safar");
      case 3:
        return locale()->translate("of Rabi` al-Awal");
      case 4:
        return locale()->translate("of Rabi` al-Thaani");
      case 5:
        return locale()->translate("of Jumaada al-Awal");
      case 6:
        return locale()->translate("of Jumaada al-Thaani");
      case 7:
        return locale()->translate("of Rajab");
      case 8:
        return locale()->translate("of Sha`ban");
      case 9:
        return locale()->translate("of Ramadan");
      case 10:
        return locale()->translate("of Shawwal");
      case 11:
        return locale()->translate("of Thu al-Qi`dah");
      case 12:
        return locale()->translate("of Thu al-Hijjah");
      }

  return QString::null;
}

bool KCalendarSystemHijri::setYMD(QDate & date, int y, int m, int d) const
{

  if ( y < minValidYear() || y > maxValidYear() )
    return false;

  if ( m < 1 || m > 12 )
    return false;

  if ( d < 1 || d > lastDayOfIslamicMonth(m, y) )
    return false;

  IslamicDate islamic (m, d, y);
  int absolute = islamic;
  GregorianDate gregorian(absolute);

  return date.setYMD(gregorian.getYear(), gregorian.getMonth(),
    gregorian.getDay());
}

QString KCalendarSystemHijri::weekDayName(int day, bool shortName) const
{
  if ( shortName )
    switch (day)
      {
      case 1:
        return locale()->translate("Ith");
      case 2:
        return locale()->translate("Thl");
      case 3:
        return locale()->translate("Arb");
      case 4:
        return locale()->translate("Kha");
      case 5:
        return locale()->translate("Jum");
      case 6:
        return locale()->translate("Sab");
      case 7:
        return locale()->translate("Ahd");
      }
  else
    switch ( day )
      {
      case 1:
        return locale()->translate("Yaum al-Ithnain");
      case 2:
        return locale()->translate("Yau al-Thulatha");
      case 3:
        return locale()->translate("Yaum al-Arbi'a");
      case 4:
        return locale()->translate("Yaum al-Khamees");
      case 5:
        return locale()->translate("Yaum al-Jumma");
      case 6:
        return locale()->translate("Yaum al-Sabt");
      case 7:
        return locale()->translate("Yaum al-Ahad");
      }

  return QString::null;
}

QString KCalendarSystemHijri::weekDayName(const QDate& date,
                                          bool shortName) const
{
  return weekDayName(dayOfWeek(date), shortName);
}

int KCalendarSystemHijri::dayOfWeek(const QDate& date) const
{
  return date.dayOfWeek();
}

int KCalendarSystemHijri::dayOfYear(const QDate & date) const
{
  QDate first;
  setYMD(first, year(date), 1, 1);

  return first.daysTo(date) + 1;

  return 100;
}

int KCalendarSystemHijri::daysInMonth(const QDate& date) const
{
  int y, m;
  gregorianToHijri(date, &y, &m, 0);

  return lastDayOfIslamicMonth(m, y);
}


int KCalendarSystemHijri::minValidYear() const
{
  QDate date(1753, 1, 1);

  return year(date);
}


int KCalendarSystemHijri::maxValidYear() const
{
  QDate date(8000, 1, 1);

  return year(date);
}

int KCalendarSystemHijri::daysInYear(const QDate & date) const
{
  QDate first, last;
  setYMD(first, year(date), 1, 1);
  setYMD(last, year(date) + 1, 1, 1);

  return first.daysTo(last);
}

int KCalendarSystemHijri::weekDayOfPray() const
{
  return 5;
}

QDate KCalendarSystemHijri::addDays( const QDate & date, int ndays ) const
{
  return date.addDays( ndays );
}

QDate KCalendarSystemHijri::addMonths( const QDate & date, int nmonths ) const
{
  QDate result = date;
  int m = month(date);
  int y = year(date);

  if ( nmonths < 0 )
  {
    m += 12;
    y -= 1;
  }

  --m;
  m += nmonths;
  y += m / 12;
  m %= 12;
  ++m;

  setYMD( result, y, m, day(date) );

  return result;
}

QDate KCalendarSystemHijri::addYears( const QDate & date, int nyears ) const
{
  QDate result = date;
  int y = year(date) + nyears;

  setYMD( result, y, month(date), day(date) );

  return result;
}

QString KCalendarSystemHijri::calendarName() const
{
  return QString::fromLatin1("hijri");
}

bool KCalendarSystemHijri::isLunar() const
{
  return true;
}

bool KCalendarSystemHijri::isLunisolar() const
{
  return false;
}

bool KCalendarSystemHijri::isSolar() const
{
  return false;
}

QString KCalendarSystemHijri::yearLiteral (int year) const
{
   return QString::number(year);
}

QString KCalendarSystemHijri::yearLiteral (const QDate & date) const
{
   return yearLiteral(year(date));
}
# 91 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhebrew.cpp" 1
# 25 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhebrew.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhebrew.h" 1
# 22 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhebrew.h"






class KCalendarSystemHebrewPrivate;
# 44 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhebrew.h"
class KCalendarSystemHebrew : public KCalendarSystem
{
public:
  KCalendarSystemHebrew(const KLocale * locale = 0);
  virtual ~KCalendarSystemHebrew();

  virtual int year (const QDate & date) const;
  virtual int month (const QDate & date) const;
  virtual int day (const QDate & date) const;
  virtual int dayOfWeek (const QDate & date) const;
  virtual int dayOfYear (const QDate & date) const;

  virtual bool setYMD(QDate & date, int y, int m, int d) const;

  virtual QDate addYears(const QDate & date, int nyears) const;
  virtual QDate addMonths(const QDate & date, int nmonths) const;
  virtual QDate addDays(const QDate & date, int ndays) const;

  virtual int monthsInYear (const QDate & date) const;
  virtual int daysInYear (const QDate & date) const;
  virtual int daysInMonth (const QDate & date) const;
  virtual int weeksInYear(int year) const;
  virtual int weekNumber(const QDate& date, int * yearNum = 0) const;

  virtual QString yearLiteral (int year) const;
  virtual QString yearLiteral (const QDate & date) const;
  virtual QString monthName (int month, int year, bool shortName = false) const;
  virtual QString monthName (const QDate & date, bool shortName = false ) const;
  virtual QString monthNamePossessive(int month, int year, bool shortName = false) const;
  virtual QString monthNamePossessive(const QDate & date, bool shortName = false ) const;
  virtual QString weekDayName (int weekDay, bool shortName = false) const;
  virtual QString weekDayName (const QDate & date, bool shortName = false) const;

  virtual QString dayString(const QDate & pDate, bool bShort) const;
  virtual QString yearString(const QDate & pDate, bool bShort) const;
  virtual int dayStringToInteger(const QString & sNum, int & iLength) const;
  virtual int yearStringToInteger(const QString & sNum, int & iLength) const;

  virtual int minValidYear () const;
  virtual int maxValidYear () const;
  virtual int weekDayOfPray () const;

  virtual QString calendarName() const;

  virtual bool isLunar() const;
  virtual bool isLunisolar() const;
  virtual bool isSolar() const;

private:







  int hndays(int year, int mon) const;

  KCalendarSystemHebrewPrivate * d;
};
# 26 "/coolo/prod/kdelibs/kdecore/kcalendarsystemhebrew.cpp" 2

static int hebrewDaysInYear(int y);
static QString num2heb(int num, bool includeMillenium);

class h_date
{
public:
  int hd_day;
  int hd_mon;
  int hd_year;
  int hd_dw;
  int hd_flg;
};




static class h_date * hebrewToGregorian(int y, int m, int d)
{
  static class h_date h;
  int s;

  y -= 3744;
  s = hebrewDaysInYear(y);
  d += s;
  s = hebrewDaysInYear(y + 1) - s;

  if (s > 365 && m > 6 )
  {
    --m;
    d += 30;
  }
  d += (59 * (m - 1) + 1) / 2;

  if (s % 10 > 4 && m > 2)
    d++;
  if (s % 10 < 4 && m > 3)
    d--;



  d -= 6002;

  y = (d + 36525) * 4 / 146097 - 1;
  d -= y / 4 * 146097 + (y % 4) * 36524;
  y *= 100;


  s = (d + 366)*4/1461-1;
  d -= s/4*1461 + (s % 4)*365;
  y += s;

  m = (d + 245)*12/367-7;
  d -= m*367/12-30;
  if (++m >= 12) {
    m -= 12;
    y++;
  }
  h.hd_day = d;
  h.hd_mon = m;
  h.hd_year = y;
  return(&h);
}




static class h_date * gregorianToHebrew(int y, int m, int d)
{
  static class h_date h;
  int s;

  if ((m -= 2) <= 0) {
    m += 12;
    y--;
  }

  d += 365*y + y/4 + 367*m/12 + 5968;

  d -= y/100-y/400-2;
  h.hd_dw = (d + 1) % 7;


  y += 16;
  s = hebrewDaysInYear(y);
  m = hebrewDaysInYear(y + 1);
  while(d >= m) {
    s = m;
    y++;
    m = hebrewDaysInYear(y + 1);
  }
  d -= s;
  s = m-s;
  y += 3744;

  h.hd_flg = s % 10-4;


  if (d >= s-236) {
    d -= s-236;
    m = d*2/59;
    d -= (m*59 + 1)/2;
    m += 4;
    if (s > 365 && m <= 5)
      m += 8;
  } else {

    s = 114 + s % 10;
    m = d * 4 / s;
    d -= (m * s + 3) / 4;
  }

  h.hd_day = d;
  h.hd_mon = m;
  h.hd_year = y;
  return(&h);
}

static QString num2heb(int num, bool includeMillenium)
{
  const QChar decade[] = {0x05D8, 0x05D9, 0x05DB, 0x05DC, 0x05DE,
                          0x05E0, 0x05E1, 0x05E2, 0x05E4, 0x05E6};
  QString result;

  if (num < 1 || num > 9999)
    return QString::number(num);

  if (num >= 1000) {
    if (includeMillenium || num % 1000 == 0)
      result += QChar(0x05D0 - 1 + num / 1000);
    num %= 1000;
  }
  if (num >= 100) {
    while (num >= 500) {
      result += QChar(0x05EA);
      num -= 400;
    }
    result += QChar(0x05E7 - 1 + num / 100);
    num %= 100;
  }
  if (num >= 10) {
    if (num == 15 || num == 16)
      num -= 9;
    result += decade[num / 10];
    num %= 10;
  }
  if (num > 0)
    result += QChar(0x05D0 - 1 + num);

  if (result.length() == 1)
    result += "'";
  else
    result.insert(result.length() - 1, '\"');

  return result;
}


static const int HOUR = 1080;
static const int DAY = 24*HOUR;
static const int WEEK = 7*DAY;





static int hebrewDaysInYear(int y)
{
  int m, nm, dw, s, l;

  l = y * 7 + 1;
  m = y*12+l/19;
  l %= 19;
  nm = m*(DAY+((12)*HOUR+793))+((1+6)*HOUR+779);
  s = m*28+nm/DAY-2;

  nm %= WEEK;
  dw = nm/DAY;
  nm %= DAY;


  if (l < 12 && dw == 3 && nm >= ((9 + 6)*HOUR+204) ||
   l < 7 && dw == 2 && nm>=((15+6)*HOUR+589))
    s++,dw++;

  if (dw == 1 || dw == 4 || dw == 6)
    s++;
  return s;
}





static int long_cheshvan(int year)
{
  return ((hebrewDaysInYear(year) % 10) == 5);
}





static int short_kislev(int year)
{
  return ((hebrewDaysInYear(year) % 10) == 3);
}

static bool is_leap_year(int year)
{
  return ((((7 * year) + 1) % 19) < 7);
}


KCalendarSystemHebrew::KCalendarSystemHebrew(const KLocale * locale)
  : KCalendarSystem(locale)
{
}


KCalendarSystemHebrew::~KCalendarSystemHebrew()
{
}


static class h_date * toHebrew(const QDate & date)
{
  class h_date *sd;
  sd = gregorianToHebrew(date.year(), date.month(), date.day());
  ++sd->hd_mon;
  ++sd->hd_day;
  return sd;
}


int KCalendarSystemHebrew::year(const QDate& date) const
{
  class h_date *sd = toHebrew(date);
  return sd->hd_year;
}


int KCalendarSystemHebrew::monthsInYear( const QDate & date ) const
{
  if ( is_leap_year( year(date) ) )
    return 13;
  else
    return 12;
}


int KCalendarSystemHebrew::weeksInYear(int year) const
{
  QDate temp;
  setYMD(temp, year, monthsInYear(temp), hndays(monthsInYear(temp), year) );

  int nWeekNumber = weekNumber(temp);
  if(nWeekNumber == 1)
  {
    temp = temp.addDays(-7);
    nWeekNumber = weekNumber(temp);
  }

  return nWeekNumber;
}

int KCalendarSystemHebrew::weekNumber(const QDate& date, int * yearNum) const
{
  QDate firstDayWeek1, lastDayOfYear;
  int y = year(date);
  int week;
  int weekDay1, dayOfWeek1InYear;


  setYMD(firstDayWeek1, y, 1, 1);
  weekDay1 = dayOfWeek(firstDayWeek1);



  if (weekDay1 > 4 )
    firstDayWeek1 = addDays(firstDayWeek1 , 7 - weekDay1 + 1);

  dayOfWeek1InYear = dayOfYear(firstDayWeek1);

  if ( dayOfYear(date) < dayOfWeek1InYear )
  {
    if ( yearNum )
      *yearNum = y - 1;
    return weeksInYear(y - 1);
  }


  setYMD(lastDayOfYear, y + 1, 1, 1);
  lastDayOfYear = addDays(lastDayOfYear, -1);
  if ( (dayOfYear(date) >= daysInYear(date) - dayOfWeek(lastDayOfYear) + 1)

       && dayOfWeek(lastDayOfYear) < 4)
    {
      if ( yearNum )
        *yearNum = y + 1;
      week = 1;
    }
  else
  {
   if( weekDay1 < 5 )

      firstDayWeek1 = addDays( firstDayWeek1, -( weekDay1 - 1));

   week = firstDayWeek1.daysTo(date) / 7 + 1;
  }

  return week;
}


QString KCalendarSystemHebrew::monthName(const QDate& date,
                                        bool shortName) const
{
  return monthName(month(date), year(date), shortName);
}


QString KCalendarSystemHebrew::monthNamePossessive(const QDate& date,
                                                  bool shortName) const
{
  return monthNamePossessive(month(date), year(date), shortName);
}


QString KCalendarSystemHebrew::monthName(int month, int year, bool ) const
{
  if ( month < 1 )
    return QString::null;
  if ( is_leap_year(year) )
  {
    if ( month > 13 )
      return QString::null;
  }
  else if ( month > 12 )
      return QString::null;


  if( month == 6 && is_leap_year(year) )
    month = 13;
  else if ( month == 7 && is_leap_year(year) )
    month = 14;
  else if ( month > 7 && is_leap_year(year) )
    month--;

  switch(month)
  {
  case 1:
    return locale()->translate("Tishrey");
  case 2:
    return locale()->translate("Heshvan");
  case 3:
    return locale()->translate("Kislev");
  case 4:
    return locale()->translate("Tevet");
  case 5:
    return locale()->translate("Shvat");
  case 6:
    return locale()->translate("Adar");
  case 7:
    return locale()->translate("Nisan");
  case 8:
    return locale()->translate("Iyar");
  case 9:
    return locale()->translate("Sivan");
  case 10:
    return locale()->translate("Tamuz");
  case 11:
    return locale()->translate("Av");
  case 12:
    return locale()->translate("Elul");
  case 13:
    return locale()->translate("Adar I");
  case 14:
    return locale()->translate("Adar II");
  default:
    break;
  }

  return QString::null;
}


QString KCalendarSystemHebrew::monthNamePossessive(int month, int year,
                                                  bool shortName) const
{
  return "of " + monthName(month, year, shortName);
}

bool KCalendarSystemHebrew::setYMD(QDate & date, int y, int m, int d) const
{

  class h_date * gd = hebrewToGregorian( y, m, d );

  if( y < minValidYear() || y > maxValidYear() )
    return false;
  if( m < 1 || m > (is_leap_year(y) ? 13 : 12) )
    return false;
  if( d < 1 || d > hndays(m,y) )
    return false;

  return date.setYMD(gd->hd_year, gd->hd_mon + 1, gd->hd_day + 1);
}

QString KCalendarSystemHebrew::weekDayName(int day, bool shortName) const
{
  if ( day == 6 )
  {
    if (shortName)
      return locale()->translate("Hebrew Calendar WeekDay 6 Short", "Sab");
    else
      return locale()->translate("Hebrew Calendar WeekDay 6 Long", "Sabbath");
  }

  return locale()->weekDayName(day, shortName);
}


QString KCalendarSystemHebrew::weekDayName(const QDate& date,
                                          bool shortName) const
{
  return weekDayName(dayOfWeek(date), shortName);
}


int KCalendarSystemHebrew::dayOfWeek(const QDate& date) const
{
  class h_date *sd = toHebrew(date);
  if ( sd->hd_dw == 0 )
    return 7;
  else
    return (sd->hd_dw);
}


int KCalendarSystemHebrew::dayOfYear(const QDate & date) const
{
  QDate first;
  setYMD(first, year(date), 1, 1);

  return first.daysTo(date) + 1;
}

int KCalendarSystemHebrew::daysInMonth(const QDate& date) const
{
  class h_date *sd = toHebrew(date);
  return hndays(sd->hd_mon, sd->hd_year);
}


int KCalendarSystemHebrew::hndays(int mon, int year) const
{
  if ( is_leap_year(year) )
    if ( mon == 6 )
      mon = 13;
    else if ( mon == 7 )
      mon = 14;
    else
      --mon;

  if( mon == 8 || mon == 10 ||
    mon == 12 || mon == 4 ||
    mon == 14 ||
    ( mon == 13 && !is_leap_year(year)) ||
    (mon == 2 && !long_cheshvan(year)) ||
    (mon == 3 && short_kislev(year)))
    return 29;
  else
    return 30;
}



int KCalendarSystemHebrew::minValidYear() const
{
  QDate date(1753, 1, 1);

  return year(date);
}



int KCalendarSystemHebrew::maxValidYear() const
{
  QDate date(8000, 1, 1);

  return year(date);
}


int KCalendarSystemHebrew::day(const QDate& date) const
{
  class h_date *sd = toHebrew(date);

  return sd->hd_day;
}


int KCalendarSystemHebrew::month(const QDate& date) const
{
  class h_date *sd = toHebrew(date);

  int month = sd->hd_mon;
  if ( is_leap_year( sd->hd_year ) )
  {
    if( month == 13 )
       month = 6;
    else if( month == 14 )
       month = 7;
    else if ( month > 6 && month < 13 )
      ++month;
  }

  return month;
}


int KCalendarSystemHebrew::daysInYear(const QDate & date) const
{
  QDate first, last;
  setYMD(first, year(date), 1, 1);
  setYMD(last, year(date) + 1, 1, 1);

  return first.daysTo(last);
}


int KCalendarSystemHebrew::weekDayOfPray() const
{
  return 6;
}


QDate KCalendarSystemHebrew::addDays( const QDate & date, int ndays ) const
{
  return date.addDays( ndays );
}


QDate KCalendarSystemHebrew::addMonths( const QDate & date, int nmonths ) const
{
  QDate result = date;

  while ( nmonths > 0 )
  {
    result = addDays(result, daysInMonth(result));
    --nmonths;
  }

  while ( nmonths < 0 )
  {


    int nDaysInMonth = daysInMonth(addDays(result, -day(result)));
    result = addDays(result, -nDaysInMonth);
    ++nmonths;
  }

  return result;
}


QDate KCalendarSystemHebrew::addYears( const QDate & date, int nyears ) const
{
  QDate result = date;
  int y = year(date) + nyears;

  setYMD( result, y, month(date), day(date) );

  return result;
}


QString KCalendarSystemHebrew::calendarName() const
{
  return QString::fromLatin1("hebrew");
}


bool KCalendarSystemHebrew::isLunar() const
{
  return false;
}


bool KCalendarSystemHebrew::isLunisolar() const
{
  return true;
}


bool KCalendarSystemHebrew::isSolar() const
{
  return false;
}

QString KCalendarSystemHebrew::yearLiteral (int year) const
{
   return QString::number(year);
}
QString KCalendarSystemHebrew::yearLiteral (const QDate & date) const
{
   return yearLiteral(year(date));
}

QString KCalendarSystemHebrew::dayString(const QDate & pDate, bool bShort) const
{
  QString sResult;


  if (locale()->language() == QString::fromLatin1("he"))
    sResult = num2heb(day(pDate), false);
  else
    sResult = KCalendarSystem::dayString(pDate, bShort);

  return sResult;
}

QString KCalendarSystemHebrew::yearString(const QDate & pDate, bool bShort) const
{
  QString sResult;


  if (locale()->language() == QString::fromLatin1("he"))
    sResult = num2heb(year(pDate), !bShort);
  else
    sResult = KCalendarSystem::yearString(pDate, bShort);

  return sResult;
}

static int heb2num(const QString& str, int & iLength) {
  QChar c;
  QString s = str;
  int result = 0;
  s.remove("\'");
  s.remove("\"");

  uint i;
  for (i = 0 ; i < s.length() ; i++)
  {
    c = s[i];
    if (c == QChar(0x05D0) || c == QChar(0x05D1) || c == QChar(0x05D2) ||
        c == QChar(0x05D3) || c == QChar(0x05D4) || c == QChar(0x05D5) ||
        c == QChar(0x05D6) || c == QChar(0x05D7))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D0) && s[i + 1] <= QChar(0x05EA))
        result += (c.unicode() - 0x05D0 + 1) * 1000;
      else
        result += c.unicode() - 0x05D0 + 1;
    }
    else if (c == QChar(0x05D8))
    {
      if (s.length() > i && s[i + 1] == QChar(0x05D5))
        result += 15;
      else if (s.length() > i && s[i + 1] == QChar(0x05D6))
        result += 16;
      else if (s.length() > i && s[i + 1] >= QChar(0x05D0) && s[i + 1] <= QChar(0x05EA))
        result += 9000;
      else
        result += 9;
    }
    else if (c == QChar(0x05D9))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 10;
    }
    else if (c == QChar(0x05DA) || c == QChar(0x05DB))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 20;
    }
    else if (c == QChar(0x05DC))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 30;
    }
    else if (c == QChar(0x05DD) || c == QChar(0x05DE))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 40;
    }
    else if (c == QChar(0x05DF) || c == QChar(0x05E0))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 50;
    }
    else if (c == QChar(0x05E1))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 60;
    }
    else if (c == QChar(0x05E2))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 70;
    }
    else if (c == QChar(0x05E3) || c == QChar(0x05E4))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 80;
    }
    else if (c == QChar(0x05E5) || c == QChar(0x05E6))
    {
      if (s.length() > i && s[i + 1] >= QChar(0x05D9))
        return -1;
      else
        result += 90;
    }
    else if (c == QChar(0x05E7) || c == QChar(0x05E8) ||
             c == QChar(0x05E9) || c == QChar(0x05EA))
   {
        result += (c.unicode() - 0x05E7 + 1) * 100;
   }
   else
   {
     break;
   }
  }

  iLength = i;

  return result;
}

int KCalendarSystemHebrew::dayStringToInteger(const QString & sNum, int & iLength) const
{
  int iResult;
  if (locale()->language() == "he")
    iResult= heb2num(sNum, iLength);
  else
    iResult = KCalendarSystem::yearStringToInteger(sNum, iLength);

  kdDebug() << "KCalendarSystemHebrew::dayStringToInteger: Not implemnted" << endl;

  return iResult;
}

int KCalendarSystemHebrew::yearStringToInteger(const QString & sNum, int & iLength) const
{
  int iResult;
  if (locale()->language() == "he")
    iResult = heb2num(sNum, iLength);
  else
    iResult = KCalendarSystem::yearStringToInteger(sNum, iLength);

  if (iResult < 1000)
    iResult += 5000;

  kdDebug() << "KCalendarSystemHebrew::yearStringToInteger: Not implemnted" << endl;

  return iResult;
}
# 92 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemfactory.cpp" 1
# 32 "/coolo/prod/kdelibs/kdecore/kcalendarsystemfactory.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemjalali.h" 1

# 32 "/coolo/prod/kdelibs/kdecore/kcalendarsystemjalali.h"
class KCalendarSystemJalaliPrivate;



class KCalendarSystemJalali : public KCalendarSystem
{
public:
  KCalendarSystemJalali(const KLocale * locale = 0);
  virtual ~KCalendarSystemJalali();



  virtual int year (const QDate & date) const;
  virtual int month (const QDate & date) const;
  virtual int day (const QDate & date) const;
  virtual int dayOfWeek (const QDate & date) const;
  virtual int dayOfYear (const QDate & date) const;

  virtual bool setYMD(QDate & date, int y, int m, int d) const;

  virtual QDate addYears(const QDate & date, int nyears) const;
  virtual QDate addMonths(const QDate & date, int nmonths) const;
  virtual QDate addDays(const QDate & date, int ndays) const;

  virtual int monthsInYear (const QDate & date) const;

  virtual int daysInYear (const QDate & date) const;
  virtual int daysInMonth (const QDate & date) const;
  virtual int weeksInYear(int year) const;
  virtual int weekNumber(const QDate& date, int * yearNum = 0) const;

  virtual QString monthName (const QDate & date, bool shortName = false ) const;
  virtual QString monthNamePossessive(const QDate & date, bool shortName = false ) const;
  virtual QString weekDayName (int weekDay, bool shortName = false) const;
  virtual QString weekDayName (const QDate & date, bool shortName = false) const;
  virtual QString yearLiteral(int anInt) const;
  virtual QString yearLiteral(const QDate &) const;
  virtual QString monthNamePossessive(int m, int y, bool = false) const;
  virtual QString monthName(int, int, bool = false) const;
  virtual int minValidYear () const;
  virtual int maxValidYear () const;
  virtual int weekDayOfPray () const;

  virtual QString calendarName() const;

  virtual bool isLunar() const;
  virtual bool isLunisolar() const;
  virtual bool isSolar() const;

};
# 33 "/coolo/prod/kdelibs/kdecore/kcalendarsystemfactory.cpp" 2

KCalendarSystemFactory::KCalendarSystemFactory()
{
  kdDebug(5400) << "Created factory calendar" << endl;
}

KCalendarSystemFactory::~KCalendarSystemFactory()
{
}

KCalendarSystem *KCalendarSystemFactory::create( const QString &calType,
                                                 const KLocale * locale )
{
  if ( calType == "hebrew" )
    return new KCalendarSystemHebrew(locale);
  if ( calType == "hijri" )
    return new KCalendarSystemHijri(locale);
  if ( calType == "gregorian" )
    return new KCalendarSystemGregorian(locale);
  if ( calType == "jalali" )
    return new KCalendarSystemJalali(locale);

  kdDebug(5400) << "Calendar " << calType << " not found, defaulting to gregorian" << endl;


  return new KCalendarSystemGregorian(locale);
}

QStringList KCalendarSystemFactory::calendarSystems()
{
   QStringList lst;
   lst.append("hebrew");
   lst.append("hijri");
   lst.append("gregorian");
   lst.append("jalali");

   return lst;
}
# 93 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kmacroexpander.cpp" 1
# 25 "/coolo/prod/kdelibs/kdecore/kmacroexpander.cpp"
# 1 "/coolo/prod/qt-copy/include/qvaluestack.h" 1
# 39 "/coolo/prod/qt-copy/include/qvaluestack.h"






template<class T>
class QValueStack : public QValueList<T>
{
public:
    QValueStack() {}
   ~QValueStack() {}
    void push( const T& d ) { this->append(d); }
    T pop()
    {
        T elem( this->last() );
        if ( !this->isEmpty() )
            this->remove( this->fromLast() );
        return elem;
    }
    T& top() { return this->last(); }
    const T& top() const { return this->last(); }
};
# 26 "/coolo/prod/kdelibs/kdecore/kmacroexpander.cpp" 2


KMacroExpanderBase::KMacroExpanderBase( QChar c )
{
    escapechar = c;
}

KMacroExpanderBase::~KMacroExpanderBase()
{
}

void
KMacroExpanderBase::setEscapeChar( QChar c )
{
    escapechar = c;
}

QChar
KMacroExpanderBase::escapeChar() const
{
    return escapechar;
}

void KMacroExpanderBase::expandMacros( QString &str )
{
    uint pos;
    int len;
    QChar ec( escapechar );
    QStringList rst;
    QString rsts;

    for (pos = 0; pos < str.length(); ) {
        if (ec != (char)0) {
            if (str.unicode()[pos] != ec)
                goto nohit;
            if (!(len = expandEscapedMacro( str, pos, rst )))
                goto nohit;
        } else {
            if (!(len = expandPlainMacro( str, pos, rst )))
                goto nohit;
        }
            if (len < 0) {
                pos -= len;
                continue;
            }
            rsts = rst.join( " " );
            rst.clear();
            str.replace( pos, len, rsts );
            pos += rsts.length();
            continue;
      nohit:
        pos++;
    }
}


namespace KMacroExpander {

    enum Quoting { noquote, singlequote, doublequote, dollarquote,
                   paren, subst, group, math };
    typedef struct {
        Quoting current;
        bool dquote;
    } State;
    typedef struct {
        QString str;
        uint pos;
    } Save;

}

using namespace KMacroExpander;

bool KMacroExpanderBase::expandMacrosShellQuote( QString &str, uint &pos )
{
    int len;
    uint pos2;
    QChar ec( escapechar );
    State state = { noquote, false };
    QValueStack<State> sstack;
    QValueStack<Save> ostack;
    QStringList rst;
    QString rsts;

    while (pos < str.length()) {
        QChar cc( str.unicode()[pos] );
        if (ec != (char)0) {
            if (cc != ec)
                goto nohit;
            if (!(len = expandEscapedMacro( str, pos, rst )))
                goto nohit;
        } else {
            if (!(len = expandPlainMacro( str, pos, rst )))
                goto nohit;
        }
            if (len < 0) {
                pos -= len;
                continue;
            }
            if (state.dquote) {
                rsts = rst.join( " " );
                rsts.replace( QRegExp("([$`\"\\\\])"), "\\\\1" );
            } else if (state.current == dollarquote) {
                rsts = rst.join( " " );
                rsts.replace( QRegExp("(['\\\\])"), "\\\\1" );
            } else if (state.current == singlequote) {
                rsts = rst.join( " " );
                rsts.replace( '\'', "'\\''");
            } else {
                if (rst.isEmpty()) {
                    str.remove( pos, len );
                    continue;
                } else {
                    rsts = "'";





                    for (QStringList::ConstIterator it = rst.begin(); it != rst.end(); ++it) {
                        if (it != rst.begin())
                            rsts += "' '";
                        QString trsts( *it );
                        trsts.replace( '\'', "'\\''" );
                        rsts += trsts;
                    }

                    rsts += "'";
                }
            }
            rst.clear();
            str.replace( pos, len, rsts );
            pos += rsts.length();
            continue;
      nohit:
        if (state.current == singlequote) {
            if (cc == '\'')
                state = sstack.pop();
        } else if (cc == '\\') {

            pos += 2;
            continue;
        } else if (state.current == dollarquote) {
            if (cc == '\'')
                state = sstack.pop();
        } else if (cc == '$') {
            cc = str[++pos];
            if (cc == '(') {
                sstack.push( state );
                if (str[pos + 1] == '(') {
                    Save sav = { str, pos + 2 };
                    ostack.push( sav );
                    state.current = math;
                    pos += 2;
                    continue;
                } else {
                    state.current = paren;
                    state.dquote = false;
                }
            } else if (cc == '{') {
                sstack.push( state );
                state.current = subst;
            } else if (!state.dquote) {
                if (cc == '\'') {
                    sstack.push( state );
                    state.current = dollarquote;
                } else if (cc == '"') {
                    sstack.push( state );
                    state.current = doublequote;
                    state.dquote = true;
                }
            }

        } else if (cc == '`') {
            str.replace( pos, 1, "$( " );
            pos2 = pos += 3;
            for (;;) {
                if (pos2 >= str.length()) {
                    pos = pos2;
                    return false;
                }
                cc = str.unicode()[pos2];
                if (cc == '`')
                    break;
                if (cc == '\\') {
                    cc = str[++pos2];
                    if (cc == '$' || cc == '`' || cc == '\\' ||
                        (cc == '"' && state.dquote))
                    {
                        str.remove( pos2 - 1, 1 );
                        continue;
                    }
                }
                pos2++;
            }
            str[pos2] = ')';
            sstack.push( state );
            state.current = paren;
            state.dquote = false;
            continue;
        } else if (state.current == doublequote) {
            if (cc == '"')
                state = sstack.pop();
        } else if (cc == '\'') {
            if (!state.dquote) {
                sstack.push( state );
                state.current = singlequote;
            }
        } else if (cc == '"') {
            if (!state.dquote) {
                sstack.push( state );
                state.current = doublequote;
                state.dquote = true;
            }
        } else if (state.current == subst) {
            if (cc == '}')
                state = sstack.pop();
        } else if (cc == ')') {
            if (state.current == math) {
                if (str[pos + 1] == ')') {
                    state = sstack.pop();
                    pos += 2;
                } else {


                    pos = ostack.top().pos;
                    str = ostack.top().str;
                    ostack.pop();
                    state.current = paren;
                    state.dquote = false;
                    sstack.push( state );
                }
                continue;
            } else if (state.current == paren)
                state = sstack.pop();
            else
                break;
        } else if (cc == '}') {
            if (state.current == KMacroExpander::group)
                state = sstack.pop();
            else
                break;
        } else if (cc == '(') {
            sstack.push( state );
            state.current = paren;
        } else if (cc == '{') {
            sstack.push( state );
            state.current = KMacroExpander::group;
        }
        pos++;
    }
    return sstack.empty();
}

bool KMacroExpanderBase::expandMacrosShellQuote( QString &str )
{
  uint pos = 0;
  return expandMacrosShellQuote( str, pos ) && pos == str.length();
}

int KMacroExpanderBase::expandPlainMacro( const QString &, uint, QStringList & )
{ qFatal( "KMacroExpanderBase::expandPlainMacro called!" ); return 0; }

int KMacroExpanderBase::expandEscapedMacro( const QString &, uint, QStringList & )
{ qFatal( "KMacroExpanderBase::expandEscapedMacro called!" ); return 0; }




template<class KT,class VT>
class KMacroMapExpander : public KMacroExpanderBase {

public:
    KMacroMapExpander( const QMap<KT,VT> &map, QChar c = '%' ) :
        KMacroExpanderBase( c ), macromap( map ) {}

protected:
    virtual int expandPlainMacro( const QString &str, uint pos, QStringList &ret );
    virtual int expandEscapedMacro( const QString &str, uint pos, QStringList &ret );

private:
    QMap<KT,VT> macromap;
};

static QStringList &operator+=( QStringList &s, const QString &n) { s << n; return s; }



template<class VT>
class KMacroMapExpander<QChar,VT> : public KMacroExpanderBase {

public:
    KMacroMapExpander( const QMap<QChar,VT> &map, QChar c = '%' ) :
        KMacroExpanderBase( c ), macromap( map ) {}

protected:
    virtual int expandPlainMacro( const QString &str, uint pos, QStringList &ret );
    virtual int expandEscapedMacro( const QString &str, uint pos, QStringList &ret );

private:
    QMap<QChar,VT> macromap;
};

template<class VT>
int
KMacroMapExpander<QChar,VT>::expandPlainMacro( const QString &str, uint pos, QStringList &ret )
{
    QMapConstIterator<QChar,VT> it = macromap.find(str[pos]);
    if (it != macromap.end()) {
       ret += it.data();
       return 1;
    }
    return 0;
}

template<class VT>
int
KMacroMapExpander<QChar,VT>::expandEscapedMacro( const QString &str, uint pos, QStringList &ret )
{
    if (str[pos + 1] == escapeChar()) {
        ret += QString( escapeChar() );
        return 2;
    }

    QMapConstIterator<QChar,VT> it = macromap.find(str[pos+1]);
    if (it != macromap.end()) {
       ret += it.data();
       return 2;
    }
    return false;
}

template<class VT>
class KMacroMapExpander<QString,VT> : public KMacroExpanderBase {

public:
    KMacroMapExpander( const QMap<QString,VT> &map, QChar c = '%' ) :
        KMacroExpanderBase( c ), macromap( map ) {}

protected:
    virtual int expandPlainMacro( const QString &str, uint pos, QStringList &ret );
    virtual int expandEscapedMacro( const QString &str, uint pos, QStringList &ret );

private:
    bool isIdentifier(uint c) { return c == '_' || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'); }
    QMap<QString,VT> macromap;
};

template<class VT>
int
KMacroMapExpander<QString,VT>::expandPlainMacro( const QString &str, uint pos, QStringList &ret )
{
    if (isIdentifier( str[pos - 1].unicode() ))
        return 0;
    uint sl;
    for (sl = 0; isIdentifier( str[pos + sl].unicode() ); sl++);
    if (!sl)
        return 0;
    QMapConstIterator<QString,VT> it =
        macromap.find( QConstString( str.unicode() + pos, sl ).string() );
    if (it != macromap.end()) {
        ret += it.data();
        return sl;
    }
    return false;
}

template<class VT>
int
KMacroMapExpander<QString,VT>::expandEscapedMacro( const QString &str, uint pos, QStringList &ret )
{
    if (str[pos + 1] == escapeChar()) {
        ret += QString( escapeChar() );
        return 2;
    }
    uint sl, rsl, rpos;
    if (str[pos + 1] == '{') {
        rpos = pos + 2;
        for (sl = 0; str[rpos + sl] != '}'; sl++);
        rsl = sl + 3;
    } else {
        rpos = pos + 1;
        for (sl = 0; isIdentifier( str[rpos + sl].unicode() ); sl++);
        rsl = sl + 1;
    }
    if (!sl)
        return 0;
    QMapConstIterator<QString,VT> it =
        macromap.find( QConstString( str.unicode() + rpos, sl ).string() );
    if (it != macromap.end()) {
        ret += it.data();
        return rsl;
    }
    return false;
}



template<class KT,class VT>
inline QString
TexpandMacros( const QString &ostr, const QMap<KT,VT> &map, QChar c )
{
    QString str( ostr );
    KMacroMapExpander<KT,VT> kmx( map, c );
    kmx.expandMacros( str );
    return str;
}

template<class KT,class VT>
inline QString
TexpandMacrosShellQuote( const QString &ostr, const QMap<KT,VT> &map, QChar c )
{
    QString str( ostr );
    KMacroMapExpander<KT,VT> kmx( map, c );
    if (!kmx.expandMacrosShellQuote( str ))
        return QString::null;
    return str;
}


namespace KMacroExpander {

  QString expandMacros( const QString &ostr, const QMap<QChar,QString> &map, QChar c ) { return TexpandMacros( ostr, map, c ); }
  QString expandMacrosShellQuote( const QString &ostr, const QMap<QChar,QString> &map, QChar c ) { return TexpandMacrosShellQuote( ostr, map, c ); }
  QString expandMacros( const QString &ostr, const QMap<QString,QString> &map, QChar c ) { return TexpandMacros( ostr, map, c ); }
  QString expandMacrosShellQuote( const QString &ostr, const QMap<QString,QString> &map, QChar c ) { return TexpandMacrosShellQuote( ostr, map, c ); }
  QString expandMacros( const QString &ostr, const QMap<QChar,QStringList> &map, QChar c ) { return TexpandMacros( ostr, map, c ); }
  QString expandMacrosShellQuote( const QString &ostr, const QMap<QChar,QStringList> &map, QChar c ) { return TexpandMacrosShellQuote( ostr, map, c ); }
  QString expandMacros( const QString &ostr, const QMap<QString,QStringList> &map, QChar c ) { return TexpandMacros( ostr, map, c ); }
  QString expandMacrosShellQuote( const QString &ostr, const QMap<QString,QStringList> &map, QChar c ) { return TexpandMacrosShellQuote( ostr, map, c ); }

}
# 94 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kidna.cpp" 1
# 29 "/coolo/prod/kdelibs/kdecore/kidna.cpp"

static lt_dlhandle KIDNA_lib;
static bool KIDNA_lib_load_failed;

typedef int (*KIDNA_utf8_to_ace_t)(const char *, char **);
typedef int (*KIDNA_utf8ace_to_utf8_t)(const char *, char **);

static KIDNA_utf8_to_ace_t KIDNA_utf8_to_ace;
static KIDNA_utf8ace_to_utf8_t KIDNA_utf8ace_to_utf8;

static void KIDNA_load_lib()
{
   KIDNA_lib_load_failed = true;
   KIDNA_lib = lt_dlopen("/usr/local/lib/libidn.la");
   if (!KIDNA_lib)
   {
      KIDNA_lib = lt_dlopen("/usr/lib/libidn.la");
   }

   if (!KIDNA_lib)
      return;

   KIDNA_utf8_to_ace = (KIDNA_utf8_to_ace_t) lt_dlsym(KIDNA_lib, "idna_utf8_to_ace");
   if (!KIDNA_utf8_to_ace)
   {
      kdWarning() << "Symbol idna_utf8_to_ace not found." << endl;
      return;
   }

   KIDNA_utf8ace_to_utf8 = (KIDNA_utf8ace_to_utf8_t) lt_dlsym(KIDNA_lib, "idna_utf8ace_to_utf8");
   if (!KIDNA_utf8ace_to_utf8)
   {
      kdWarning() << "Symbol idna_utf8ace_to_utf8 not found." << endl;
      return;
   }
   KIDNA_lib_load_failed = false;
}

QCString KIDNA::toAsciiCString(const QString &idna)
{
   int l = idna.length();
   const QChar *u = idna.unicode();
   bool needConversion = false;
   for(;l--;)
   {
      if ((*u++).unicode() > 127)
      {
          needConversion = true;
          break;
      }
   }
   if (!needConversion)
      return idna.lower().latin1();

   if (!KIDNA_lib && !KIDNA_lib_load_failed)
   {
      KIDNA_load_lib();
   }

   if (KIDNA_lib_load_failed)
   {
      return 0;
   }
   else
   {


      bool bStartsWithDot = (idna[0] == '.');
      char *pOutput;
      if ((*KIDNA_utf8_to_ace)(idna.utf8().data()+(bStartsWithDot ? 1: 0), &pOutput) == 0)
      {
         QCString result = pOutput;
         free(pOutput);
         if (bStartsWithDot)
            return "."+result;
         return result;
      }
      else
      {
         return 0;
      }
   }
}

QString KIDNA::toAscii(const QString &idna)
{
   int l = idna.length();
   const QChar *u = idna.unicode();
   bool needConversion = false;
   for(;l--;)
   {
      if ((*u++).unicode() > 127)
      {
          needConversion = true;
          break;
      }
   }
   if (!needConversion)
      return idna.lower();

   if (!KIDNA_lib && !KIDNA_lib_load_failed)
   {
      KIDNA_load_lib();
   }

   if (KIDNA_lib_load_failed)
   {
      return QString::null;
   }
   else
   {


      bool bStartsWithDot = (idna[0] == '.');
      char *pOutput;
      if ((*KIDNA_utf8_to_ace)(idna.utf8().data()+(bStartsWithDot ? 1: 0), &pOutput) == 0)
      {
         QString result(pOutput);
         free(pOutput);
         if (bStartsWithDot)
            return "."+result;
         return result;
      }
      else
      {
         return QString::null;
      }
   }
}

QString KIDNA::toUnicode(const QString &idna)
{
   if (!KIDNA_lib && !KIDNA_lib_load_failed)
   {
      KIDNA_load_lib();
   }

   if (KIDNA_lib_load_failed)
   {
      return idna.lower();
   }
   else
   {
      char *pOutput;
      if ((*KIDNA_utf8ace_to_utf8)(idna.utf8(), &pOutput) == 0)
      {
         QString result = QString::fromUtf8(pOutput);
         free(pOutput);
         return result;
      }
      else
      {
         return idna.lower();
      }
   }
}
# 95 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/ktempdir.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/ktempdir.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/ktempdir.cpp" 2
# 52 "/coolo/prod/kdelibs/kdecore/ktempdir.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/ktempdir.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/ktempdir.h"



# 1 "/usr/include/errno.h" 1 3 4
# 26 "/coolo/prod/kdelibs/kdecore/ktempdir.h" 2

class QDir;
class KTempDirPrivate;
# 51 "/coolo/prod/kdelibs/kdecore/ktempdir.h"
class KTempDir
{
public:
# 62 "/coolo/prod/kdelibs/kdecore/ktempdir.h"
   KTempDir(QString directoryPrefix=QString::null,
             int mode = 0700 );





   ~KTempDir();






   void setAutoDelete(bool autoDelete) { bAutoDelete = autoDelete; }
# 87 "/coolo/prod/kdelibs/kdecore/ktempdir.h"
   int status() const;






   QString name() const;







   QDir *qDir();




   void unlink();




   bool existing() const;

protected:

   bool create(const QString &directoryPrefix, int mode);

   void setError(int error) { mError = error; }

private:
   int mError;
   QString mTmpName;
   bool bExisting;
   bool bAutoDelete;

   KTempDirPrivate *d;
};
# 53 "/coolo/prod/kdelibs/kdecore/ktempdir.cpp" 2




KTempDir::KTempDir(QString directoryPrefix, int mode)
{
   bAutoDelete = false;
   bExisting = false;
   mError=0;
   if (directoryPrefix.isEmpty())
   {
      directoryPrefix = locateLocal("tmp", KGlobal::instance()->instanceName());
   }
   (void) create(directoryPrefix , mode);
}

bool
KTempDir::create(const QString &directoryPrefix, int mode)
{

   (void) KApplication::random();

   QCString nme = QFile::encodeName(directoryPrefix) + "XXXXXX";
   char *realName;
   if((realName=mkdtemp(nme.data())) == 0)
   {

       QCString nme = QFile::encodeName(directoryPrefix) + "XXXXXX";
       qWarning("KTempDir: Error trying to create %s: %s", nme.data(), strerror((*__errno_location ())));
       mError = (*__errno_location ());
       mTmpName = QString::null;
       return false;
   }


   QCString realNameStr(realName);
   mTmpName = QFile::decodeName(realNameStr)+"/";
   kdDebug()<<"KTempDir: Temporary directory created :"<<realNameStr<<endl;
   kdDebug()<<"KTempDir: Temporary directory created :"<<mTmpName<<endl;
   mode_t tmp = 0;
   mode_t umsk = umask(tmp);
   umask(umsk);
   chmod(nme, mode&(~umsk));


   bExisting = true;


   chown(nme, getuid(), getgid());
   return true;
}

KTempDir::~KTempDir()
{
   if (bAutoDelete)
      unlink();
}

int
KTempDir::status() const
{
   return mError;
}

QString
KTempDir::name() const
{
   return mTmpName;
}

bool
KTempDir::existing() const
{
   return bExisting;
}

QDir *
KTempDir::qDir()
{
   if (bExisting) return new QDir(mTmpName);
   return 0;
}

void
KTempDir::unlink()
{
   if (!bExisting) return;
   QString rmstr("/bin/rm -rf ");
   rmstr += KProcess::quote(mTmpName);
   ::system( QFile::encodeName(rmstr) );

   bExisting=false;
   mError=0;
}
# 96 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kshell.cpp" 1
# 30 "/coolo/prod/kdelibs/kdecore/kshell.cpp"
static int fromHex( QChar c )
{
    if (c >= '0' && c <= '9')
        return c - '0';
    else if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    else if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    return -1;
}

inline static bool isQuoteMeta( uint c )
{
# 51 "/coolo/prod/kdelibs/kdecore/kshell.cpp"
    return c == '\\' || c == '\'' || c == '"' || c == '$';

}

inline static bool isMeta( uint c )
{
    static const uchar iqm[] = {
        0x00, 0x00, 0x00, 0x00, 0xdc, 0x07, 0x00, 0xd8,
        0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x38
    };

    return (c < sizeof(iqm) * 8) && (iqm[c / 8] & (1 << (c & 7)));
}

QStringList KShell::splitArgs( const QString &args, int flags, int *err )
{
    QStringList ret;
    bool firstword = flags & AbortOnMeta;

    for (uint pos = 0; ; ) {
        QChar c;
        do {
            if (pos >= args.length())
                goto okret;
            c = args.unicode()[pos++];
        } while (c.isSpace());
        QString cret;
        if ((flags & TildeExpand) && c == '~') {
            uint opos = pos;
            for (; ; pos++) {
                if (pos >= args.length())
                    break;
                c = args.unicode()[pos];
                if (c == '/' || c.isSpace())
                    break;
                if (isQuoteMeta( c )) {
                    pos = opos;
                    c = '~';
                    goto notilde;
                }
                if ((flags & AbortOnMeta) && isMeta( c ))
                    goto metaerr;
            }
            QString ccret = homeDir( QConstString( args.unicode() + opos, pos - opos ).string() );
            if (ccret.isEmpty()) {
                pos = opos;
                c = '~';
                goto notilde;
            }
            if (pos >= args.length()) {
                ret += ccret;
                goto okret;
            }
            pos++;
            if (c.isSpace()) {
                ret += ccret;
                firstword = false;
                continue;
            }
            cret = ccret;
        }

        if (firstword) {
            if (c == '_' || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
                uint pos2 = pos;
                QChar cc;
                do
                  cc = args[pos2++];
                while (cc == '_' || (cc >= 'A' && cc <= 'Z') ||
                       (cc >= 'a' && cc <= 'z') || (cc >= '0' && cc <= '9'));
                if (cc == '=')
                    goto metaerr;
            }
        }
      notilde:
        do {
            if (c == '\'') {
                uint spos = pos;
                do {
                    if (pos >= args.length())
                        goto quoteerr;
                    c = args.unicode()[pos++];
                } while (c != '\'');
                cret += QConstString( args.unicode() + spos, pos - spos - 1 ).string();
            } else if (c == '"') {
                for (;;) {
                    if (pos >= args.length())
                        goto quoteerr;
                    c = args.unicode()[pos++];
                    if (c == '"')
                        break;
                    if (c == '\\') {
                        if (pos >= args.length())
                            goto quoteerr;
                        c = args.unicode()[pos++];
                        if (c != '"' && c != '\\' &&
                            !((flags & AbortOnMeta) && (c == '$' || c == '`')))
                            cret += '\\';
                    } else if ((flags & AbortOnMeta) && (c == '$' || c == '`'))
                        goto metaerr;
                    cret += c;
                }
            } else if (c == '$' && args[pos] == '\'') {
                pos++;
                for (;;) {
                    if (pos >= args.length())
                        goto quoteerr;
                    c = args.unicode()[pos++];
                    if (c == '\'')
                        break;
                    if (c == '\\') {
                        if (pos >= args.length())
                            goto quoteerr;
                        c = args.unicode()[pos++];
                        switch (c) {
                        case 'a': cret += '\a'; break;
                        case 'b': cret += '\b'; break;
                        case 'e': cret += '\033'; break;
                        case 'f': cret += '\f'; break;
                        case 'n': cret += '\n'; break;
                        case 'r': cret += '\r'; break;
                        case 't': cret += '\t'; break;
                        case '\\': cret += '\\'; break;
                        case '\'': cret += '\''; break;
                        case 'c': cret += args[pos++] & 31; break;
                        case 'x':
                          {
                            int hv = fromHex( args[pos] );
                            if (hv < 0) {
                                cret += "\\x";
                            } else {
                                int hhv = fromHex( args[++pos] );
                                if (hhv > 0) {
                                    hv = hv * 16 + hhv;
                                    pos++;
                                }
                                cret += QChar( hv );
                            }
                            break;
                          }
                        default:
                            if (c >= '0' && c <= '7') {
                                int hv = c - '0';
                                for (int i = 0; i < 2; i++) {
                                    c = args[pos];
                                    if (c < '0' || c > '7')
                                        break;
                                    hv = hv * 8 + (c - '0');
                                    pos++;
                                }
                                cret += QChar( hv );
                            } else {
                                cret += '\\';
                                cret += c;
                            }
                            break;
                        }
                    } else
                        cret += c;
                }
            } else {
                if (c == '\\') {
                    if (pos >= args.length())
                        goto quoteerr;
                    c = args.unicode()[pos++];
                    if (!c.isSpace() &&
                        !((flags & AbortOnMeta) ? isMeta( c ) : isQuoteMeta( c )))
                        cret += '\\';
                } else if ((flags & AbortOnMeta) && isMeta( c ))
                    goto metaerr;
                cret += c;
            }
            if (pos >= args.length())
                break;
            c = args.unicode()[pos++];
        } while (!c.isSpace());
        ret += cret;
        firstword = false;
    }

  okret:
    if (err)
        *err = NoError;
    return ret;

  quoteerr:
   if (err)
       *err = BadQuoting;
   return QStringList();

  metaerr:
   if (err)
       *err = FoundMeta;
   return QStringList();
}

inline static bool isSpecial( uint c )
{
    static const uchar iqm[] = {
        0xff, 0xff, 0xff, 0xff, 0xdd, 0x07, 0x00, 0xd8,
        0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x38
    };

    return (c < sizeof(iqm) * 8) && (iqm[c / 8] & (1 << (c & 7)));
}

QString KShell::joinArgs( const QStringList &args )
{
    QChar q( '\'' );
    QString ret;
    for (QStringList::ConstIterator it = args.begin(); it != args.end(); ++it) {
        if (!ret.isEmpty())
            ret += ' ';
        if (!(*it).length())
            ret.append( q ).append( q );
        else {
            for (uint i = 0; i < (*it).length(); i++)
                if (isSpecial((*it).unicode()[i])) {
                    QString tmp(*it);
                    tmp.replace( q, "'\\''" );
                    ret += q;
                    tmp += q;
                    ret += tmp;
                    goto ex;
                }
            ret += *it;
          ex: ;
        }
    }
    return ret;
}

QString KShell::joinArgs( const char * const *args, int nargs )
{
    if (!args)
        return QString::null;
    QChar q( '\'' );
    QString ret;
    for (const char * const *argp = args; nargs && *argp; argp++, nargs--) {
        if (!ret.isEmpty())
            ret += ' ';
        if (!**argp)
            ret.append( q ).append( q );
        else {
            QString tmp( QFile::decodeName( *argp ) );
            for (uint i = 0; i < tmp.length(); i++)
                if (isSpecial(tmp.unicode()[i])) {
                    tmp.replace( q, "'\\''" );
                    ret += q;
                    tmp += q;
                    ret += tmp;
                    goto ex;
                }
            ret += tmp;
          ex: ;
       }
    }
    return ret;
}

QString KShell::joinArgsDQ( const QStringList &args )
{
    QChar q( '\'' ), sp( ' ' ), bs( '\\' );
    QString ret;
    for (QStringList::ConstIterator it = args.begin(); it != args.end(); ++it) {
        if (!ret.isEmpty())
            ret += sp;
        if (!(*it).length())
            ret.append( q ).append( q );
        else {
            for (uint i = 0; i < (*it).length(); i++)
                if (isSpecial((*it).unicode()[i])) {
                    ret.append( '$' ).append( q );
                    for (uint pos = 0; pos < (*it).length(); pos++) {
                        int c = (*it).unicode()[pos];
                        if (c < 32) {
                            ret += bs;
                            switch (c) {
                            case '\a': ret += 'a'; break;
                            case '\b': ret += 'b'; break;
                            case '\033': ret += 'e'; break;
                            case '\f': ret += 'f'; break;
                            case '\n': ret += 'n'; break;
                            case '\r': ret += 'r'; break;
                            case '\t': ret += 't'; break;
                            case '\034': ret += 'c'; ret += '|'; break;
                            default: ret += 'c'; ret += c + '@'; break;
                            }
                        } else {
                            if (c == '\'' || c == '\\')
                                ret += bs;
                            ret += c;
                        }
                    }
                    ret.append( q );
                    goto ex;
                }
            ret += *it;
          ex: ;
        }
    }
    return ret;
}

QString KShell::tildeExpand( const QString &fname )
{
    if (fname[0] == '~') {
        int pos = fname.find( '/' );
        if (pos < 0)
            return homeDir( QConstString( fname.unicode() + 1, fname.length() - 1 ).string() );
        QString ret = homeDir( QConstString( fname.unicode() + 1, pos - 1 ).string() );
        if (!ret.isNull())
            ret += QConstString( fname.unicode() + pos, fname.length() - pos ).string();
        return ret;
    }
    return fname;
}

QString KShell::homeDir( const QString &user )
{
    if (user.isEmpty())
        return QFile::decodeName( getenv( "HOME" ) );
    struct passwd *pw = getpwnam( QFile::encodeName( user ).data() );
    if (!pw)
        return QString::null;
    return QFile::decodeName( pw->pw_dir );
}
# 97 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp" 1
# 23 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp"
# 1 "../config.h" 1
# 13 "../config.h"









# 34 "../config.h"










# 55 "../config.h"







# 74 "../config.h"


# 86 "../config.h"























































# 176 "../config.h"

























































# 266 "../config.h"











# 290 "../config.h"



























# 336 "../config.h"


















# 372 "../config.h"


































# 438 "../config.h"































































































# 577 "../config.h"





















# 617 "../config.h"




# 633 "../config.h"







































# 699 "../config.h"












# 761 "../config.h"
# 793 "../config.h"
extern "C"

int mkstemps(char *, int);
# 829 "../config.h"
extern "C"

unsigned long strlcat(char*, const char*, unsigned long);






extern "C"

unsigned long strlcpy(char*, const char*, unsigned long);
# 905 "../config.h"




# 920 "../config.h"
# 937 "../config.h"
# 24 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp" 2
# 39 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp"
# 1 "/usr/include/mntent.h" 1 3 4
# 21 "/usr/include/mntent.h" 3 4

















extern "C" {


struct mntent
  {
    char *mnt_fsname;
    char *mnt_dir;
    char *mnt_type;
    char *mnt_opts;
    int mnt_freq;
    int mnt_passno;
  };




extern FILE *setmntent (__const char *__file, __const char *__mode) throw ();




extern struct mntent *getmntent (FILE *__stream) throw ();



extern struct mntent *getmntent_r (FILE *__restrict __stream,
                                   struct mntent *__restrict __result,
                                   char *__restrict __buffer,
                                   int __bufsize) throw ();




extern int addmntent (FILE *__restrict __stream,
                      __const struct mntent *__restrict __mnt) throw ();


extern int endmntent (FILE *__stream) throw ();



extern char *hasmntopt (__const struct mntent *__mnt,
                        __const char *__opt) throw ();


}
# 40 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp" 2
# 50 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp"
# 1 "/usr/include/sys/mount.h" 1 3 4
# 23 "/usr/include/sys/mount.h" 3 4








enum
{
  MS_RDONLY = 1,
  MS_NOSUID = 2,
  MS_NODEV = 4,
  MS_NOEXEC = 8,
  MS_SYNCHRONOUS = 16,
  MS_REMOUNT = 32,
  MS_MANDLOCK = 64,
  S_WRITE = 128,
  S_APPEND = 256,
  S_IMMUTABLE = 512,
  MS_NOATIME = 1024,
  MS_NODIRATIME = 2048,
  MS_BIND = 4096,
};















enum
{
  MNT_FORCE = 1
};


extern "C" {


extern int mount (__const char *__special_file, __const char *__dir,
                  __const char *__fstype, unsigned long int __rwflag,
                  __const void *__data) throw ();


extern int umount (__const char *__special_file) throw ();


extern int umount2 (__const char *__special_file, int __flags) throw ();

}
# 51 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp" 2



# 1 "/usr/include/fstab.h" 1 3 4
# 33 "/usr/include/fstab.h" 3 4
# 48 "/usr/include/fstab.h" 3 4


struct fstab
  {
    char *fs_spec;
    char *fs_file;
    char *fs_vfstype;
    char *fs_mntops;
    const char *fs_type;
    int fs_freq;
    int fs_passno;
  };


extern "C" {

extern struct fstab *getfsent (void) throw ();
extern struct fstab *getfsspec (__const char *__name) throw ();
extern struct fstab *getfsfile (__const char *__name) throw ();
extern int setfsent (void) throw ();
extern void endfsent (void) throw ();

}
# 55 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp" 2
# 74 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp"
#undef MNTTAB
# 92 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp"




KMountPoint::KMountPoint()
{
}

KMountPoint::~KMountPoint()
{
}


# 127 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp"
KMountPoint::List KMountPoint::possibleMountPoints(int infoNeeded)
{
  KMountPoint::List result;


   FILE * fstab;
   if ((fstab = setmntent("/etc/fstab", "r")) == 0)
      return result;

   struct mntent * fe;
   while (((fe = getmntent(fstab)) != 0))
   {
      KMountPoint *mp = new KMountPoint();
      mp->m_mountedFrom = QFile::decodeName(fe->mnt_fsname);

      mp->m_mountPoint = QFile::decodeName(fe->mnt_dir);
      mp->m_mountType = QFile::decodeName(fe->mnt_type);
      if (infoNeeded & NeedMountOptions)
      {
         QString options = QFile::decodeName(fe->mnt_opts);
         mp->m_mountOptions = QStringList::split(',', options);
      }

      if (infoNeeded & NeedRealDeviceName)
      {
         if (mp->m_mountedFrom.startsWith("/"))
            mp->m_device = KStandardDirs::realPath(mp->m_mountedFrom);
      }

      result.append(mp);
   }
   endmntent(fstab);
# 211 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp"
   return result;
}

KMountPoint::List KMountPoint::currentMountPoints(int infoNeeded)
{
  KMountPoint::List result;
# 324 "/coolo/prod/kdelibs/kdecore/kmountpoint.cpp"
   FILE * mnttab;
   if ((mnttab = setmntent("/etc/mtab", "r")) == 0)
      return result;

   struct mntent * fe;
   while (((fe = getmntent(mnttab)) != 0))
   {
      KMountPoint *mp = new KMountPoint();
      mp->m_mountedFrom = QFile::decodeName(fe->mnt_fsname);

      mp->m_mountPoint = QFile::decodeName(fe->mnt_dir);
      mp->m_mountType = QFile::decodeName(fe->mnt_type);
      if (infoNeeded & NeedMountOptions)
      {
         QString options = QFile::decodeName(fe->mnt_opts);
         mp->m_mountOptions = QStringList::split(',', options);
      }

      if (infoNeeded & NeedRealDeviceName)
      {
         if (mp->m_mountedFrom.startsWith("/"))
            mp->m_device = KStandardDirs::realPath(mp->m_mountedFrom);
      }

      result.append(mp);
   }
   endmntent(mnttab);

   return result;
}
# 98 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kcalendarsystemjalali.cpp" 1
# 36 "/coolo/prod/kdelibs/kdecore/kcalendarsystemjalali.cpp"
static const int gMonthDay[2][13]={
        {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
        {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
};

static const int jMonthDay[2][13] = {
        {0, 31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29},
        {0, 31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 30},
};

typedef struct {
        int day;
        int mon;
        int year;
        } SDATE;


static int Ceil(float number)
{
    int ret;
    if(number>0)
        number += 0.5;
    ret =(int) number;
    return ret;
}

static long jalali_jdn(int year, int month, int day)
{
    const long PERSIAN_EPOCH = 1948321;
    int epbase;
    long epyear;
    long mdays;
    long jdn;
    epbase = year - 474;
    epyear = 474 + (epbase % 2820);
    if (month <= 7)
        mdays = (month - 1) * 31;
    else
        mdays = (month - 1) * 30 + 6;
    jdn = day + mdays ;
    jdn += (((epyear * 682) - 110) / 2816) ;
    jdn += (epyear - 1) * 365;
    jdn += (epbase / 2820) * 1029983 ;
    jdn += (PERSIAN_EPOCH - 1);
    return jdn;
}


static SDATE jdn_jalali(long jdn)
{
    static SDATE ret;
    int day, month, year;
    int iYear, iMonth, iDay;
    int depoch;
    int cycle;
    int cyear;
    int ycycle;
    int aux1, aux2;
    int yday;
    day = 1;
    month = 1;
    year = 475;
    depoch = jdn - jalali_jdn(year,month, day);
    cycle = (int) (depoch / 1029983);
    cyear = depoch % 1029983;
    if( cyear == 1029982)
        ycycle = 2820;
    else{
        aux1 = cyear / 366;
        aux2 = cyear % 366;
        ycycle = (((2134 * aux1) + (2816 * aux2) + 2815) / 1028522) + aux1 + 1;
    }
    iYear = ycycle + (2820 * cycle) + 474;
    if (iYear <= 0)
        iYear = iYear - 1;
    year = iYear;
    yday = (jdn - jalali_jdn(year, month, day)) + 1;
    if(yday <= 186 )
        iMonth = Ceil((yday-1) / 31);
    else
        iMonth = Ceil((yday - 7) / 30);
    iMonth++;
    month = iMonth;
    iDay = (jdn - jalali_jdn(year, month, day)) + 1;
    ret.day = iDay;
    ret.mon = iMonth;
    ret.year = iYear;
    return ret;
}



static long civil_jdn(int year, int month, int day)
{
    long jdn = ((1461 * (year + 4800 + ((month - 14) / 12))) / 4)
        + ((367 * (month - 2 - 12 * (((month - 14) / 12)))) / 12)
        - ((3 * (((year + 4900 + ((month - 14) / 12)) / 100))) / 4)
        + day - 32075;
    return jdn;
}

static SDATE jdn_civil(long jdn)
{
    long l, n, i, j;
    static SDATE ret;
    int iday, imonth, iyear;
    l = jdn + 68569;
    n = ((4 * l) / 146097);
    l = l - ((146097 * n + 3) / 4);
    i = ((4000 * (l + 1)) / 1461001);
    l = l - ((1461 * i) / 4) + 31;
    j = ((80 * l) / 2447);
    iday = l - ((2447 * j) / 80);
    l = (j / 11);
    imonth = j + 2 - 12 * l;
    iyear = 100 * (n - 49) + i + l;
    ret.day = iday;
    ret.mon = imonth;
    ret.year = iyear;
    return (ret);
}

static SDATE *jalaliToGregorian(int y,int m,int d)
{
static SDATE sd;
long jday = jalali_jdn(y,m,d);
sd= jdn_civil(jday);
return (&sd);
}
static SDATE *gregorianToJalali(int y,int m, int d)
{
    static SDATE sd;
    long jdn = civil_jdn(y,m,d);
    sd = jdn_jalali(jdn);
    return(&sd);
}
static void gregorianToJalali(const QDate & date, int * pYear, int * pMonth,
                               int * pDay)
{
  SDATE *sd;
  sd = gregorianToJalali(date.year(), date.month(), date.day());
  if (pYear)
    *pYear = sd->year;
  if (pMonth)
    *pMonth = sd->mon;
  if (pDay)
    *pDay = sd->day;

}



static int isJalaliLeap(int year)
{
 int tmp;
 tmp = year % 33;
 if (tmp == 1 || tmp == 5||tmp==9||tmp==13||tmp==17||tmp==22||tmp==26||tmp==30)
     return 1;
else
     return 0;
}
static int hndays(int m,int y)
{
  return jMonthDay[isJalaliLeap(y)][m];
}


KCalendarSystemJalali::KCalendarSystemJalali(const KLocale * locale)
  : KCalendarSystem(locale)
{
}

KCalendarSystemJalali::~KCalendarSystemJalali()
{
}

int KCalendarSystemJalali::year(const QDate& date) const

{
  kdDebug(5400) << "Jalali year..." << endl;
int y;
  gregorianToJalali(date, &y, 0, 0);
  return y;
}

int KCalendarSystemJalali::month (const QDate& date) const

{
  kdDebug(5400) << "Jalali month..." << endl;
int m;
  gregorianToJalali(date, 0 , &m, 0);
  return m;
}

int KCalendarSystemJalali::day(const QDate& date) const

{
  kdDebug(5400) << "Jalali day..." << endl;
int d;
  gregorianToJalali(date, 0, 0, &d);
  return d;
}

int KCalendarSystemJalali::dayOfWeek(const QDate& date) const
{

  return date.dayOfWeek();

}


int KCalendarSystemJalali::dayOfYear(const QDate & date) const
{
  QDate first;
  setYMD(first, year(date), 1, 1);

  return first.daysTo(date) + 1;
}


bool KCalendarSystemJalali::setYMD(QDate & date, int y, int m, int d) const
{

  if ( y < minValidYear() || y > maxValidYear() )
    return false;

  if ( m < 1 || m > 12 )
    return false;

  if ( d < 1 || d > hndays(m, y) )
    return false;

  SDATE *gd =jalaliToGregorian( y, m, d);

  return date.setYMD(gd->year, gd->mon, gd->day);
}

QDate KCalendarSystemJalali::addYears( const QDate & date, int nyears ) const
{
  QDate result = date;
  int y = year(date) + nyears;
  setYMD( result, y, month(date), day(date) );

  return result;
}

QDate KCalendarSystemJalali::addMonths( const QDate & date, int nmonths ) const
{
  QDate result = date;
  int m = month(date);
  int y = year(date);

  if ( nmonths < 0 )
  {
    m += 12;
    y -= 1;
  }

  --m;
  m += nmonths;
  y += m / 12;
  m %= 12;
  ++m;

  setYMD( result, y, m, day(date) );

  return result;
}

QDate KCalendarSystemJalali::addDays( const QDate & date, int ndays ) const
{
  return date.addDays( ndays );
}

int KCalendarSystemJalali::monthsInYear( const QDate & date ) const
{
  (void)date;

  return 12;
}

int KCalendarSystemJalali::daysInYear(const QDate & date) const
{
(void)date;;
int result;


        result=366;


return result;
}

int KCalendarSystemJalali::daysInMonth(const QDate & date) const
{
SDATE *sd = gregorianToJalali(date.year(),date.month(),date.day());
return hndays(sd->mon,sd->year);
}

int KCalendarSystemJalali::weeksInYear(int year) const

{
  (void)year;;

return 52;
}

int KCalendarSystemJalali::weekNumber(const QDate& date, int * yearNum) const
{
  QDate firstDayWeek1, lastDayOfYear;
  int y = year(date);
  int week;
  int weekDay1, dayOfWeek1InYear;


  setYMD(firstDayWeek1, y, 1, 1);
  weekDay1 = dayOfWeek(firstDayWeek1);



  if (weekDay1 > 4 )
    firstDayWeek1 = addDays(firstDayWeek1 , 7 - weekDay1 + 1);

  dayOfWeek1InYear = dayOfYear(firstDayWeek1);

  if ( dayOfYear(date) < dayOfWeek1InYear )
  {
    if ( yearNum )
      *yearNum = y - 1;
    return weeksInYear(y - 1);
  }

  setYMD(lastDayOfYear, y, 12, hndays(12, y));
  if ( (dayOfYear(date) >= daysInYear(date) - dayOfWeek(lastDayOfYear) + 1)

       && dayOfWeek(lastDayOfYear) < 4)
    {
      if ( yearNum )
        *yearNum = y + 1;
      week = 1;
    }
  else
    week = firstDayWeek1.daysTo(date) / 7 + 1;

  return week;
}
QString KCalendarSystemJalali::yearLiteral (int year) const
{



   return QString::number(year);
}

QString KCalendarSystemJalali::yearLiteral (const QDate & date) const
{





 SDATE *sd= gregorianToJalali(date.year(),date.month(),date.day());
  return yearLiteral(sd->year);
}

QString KCalendarSystemJalali::monthName(int month, int year, bool shortName)
  const
{
  (void)year;;

  if (shortName)
    switch ( month )
      {
      case 1:
        return locale()->translate("Far");
      case 2:
        return locale()->translate("Ord");
      case 3:
        return locale()->translate("Kho");
      case 4:
        return locale()->translate("Tir");
      case 5:
        return locale()->translate("Mor");
      case 6:
        return locale()->translate("Sha");
      case 7:
        return locale()->translate("Meh");
      case 8:
        return locale()->translate("Aba");
      case 9:
        return locale()->translate("Aza");
      case 10:
        return locale()->translate("Dei");
      case 11:
        return locale()->translate("Bah");
      case 12:
        return locale()->translate("Esf");
    }
  else
    switch ( month )
      {
      case 1:
        return locale()->translate("Farvardin");
      case 2:
        return locale()->translate("Ordibehesht");
      case 3:
        return locale()->translate("Khordad");
      case 4:
        return locale()->translate("Tir");
      case 5:
        return locale()->translate("Mordad");
      case 6:
        return locale()->translate("Shahrivar");
      case 7:
        return locale()->translate("Mehr");
      case 8:
        return locale()->translate("Aban");
      case 9:
        return locale()->translate("Azar");
      case 10:
        return locale()->translate("Dei");
      case 11:
        return locale()->translate("Bahman");
      case 12:
        return locale()->translate("Esfand");
      }

  return QString::null;
}

QString KCalendarSystemJalali::monthName(const QDate& date, bool shortName)
  const
{
int mon;
gregorianToJalali(date,0,&mon,0);

  return (monthName(mon,shortName));
}

QString KCalendarSystemJalali::monthNamePossessive(const QDate& date,
                                                     bool shortName ) const
{
  return monthName(date,shortName);
}

QString KCalendarSystemJalali::monthNamePossessive(int month, int year,
                                                     bool shortName ) const
{
  return monthName(month,year,shortName);
}


QString KCalendarSystemJalali::weekDayName(int day, bool shortName) const
{
  if ( shortName )
    switch (day)
      {
      case 1:
        return locale()->translate("2sh");
      case 2:
        return locale()->translate("3sh");
      case 3:
        return locale()->translate("4sh");
      case 4:
        return locale()->translate("5sh");
      case 5:
        return locale()->translate("Jom");
      case 6:
        return locale()->translate("shn");
      case 7:
        return locale()->translate("1sh");
      }
  else
    switch ( day )
      {
      case 1:
        return locale()->translate("Do shanbe");
      case 2:
        return locale()->translate("Se shanbe");
      case 3:
        return locale()->translate("Chahar shanbe");
      case 4:
        return locale()->translate("Panj shanbe");
      case 5:
        return locale()->translate("Jumee");
      case 6:
        return locale()->translate("Shanbe");
      case 7:
        return locale()->translate("Yek-shanbe");
      }

  return QString::null;
}

QString KCalendarSystemJalali::weekDayName(const QDate &date,bool shortName)
  const
{
 return weekDayName(dayOfWeek(date), shortName);
}


int KCalendarSystemJalali::minValidYear() const
{
  QDate date(1753, 1, 1);

  return year(date);
}


int KCalendarSystemJalali::maxValidYear() const
{







  return 10000;
}
int KCalendarSystemJalali::weekDayOfPray() const
{
  return 5;
}
QString KCalendarSystemJalali::calendarName() const
{
  return QString::fromLatin1("jalali");
}

bool KCalendarSystemJalali::isLunar() const
{
  return false;
}

bool KCalendarSystemJalali::isLunisolar() const
{
  return false;
}

bool KCalendarSystemJalali::isSolar() const
{
  return true;
}
# 99 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kprotocolinfo_kdecore.cpp" 1
# 20 "/coolo/prod/kdelibs/kdecore/kprotocolinfo_kdecore.cpp"
# 1 "/coolo/prod/kdelibs/kdecore/kprotocolinfofactory.h" 1
# 21 "/coolo/prod/kdelibs/kdecore/kprotocolinfofactory.h"
# 30 "/coolo/prod/kdelibs/kdecore/kprotocolinfofactory.h"
class KProtocolInfoPrivate;
# 39 "/coolo/prod/kdelibs/kdecore/kprotocolinfofactory.h"
class KProtocolInfoFactory : public KSycocaFactory
{
  public: virtual KSycocaFactoryId factoryId() const { return KST_KProtocolInfoFactory; } private:
public:




  static KProtocolInfoFactory* self()
  { if ( !_self) new KProtocolInfoFactory(); return _self; }

  KProtocolInfoFactory();
  virtual ~KProtocolInfoFactory();
# 60 "/coolo/prod/kdelibs/kdecore/kprotocolinfofactory.h"
  KProtocolInfo *findProtocol(const QString &protocol);





  QStringList protocols();
protected:




  virtual KSycocaEntry *createEntry(const QString &, const char *)
    { return 0; }




  virtual KProtocolInfo *createEntry(int offset);

protected:
  static KProtocolInfoFactory *_self;

  QString m_lastProtocol;
  KProtocolInfo::Ptr m_lastInfo;
protected:
  virtual void virtual_hook( int id, void* data );
private:
  class KProtocolInfoFactoryPrivate* d;
};
# 21 "/coolo/prod/kdelibs/kdecore/kprotocolinfo_kdecore.cpp" 2
# 30 "/coolo/prod/kdelibs/kdecore/kprotocolinfo_kdecore.cpp"
class KProtocolInfo::KProtocolInfoPrivate
{
public:
  QString docPath;
  QString protClass;
  KProtocolInfo::ExtraFieldList extraFields;
};




KProtocolInfo::KProtocolInfo(const QString &path)
 : KSycocaEntry(path)
{
  d = new KProtocolInfoPrivate;
  QString fullPath = locate("services", path);

  KSimpleConfig config( fullPath, true );
  config.setGroup( "Protocol" );

  m_name = config.readEntry( "protocol" );
  m_exec = config.readPathEntry( "exec" );
  m_isSourceProtocol = config.readBoolEntry( "source", true );
  m_isHelperProtocol = config.readBoolEntry( "helper", false );
  m_supportsReading = config.readBoolEntry( "reading", false );
  m_supportsWriting = config.readBoolEntry( "writing", false );
  m_supportsMakeDir = config.readBoolEntry( "makedir", false );
  m_supportsDeleting = config.readBoolEntry( "deleting", false );
  m_supportsLinking = config.readBoolEntry( "linking", false );
  m_supportsMoving = config.readBoolEntry( "moving", false );
  m_canCopyFromFile = config.readBoolEntry( "copyFromFile", false );
  m_canCopyToFile = config.readBoolEntry( "copyToFile", false );
  m_listing = config.readListEntry( "listing" );

  if ( m_listing.count() == 1 && m_listing.first() == "false" )
    m_listing.clear();
  m_supportsListing = ( m_listing.count() > 0 );
  m_defaultMimetype = config.readEntry( "defaultMimetype" );
  m_determineMimetypeFromExtension = config.readBoolEntry( "determineMimetypeFromExtension", true );
  m_icon = config.readEntry( "Icon", "mime_empty" );
  m_config = config.readEntry( "config", m_name );
  m_maxSlaves = config.readNumEntry( "maxInstances", 1);

  QString tmp = config.readEntry( "input" );
  if ( tmp == "filesystem" )
    m_inputType = KProtocolInfo::T_FILESYSTEM;
  else if ( tmp == "stream" )
    m_inputType = KProtocolInfo::T_STREAM;
  else
    m_inputType = KProtocolInfo::T_NONE;

  tmp = config.readEntry( "output" );
  if ( tmp == "filesystem" )
    m_outputType = KProtocolInfo::T_FILESYSTEM;
  else if ( tmp == "stream" )
    m_outputType = KProtocolInfo::T_STREAM;
  else
    m_outputType = KProtocolInfo::T_NONE;

  d->docPath = config.readPathEntry( "DocPath" );
  d->protClass = config.readEntry( "Class" ).lower();
  if (!d->protClass.startsWith(":"))
     d->protClass.prepend(':');

  QStringList extraNames = config.readListEntry( "ExtraNames" );
  QStringList extraTypes = config.readListEntry( "ExtraTypes" );
  QStringList::Iterator it = extraNames.begin();
  QStringList::Iterator typeit = extraTypes.begin();
  for( ; it != extraNames.end() && typeit != extraTypes.end(); ++it, ++typeit ) {
      d->extraFields.append( ExtraField( *it, *typeit ) );
  }
}

KProtocolInfo::KProtocolInfo( QDataStream& _str, int offset) :
        KSycocaEntry( _str, offset)
{
   d = new KProtocolInfoPrivate;
   load( _str );
}

KProtocolInfo::~KProtocolInfo()
{
   delete d;
}

void
KProtocolInfo::load( QDataStream& _str)
{
   Q_INT32 i_inputType, i_outputType;
   Q_INT8 i_isSourceProtocol, i_isHelperProtocol,
          i_supportsListing, i_supportsReading,
          i_supportsWriting, i_supportsMakeDir,
          i_supportsDeleting, i_supportsLinking,
          i_supportsMoving, i_determineMimetypeFromExtension,
          i_canCopyFromFile, i_canCopyToFile;
   _str >> m_name >> m_exec >> m_listing >> m_defaultMimetype
        >> i_determineMimetypeFromExtension
        >> m_icon
        >> i_inputType >> i_outputType
        >> i_isSourceProtocol >> i_isHelperProtocol
        >> i_supportsListing >> i_supportsReading
        >> i_supportsWriting >> i_supportsMakeDir
        >> i_supportsDeleting >> i_supportsLinking
        >> i_supportsMoving
        >> i_canCopyFromFile >> i_canCopyToFile
        >> m_config >> m_maxSlaves >> d->docPath >> d->protClass >> d->extraFields;
   m_inputType = (Type) i_inputType;
   m_outputType = (Type) i_outputType;
   m_isSourceProtocol = (i_isSourceProtocol != 0);
   m_isHelperProtocol = (i_isHelperProtocol != 0);
   m_supportsListing = (i_supportsListing != 0);
   m_supportsReading = (i_supportsReading != 0);
   m_supportsWriting = (i_supportsWriting != 0);
   m_supportsMakeDir = (i_supportsMakeDir != 0);
   m_supportsDeleting = (i_supportsDeleting != 0);
   m_supportsLinking = (i_supportsLinking != 0);
   m_supportsMoving = (i_supportsMoving != 0);
   m_canCopyFromFile = (i_canCopyFromFile != 0);
   m_canCopyToFile = (i_canCopyToFile != 0);
   m_determineMimetypeFromExtension = (i_determineMimetypeFromExtension != 0);
}

void
KProtocolInfo::save( QDataStream& _str)
{
   KSycocaEntry::save( _str );

   Q_INT32 i_inputType, i_outputType;
   Q_INT8 i_isSourceProtocol, i_isHelperProtocol,
          i_supportsListing, i_supportsReading,
          i_supportsWriting, i_supportsMakeDir,
          i_supportsDeleting, i_supportsLinking,
          i_supportsMoving, i_determineMimetypeFromExtension,
          i_canCopyFromFile, i_canCopyToFile;

   i_inputType = (Q_INT32) m_inputType;
   i_outputType = (Q_INT32) m_outputType;
   i_isSourceProtocol = m_isSourceProtocol ? 1 : 0;
   i_isHelperProtocol = m_isHelperProtocol ? 1 : 0;
   i_supportsListing = m_supportsListing ? 1 : 0;
   i_supportsReading = m_supportsReading ? 1 : 0;
   i_supportsWriting = m_supportsWriting ? 1 : 0;
   i_supportsMakeDir = m_supportsMakeDir ? 1 : 0;
   i_supportsDeleting = m_supportsDeleting ? 1 : 0;
   i_supportsLinking = m_supportsLinking ? 1 : 0;
   i_supportsMoving = m_supportsMoving ? 1 : 0;
   i_canCopyFromFile = m_canCopyFromFile ? 1 : 0;
   i_canCopyToFile = m_canCopyToFile ? 1 : 0;
   i_determineMimetypeFromExtension = m_determineMimetypeFromExtension ? 1 : 0;


   _str << m_name << m_exec << m_listing << m_defaultMimetype
        << i_determineMimetypeFromExtension
        << m_icon
        << i_inputType << i_outputType
        << i_isSourceProtocol << i_isHelperProtocol
        << i_supportsListing << i_supportsReading
        << i_supportsWriting << i_supportsMakeDir
        << i_supportsDeleting << i_supportsLinking
        << i_supportsMoving
        << i_canCopyFromFile << i_canCopyToFile
        << m_config << m_maxSlaves << d->docPath << d->protClass << d->extraFields;
}






QStringList KProtocolInfo::protocols()
{
  return KProtocolInfoFactory::self()->protocols();
}

bool KProtocolInfo::isSourceProtocol( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_isSourceProtocol;
}

bool KProtocolInfo::isFilterProtocol( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return !prot->m_isSourceProtocol;
}

bool KProtocolInfo::isHelperProtocol( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_isHelperProtocol;
}

bool KProtocolInfo::isKnownProtocol( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  return ( prot != 0);
}

bool KProtocolInfo::supportsListing( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_supportsListing;
}

QStringList KProtocolInfo::listing( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return QStringList();

  return prot->m_listing;
}

bool KProtocolInfo::supportsReading( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_supportsReading;
}

bool KProtocolInfo::supportsWriting( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_supportsWriting;
}

bool KProtocolInfo::supportsMakeDir( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_supportsMakeDir;
}

bool KProtocolInfo::supportsDeleting( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_supportsDeleting;
}

bool KProtocolInfo::supportsLinking( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_supportsLinking;
}

bool KProtocolInfo::supportsMoving( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_supportsMoving;
}

bool KProtocolInfo::canCopyFromFile( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_canCopyFromFile;
}


bool KProtocolInfo::canCopyToFile( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return false;

  return prot->m_canCopyToFile;
}

QString KProtocolInfo::icon( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return QString::fromLatin1("mime_empty");

  return prot->m_icon;
}

QString KProtocolInfo::config( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return QString::null;

  return QString("kio_%1rc").arg(prot->m_config);
}

int KProtocolInfo::maxSlaves( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return 1;

  return prot->m_maxSlaves;
}

QString KProtocolInfo::defaultMimetype( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return QString::null;

  return prot->m_defaultMimetype;
}

bool KProtocolInfo::determineMimetypeFromExtension( const QString &_protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol( _protocol );
  if ( !prot )
    return true;

  return prot->m_determineMimetypeFromExtension;
}

QString KProtocolInfo::exec( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return QString::null;

  return prot->m_exec;
}

KProtocolInfo::Type KProtocolInfo::inputType( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return T_NONE;

  return prot->m_inputType;
}

KProtocolInfo::Type KProtocolInfo::outputType( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return T_NONE;

  return prot->m_outputType;
}

KProtocolInfo::ExtraFieldList KProtocolInfo::extraFields( const KURL &url )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(url.protocol());
  if ( !prot )
    return ExtraFieldList();

  return prot->d->extraFields;
}

QString KProtocolInfo::docPath( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return QString::null;

  return prot->d->docPath;
}

QString KProtocolInfo::protocolClass( const QString& _protocol )
{
  KProtocolInfo::Ptr prot = KProtocolInfoFactory::self()->findProtocol(_protocol);
  if ( !prot )
    return QString::null;

  return prot->d->protClass;
}

QDataStream& operator>>( QDataStream& s, KProtocolInfo::ExtraField& field ) {
  s >> field.name;
  s >> field.type;
  return s;
}

QDataStream& operator<<( QDataStream& s, const KProtocolInfo::ExtraField& field ) {
  s << field.name;
  s << field.type;
  return s;
}



void KProtocolInfo::virtual_hook( int id, void* data )
{ KSycocaEntry::virtual_hook( id, data ); }
# 100 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kprotocolinfofactory.cpp" 1
# 30 "/coolo/prod/kdelibs/kdecore/kprotocolinfofactory.cpp"
KProtocolInfoFactory* KProtocolInfoFactory::_self = 0;

KProtocolInfoFactory::KProtocolInfoFactory() : KSycocaFactory( KST_KProtocolInfoFactory )
{
  _self = this;
}

KProtocolInfoFactory::~KProtocolInfoFactory()
{
  _self = 0;
}


KProtocolInfo*
KProtocolInfoFactory::createEntry(int offset)
{
   KProtocolInfo *info = 0;
   KSycocaType type;
   QDataStream *str = KSycoca::self()->findEntry(offset, type);
   switch (type)
   {
     case KST_KProtocolInfo:
       info = new KProtocolInfo(*str, offset);
       break;
     default:
       return 0;
   }
   if (!info->isValid())
   {
      delete info;
      info = 0;
   }
   return info;
}


QStringList KProtocolInfoFactory::protocols()
{
  QStringList res;

  KSycocaEntry::List list = allEntries();
  for( KSycocaEntry::List::Iterator it = list.begin();
       it != list.end();
       ++it)
  {
     KSycocaEntry *entry = (*it).data();
     KProtocolInfo *info = static_cast<KProtocolInfo *>(entry);

     res.append( info->name() );
  }

  return res;
}

KProtocolInfo *
KProtocolInfoFactory::findProtocol(const QString &protocol)
{
  if (!m_sycocaDict) return 0;

  if (protocol == m_lastProtocol) return m_lastInfo;

  int offset;

  offset = m_sycocaDict->find_string( protocol );

  if (!offset) return 0;

  KProtocolInfo *info = createEntry(offset);

  if (info && (info->name() != protocol))
  {

     delete info;
     info = 0;
  }
  m_lastProtocol = protocol;
  m_lastInfo = info;
  return info;
}

void KProtocolInfoFactory::virtual_hook( int id, void* data )
{ KSycocaFactory::virtual_hook( id, data ); }
# 101 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "/coolo/prod/kdelibs/kdecore/kxerrorhandler.cpp" 1
# 29 "/coolo/prod/kdelibs/kdecore/kxerrorhandler.cpp"
# 1 "/usr/include/assert.h" 1 3 4
# 25 "/usr/include/assert.h" 3 4
#undef _ASSERT_H
#undef assert
#undef __ASSERT_VOID_CAST


#undef assert_perror







# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
                           unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
                                  unsigned int __line,
                                  __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}






# 105 "/usr/include/assert.h" 3 4
# 30 "/coolo/prod/kdelibs/kdecore/kxerrorhandler.cpp" 2


KXErrorHandler** KXErrorHandler::handlers = __null;
int KXErrorHandler::pos = 0;
int KXErrorHandler::size = 0;

KXErrorHandler::KXErrorHandler( Display* dpy )
    : user_handler1( __null ),
        user_handler2( __null ),
        old_handler( XSetErrorHandler( handler_wrapper )),
        first_request( XNextRequest( dpy )),
        display( dpy ),
        was_error( false )
    {
    addHandler();
    }

KXErrorHandler::KXErrorHandler( bool (*handler)( int request, int error_code, unsigned long resource_id ), Display* dpy )
    : user_handler1( handler ),
        user_handler2( __null ),
        old_handler( XSetErrorHandler( handler_wrapper )),
        first_request( XNextRequest( dpy )),
        display( dpy ),
        was_error( false )
    {
    addHandler();
    }

KXErrorHandler::KXErrorHandler( int (*handler)( Display*, XErrorEvent* ), Display* dpy )
    : user_handler1( __null ),
        user_handler2( handler ),
        old_handler( XSetErrorHandler( handler_wrapper )),
        first_request( XNextRequest( dpy )),
        display( dpy ),
        was_error( false )
    {
    addHandler();
    }

KXErrorHandler::~KXErrorHandler()
    {
    XSetErrorHandler( old_handler );
    (static_cast<void> ((this == handlers[ pos - 1 ]) ? 0 : (__assert_fail ("this == handlers[ pos - 1 ]", "/coolo/prod/kdelibs/kdecore/kxerrorhandler.cpp", 72, __PRETTY_FUNCTION__), 0)));
    --pos;
    }

void KXErrorHandler::addHandler()
    {
    if( size == pos )
        {
        size += 16;
        handlers = static_cast< KXErrorHandler** >( realloc( handlers, size * sizeof( KXErrorHandler* )));
        }
    handlers[ pos++ ] = this;
    }

bool KXErrorHandler::error( bool sync ) const
    {
    if( sync )
        XSync( display, 0 );
    return was_error;
    }

int KXErrorHandler::handler_wrapper( Display* dpy, XErrorEvent* e )
    {
    --pos;
    int ret = handlers[ pos ]->handle( dpy, e );
    ++pos;
    return ret;
    }

int KXErrorHandler::handle( Display* dpy, XErrorEvent* e )
    {
    if( dpy == display
        && e->serial - first_request < 1000000000 )
        {

        if( user_handler1 != __null )
            was_error |= user_handler1( e->request_code, e->error_code, e->resourceid );
        else if( user_handler2 != __null )
            was_error |= ( user_handler2( dpy, e ) != 0 );
        else
            was_error = true;
        return 0;
        }

    return old_handler( dpy, e );
    }
# 102 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "../kdecore/ksycoca_skel.cpp" 1
# 14 "../kdecore/ksycoca_skel.cpp"
static const char* const KSycoca_ftable[2][3] = {
    { "void", "notifyDatabaseChanged(QStringList)", "notifyDatabaseChanged(QStringList)" },
    { 0, 0, 0 }
};
static const int KSycoca_ftable_hiddens[1] = {
    0,
};

bool KSycoca::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    if ( fun == KSycoca_ftable[0][1] ) {
        QStringList arg0;
        QDataStream arg( data, 0x0001 );
        arg >> arg0;
        replyType = KSycoca_ftable[0][0];
        notifyDatabaseChanged(arg0 );
    } else {
        return DCOPObject::process( fun, data, replyType, replyData );
    }
    return TRUE;
}

QCStringList KSycoca::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "KSycoca";
    return ifaces;
}

QCStringList KSycoca::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; KSycoca_ftable[i][2]; i++ ) {
        if (KSycoca_ftable_hiddens[i])
            continue;
        QCString func = KSycoca_ftable[i][0];
        func += ' ';
        func += KSycoca_ftable[i][2];
        funcs << func;
    }
    return funcs;
}
# 103 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "../kdecore/kappdcopiface_skel.cpp" 1
# 14 "../kdecore/kappdcopiface_skel.cpp"
static const char* const KAppDCOPInterface_ftable[5][3] = {
    { "void", "disableSessionManagement()", "disableSessionManagement()" },
    { "QCString", "startupId()", "startupId()" },
    { "QCString", "caption()", "caption()" },
    { "void", "quit()", "quit()" },
    { 0, 0, 0 }
};
static const int KAppDCOPInterface_ftable_hiddens[4] = {
    0,
    0,
    0,
    0,
};

bool KAppDCOPInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    if ( fun == KAppDCOPInterface_ftable[0][1] ) {
        replyType = KAppDCOPInterface_ftable[0][0];
        disableSessionManagement( );
    } else if ( fun == KAppDCOPInterface_ftable[1][1] ) {
        replyType = KAppDCOPInterface_ftable[1][0];
        QDataStream _replyStream( replyData, 0x0002 );
        _replyStream << startupId( );
    } else if ( fun == KAppDCOPInterface_ftable[2][1] ) {
        replyType = KAppDCOPInterface_ftable[2][0];
        QDataStream _replyStream( replyData, 0x0002 );
        _replyStream << caption( );
    } else if ( fun == KAppDCOPInterface_ftable[3][1] ) {
        replyType = KAppDCOPInterface_ftable[3][0];
        quit( );
    } else {
        return DCOPObject::process( fun, data, replyType, replyData );
    }
    return TRUE;
}

QCStringList KAppDCOPInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "KAppDCOPInterface";
    return ifaces;
}

QCStringList KAppDCOPInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; KAppDCOPInterface_ftable[i][2]; i++ ) {
        if (KAppDCOPInterface_ftable_hiddens[i])
            continue;
        QCString func = KAppDCOPInterface_ftable[i][0];
        func += ' ';
        func += KAppDCOPInterface_ftable[i][2];
        funcs << func;
    }
    return funcs;
}
# 104 "../kdecore/libkdecore_la_all_cpp.cpp" 2
# 1 "../kdecore/kdebugdcopiface_skel.cpp" 1
# 14 "../kdecore/kdebugdcopiface_skel.cpp"
static const char* const KDebugDCOPIface_ftable[2][3] = {
    { "void", "notifyKDebugConfigChanged()", "notifyKDebugConfigChanged()" },
    { 0, 0, 0 }
};
static const int KDebugDCOPIface_ftable_hiddens[1] = {
    0,
};

bool KDebugDCOPIface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    if ( fun == KDebugDCOPIface_ftable[0][1] ) {
        replyType = KDebugDCOPIface_ftable[0][0];
        notifyKDebugConfigChanged( );
    } else {
        return DCOPObject::process( fun, data, replyType, replyData );
    }
    return TRUE;
}

QCStringList KDebugDCOPIface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "KDebugDCOPIface";
    return ifaces;
}

QCStringList KDebugDCOPIface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; KDebugDCOPIface_ftable[i][2]; i++ ) {
        if (KDebugDCOPIface_ftable_hiddens[i])
            continue;
        QCString func = KDebugDCOPIface_ftable[i][0];
        func += ' ';
        func += KDebugDCOPIface_ftable[i][2];
        funcs << func;
    }
    return funcs;
}
# 105 "../kdecore/libkdecore_la_all_cpp.cpp" 2
